<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Welcome to Rick&#39;s Page  | STL 总结</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.91.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/rick/dist/css/app.955516233bcafa4d2a1c13cea63c7b50.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="STL 总结" />
<meta property="og:description" content="STL 总结 1、六大组件介绍  容器：数据结构，用来存放数据 算法：常用算法 迭代器：容器和算法之间的胶合剂，“范型指针” 仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数 配置器：为容器分配并管理内存 适配器：修改其他组件接口  2、STL 常用的容器有哪些以及各自的特点是什么?    名称 特点     vector 底层数据结构为数组，支持快速随机访问   list 底层数据结构为双向链表，支持快速增删   deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问   stack 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   queue 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   priority_queue 底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现   set 底层数据结构为红黑树，有序，不重复   multiset 底层数据结构为红黑树，有序，可重复   map 底层数据结构为红黑树，有序，不重复   multimap 底层数据结构为红黑树，有序，可重复   unordered_set 底层数据结构为hash表，无序，不重复   unordered_multiset 底层数据结构为hash表，无序，可重复   unordered_map 底层数据结构为hash表，无序，不重复   unordered_multimap 底层数据结构为hash表，无序，可重复    3、vector 和 list 的区别  vector底层实现是数组，所以在内存中是连续存放的，随机读取效率高，但插入、删除效率低；list底层实现是双向链表，所以在内存中是任意存放的，插入、删除效率高，但访问元素效率低 vector在中间节点进行插入、删除会导致内存拷贝，而list不会 vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请  4、vector 扩容原理 以原内存空间大小的两倍配置一份新的内存空间，并将原空间数据拷贝过来进行初始化" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://874656645.github.io/rick/posts/56-stl-%E6%80%BB%E7%BB%93/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-30T10:34:27+08:00" />
<meta property="article:modified_time" content="2021-12-30T10:34:27+08:00" />

<meta itemprop="name" content="STL 总结">
<meta itemprop="description" content="STL 总结 1、六大组件介绍  容器：数据结构，用来存放数据 算法：常用算法 迭代器：容器和算法之间的胶合剂，“范型指针” 仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数 配置器：为容器分配并管理内存 适配器：修改其他组件接口  2、STL 常用的容器有哪些以及各自的特点是什么?    名称 特点     vector 底层数据结构为数组，支持快速随机访问   list 底层数据结构为双向链表，支持快速增删   deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问   stack 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   queue 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   priority_queue 底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现   set 底层数据结构为红黑树，有序，不重复   multiset 底层数据结构为红黑树，有序，可重复   map 底层数据结构为红黑树，有序，不重复   multimap 底层数据结构为红黑树，有序，可重复   unordered_set 底层数据结构为hash表，无序，不重复   unordered_multiset 底层数据结构为hash表，无序，可重复   unordered_map 底层数据结构为hash表，无序，不重复   unordered_multimap 底层数据结构为hash表，无序，可重复    3、vector 和 list 的区别  vector底层实现是数组，所以在内存中是连续存放的，随机读取效率高，但插入、删除效率低；list底层实现是双向链表，所以在内存中是任意存放的，插入、删除效率高，但访问元素效率低 vector在中间节点进行插入、删除会导致内存拷贝，而list不会 vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请  4、vector 扩容原理 以原内存空间大小的两倍配置一份新的内存空间，并将原空间数据拷贝过来进行初始化"><meta itemprop="datePublished" content="2021-12-30T10:34:27+08:00" />
<meta itemprop="dateModified" content="2021-12-30T10:34:27+08:00" />
<meta itemprop="wordCount" content="71">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="STL 总结"/>
<meta name="twitter:description" content="STL 总结 1、六大组件介绍  容器：数据结构，用来存放数据 算法：常用算法 迭代器：容器和算法之间的胶合剂，“范型指针” 仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数 配置器：为容器分配并管理内存 适配器：修改其他组件接口  2、STL 常用的容器有哪些以及各自的特点是什么?    名称 特点     vector 底层数据结构为数组，支持快速随机访问   list 底层数据结构为双向链表，支持快速增删   deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问   stack 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   queue 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   priority_queue 底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现   set 底层数据结构为红黑树，有序，不重复   multiset 底层数据结构为红黑树，有序，可重复   map 底层数据结构为红黑树，有序，不重复   multimap 底层数据结构为红黑树，有序，可重复   unordered_set 底层数据结构为hash表，无序，不重复   unordered_multiset 底层数据结构为hash表，无序，可重复   unordered_map 底层数据结构为hash表，无序，不重复   unordered_multimap 底层数据结构为hash表，无序，可重复    3、vector 和 list 的区别  vector底层实现是数组，所以在内存中是连续存放的，随机读取效率高，但插入、删除效率低；list底层实现是双向链表，所以在内存中是任意存放的，插入、删除效率高，但访问元素效率低 vector在中间节点进行插入、删除会导致内存拷贝，而list不会 vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请  4、vector 扩容原理 以原内存空间大小的两倍配置一份新的内存空间，并将原空间数据拷贝过来进行初始化"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://874656645.github.io/rick/" class="f3 fw2 hover-white no-underline white-90 dib">
      Welcome to Rick&#39;s Page
    </a>
    <div class="flex-l items-center">
      
      
<div hidden>
  <span id="new-window-0">Opens in a new window</span>
  <span id="new-window-1">Opens an external site</span>
  <span id="new-window-2">Opens an external site in a new window</span>
</div>









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">STL 总结</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2021-12-30T10:34:27&#43;08:00">December 30, 2021</time>      
      
      
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="stl-总结">STL 总结</h2>
<h3 id="1六大组件介绍">1、六大组件介绍</h3>
<ul>
<li>容器：数据结构，用来存放数据</li>
<li>算法：常用算法</li>
<li>迭代器：容器和算法之间的胶合剂，“范型指针”</li>
<li>仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数</li>
<li>配置器：为容器分配并管理内存</li>
<li>适配器：修改其他组件接口</li>
</ul>
<h3 id="2stl-常用的容器有哪些以及各自的特点是什么">2、STL 常用的容器有哪些以及各自的特点是什么?</h3>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">vector</td>
<td style="text-align:left">底层数据结构为数组，支持快速随机访问</td>
</tr>
<tr>
<td style="text-align:left">list</td>
<td style="text-align:left">底层数据结构为双向链表，支持快速增删</td>
</tr>
<tr>
<td style="text-align:left">deque</td>
<td style="text-align:left">底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问</td>
</tr>
<tr>
<td style="text-align:left">stack</td>
<td style="text-align:left">底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</td>
</tr>
<tr>
<td style="text-align:left">queue</td>
<td style="text-align:left">底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</td>
</tr>
<tr>
<td style="text-align:left">priority_queue</td>
<td style="text-align:left">底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</td>
</tr>
<tr>
<td style="text-align:left">set</td>
<td style="text-align:left">底层数据结构为红黑树，有序，不重复</td>
</tr>
<tr>
<td style="text-align:left">multiset</td>
<td style="text-align:left">底层数据结构为红黑树，有序，可重复</td>
</tr>
<tr>
<td style="text-align:left">map</td>
<td style="text-align:left">底层数据结构为红黑树，有序，不重复</td>
</tr>
<tr>
<td style="text-align:left">multimap</td>
<td style="text-align:left">底层数据结构为红黑树，有序，可重复</td>
</tr>
<tr>
<td style="text-align:left">unordered_set</td>
<td style="text-align:left">底层数据结构为hash表，无序，不重复</td>
</tr>
<tr>
<td style="text-align:left">unordered_multiset</td>
<td style="text-align:left">底层数据结构为hash表，无序，可重复</td>
</tr>
<tr>
<td style="text-align:left">unordered_map</td>
<td style="text-align:left">底层数据结构为hash表，无序，不重复</td>
</tr>
<tr>
<td style="text-align:left">unordered_multimap</td>
<td style="text-align:left">底层数据结构为hash表，无序，可重复</td>
</tr>
</tbody>
</table>
<h3 id="3vector-和-list-的区别">3、vector 和 list 的区别</h3>
<ul>
<li>vector底层实现是数组，所以在内存中是连续存放的，随机读取效率高，但插入、删除效率低；list底层实现是双向链表，所以在内存中是任意存放的，插入、删除效率高，但访问元素效率低</li>
<li>vector在中间节点进行插入、删除会导致内存拷贝，而list不会</li>
<li>vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请</li>
</ul>
<h3 id="4vector-扩容原理">4、vector 扩容原理</h3>
<p>以原内存空间大小的两倍配置一份新的内存空间，并将原空间数据拷贝过来进行初始化</p>
<h3 id="5map-和-set-有什么区别">5、map 和 set 有什么区别</h3>
<ul>
<li>map中的元素是键值对；Set仅是关键字的简单集合</li>
<li>set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key</li>
<li>map支持用关键字作下标操作，set不支持下标操作</li>
</ul>
<h3 id="6map-和-unordered_map-的区别">6、map 和 unordered_map 的区别</h3>
<ul>
<li>map内部实现了一个红黑树，红黑树的每一个节点都代表着map的一个元素，因此所有元素都是有序的，对其进行查找、插入、删除得效率都是O(log n)；但是，因为每个结点都需要额外保存数据，所以空间占用率比较高</li>
<li>unordered_map内部实现了一个哈希表，因此内部元素是无序的，对其进行查找、插入、删除得效率都是O(1)；但是建立哈希表比较费时</li>
</ul>
<h3 id="7stl-中迭代器的作用有指针为何还要迭代器">7、STL 中迭代器的作用，有指针为何还要迭代器</h3>
<ul>
<li>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示</li>
<li>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、&ndash;等，相当于一种智能指针</li>
<li>迭代器产生原因：Iterator采用的是面向对象的思想，<strong>把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果</strong></li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6">
        
      </div>
    </main>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://874656645.github.io/rick/" >
    &copy; 2021 Welcome to Rick&#39;s Page
  </a>
    <div>
<div hidden>
  <span id="new-window-0">Opens in a new window</span>
  <span id="new-window-1">Opens an external site</span>
  <span id="new-window-2">Opens an external site in a new window</span>
</div>








</div>
  </div>
</footer>

    

  <script src="/rick/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
