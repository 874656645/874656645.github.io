<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Welcome to Rick&#39;s Page  | 类其它总结</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.52" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/rick/dist/css/app.955516233bcafa4d2a1c13cea63c7b50.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="类其它总结" />
<meta property="og:description" content="类其它总结 1. this指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用该成员函数的对象的首地址
 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值 this 是个右值，所以不能取 this 的地址  2. delete this  类的成员函数中可以调用 delete this，但是在释放后，对象后续调用的方法不能再用到 this 指针 delete this 释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，此时其中的值是不确定的 delete 的本质是为将被释放的内存调用一个或多个析构函数，如果在类的析构函数中调用 delete this，会陷入无限递归，造成栈溢出  3. 一个空类class中有什么？ 构造函数、拷贝构造函数、析构函数、赋值运算符重载、取地址操作符重载、被 const 修饰的取地址操作符重载
4. C&#43;&#43; 计算一个类的 sizeof  一个空的类 sizeof 返回 *1*，因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址 类内的普通成员函数不参与 sizeof 的统计，因为 sizeof 是针对实例的，而普通成员函数，是针对类体的 一个类如果含有虚函数，则这个类中有一个指向虚函数表的指针（虚函数指针），32位程序占4个字节，64位程序占8个字节 静态成员不影响类的大小，被编译器放在程序的数据段中 普通继承的类sizeof，会得到基类的大小加上派生类自身成员的大小 当存在虚拟继承时，派生类中会有一个指向虚基类表的指针。所以其大小应为普通继承的大小，再加上虚基类表的指针大小  5. 构造函数和析构函数能被继承吗? 不能。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么
6. 构造函数能不能是虚函数？ 不能。虚函数对应一个虚函数表，可是这个虚函数表存储在对象的内存空间的。问题就在于，如果构造函数是虚的，就需要通过 虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，就不会有虚函数表" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://874656645.github.io/rick/posts/50-%E7%B1%BB%E5%85%B6%E5%AE%83%E6%80%BB%E7%BB%93/" /><meta property="article:published_time" content="2021-12-28T17:34:27&#43;08:00"/>
<meta property="article:modified_time" content="2021-12-28T17:34:27&#43;08:00"/>

<meta itemprop="name" content="类其它总结">
<meta itemprop="description" content="类其它总结 1. this指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用该成员函数的对象的首地址
 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值 this 是个右值，所以不能取 this 的地址  2. delete this  类的成员函数中可以调用 delete this，但是在释放后，对象后续调用的方法不能再用到 this 指针 delete this 释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，此时其中的值是不确定的 delete 的本质是为将被释放的内存调用一个或多个析构函数，如果在类的析构函数中调用 delete this，会陷入无限递归，造成栈溢出  3. 一个空类class中有什么？ 构造函数、拷贝构造函数、析构函数、赋值运算符重载、取地址操作符重载、被 const 修饰的取地址操作符重载
4. C&#43;&#43; 计算一个类的 sizeof  一个空的类 sizeof 返回 *1*，因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址 类内的普通成员函数不参与 sizeof 的统计，因为 sizeof 是针对实例的，而普通成员函数，是针对类体的 一个类如果含有虚函数，则这个类中有一个指向虚函数表的指针（虚函数指针），32位程序占4个字节，64位程序占8个字节 静态成员不影响类的大小，被编译器放在程序的数据段中 普通继承的类sizeof，会得到基类的大小加上派生类自身成员的大小 当存在虚拟继承时，派生类中会有一个指向虚基类表的指针。所以其大小应为普通继承的大小，再加上虚基类表的指针大小  5. 构造函数和析构函数能被继承吗? 不能。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么
6. 构造函数能不能是虚函数？ 不能。虚函数对应一个虚函数表，可是这个虚函数表存储在对象的内存空间的。问题就在于，如果构造函数是虚的，就需要通过 虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，就不会有虚函数表">


<meta itemprop="datePublished" content="2021-12-28T17:34:27&#43;08:00" />
<meta itemprop="dateModified" content="2021-12-28T17:34:27&#43;08:00" />
<meta itemprop="wordCount" content="97">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="类其它总结"/>
<meta name="twitter:description" content="类其它总结 1. this指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用该成员函数的对象的首地址
 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值 this 是个右值，所以不能取 this 的地址  2. delete this  类的成员函数中可以调用 delete this，但是在释放后，对象后续调用的方法不能再用到 this 指针 delete this 释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，此时其中的值是不确定的 delete 的本质是为将被释放的内存调用一个或多个析构函数，如果在类的析构函数中调用 delete this，会陷入无限递归，造成栈溢出  3. 一个空类class中有什么？ 构造函数、拷贝构造函数、析构函数、赋值运算符重载、取地址操作符重载、被 const 修饰的取地址操作符重载
4. C&#43;&#43; 计算一个类的 sizeof  一个空的类 sizeof 返回 *1*，因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址 类内的普通成员函数不参与 sizeof 的统计，因为 sizeof 是针对实例的，而普通成员函数，是针对类体的 一个类如果含有虚函数，则这个类中有一个指向虚函数表的指针（虚函数指针），32位程序占4个字节，64位程序占8个字节 静态成员不影响类的大小，被编译器放在程序的数据段中 普通继承的类sizeof，会得到基类的大小加上派生类自身成员的大小 当存在虚拟继承时，派生类中会有一个指向虚基类表的指针。所以其大小应为普通继承的大小，再加上虚基类表的指针大小  5. 构造函数和析构函数能被继承吗? 不能。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么
6. 构造函数能不能是虚函数？ 不能。虚函数对应一个虚函数表，可是这个虚函数表存储在对象的内存空间的。问题就在于，如果构造函数是虚的，就需要通过 虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，就不会有虚函数表"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://874656645.github.io/rick/" class="f3 fw2 hover-white no-underline white-90 dib">
      Welcome to Rick&#39;s Page
    </a>
    <div class="flex-l items-center">
      
      
<div hidden>
  <span id="new-window-0">Opens in a new window</span>
  <span id="new-window-1">Opens an external site</span>
  <span id="new-window-2">Opens an external site in a new window</span>
</div>









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">类其它总结</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2021-12-28T17:34:27&#43;08:00">December 28, 2021</time>      
      
      
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h2 id="类其它总结">类其它总结</h2>

<h3 id="1-this-指针">1. <code>this</code>指针</h3>

<p>this 指针是一个隐含于每一个<strong>非静态成员函数</strong>中的特殊指针，它指向调用该成员函数的对象的首地址</p>

<ul>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值</li>
<li><code>this</code> 是个右值，所以不能取 <code>this</code> 的地址</li>
</ul>

<h3 id="2-delete-this">2. <code>delete this</code></h3>

<ul>
<li>类的成员函数中可以调用 <code>delete this</code>，但是在释放后，对象后续调用的方法不能再用到 <code>this</code> 指针</li>
<li><code>delete this</code> 释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，此时其中的值是不确定的</li>
<li><code>delete</code> 的本质是为将被释放的内存调用一个或多个析构函数，如果在类的析构函数中调用 <code>delete this</code>，会陷入<strong>无限递归</strong>，造成栈溢出</li>
</ul>

<h3 id="3-一个空类class中有什么">3. 一个空类class中有什么？</h3>

<p>构造函数、拷贝构造函数、析构函数、赋值运算符重载、取地址操作符重载、被 <code>const</code> 修饰的取地址操作符重载</p>

<h3 id="4-c-计算一个类的-sizeof">4. <code>C++</code> 计算一个类的 <code>sizeof</code></h3>

<ul>
<li>一个空的类 <code>sizeof</code> 返回 *1*，因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址</li>
<li>类内的普通成员函数不参与 <code>sizeof</code> 的统计，因为 <code>sizeof</code> 是针对实例的，而普通成员函数，是针对<strong>类体</strong>的</li>
<li>一个类如果含有<strong>虚函数</strong>，则这个类中有一个指向虚函数表的指针（虚函数指针），32位程序占4个字节，64位程序占8个字节</li>
<li>静态成员不影响类的大小，被编译器放在程序的数据段中</li>
<li>普通继承的类sizeof，会得到基类的大小加上派生类自身成员的大小</li>
<li>当存在虚拟继承时，派生类中会有一个指向虚基类表的指针。所以其大小应为普通继承的大小，再加上虚基类表的指针大小</li>
</ul>

<h3 id="5-构造函数和析构函数能被继承吗">5. 构造函数和析构函数能被继承吗?</h3>

<p>不能。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么</p>

<h3 id="6-构造函数能不能是虚函数">6. 构造函数能不能是虚函数？</h3>

<p>不能。虚函数对应一个虚函数表，可是这个虚函数表存储在对象的内存空间的。问题就在于，如果构造函数是虚的，就需要通过 虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，就不会有虚函数表</p>

<h3 id="7-构造函数和析构函数能不能被重载">7. 构造函数和析构函数能不能被重载？</h3>

<p>构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数。</p>

<h3 id="8-构造函数调用顺序-析构函数调用顺序">8. 构造函数调用顺序，析构函数调用顺序？</h3>

<p>基类的构造函数——<strong>成员类对象的构造函数</strong>——派生类的构造函数；<br />
析构函数<strong>相反</strong></p>

<h3 id="9-构造函数和析构函数调用时机">9. 构造函数和析构函数调用时机</h3>

<ul>
<li>全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数</li>
<li>局部自动对象：建立对象时调用构造函数，函数结束时调用析构函数</li>
<li>动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数</li>
<li>静态局部变量对象：建立对象时调用构造函数，在主函数结束时调用析构函数</li>
</ul>

<h3 id="10-拷贝构造函数中深拷贝和浅拷贝区别">10. 拷贝构造函数中深拷贝和浅拷贝区别</h3>

<ul>
<li>深拷贝会先申请一块和拷贝数据一样大的内存空间，然后将数据逐字节拷贝过去，拷贝后两个指针<strong>指向不同的两个内存空间</strong></li>
<li>浅拷贝仅是拷贝指针地址，拷贝后两个指针指向同一个内存空间<br />
<strong>当浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针，因为所指向的内存空间已经被释放了</strong></li>
</ul>

<h3 id="11-什么时候必须重写拷贝构造函数">11. 什么时候必须重写拷贝构造函数？</h3>

<p>当构造函数涉及到动态内存分配时，要自己写拷贝构造函数，并且<strong>要深拷贝</strong></p>

<h3 id="12-面向过程编程和面向对象编程的区别">12. 面向过程编程和面向对象编程的区别</h3>

<ul>
<li><strong>面向过程</strong>：就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现（<strong>函数驱动</strong>）</li>
<li><strong>面向对象</strong>：面向对象是一种对现实世界理解和抽象的方法，强调的是通过将需求要素转化为对象进行问题处理的一种思想（<strong>对象驱动</strong>）</li>
</ul>

<h3 id="13-为什么内联函数-构造函数-静态成员函数不能为virtual函数">13. 为什么内联函数，构造函数，静态成员函数不能为virtual函数？</h3>

<ul>
<li><strong>内联函数</strong>：内联函数是在<strong>编译时期展开</strong>，而虚函数的特性是<strong>运行时才动态联编</strong>,所以两者矛盾,不能定义内联函数为虚函数</li>
<li><strong>构造函数</strong>：构造函数用来创建一个新的对象，而<strong>虚函数的运行是建立在对象的基础上</strong>，在构造函数执行时，对象尚未形成,所以不能将构造函数定义为虚函数</li>
<li><strong>静态成员函数</strong>：静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</li>
<li><strong>友元函数</strong>：C++不支持友元函数的继承，对于没有继承性的函数没有虚函数</li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6">
        
      </div>
    </main>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://874656645.github.io/rick/" >
    &copy; 2021 Welcome to Rick&#39;s Page
  </a>
    <div>
<div hidden>
  <span id="new-window-0">Opens in a new window</span>
  <span id="new-window-1">Opens an external site</span>
  <span id="new-window-2">Opens an external site in a new window</span>
</div>








</div>
  </div>
</footer>

    

  <script src="/rick/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
