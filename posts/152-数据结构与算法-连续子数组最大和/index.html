<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>数据结构与算法——连续子数组最大和 | Slow is Smooth and Smooth is Fast</title>
<meta name="keywords" content="数据结构与算法" />
<meta name="description" content="一、暴力算法 $\mathcal{O}(n^3)$ 遍历数组的所有子数组集合，并对其求和，筛选出和的最大值
int maxSumOfSub1(int* array, int length){ int maxSum = 0; int startIndex = 0, endIndex = 0; for(int i = 0; i &lt; length; i&#43;&#43;){ for(int j = i; j &lt; length; j&#43;&#43;){ int sum = 0; for(int k = i; k &lt;= j; k&#43;&#43;) sum &#43;= array[k]; if(maxSum &lt; sum){ maxSum = sum; startIndex = i; endIndex = j; } } } cout &lt;&lt; &#34;Begin:&#34; &lt;&lt; startIndex &lt;&lt; &#34; End:&#34; &lt;&lt; endIndex &lt;&lt; &#34; Num:&#34; &lt;&lt; maxSum &lt;&lt; endl; return maxSum; } 二、前缀和 $\mathcal{O}(n^2)$ 先把数组的前 i 项和求出来并将其保存到数组中，然后计算所有子数组集合的和，筛选其中最大的">
<meta name="author" content="Rick Cui">
<link rel="canonical" href="https://874656645.github.io/posts/152-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/" />
<meta name="google-site-verification" content="XYZabc" />
<meta name="yandex-verification" content="XYZabc" />
<meta name="msvalidate.01" content="XYZabc" />

<script defer crossorigin="anonymous" src="https://hm.baidu.com/hm.js?c4f60a311141f59e46a3c3223ff62c0b"></script>
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.a8d96e9fdcfb04de6ce842f2e3dc4f0df9ca7b9e31b230fd17e775ab09b8c508.css" integrity="sha256-qNlun9z7BN5s6ELy49xPDfnKe54xsjD9F&#43;d1qwm4xQg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://874656645.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://874656645.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://874656645.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://874656645.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://874656645.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-123-45', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="数据结构与算法——连续子数组最大和" />
<meta property="og:description" content="一、暴力算法 $\mathcal{O}(n^3)$ 遍历数组的所有子数组集合，并对其求和，筛选出和的最大值
int maxSumOfSub1(int* array, int length){ int maxSum = 0; int startIndex = 0, endIndex = 0; for(int i = 0; i &lt; length; i&#43;&#43;){ for(int j = i; j &lt; length; j&#43;&#43;){ int sum = 0; for(int k = i; k &lt;= j; k&#43;&#43;) sum &#43;= array[k]; if(maxSum &lt; sum){ maxSum = sum; startIndex = i; endIndex = j; } } } cout &lt;&lt; &#34;Begin:&#34; &lt;&lt; startIndex &lt;&lt; &#34; End:&#34; &lt;&lt; endIndex &lt;&lt; &#34; Num:&#34; &lt;&lt; maxSum &lt;&lt; endl; return maxSum; } 二、前缀和 $\mathcal{O}(n^2)$ 先把数组的前 i 项和求出来并将其保存到数组中，然后计算所有子数组集合的和，筛选其中最大的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://874656645.github.io/posts/152-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/" /><meta property="og:image" content="https://874656645.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-19T15:35:35&#43;08:00" />
<meta property="article:modified_time" content="2022-03-19T15:35:35&#43;08:00" />


<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://874656645.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"/>

<meta name="twitter:title" content="数据结构与算法——连续子数组最大和"/>
<meta name="twitter:description" content="一、暴力算法 $\mathcal{O}(n^3)$ 遍历数组的所有子数组集合，并对其求和，筛选出和的最大值
int maxSumOfSub1(int* array, int length){ int maxSum = 0; int startIndex = 0, endIndex = 0; for(int i = 0; i &lt; length; i&#43;&#43;){ for(int j = i; j &lt; length; j&#43;&#43;){ int sum = 0; for(int k = i; k &lt;= j; k&#43;&#43;) sum &#43;= array[k]; if(maxSum &lt; sum){ maxSum = sum; startIndex = i; endIndex = j; } } } cout &lt;&lt; &#34;Begin:&#34; &lt;&lt; startIndex &lt;&lt; &#34; End:&#34; &lt;&lt; endIndex &lt;&lt; &#34; Num:&#34; &lt;&lt; maxSum &lt;&lt; endl; return maxSum; } 二、前缀和 $\mathcal{O}(n^2)$ 先把数组的前 i 项和求出来并将其保存到数组中，然后计算所有子数组集合的和，筛选其中最大的"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://874656645.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "数据结构与算法——连续子数组最大和",
      "item": "https://874656645.github.io/posts/152-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据结构与算法——连续子数组最大和",
  "name": "数据结构与算法——连续子数组最大和",
  "description": "一、暴力算法 $\\mathcal{O}(n^3)$ 遍历数组的所有子数组集合，并对其求和，筛选出和的最大值\nint maxSumOfSub1(int* array, int length){ int maxSum = 0; int startIndex = 0, endIndex = 0; for(int i = 0; i \u0026lt; length; i++){ for(int j = i; j \u0026lt; length; j++){ int sum = 0; for(int k = i; k \u0026lt;= j; k++) sum += array[k]; if(maxSum \u0026lt; sum){ maxSum = sum; startIndex = i; endIndex = j; } } } cout \u0026lt;\u0026lt; \u0026#34;Begin:\u0026#34; \u0026lt;\u0026lt; startIndex \u0026lt;\u0026lt; \u0026#34; End:\u0026#34; \u0026lt;\u0026lt; endIndex \u0026lt;\u0026lt; \u0026#34; Num:\u0026#34; \u0026lt;\u0026lt; maxSum \u0026lt;\u0026lt; endl; return maxSum; } 二、前缀和 $\\mathcal{O}(n^2)$ 先把数组的前 i 项和求出来并将其保存到数组中，然后计算所有子数组集合的和，筛选其中最大的",
  "keywords": [
    "数据结构与算法"
  ],
  "articleBody": "一、暴力算法 $\\mathcal{O}(n^3)$ 遍历数组的所有子数组集合，并对其求和，筛选出和的最大值\nint maxSumOfSub1(int* array, int length){ int maxSum = 0; int startIndex = 0, endIndex = 0; for(int i = 0; i  length; i++){ for(int j = i; j  length; j++){ int sum = 0; for(int k = i; k  j; k++) sum += array[k]; if(maxSum  sum){ maxSum = sum; startIndex = i; endIndex = j; } } } cout  \"Begin:\"  startIndex  \" End:\"  endIndex  \" Num:\"  maxSum  endl; return maxSum; } 二、前缀和 $\\mathcal{O}(n^2)$ 先把数组的前 i 项和求出来并将其保存到数组中，然后计算所有子数组集合的和，筛选其中最大的\nint maxSumOfSub2(int* array, int length){ int maxSum = 0; int sumLen = length + 1; int sum[sumLen] = {0}; int startIndex = 0, endIndex = 0; for(int i = 1; i  length; ++i){ sum[i] = sum[i-1] + array[i-1]; } // for_each(sum, sum + sumLen, [](int ele){ cout  // cout  for(int i = 0; i  length; i++){ for(int j = i + 1; j  length; j++){ int res = sum[j] - sum[i]; if(maxSum  res){ maxSum = res; startIndex = i; endIndex = j-1; } } } cout  \"Begin:\"  startIndex  \" End:\"  endIndex  \" Num:\"  maxSum  endl; return maxSum; } 三、分治法 $\\mathcal{O}(n\\log_2{}n)$ 先将数组分为两个子数组 a, b；\n分别求出两个子数组 a，b 的连续子数组中和的最大值 ma, mb；\n还有一种情况：有可能最大和的子数组跨越两个数组 mc；\n在计算 mc 时，注意：mc必定包含总区间的中间元素，因此求 mc 等价于从中间元素开始往左累加的最大值 + 从中间元素开始往右累加的最大值。\n最后比较 ma, mb, mc，取最大的。\nint maxSumOfSub3(int* array, int l, int r){ if(l == r){ return array[l]; } int mid = (l + r) / 2; //计算Ma,Mb的情况  int maxa = maxSumOfSub3(array, l, mid); int maxb = maxSumOfSub3(array, mid + 1, r); //计算子数组跨越两个子数组（Mc）的情况  int maxc = 0, lmax = 0, rmax = 0, sum = 0; for(int i = mid; i = l; i--){//从中间元素开始往左累加的最大值  sum += array[i]; lmax = max(lmax, sum); } sum = 0; for(int i = mid + 1; i  r; i++){//从中间元素开始往右累加的最大值  sum += array[i]; rmax = max(rmax, sum); } maxc = lmax + rmax; return max(maxc, max(maxa, maxb)); } 四、动态规划法 $\\mathcal{O}(n)$  dp[i] 表示以下标 i 指向的元素结尾的所有子数组的和的最大值 状态转移方程：dp[i] = max(dp[i-1] + nums[i], nums[i]) 最后的子数组最大和：ans = max(dp[i], ans) 需要比较三个值，筛选出三者中的最大值：前最大子数组和（索引 i-1 之前）、当前项 num[i] 的值、边界最大子数组和（索引 i 之前）  int maxSumOfSub4( int* array, int length) { int dp[length] = {array[0]}; int maxSum = array[0]; for( int i = 1; i  length; ++i ) { dp[i] = max(dp[i-1] + array[i], array[i]); maxSum = max(maxSum, dp[i]); } return maxSum; } 改进一：省去保存历史状态值的数组空间\nint maxSumOfSub5( int* array, int length) { int boundry = array[0]; int maxSum = array[0]; for( int i = 1; i  length; ++i ) { boundry = max(boundry + array[i], array[i]); maxSum = max(maxSum, boundry); } return maxSum; } 改进二：记录最大子数组区间\nint maxSumOfSub6( int* array, int length) { int dp[length] = {array[0]}; int maxSum = array[0]; int endIndex = 0; int startIndex = 0; int tmpBeginIndex = 0; for( int i = 1; i  length; ++i ) { // dp[i] = max(dp[i-1] + array[i], array[i]);  // maxSum = max(maxSum, dp[i]);  if(dp[i-1] + array[i]  array[i]){ dp[i] = array[i]; tmpBeginIndex = i; } else{ dp[i] = dp[i-1] + array[i]; } if(maxSum  dp[i]){ maxSum = dp[i]; startIndex = tmpBeginIndex; endIndex = i; } } cout  \"Begin:\"  startIndex  \" End:\"  endIndex  \" Num:\"  maxSum  endl; return maxSum; } 改进三：省去保存历史状态值的数组空间，并且记录大子数组区间\nint maxSumOfSub7( int* array, int length) { int boundry = array[0]; int maxSum = array[0]; int endIndex = 0; int startIndex = 0; int tmpBeginIndex = 0; for( int i = 1; i  length; ++i ) { // boundry = max(boundry + array[i], array[i]);  // maxSum = max(maxSum, boundry);  if(boundry + array[i]  array[i]){ boundry = array[i]; tmpBeginIndex = i; } else{ boundry += array[i]; } if(maxSum  boundry){ maxSum = boundry; startIndex = tmpBeginIndex; endIndex = i; } } cout  \"Begin:\"  startIndex  \" End:\"  endIndex  \" Num:\"  maxSum  endl; return maxSum; } 五、扫描法 $\\mathcal{O}(n)$ 当加上一个正数时，和会增加；当加上一个负数时，和会减少。如果当前得到的和是个负数，那么这个和在接下来的累加中应该抛弃并重新清零，不然的话这个负数将会减少接下来的和。（与动态规划算法很像似）\nint maxSumOfSub8( int* array, int length) { int boundry = array[0]; int maxSum = array[0]; int endIndex = 0; int startIndex = 0; int tmpBeginIndex = 0; for( int i = 1; i  length; ++i ) { if(boundry  0){ boundry = array[i]; tmpBeginIndex = i; } else{ boundry += array[i]; } if( maxSum  boundry ) { maxSum = boundry; startIndex = tmpBeginIndex; endIndex = i; } } cout  \"Begin:\"  startIndex  \" End:\"  endIndex  \" Num:\"  maxSum  endl; return maxSum; } 测试 int main() { int a[] = {1,-2,3,10,-4,7,2,-48}; // int a[] = {3,-1,-1,-1,-1,-1,-1,-1};  // int a[] = {-1,-1,-1,-1,-1,-1,-1,3};  // int a[] = {5,-2,-3,-1,-1,-1,-1,-3};  int num = sizeof(a)/sizeof(a[0]); // int result = maxSumOfSub5(a, num);  int result = 0; result = maxSumOfSub1(a, num); result = maxSumOfSub2(a, num); result = maxSumOfSub3(a, 0, num-1); cout  \"Num:\"  result  endl; result = maxSumOfSub4(a, num); cout  \"Num:\"  result  endl; result = maxSumOfSub5(a, num); cout  \"Num:\"  result  endl; result = maxSumOfSub6(a, num); result = maxSumOfSub7(a, num); result = maxSumOfSub8(a, num); cout  \"-----------------------------\"  endl; int b[] = {3,-1,5,-1,9,-20,21,-20,20,21}; num = sizeof(b)/sizeof(b[0]); result = maxSumOfSub1(b, num); result = maxSumOfSub2(b, num); result = maxSumOfSub3(b, 0, num-1); cout  \"Num:\"  result  endl; result = maxSumOfSub4(b, num); cout  \"Num:\"  result  endl; result = maxSumOfSub5(b, num); cout  \"Num:\"  result  endl; result = maxSumOfSub6(b, num); result = maxSumOfSub7(b, num); result = maxSumOfSub8(b, num); return 0; } 输出：\nBegin:2 End:6 Num:18 Begin:2 End:6 Num:18 Num:18 Num:18 Num:18 Begin:2 End:6 Num:18 Begin:2 End:6 Num:18 Begin:2 End:6 Num:18 ----------------------------- Begin:6 End:9 Num:42 Begin:6 End:9 Num:42 Num:42 Num:42 Num:42 Begin:6 End:9 Num:42 Begin:6 End:9 Num:42 Begin:6 End:9 Num:42 ",
  "wordCount" : "927",
  "inLanguage": "en",
  "datePublished": "2022-03-19T15:35:35+08:00",
  "dateModified": "2022-03-19T15:35:35+08:00",
  "author":{
    "@type": "Person",
    "name": "Rick Cui"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://874656645.github.io/posts/152-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Slow is Smooth and Smooth is Fast",
    "logo": {
      "@type": "ImageObject",
      "url": "https://874656645.github.io/favicon.ico"
    }
  }
}
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://874656645.github.io" accesskey="h" title="Welcome Aboard (Alt + H)">Welcome Aboard</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://874656645.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://874656645.github.io/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://874656645.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://874656645.github.io/series" title="Series">
                    <span>Series</span>
                </a>
            </li>
            <li>
                <a href="https://874656645.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://874656645.github.io">Home</a>&nbsp;»&nbsp;<a href="https://874656645.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      数据结构与算法——连续子数组最大和
    </h1>
    <div class="post-meta"><span title='2022-03-19 15:35:35 +0800 CST'>March 19, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Rick Cui

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%b8%80%e6%9a%b4%e5%8a%9b%e7%ae%97%e6%b3%95-mathcalon3" aria-label="一、暴力算法 $\mathcal{O}(n^3)$">一、暴力算法 $\mathcal{O}(n^3)$</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%89%8d%e7%bc%80%e5%92%8c-mathcalon2" aria-label="二、前缀和 $\mathcal{O}(n^2)$">二、前缀和 $\mathcal{O}(n^2)$</a></li>
                <li>
                    <a href="#%e4%b8%89%e5%88%86%e6%b2%bb%e6%b3%95-mathcalonlog_2n" aria-label="三、分治法 $\mathcal{O}(n\log_2{}n)$">三、分治法 $\mathcal{O}(n\log_2{}n)$</a></li>
                <li>
                    <a href="#%e5%9b%9b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e6%b3%95-mathcalon" aria-label="四、动态规划法 $\mathcal{O}(n)$">四、动态规划法 $\mathcal{O}(n)$</a></li>
                <li>
                    <a href="#%e4%ba%94%e6%89%ab%e6%8f%8f%e6%b3%95-mathcalon" aria-label="五、扫描法 $\mathcal{O}(n)$">五、扫描法 $\mathcal{O}(n)$</a></li>
                <li>
                    <a href="#%e6%b5%8b%e8%af%95" aria-label="测试">测试</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="一暴力算法-mathcalon3">一、暴力算法 $\mathcal{O}(n^3)$<a hidden class="anchor" aria-hidden="true" href="#一暴力算法-mathcalon3">#</a></h2>
<p>遍历数组的所有子数组集合，并对其求和，筛选出和的最大值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSumOfSub1</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> array, <span style="color:#66d9ef">int</span> length){
    <span style="color:#66d9ef">int</span> maxSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> startIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, endIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length; i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;</span> length; j<span style="color:#f92672">++</span>){
            <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> i; k <span style="color:#f92672">&lt;=</span> j; k<span style="color:#f92672">++</span>)
                sum <span style="color:#f92672">+=</span> array[k];
            <span style="color:#66d9ef">if</span>(maxSum <span style="color:#f92672">&lt;</span> sum){
                maxSum <span style="color:#f92672">=</span> sum;
                startIndex <span style="color:#f92672">=</span> i;
                endIndex <span style="color:#f92672">=</span> j;
            }
        }
    }
    
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Begin:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> startIndex <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;  End:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endIndex <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;  Num:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> maxSum <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> maxSum;
}
</code></pre></div><h2 id="二前缀和-mathcalon2">二、前缀和 $\mathcal{O}(n^2)$<a hidden class="anchor" aria-hidden="true" href="#二前缀和-mathcalon2">#</a></h2>
<p>先把数组的前 i 项和求出来并将其保存到数组中，然后计算所有子数组集合的和，筛选其中最大的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSumOfSub2</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> array, <span style="color:#66d9ef">int</span> length){
    <span style="color:#66d9ef">int</span> maxSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> sumLen <span style="color:#f92672">=</span> length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> sum[sumLen] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
    <span style="color:#66d9ef">int</span> startIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, endIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> length; <span style="color:#f92672">++</span>i){
        sum[i] <span style="color:#f92672">=</span> sum[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> array[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]; 
    }
    <span style="color:#75715e">// for_each(sum, sum + sumLen, [](int ele){ cout &lt;&lt; ele &lt;&lt; &#34; &#34;;});
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// cout &lt;&lt; endl;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length; i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> length; j<span style="color:#f92672">++</span>){
            <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> sum[j] <span style="color:#f92672">-</span> sum[i];
            <span style="color:#66d9ef">if</span>(maxSum <span style="color:#f92672">&lt;</span> res){
                maxSum <span style="color:#f92672">=</span> res;
                startIndex <span style="color:#f92672">=</span> i;
                endIndex <span style="color:#f92672">=</span> j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
            }
        }
    }
    
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Begin:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> startIndex <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;  End:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endIndex <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;  Num:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> maxSum <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> maxSum;
}
</code></pre></div><h2 id="三分治法-mathcalonlog_2n">三、分治法 $\mathcal{O}(n\log_2{}n)$<a hidden class="anchor" aria-hidden="true" href="#三分治法-mathcalonlog_2n">#</a></h2>
<p>先将数组分为两个子数组 a, b；<br>
分别求出两个子数组 a，b 的连续子数组中和的最大值 ma, mb；<br>
还有一种情况：有可能最大和的子数组跨越两个数组 mc；<br>
在计算 mc 时，注意：mc必定包含总区间的中间元素，因此求 mc 等价于从中间元素开始往左累加的最大值 + 从中间元素开始往右累加的最大值。<br>
最后比较 ma, mb, mc，取最大的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSumOfSub3</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> array, <span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r){
    <span style="color:#66d9ef">if</span>(l <span style="color:#f92672">==</span> r){ 
        <span style="color:#66d9ef">return</span> array[l];
    }
    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> (l <span style="color:#f92672">+</span> r) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
    <span style="color:#75715e">//计算Ma,Mb的情况
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> maxa <span style="color:#f92672">=</span> maxSumOfSub3(array, l, mid);
    <span style="color:#66d9ef">int</span> maxb <span style="color:#f92672">=</span> maxSumOfSub3(array, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r);

    <span style="color:#75715e">//计算子数组跨越两个子数组（Mc）的情况
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> maxc <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, lmax <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, rmax <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> mid; i <span style="color:#f92672">&gt;=</span> l; i<span style="color:#f92672">--</span>){<span style="color:#75715e">//从中间元素开始往左累加的最大值
</span><span style="color:#75715e"></span>        sum <span style="color:#f92672">+=</span> array[i];
        lmax <span style="color:#f92672">=</span> max(lmax, sum);
    }
    sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> r; i<span style="color:#f92672">++</span>){<span style="color:#75715e">//从中间元素开始往右累加的最大值
</span><span style="color:#75715e"></span>        sum <span style="color:#f92672">+=</span> array[i];
        rmax <span style="color:#f92672">=</span> max(rmax, sum);
    }
    maxc <span style="color:#f92672">=</span> lmax <span style="color:#f92672">+</span> rmax;
    <span style="color:#66d9ef">return</span> max(maxc, max(maxa, maxb));
}
</code></pre></div><h2 id="四动态规划法-mathcalon">四、动态规划法 $\mathcal{O}(n)$<a hidden class="anchor" aria-hidden="true" href="#四动态规划法-mathcalon">#</a></h2>
<ul>
<li><code>dp[i]</code> 表示以下标 <code>i</code> 指向的元素结尾的所有子数组的和的最大值</li>
<li>状态转移方程：<code>dp[i] = max(dp[i-1] + nums[i], nums[i])</code></li>
<li>最后的子数组最大和：<code>ans = max(dp[i], ans)</code></li>
<li>需要比较三个值，筛选出三者中的最大值：前最大子数组和（索引 <code>i-1</code> 之前）、当前项 <code>num[i]</code> 的值、边界最大子数组和（索引 <code>i</code> 之前）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSumOfSub4</span>( <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> array, <span style="color:#66d9ef">int</span> length)
{
    <span style="color:#66d9ef">int</span> dp[length] <span style="color:#f92672">=</span> {array[<span style="color:#ae81ff">0</span>]};
    <span style="color:#66d9ef">int</span> maxSum <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i )
    {
        dp[i] <span style="color:#f92672">=</span> max(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> array[i], array[i]);
        maxSum <span style="color:#f92672">=</span> max(maxSum, dp[i]);
    }
    
    <span style="color:#66d9ef">return</span> maxSum;
}
</code></pre></div><p>改进一：省去保存历史状态值的数组空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSumOfSub5</span>( <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> array, <span style="color:#66d9ef">int</span> length)
{
    <span style="color:#66d9ef">int</span> boundry <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">int</span> maxSum <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i )
    {
        boundry <span style="color:#f92672">=</span> max(boundry <span style="color:#f92672">+</span> array[i], array[i]);
        maxSum <span style="color:#f92672">=</span> max(maxSum, boundry);
    }
    
    <span style="color:#66d9ef">return</span> maxSum;
}
</code></pre></div><p>改进二：记录最大子数组区间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSumOfSub6</span>( <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> array, <span style="color:#66d9ef">int</span> length)
{
    <span style="color:#66d9ef">int</span> dp[length] <span style="color:#f92672">=</span> {array[<span style="color:#ae81ff">0</span>]};
    <span style="color:#66d9ef">int</span> maxSum <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">int</span> endIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> startIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> tmpBeginIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i )
    {
        <span style="color:#75715e">// dp[i] = max(dp[i-1] + array[i], array[i]);
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// maxSum = max(maxSum, dp[i]);
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> array[i] <span style="color:#f92672">&lt;</span> array[i]){
            dp[i] <span style="color:#f92672">=</span> array[i];
            tmpBeginIndex <span style="color:#f92672">=</span> i;
        }
        <span style="color:#66d9ef">else</span>{
            dp[i] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> array[i];
        }
        <span style="color:#66d9ef">if</span>(maxSum <span style="color:#f92672">&lt;</span> dp[i]){
            maxSum <span style="color:#f92672">=</span> dp[i];
            startIndex <span style="color:#f92672">=</span> tmpBeginIndex;
            endIndex <span style="color:#f92672">=</span> i;
        }
    }
    
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Begin:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> startIndex <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;  End:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endIndex <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;  Num:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> maxSum <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> maxSum;
}
</code></pre></div><p>改进三：省去保存历史状态值的数组空间，并且记录大子数组区间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSumOfSub7</span>( <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> array, <span style="color:#66d9ef">int</span> length)
{
    <span style="color:#66d9ef">int</span> boundry <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">int</span> maxSum <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">int</span> endIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> startIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> tmpBeginIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i )
    {
        <span style="color:#75715e">// boundry = max(boundry + array[i], array[i]);
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// maxSum = max(maxSum, boundry);
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(boundry <span style="color:#f92672">+</span> array[i] <span style="color:#f92672">&lt;</span> array[i]){
            boundry <span style="color:#f92672">=</span> array[i];
            tmpBeginIndex <span style="color:#f92672">=</span> i;
        }
        <span style="color:#66d9ef">else</span>{
            boundry <span style="color:#f92672">+=</span> array[i];
        }
        <span style="color:#66d9ef">if</span>(maxSum <span style="color:#f92672">&lt;</span> boundry){
            maxSum <span style="color:#f92672">=</span> boundry;
            startIndex <span style="color:#f92672">=</span> tmpBeginIndex;
            endIndex <span style="color:#f92672">=</span> i;
        }
    }
    
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Begin:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> startIndex <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;  End:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endIndex <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;  Num:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> maxSum <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> maxSum;
}
</code></pre></div><h2 id="五扫描法-mathcalon">五、扫描法 $\mathcal{O}(n)$<a hidden class="anchor" aria-hidden="true" href="#五扫描法-mathcalon">#</a></h2>
<p>当加上一个正数时，和会增加；当加上一个负数时，和会减少。如果当前得到的和是个负数，那么这个和在接下来的累加中应该抛弃并重新清零，不然的话这个负数将会减少接下来的和。（与动态规划算法很像似）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSumOfSub8</span>( <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> array, <span style="color:#66d9ef">int</span> length)
{
    <span style="color:#66d9ef">int</span> boundry <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">int</span> maxSum <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">int</span> endIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> startIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> tmpBeginIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i )
    {
        <span style="color:#66d9ef">if</span>(boundry <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){
            boundry <span style="color:#f92672">=</span> array[i];
            tmpBeginIndex <span style="color:#f92672">=</span> i;
        }
        <span style="color:#66d9ef">else</span>{
            boundry <span style="color:#f92672">+=</span> array[i];
        }
        <span style="color:#66d9ef">if</span>( maxSum <span style="color:#f92672">&lt;</span> boundry )
        {
            maxSum <span style="color:#f92672">=</span> boundry; 
            startIndex <span style="color:#f92672">=</span> tmpBeginIndex;
            endIndex <span style="color:#f92672">=</span> i;
        }
    }
    
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Begin:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> startIndex <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;  End:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endIndex <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;  Num:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> maxSum <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> maxSum;
}
</code></pre></div><h2 id="测试">测试<a hidden class="anchor" aria-hidden="true" href="#测试">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> a[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">10</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">2</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">48</span>};
    <span style="color:#75715e">// int a[] = {3,-1,-1,-1,-1,-1,-1,-1};
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// int a[] = {-1,-1,-1,-1,-1,-1,-1,3};
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// int a[] = {5,-2,-3,-1,-1,-1,-1,-3};
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(a)<span style="color:#f92672">/</span><span style="color:#66d9ef">sizeof</span>(a[<span style="color:#ae81ff">0</span>]);
    <span style="color:#75715e">// int result = maxSumOfSub5(a, num);
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    result <span style="color:#f92672">=</span> maxSumOfSub1(a, num);
    result <span style="color:#f92672">=</span> maxSumOfSub2(a, num);
    result <span style="color:#f92672">=</span> maxSumOfSub3(a, <span style="color:#ae81ff">0</span>, num<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Num:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> result <span style="color:#f92672">&lt;&lt;</span> endl;
    result <span style="color:#f92672">=</span> maxSumOfSub4(a, num);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Num:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> result <span style="color:#f92672">&lt;&lt;</span> endl;
    result <span style="color:#f92672">=</span> maxSumOfSub5(a, num);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Num:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> result <span style="color:#f92672">&lt;&lt;</span> endl;
    result <span style="color:#f92672">=</span> maxSumOfSub6(a, num);
    result <span style="color:#f92672">=</span> maxSumOfSub7(a, num);
    result <span style="color:#f92672">=</span> maxSumOfSub8(a, num);
    
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;-----------------------------&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    
    <span style="color:#66d9ef">int</span> b[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">3</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">5</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">9</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">20</span>,<span style="color:#ae81ff">21</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">20</span>,<span style="color:#ae81ff">20</span>,<span style="color:#ae81ff">21</span>};
    num <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(b)<span style="color:#f92672">/</span><span style="color:#66d9ef">sizeof</span>(b[<span style="color:#ae81ff">0</span>]);
    result <span style="color:#f92672">=</span> maxSumOfSub1(b, num);
    result <span style="color:#f92672">=</span> maxSumOfSub2(b, num);
    result <span style="color:#f92672">=</span> maxSumOfSub3(b, <span style="color:#ae81ff">0</span>, num<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Num:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> result <span style="color:#f92672">&lt;&lt;</span> endl;
    result <span style="color:#f92672">=</span> maxSumOfSub4(b, num);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Num:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> result <span style="color:#f92672">&lt;&lt;</span> endl;
    result <span style="color:#f92672">=</span> maxSumOfSub5(b, num);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Num:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> result <span style="color:#f92672">&lt;&lt;</span> endl;
    result <span style="color:#f92672">=</span> maxSumOfSub6(b, num);
    result <span style="color:#f92672">=</span> maxSumOfSub7(b, num);
    result <span style="color:#f92672">=</span> maxSumOfSub8(b, num);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Begin:2  End:6  Num:18
Begin:2  End:6  Num:18
Num:18
Num:18
Num:18
Begin:2  End:6  Num:18
Begin:2  End:6  Num:18
Begin:2  End:6  Num:18
-----------------------------
Begin:6  End:9  Num:42
Begin:6  End:9  Num:42
Num:42
Num:42
Num:42
Begin:6  End:9  Num:42
Begin:6  End:9  Num:42
Begin:6  End:9  Num:42
</code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://874656645.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://874656645.github.io/posts/151-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E8%A1%A8/">
    <span class="title">Next Page »</span>
    <br>
    <span>数据结构与算法——线性表</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>"Take time for all things: great haste makes great waste." – Benjamin Franklin</span><br/>
    <span>&copy; 2022 <a href="https://874656645.github.io">Slow is Smooth and Smooth is Fast</a></span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>


<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
