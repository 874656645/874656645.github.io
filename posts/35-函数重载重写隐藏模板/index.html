<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Welcome to Rick&#39;s Page  | 函数重载、重写、隐藏、模板</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.52" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/rick/dist/css/app.955516233bcafa4d2a1c13cea63c7b50.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="函数重载、重写、隐藏、模板" />
<meta property="og:description" content="函数重载、重写、隐藏、模板  重载： 在同一作用域中，两个函数名相同，但是参数列表不同（个数、类型、顺序），返回值类型没有要求； 重写： 子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写； 隐藏： 派生类中函数与基类中的函数同名，但是这个函数在基类中并没有被定义为虚函数，此时基类的函数会被隐藏； 模板： 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表，只适用于 参数个数相同而类型不同 的函数。 构造函数可以被重载，析构函数不可以被重载，但是可被重写。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数  1、重载  类的静态函数也可以重载； 形参中一级指针和二级指针被认为是不同类型的参数；  class A{ public: A(int a){ m_a = a; } void print(){ cout &lt;&lt; &quot;print()&quot; &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; endl; } void freeP(A ** p){ if(p == NULL){ return; } if(*p != NULL){ free(*p); *p = NULL; } } void freeP(A * p){ if(p != NULL){ free(p); p = NULL; } } static void printS(){ cout &lt;&lt; &quot;printS() s_a = &quot; &lt;&lt; s_a &lt;&lt; endl; } static void printS(int s){ cout &lt;&lt; &quot;printS(int s) &quot; &lt;&lt; s_a * s &lt;&lt; endl; } static void printS(void *p, int s){ cout &lt;&lt; &quot;printS(void *p, int s) &quot; &lt;&lt; ((A*)p)-&gt;m_a * s &lt;&lt; endl; } static int s_a; private: int m_a; }; int A::s_a = 0; int main( ) { A *a = new A(1); a-&gt;printS(a, 20); a-&gt;print(); A::s_a = 10; a-&gt;printS(); a-&gt;printS(10); a-&gt;freeP(a); if(a == NULL){ cout &lt;&lt; &quot;*a is not valid&quot; &lt;&lt; endl; return 0; } cout &lt;&lt; &quot;*a is valid&quot; &lt;&lt; endl; a-&gt;print(); return 0; }  输出：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://874656645.github.io/rick/posts/35-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F%E6%A8%A1%E6%9D%BF/" /><meta property="article:published_time" content="2021-12-23T12:34:27&#43;08:00"/>
<meta property="article:modified_time" content="2021-12-23T12:34:27&#43;08:00"/>

<meta itemprop="name" content="函数重载、重写、隐藏、模板">
<meta itemprop="description" content="函数重载、重写、隐藏、模板  重载： 在同一作用域中，两个函数名相同，但是参数列表不同（个数、类型、顺序），返回值类型没有要求； 重写： 子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写； 隐藏： 派生类中函数与基类中的函数同名，但是这个函数在基类中并没有被定义为虚函数，此时基类的函数会被隐藏； 模板： 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表，只适用于 参数个数相同而类型不同 的函数。 构造函数可以被重载，析构函数不可以被重载，但是可被重写。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数  1、重载  类的静态函数也可以重载； 形参中一级指针和二级指针被认为是不同类型的参数；  class A{ public: A(int a){ m_a = a; } void print(){ cout &lt;&lt; &quot;print()&quot; &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; endl; } void freeP(A ** p){ if(p == NULL){ return; } if(*p != NULL){ free(*p); *p = NULL; } } void freeP(A * p){ if(p != NULL){ free(p); p = NULL; } } static void printS(){ cout &lt;&lt; &quot;printS() s_a = &quot; &lt;&lt; s_a &lt;&lt; endl; } static void printS(int s){ cout &lt;&lt; &quot;printS(int s) &quot; &lt;&lt; s_a * s &lt;&lt; endl; } static void printS(void *p, int s){ cout &lt;&lt; &quot;printS(void *p, int s) &quot; &lt;&lt; ((A*)p)-&gt;m_a * s &lt;&lt; endl; } static int s_a; private: int m_a; }; int A::s_a = 0; int main( ) { A *a = new A(1); a-&gt;printS(a, 20); a-&gt;print(); A::s_a = 10; a-&gt;printS(); a-&gt;printS(10); a-&gt;freeP(a); if(a == NULL){ cout &lt;&lt; &quot;*a is not valid&quot; &lt;&lt; endl; return 0; } cout &lt;&lt; &quot;*a is valid&quot; &lt;&lt; endl; a-&gt;print(); return 0; }  输出：">


<meta itemprop="datePublished" content="2021-12-23T12:34:27&#43;08:00" />
<meta itemprop="dateModified" content="2021-12-23T12:34:27&#43;08:00" />
<meta itemprop="wordCount" content="199">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="函数重载、重写、隐藏、模板"/>
<meta name="twitter:description" content="函数重载、重写、隐藏、模板  重载： 在同一作用域中，两个函数名相同，但是参数列表不同（个数、类型、顺序），返回值类型没有要求； 重写： 子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写； 隐藏： 派生类中函数与基类中的函数同名，但是这个函数在基类中并没有被定义为虚函数，此时基类的函数会被隐藏； 模板： 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表，只适用于 参数个数相同而类型不同 的函数。 构造函数可以被重载，析构函数不可以被重载，但是可被重写。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数  1、重载  类的静态函数也可以重载； 形参中一级指针和二级指针被认为是不同类型的参数；  class A{ public: A(int a){ m_a = a; } void print(){ cout &lt;&lt; &quot;print()&quot; &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; endl; } void freeP(A ** p){ if(p == NULL){ return; } if(*p != NULL){ free(*p); *p = NULL; } } void freeP(A * p){ if(p != NULL){ free(p); p = NULL; } } static void printS(){ cout &lt;&lt; &quot;printS() s_a = &quot; &lt;&lt; s_a &lt;&lt; endl; } static void printS(int s){ cout &lt;&lt; &quot;printS(int s) &quot; &lt;&lt; s_a * s &lt;&lt; endl; } static void printS(void *p, int s){ cout &lt;&lt; &quot;printS(void *p, int s) &quot; &lt;&lt; ((A*)p)-&gt;m_a * s &lt;&lt; endl; } static int s_a; private: int m_a; }; int A::s_a = 0; int main( ) { A *a = new A(1); a-&gt;printS(a, 20); a-&gt;print(); A::s_a = 10; a-&gt;printS(); a-&gt;printS(10); a-&gt;freeP(a); if(a == NULL){ cout &lt;&lt; &quot;*a is not valid&quot; &lt;&lt; endl; return 0; } cout &lt;&lt; &quot;*a is valid&quot; &lt;&lt; endl; a-&gt;print(); return 0; }  输出："/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://874656645.github.io/rick/" class="f3 fw2 hover-white no-underline white-90 dib">
      Welcome to Rick&#39;s Page
    </a>
    <div class="flex-l items-center">
      
      
<div hidden>
  <span id="new-window-0">Opens in a new window</span>
  <span id="new-window-1">Opens an external site</span>
  <span id="new-window-2">Opens an external site in a new window</span>
</div>









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">函数重载、重写、隐藏、模板</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2021-12-23T12:34:27&#43;08:00">December 23, 2021</time>      
      
      
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h2 id="函数重载-重写-隐藏-模板">函数重载、重写、隐藏、模板</h2>

<ul>
<li><strong>重载：</strong> 在同一作用域中，两个函数名相同，但是参数列表不同（个数、类型、顺序），<strong>返回值类型没有要求</strong>；</li>
<li><strong>重写：</strong> 子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写；</li>
<li><strong>隐藏：</strong> 派生类中函数与基类中的函数同名，但是这个函数在基类中并没有被定义为虚函数，此时基类的函数会被隐藏；</li>
<li><strong>模板：</strong> 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表，只适用于 <strong>参数个数相同而类型不同</strong> 的函数。</li>
<li>构造函数可以被重载，析构函数不可以被重载，但是可被重写。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数</li>
</ul>

<h3 id="1-重载">1、重载</h3>

<ol>
<li>类的静态函数也可以重载；</li>
<li>形参中一级指针和二级指针被认为是不同类型的参数；</li>
</ol>

<pre><code class="language-C++">class A{
public:
    A(int a){
        m_a = a;
    }
    void print(){
        cout &lt;&lt; &quot;print()&quot; &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; endl;
    }
    void freeP(A ** p){
        if(p == NULL){
            return;
        }
        if(*p != NULL){
            free(*p);
            *p = NULL;
        }
    }
    void freeP(A * p){
        if(p != NULL){
            free(p);
            p = NULL;
        }
    }
    static void printS(){
        cout &lt;&lt; &quot;printS() s_a = &quot; &lt;&lt; s_a &lt;&lt; endl;
    }
    static void printS(int s){
        cout &lt;&lt; &quot;printS(int s) &quot; &lt;&lt; s_a * s &lt;&lt; endl;
    }
    static void printS(void *p, int s){    
        cout &lt;&lt; &quot;printS(void *p, int s) &quot; &lt;&lt; ((A*)p)-&gt;m_a * s &lt;&lt; endl;
    }
    
    static int s_a;
private:
    int m_a;
};
int A::s_a = 0;
int main( )
{  
    A *a = new A(1);
    a-&gt;printS(a, 20);
    a-&gt;print();
    A::s_a = 10;
    a-&gt;printS();
    a-&gt;printS(10);
    a-&gt;freeP(a);
    if(a == NULL){
        cout &lt;&lt; &quot;*a is not valid&quot; &lt;&lt; endl;
        return 0;
    }
    cout &lt;&lt; &quot;*a is valid&quot; &lt;&lt; endl;
    a-&gt;print();
    return 0;
}
</code></pre>

<p>输出：</p>

<pre><code class="language-text">Start
printS(void *p, int s) 20
print()m_a = 1
printS() s_a = 10
printS(int s) 100
*a is valid
print()m_a = 0
0
Finish
</code></pre>
<ul class="pa0">
  
</ul>
<div class="mt6">
        
      </div>
    </main>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://874656645.github.io/rick/" >
    &copy; 2021 Welcome to Rick&#39;s Page
  </a>
    <div>
<div hidden>
  <span id="new-window-0">Opens in a new window</span>
  <span id="new-window-1">Opens an external site</span>
  <span id="new-window-2">Opens an external site in a new window</span>
</div>








</div>
  </div>
</footer>

    

  <script src="/rick/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
