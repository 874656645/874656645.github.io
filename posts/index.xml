<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Slow is Smooth and Smooth is Fast</title>
    <link>https://874656645.github.io/posts/</link>
    <description>Recent content in Posts on Slow is Smooth and Smooth is Fast</description>
    <image>
      <url>https://874656645.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://874656645.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 10 Sep 2023 14:55:17 +0800</lastBuildDate><atom:link href="https://874656645.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>WSL Ubuntu_2204 使用</title>
      <link>https://874656645.github.io/posts/262-wsl-ubuntu_2204-%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 10 Sep 2023 14:55:17 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/262-wsl-ubuntu_2204-%E4%BD%BF%E7%94%A8/</guid>
      <description>WSL 中使用 Ubuntu_2204 参考：Windows 10 中的 Linux 子系统
配置开发环境   Linux 常用命令参考
  安装常用开发环境
sudo apt-get install build-essential
  安装 python 2.7  注意：Ubuntu_2204 中自带 python3，所以 python2 需要进行手动安装和配置。    查看已安装的版本
ls /usr/bin/python*
  安装 python2
sudo apt-get install python2
  设置默认版本
sudo update-alternatives --list python
sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 1
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 2
sudo update-alternatives --config python</description>
    </item>
    
    <item>
      <title>C&#43;&#43;——打印枚举常量字符串</title>
      <link>https://874656645.github.io/posts/261-c&#43;&#43;-%E6%89%93%E5%8D%B0%E6%9E%9A%E4%B8%BE%E5%B8%B8%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Wed, 12 Apr 2023 22:02:53 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/261-c&#43;&#43;-%E6%89%93%E5%8D%B0%E6%9E%9A%E4%B8%BE%E5%B8%B8%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#define MY_INT 7777 #define STR(R) #R #define STR2(R) STR(R)  enum MyType{ MyType_NULL, MyType_One, MyType_Two }; int main() { printf(&amp;#34;%s\n&amp;#34;, STR(MyType_One)); printf(&amp;#34;%s\n&amp;#34;, STR(HELLO_WORLD)); printf(&amp;#34;%s\n&amp;#34;, STR(MY_INT)); printf(&amp;#34;%s\n&amp;#34;, STR2(MY_INT)); const int arr[] = {1,2,3}; arr[1] = 4; // error: assignment of read-only location ‘arr[1]’  return 0; } 输出：
MyType_One HELLO_WORLD MY_INT 7777 参考：
 c++中#与##的作用  </description>
    </item>
    
    <item>
      <title>Git——TortoiseGit 分支相关操作</title>
      <link>https://874656645.github.io/posts/260-git-tortoisegit-%E5%88%86%E6%94%AF%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Fri, 24 Feb 2023 13:45:59 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/260-git-tortoisegit-%E5%88%86%E6%94%AF%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</guid>
      <description>Git 常用命令.</description>
    </item>
    
    <item>
      <title>Git——Windows TortoiseGit 配置 SSH </title>
      <link>https://874656645.github.io/posts/259-git-tortoisegit-%E9%85%8D%E7%BD%AE-ssh-/</link>
      <pubDate>Wed, 22 Feb 2023 20:09:10 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/259-git-tortoisegit-%E9%85%8D%E7%BD%AE-ssh-/</guid>
      <description>Git 常用命令.</description>
    </item>
    
    <item>
      <title>Git——stash TortoiseGit 将一个分支上的修改转移到另一个分支上</title>
      <link>https://874656645.github.io/posts/258-git-stash-%E5%B0%86%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF%E4%B8%8A%E7%9A%84%E4%BF%AE%E6%94%B9%E8%BD%AC%E7%A7%BB%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF%E4%B8%8A/</link>
      <pubDate>Wed, 22 Feb 2023 17:10:24 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/258-git-stash-%E5%B0%86%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF%E4%B8%8A%E7%9A%84%E4%BF%AE%E6%94%B9%E8%BD%AC%E7%A7%BB%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF%E4%B8%8A/</guid>
      <description>Git 常用命令.</description>
    </item>
    
    <item>
      <title>Unreal——Subsystem（子系统）</title>
      <link>https://874656645.github.io/posts/257-unreal-subsystem%E5%AD%90%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 07 Dec 2022 10:34:53 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/257-unreal-subsystem%E5%AD%90%E7%B3%BB%E7%BB%9F/</guid>
      <description>Programming Subsystems</description>
    </item>
    
    <item>
      <title>Unreal——项目和插件</title>
      <link>https://874656645.github.io/posts/256-unreal-%E9%A1%B9%E7%9B%AE%E5%92%8C%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Wed, 07 Dec 2022 09:59:17 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/256-unreal-%E9%A1%B9%E7%9B%AE%E5%92%8C%E6%8F%92%E4%BB%B6/</guid>
      <description>一、插件  插件是为特定目的设计的代码和数据的集合； 开发人员可以很容易的在单个项目中启用或禁用他们； 插件分为运行时（runtime gameplay functionality）、编辑器（editor functionality）  二、模块  项目本身也是一个模块  三、依赖 </description>
    </item>
    
    <item>
      <title>数据结构与算法——二叉树遍历</title>
      <link>https://874656645.github.io/posts/255-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 13 Nov 2022 19:46:40 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/255-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</guid>
      <description>先序遍历
template&amp;lt;typename T&amp;gt; void PreOrder(BinaryTreeNode&amp;lt;T&amp;gt;* root){ stack&amp;lt;BinaryTreeNode&amp;lt;T&amp;gt;*&amp;gt; aStack; BinaryTreeNode&amp;lt;T&amp;gt;* pointer = root; aStack.push(nullptr); // 栈底监视哨  while(pointer){ // 或者 !aStack.empty()  Visit(pointer); // 访问当前结点  if(pointer-&amp;gt;rightchild() != nullptr){ // 右孩子入栈  aStack.push(pointer-&amp;gt;rightchild()); } if(pointer-&amp;gt;leftchild() != nullptr){ // 左路下降  pointer = pointer-&amp;gt;leftchild(); }else{ // 左子树访问完毕，转向访问右子树  pointer = aStack.top(); aStack.pop(); } } }   中序遍历
template&amp;lt;typename T&amp;gt; void InOrder(BinaryTreeNode&amp;lt;T&amp;gt;* root){ stack&amp;lt;BinaryTreeNode&amp;lt;T&amp;gt;*&amp;gt; aStack; BinaryTreeNode&amp;lt;T&amp;gt;* pointer = root; while(!aStack.empty() || pointer){ if(pointer){ // Visit(pointer); // 前序访问点  aStack.</description>
    </item>
    
    <item>
      <title>数据结构与算法——二叉树</title>
      <link>https://874656645.github.io/posts/254-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 13 Nov 2022 17:58:17 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/254-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>一、相关概念   结点：根节、叶节点、分支结点、兄弟结点、父子结点
  边、路径
  结点深度、高度、层数
 根节点为第 0 层 深度指从根节点到该节点的边的数量 高度指从此节点到叶节点的结点数量    满二叉树、完全二叉树
 满二叉树指除了度为 0 的叶节点就是度为 2 的分支节点 完全二叉树指只有最下面的两层度是小于 2 的，且最下面的结点都集中在左侧    扩充二叉树
  二叉树性质
  </description>
    </item>
    
    <item>
      <title>数据结构与算法——KMP 字符串匹配算法</title>
      <link>https://874656645.github.io/posts/253-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95kmp-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 13 Nov 2022 14:56:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/253-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95kmp-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</guid>
      <description>  模式串 next 向量计算：
  字符串比较
int mystrcmp(const char* str1, const char* str2){ int i = 0; while(str1[i] == str2[i] &amp;amp;&amp;amp; str1[i] != &amp;#39;\0&amp;#39;){ i++; } return str1[i] - str2[i]; }   </description>
    </item>
    
    <item>
      <title>Unreal5——开发、使用问题汇总</title>
      <link>https://874656645.github.io/posts/252-unreal5-%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</link>
      <pubDate>Thu, 10 Nov 2022 09:01:48 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/252-unreal5-%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</guid>
      <description>新建项目的时候没有项目模板
打开 Epic Games Launcher，在 虚幻引擎 -&amp;gt; 库 中选择需要添加组件的引擎版本，打开 选项 面板，勾选需要更改的组件
  在 Play 模式下切换到鼠标控制
Shift + F1
  Detaches from the player controller，通过鼠标操作场景和 Editor
F8
  指定源码开发工具
Editor Preferences -&amp;gt; Source Code
  C++ 代码编译
Editor 右下角
  C++ Live Coding 热编译
Ctrl + Alt + F11
  重新构建 C++ 工程
注意：需要关闭 Editor
VS Code: Ctrl + Shift + B
  C++ 项目中使用插件</description>
    </item>
    
    <item>
      <title>Cesium4Unreal——Importing Quixel Assets</title>
      <link>https://874656645.github.io/posts/251-cesium-unreal-importing-quixel-assets/</link>
      <pubDate>Tue, 25 Oct 2022 09:48:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/251-cesium-unreal-importing-quixel-assets/</guid>
      <description>一、安装 Quixel Bridge   UE5 中已经集成了 Quixel Bridge 插件，不再需要单独安装（安装包），选择 编辑（Edit）&amp;gt; 插件（Plugins） 。在搜索栏中输入 bridge ，然后点击复选框以启用该插件。
  如果在插件面板中未显示 Quixel Bridge 插件，需要从 Epic Games 启动程序（Epic Games Launcher） 安装它。打开 Epic Games 启动程序，点击 库（Library） ，然后向下滚动到名为 保管库（Vault） 的分割线。在搜索栏中输入 Bridge 。选择 安装到引擎（Install to Engine） 。重新启动引擎时，可以按如上所述启用该插件。
  使用 EPIC GAME 账户 登录到 Quixel Bridge 并进行授权，加入 Unreal Unlimited 计划，如有需要，请科学上网
  如果发现账户无法登录，采用下面的步骤解决：
科学上网 如果已经运行，请关闭 Bridge； 导航到 C:\Users[用户]\AppData\Roaming 删除 Bridge、Bridge-Bifrost、Megascans Bridge 三个文件夹 重新登录到 Bridge    二、在项目中导入资源   打开 Bridge 面板，搜索自己需要的资源，并将其下载到本地</description>
    </item>
    
    <item>
      <title>Cesium4Unreal——Build a Flight Tracker With Cesium for Unreal</title>
      <link>https://874656645.github.io/posts/250-cesium-unreal-build-a-flight-tracker-with-cesium-for-unreal/</link>
      <pubDate>Wed, 19 Oct 2022 14:25:50 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/250-cesium-unreal-build-a-flight-tracker-with-cesium-for-unreal/</guid>
      <description>第一步：创建一个关卡  创建一个空的 Unreal 关卡； 登录 Cesium ion 并添加 Cesium World Terrain 和 CesiumSunSky； 设置 CesiumGeoreference 的坐标为 San Francisco International Airport (SFO)；
Origin Latitude = 37.61779
Origin Longitude = -122.390533
Origin Height = 0.0  第二步：添加 PlaneTrack 类   在 UE Editor 中添加 C++ 类，选择 Actor 作为父类，点击【下一步】，输入类名 PlaneTrack，点击【创建类】按钮，此时 Visual Studio 会自动打开，如果没有打开，可以通过【工具】——【打开Visual Studio】手动打开项目
VS 2022 解决方案类似下图：
  添加下面的代码到 project.Build.cs 文件：
// Add Cesium for Unreal plugin dependency path PrivateDependencyModuleNames.AddRange(new string[] { &amp;#34;CesiumRuntime&amp;#34; }); // Tell Unreal Engine to use C++17 CppStandard = CppStandardVersion.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;——malloc、calloc、realloc、指针杂记</title>
      <link>https://874656645.github.io/posts/249-c&#43;&#43;-malloc-calloc-realloc-%E6%8C%87%E9%92%88%E6%9D%82%E8%AE%B0/</link>
      <pubDate>Sun, 02 Oct 2022 22:18:02 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/249-c&#43;&#43;-malloc-calloc-realloc-%E6%8C%87%E9%92%88%E6%9D%82%E8%AE%B0/</guid>
      <description>void printArr(int *A, int size){ printf(&amp;#34;Elements of array: &amp;#34;); for(int i = 0; i &amp;lt; size; ++i){ printf(&amp;#34;%d\t&amp;#34;, A[i]); } printf(&amp;#34;\n&amp;#34;); } int main() { int C[3][2][2] = {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}; // 虽然地址相同，但代表的意义却不相同  printf(&amp;#34;%p\t%p\t%p\t%p\t%p\t%p \n&amp;#34;, C, *C, C[0], C[0][0], &amp;amp;C[0][0], &amp;amp;C[0][0][0]); printf(&amp;#34;%p\t%p\t%p\n&amp;#34;, *C+1, C[0]+1, C[0][1]); printf(&amp;#34;%p\t%p\n&amp;#34;, C, C[0][0] + 1); printf(&amp;#34;%p\t%p\n&amp;#34;, C, &amp;amp;C[0][0] + 1); // 分配空间，但不会对元素进行初始化  int *A = (int*)malloc(3 * sizeof(int)); for(int i = 0; i &amp;lt; 3; ++i){ A[i] = i+1; } printArr(A, 3); // 分配空间，并将元素初始化为0  int *B = (int*)calloc(3, sizeof(int)); printArr(B, 3); // 重新分配一块空间（新空间可大可小）  // 并把原来的数据拷贝过来  // 如果新空间首地址与原来空间地址不同，会将原来的内存空间释放  // ，注意：此时不能再继续访问原来的地址，虽然原来的指针并未置空  int *D = (int*)realloc(A, 10 * sizeof(int)); printf(&amp;#34;%p\t%p\n&amp;#34;, A, D); printArr(A, 3); // 此时不能访问 A 了，这是危险的行为  printArr(D, 10); // 等同于重新分配了空间  D = (int*)realloc(NULL, 3 * sizeof(int)); // int *D = (int*)malloc(3 * sizeof(int));  printf(&amp;#34;%p\t%p\n&amp;#34;, A, D); printArr(D, 3); // 等同于释放了内存空间并将指针置为空值  D = (int*)realloc(D, 0); // free(D);D = nullptr;  printf(&amp;#34;%p\n&amp;#34;, D); return 0; } 输出：</description>
    </item>
    
    <item>
      <title>C&#43;&#43;——计算最大和子矩阵问题</title>
      <link>https://874656645.github.io/posts/248-c&#43;&#43;-%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E5%92%8C%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 27 Sep 2022 18:42:52 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/248-c&#43;&#43;-%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E5%92%8C%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98/</guid>
      <description>描述 计算矩阵中，最大和的子矩阵，并输出最大的和
测试用例 用例一：
$$\begin{equation} \begin{bmatrix*}[c] -3 &amp;amp; -5 &amp;amp; -1 &amp;amp; 5 \newline 2 &amp;amp; -4 &amp;amp; -2 &amp;amp; 4 \newline -1 &amp;amp; 3 &amp;amp; -1 &amp;amp; 3 \end{bmatrix*} \end{equation}$$
用例二：
$$\begin{equation} \begin{bmatrix*}[c] -3 &amp;amp; -5 &amp;amp; -1 &amp;amp; 5 \newline 9 &amp;amp; -4 &amp;amp; -2 &amp;amp; 4 \newline -1 &amp;amp; 3 &amp;amp; -1 &amp;amp; 3 \end{bmatrix*} \end{equation}$$
用例三：
$$\begin{equation} \begin{bmatrix*}[c] -3 &amp;amp; -5 &amp;amp; -1 &amp;amp; 5 \newline 7 &amp;amp; -4 &amp;amp; -2 &amp;amp; 4 \newline -1 &amp;amp; 3 &amp;amp; -1 &amp;amp; 3 \end{bmatrix*} \end{equation}$$</description>
    </item>
    
    <item>
      <title>C&#43;&#43;——旋转骰子问题</title>
      <link>https://874656645.github.io/posts/247-c&#43;&#43;-%E6%97%8B%E8%BD%AC%E9%AA%B0%E5%AD%90%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 23 Sep 2022 16:30:43 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/247-c&#43;&#43;-%E6%97%8B%E8%BD%AC%E9%AA%B0%E5%AD%90%E9%97%AE%E9%A2%98/</guid>
      <description>方法一：使用字符串 注意 ：
 字符与字符相加返回的是一个整数 字符串与字符相加的问题：  可以使用 + 号运算符，但其中一个操作数需要是 string 类型 如果需要连续相加多个字符，前两个操作数必须有一个是 string 类型的 可以使用 string.append 方法   控制台输入字符串的问题，如果直接使用 cin &amp;gt;&amp;gt; str，遇到空格和回车都会终止读取  例如：在字符串 s 后面添加 &amp;lsquo;a&amp;rsquo;、&amp;lsquo;b&amp;rsquo;、&amp;lsquo;c&amp;rsquo; 三个字符
参考 C++ 运算符优先级和结合性
string s; s = s + &amp;#39;a&amp;#39; + &amp;#39;b&amp;#39; + &amp;#39;c&amp;#39;;	// 正确 s += &amp;#39;a&amp;#39; + &amp;#39;b&amp;#39; + &amp;#39;c&amp;#39;;	// 错误 s = &amp;#39;a&amp;#39; + &amp;#39;b&amp;#39; + &amp;#39;c&amp;#39; + s;	// 错误 int main(){ string LR = &amp;#34;1625&amp;#34;, FB = &amp;#34;3645&amp;#34;, AC = &amp;#34;1324&amp;#34;; string mov; getline(cin, mov); for (char c : mov) { string tmp = &amp;#34;&amp;#34;; switch (c) { case &amp;#39;L&amp;#39;: case &amp;#39;R&amp;#39;: { if (c == &amp;#39;L&amp;#39;) { // LR = tmp + LR[3] + LR[0] + LR[1] + LR[2]; 	LR = LR[3] + string(LR, 0, 3); } else { // LR = tmp + LR[1] + LR[2] + LR[3] + LR[0]; 	LR = string(LR, 1, 3) + LR[0]; } // FB = tmp + FB[0] + LR[1] + FB[2] + LR[3]; 	FB[1] = LR[1]; FB[3] = LR[3]; // AC = tmp + LR[0] + AC[1] + LR[2] + AC[3]; 	AC[0] = LR[0]; AC[2] = LR[2]; break; } case &amp;#39;F&amp;#39;: case &amp;#39;B&amp;#39;: { if (c == &amp;#39;F&amp;#39;) { // FB = tmp + FB[3] + FB[0] + FB[1] + FB[2]; 	FB = FB[3] + string(FB, 0, 3); } else { // FB = tmp + FB[1] + FB[2] + FB[3] + FB[0]; 	FB = string(FB, 1, 3) + FB[0]; } // LR = tmp + LR[0] + FB[1] + LR[2] + FB[3]; 	LR[1] = FB[1]; LR[3] = FB[3]; // AC = tmp + AC[0] + FB[0] + AC[2] + FB[2]; 	AC[1] = FB[0]; AC[3] = FB[2]; break; } case &amp;#39;A&amp;#39;: case &amp;#39;C&amp;#39;: { if (c == &amp;#39;A&amp;#39;) { AC = tmp + AC[3] + AC[0] + AC[1] + AC[2]; } else { AC = tmp + AC[1] + AC[2] + AC[3] + AC[0]; } LR = tmp + AC[0] + LR[1] + AC[2] + LR[3]; FB = tmp + AC[1] + FB[1] + AC[3] + FB[3]; break; } default: break; } } cout &amp;lt;&amp;lt; LR[0] &amp;lt;&amp;lt; LR[2] &amp;lt;&amp;lt; FB[0] &amp;lt;&amp;lt; FB[2] &amp;lt;&amp;lt; LR[3] &amp;lt;&amp;lt; LR[1]; return 0; } 方法二：使用 deque 容器 int main() { //string LR = &amp;#34;1625&amp;#34;, FB = &amp;#34;3645&amp;#34;, AC = &amp;#34;1324&amp;#34;; 	deque&amp;lt;char&amp;gt; LR, FB, AC; LR.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;——List、strcpy_s、strtok_s 使用</title>
      <link>https://874656645.github.io/posts/246-c&#43;&#43;-liststrcpy_sstrtok_s-%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 22 Sep 2022 16:52:07 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/246-c&#43;&#43;-liststrcpy_sstrtok_s-%E4%BD%BF%E7%94%A8/</guid>
      <description>目标 对输入的字符串中的单词，把给定的索引区间中的单词逆序
方法一  通过 strtok（strtok_s、strtok_r） 分割字符串 使用 list 容器存储各个单词 可以通过前插的方式反转指定区间的单词 也可以通过前后交换的方式反转指定区间的单词 顺序输出 list 中的单词  int main(){ string str = &amp;#34;I am a developer&amp;#34;; char *cArr = new char[str.size()+1]{0}; strcpy_s(cArr, str.size()+1, str.c_str());	// 注意：第二个参数，要拷贝的字符串的长度包括结尾的 &amp;#39;\0&amp;#39; 	char *w = nullptr, *rest = nullptr; list&amp;lt;string&amp;gt; wordList; w = strtok_s(cArr, &amp;#34; &amp;#34;, &amp;amp;rest); while (w) { wordList.push_back(w); w = strtok_s(nullptr, &amp;#34; &amp;#34;, &amp;amp;rest); } int startIndex = 0, endIndex = 0; cin &amp;gt;&amp;gt; startIndex &amp;gt;&amp;gt; endIndex; int len = wordList.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;——类模板双栈模拟队列</title>
      <link>https://874656645.github.io/posts/245-c&#43;&#43;-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%8F%8C%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/</link>
      <pubDate>Tue, 20 Sep 2022 22:14:24 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/245-c&#43;&#43;-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%8F%8C%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/</guid>
      <description></description>
    </item>
    
    <item>
      <title>C&#43;&#43;——类模板</title>
      <link>https://874656645.github.io/posts/244-c&#43;&#43;-%E7%B1%BB%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Sun, 18 Sep 2022 18:07:48 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/244-c&#43;&#43;-%E7%B1%BB%E6%A8%A1%E6%9D%BF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>C&#43;&#43;——函数模板</title>
      <link>https://874656645.github.io/posts/243-c&#43;&#43;-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Sun, 18 Sep 2022 17:28:56 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/243-c&#43;&#43;-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>C&#43;&#43;——变量模板</title>
      <link>https://874656645.github.io/posts/242-c&#43;&#43;-%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Sun, 18 Sep 2022 14:38:58 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/242-c&#43;&#43;-%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>C&#43;&#43;——Lambda表达式</title>
      <link>https://874656645.github.io/posts/241-c&#43;&#43;-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sun, 18 Sep 2022 10:38:31 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/241-c&#43;&#43;-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>C&#43;&#43;——类型推导杂记</title>
      <link>https://874656645.github.io/posts/240-c&#43;&#43;-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E6%9D%82%E8%AE%B0/</link>
      <pubDate>Fri, 16 Sep 2022 11:38:55 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/240-c&#43;&#43;-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E6%9D%82%E8%AE%B0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>C&#43;&#43;——类型转换杂记</title>
      <link>https://874656645.github.io/posts/239-c&#43;&#43;-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9D%82%E8%AE%B0/</link>
      <pubDate>Thu, 15 Sep 2022 11:13:34 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/239-c&#43;&#43;-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9D%82%E8%AE%B0/</guid>
      <description>const_cast 和 static_cast int x = 65536; (short &amp;amp;)x = 65535; cout&amp;lt;&amp;lt;x; int main() { const int x = 0; *(int*)&amp;amp;x = 2; cout &amp;lt;&amp;lt; &amp;#34;x = &amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl; // x = 0  (int&amp;amp;)x = 3; int y = x; cout &amp;lt;&amp;lt; &amp;#34;y = &amp;#34; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl; // y = 0  const_cast&amp;lt;int&amp;amp;&amp;gt;(x) = 10; y = x; cout &amp;lt;&amp;lt; &amp;#34;y = &amp;#34; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl; // y = 0  return 0; } struct T{ int x = 0; const int y = 0; int q() const{ *(int*)&amp;amp;y = y + 1; return y; } }; int main() { T m; const T n; int x = m.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;——类型转换</title>
      <link>https://874656645.github.io/posts/238-c&#43;&#43;-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Wed, 14 Sep 2022 22:02:50 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/238-c&#43;&#43;-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>C&#43;&#43;——运算符重载</title>
      <link>https://874656645.github.io/posts/237-c&#43;&#43;-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Wed, 14 Sep 2022 17:38:55 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/237-c&#43;&#43;-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
      <description></description>
    </item>
    
    <item>
      <title>C&#43;&#43;——异常的使用</title>
      <link>https://874656645.github.io/posts/236-c&#43;&#43;-%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 14 Sep 2022 11:08:56 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/236-c&#43;&#43;-%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>普通函数、lambda表达式、函数模板和模板实例函数都可以定义异常接口 指针和引用类型的异常都可以支持多态 catch 的子类异常一定要写在父类异常的上面，catch 执行后就不会再执行后面的 catch 语句了 对于指针异常，如果不打算向上抛出，一定要记得 delete const volatile void * 可以捕获抛出的任何指针异常 ... 可以捕获抛出的任何异常 不引发任何异常，在函数后面添加 throw()、throw(void)、noexcept 建议将 noexcept 应用到任何绝不允许异常传播到调用堆栈的函数，当函数被声明为 noexcept 时，它使编译器可以在多种不同的上下文中生成更高效的代码  Exception.h
struct A { int a = 1; virtual int getA()const { return a; } }; struct B : A { int a = 2; int getA()const override { return a; } }; #define cout cout&amp;lt;&amp;lt;__FILE__&amp;lt;&amp;lt;&amp;#34;:&amp;#34;&amp;lt;&amp;lt;__LINE__&amp;lt;&amp;lt;&amp;#34;: Exception: &amp;#34;  void testException() { try { // 抛出子类指针类型的异常 	//throw new B;  // 抛出子类对象类型的异常 	throw B(); } catch (const A e) { cout &amp;lt;&amp;lt; e.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;——多继承与虚基类</title>
      <link>https://874656645.github.io/posts/235-c&#43;&#43;-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E5%9F%BA%E7%B1%BB/</link>
      <pubDate>Mon, 12 Sep 2022 16:00:03 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/235-c&#43;&#43;-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E5%9F%BA%E7%B1%BB/</guid>
      <description>案例一：
class A { public: int a; A(int x) :a(x) { } }; class B : public A { public: B(int x) :A(x) {	// 这里初始化的是派生树中正常的基类 A  } }; class C { public: C() { } }; class D : virtual public A, public C { public: D(int x) :A(x) { } }; class E : /*public A,*/ public B, public D { // 不允许存在直接基类和间接虚基类的情况 public: E(int x) : A(x), B(x + 5), D(x + 10) {	// error C2385: 对“A”的访问不明确  // 所以要使用 B::A(x) 或者 D::A(x)  // 此时初始化的都是派生树中虚基类 A  } }; int main(){ E e(0); //cout &amp;lt;&amp;lt; e.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;——虚函数表与多态（派生类内存布局）</title>
      <link>https://874656645.github.io/posts/234-c&#43;&#43;-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%B8%8E%E5%A4%9A%E6%80%81%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</link>
      <pubDate>Sun, 11 Sep 2022 20:34:53 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/234-c&#43;&#43;-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%B8%8E%E5%A4%9A%E6%80%81%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</guid>
      <description>一、基类中有虚函数但不是虚继承 class A { public: A() { c(); } virtual ~A() { d(); } virtual void c() { cout &amp;lt;&amp;lt; &amp;#34;Construct A\n&amp;#34;; } virtual void d() { cout &amp;lt;&amp;lt; &amp;#34;Deconstruct A\n&amp;#34;; } }; class B : public A { public: B() { // 等价于 B() : A(){} 	c(); } ~B() { d(); } void c()override { cout &amp;lt;&amp;lt; &amp;#34;Construct B\n&amp;#34;; } void d()override { cout &amp;lt;&amp;lt; &amp;#34;Deconstruct B\n&amp;#34;; } }; int main() { B b; return 0; } Construct A Construct B Deconstruct B Deconstruct A 二、有虚继承 参考：</description>
    </item>
    
    <item>
      <title>C&#43;&#43;——作用域和可访问性</title>
      <link>https://874656645.github.io/posts/233-c&#43;&#43;-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7/</link>
      <pubDate>Fri, 09 Sep 2022 17:35:34 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/233-c&#43;&#43;-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7/</guid>
      <description>一、 命名空间   嵌套命名空间
namespace B{ namespace C{ extern int x; // 声明变量  void g(int); // 声明函数原型  void g(long){ cout &amp;lt;&amp;lt; &amp;#34;B::C::g(long)\n&amp;#34;; } }; }; using B::C::x; // 声明引用变量 x，把它引入到当前作用域  // 就不能在当前作用域定义同名变量了 using namespace B; // 引用命名空间，但不会把函数和变量引入到当前作用域  // 在当前作用域中仍然可以定义同名的变量和函数 using B::C::g; // 声明引用 void g(int) 和 void g(long)  // 将函数名为 g 的所有函数都引入到当前作用域  namespace B::C{ int y = 1; int x = 2; // 定义变量 x  void g(int a){ // 定义函数 void g(int)  cout &amp;lt;&amp;lt; &amp;#34;B::C::g(int)\n&amp;#34;; } void g(void){ cout &amp;lt;&amp;lt; &amp;#34;B::C::g(void)\n&amp;#34;; } }; static int xx = 1; class A{ public: int xx; A(int xx){ A::xx = xx; } }; int main() { static int xx = 2; A a(3); cout &amp;lt;&amp;lt; a.</description>
    </item>
    
    <item>
      <title>GIS——Global Mapper 使用</title>
      <link>https://874656645.github.io/posts/232-gis-global-mapper-%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 09 Sep 2022 11:44:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/232-gis-global-mapper-%E4%BD%BF%E7%94%A8/</guid>
      <description>  【File】-&amp;gt;【Create New Map Catalog】
  Export
  导出灰度图
 关闭【地图渲晕（Disable Hill Shading）】，默认是开启状态，关闭后，并使用【梯度渲染（Gradient Shader）】   导出 PNG 设置    </description>
    </item>
    
    <item>
      <title>C&#43;&#43;——父类与子类、基类与派生类</title>
      <link>https://874656645.github.io/posts/231-c&#43;&#43;-%E7%88%B6%E7%B1%BB%E4%B8%8E%E5%AD%90%E7%B1%BB%E5%9F%BA%E7%B1%BB%E4%B8%8E%E6%B4%BE%E7%94%9F%E7%B1%BB/</link>
      <pubDate>Tue, 06 Sep 2022 22:28:34 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/231-c&#43;&#43;-%E7%88%B6%E7%B1%BB%E4%B8%8E%E5%AD%90%E7%B1%BB%E5%9F%BA%E7%B1%BB%E4%B8%8E%E6%B4%BE%E7%94%9F%E7%B1%BB/</guid>
      <description>public 继承的派生类和基类具有父子关系 具有父子关系的派生类指针或对象可以不用进行强制类型转换，直接赋值给基类指针或引用 非 public 继承的 派生类指针 要通过强制类型转换（reinterpret_cast 或者 (Base*)）的方式才能赋值给 父类指针 在 派生类内部和派生类的友元函数 中可以用 父类指针 或 父类引用 直接指向 子类指针或对象，也可以直接将 子类对象赋值给父类对象 在其它地方，不能将 非 public 继承 的 派生类对象 赋值给父类对象或引用，提示 不可访问的基类，但可以通过 (Base&amp;amp;&amp;amp;) 这种强制类型转换的方式将派生类对象转换为基类的右值引用，且支持多态（VS 无法编译通过） 父类的析构函数必须是虚函数 即使父类的析构函数不是虚函数，在栈上定义的子类对象销毁时也会调用父类的析构函数 指针、右值引用、左值引用都支持多态 对象间赋值转换不支持多态  class A { int x, y; public: virtual ~A() { cout &amp;lt;&amp;lt; &amp;#34;~A()\n&amp;#34;; } int getx() { return x; } virtual int vf() const { return 1; } protected: int gety() { return y; } }; class B : protected A { friend int main(); bool visible; public: ~B() { cout &amp;lt;&amp;lt; &amp;#34;~B()\n&amp;#34;; } using A::gety; A* getFather(){ return this; } private: virtual int vf() const { // 子类内部不受继承方式的影响 	const A *pa = this; // 将子类指针赋值给父类指针 	const A&amp;amp; ra = *this; // 将父类引用指向子类对象 	A a = *this; // 将子类对象赋值给父类对象 	// 父类对象 a 生命期在函数结束后结束 	// 输出：~A() 	cout &amp;lt;&amp;lt; &amp;#34;in B::vf() A::vf()：&amp;#34; &amp;lt;&amp;lt; A::vf() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;in B::vf() a.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;——派生类修改基类成员的访问权限</title>
      <link>https://874656645.github.io/posts/230-c&#43;&#43;-%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%BF%AE%E6%94%B9%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</link>
      <pubDate>Sun, 04 Sep 2022 20:45:58 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/230-c&#43;&#43;-%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%BF%AE%E6%94%B9%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</guid>
      <description>案例一：
class A { int x, y; public: int getx() { return x; } protected: int gety() { return y; } }; class B : private A /* public A */ /* protected A */{ bool visible; public: using A::getx; A::gety;	// deprecated }; 案例二：
class MyList { struct Node { int v; Node* next; Node(int v, Node* n) { this-&amp;gt;v = v; next = n; } ~Node() { cout &amp;lt;&amp;lt; &amp;#34;~Node()\n&amp;#34;; delete next; next = nullptr; } } *head; public: MyList() { head = nullptr; } ~MyList() { if (head !</description>
    </item>
    
    <item>
      <title>C&#43;&#43;——Const、volatile、mutable</title>
      <link>https://874656645.github.io/posts/229-c&#43;&#43;-constvolatilemutable/</link>
      <pubDate>Sat, 03 Sep 2022 19:54:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/229-c&#43;&#43;-constvolatilemutable/</guid>
      <description> 含有私有 const 实例数据成员的类必须定义构造函数，且该实例数据成员必须通过构造函数参数列表初始化 虽然 this 是隐含参数，也可以通过添加 const、volatile 修饰符实现函数重载 成员变量的类型会随着对象实例的类型变化而变化，比如一个 volatile int 类型的成员变量，如果对象实例为 const 的，则此时成员变量的类型为 const volatile int 经实验，mutable 不可以和 static、const 一起使用，但可以与 volatile 搭配使用  </description>
    </item>
    
    <item>
      <title>C&#43;&#43;——成员指针</title>
      <link>https://874656645.github.io/posts/228-c&#43;&#43;-%E6%88%90%E5%91%98%E6%8C%87%E9%92%88/</link>
      <pubDate>Sat, 03 Sep 2022 16:44:14 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/228-c&#43;&#43;-%E6%88%90%E5%91%98%E6%8C%87%E9%92%88/</guid>
      <description>实例成员指针  实例成员指针是指向实例成员的指针，可分为实例数据成员指针和实例函数成员指针 构造函数不能被显式调用且只能执行一次，所以不能有指向构造函数的实例成员指针 运算符为 .* 和 -&amp;gt;* 实例成员指针是成员相对于对象首地址的偏移，不是真正代表地址的指针 实例成员指针不能移动 实例成员指针不能转换类型  静态成员指针  静态成员指针前不用加类作用域 静态数据成员指针与普通的变量指针相同 静态函数成员指针与普通的函数指针相同  案例  静态成员指针存放成员地址，实例成员指针存放成员偏移 静态成员指针可以移动，实例成员指针不能移动 静态成员指针可以强制类型转换，实例成员指针不能强制转换类型  class Crowd { public: int a; // 表示在本类中不会修改此变量 	// 但其它进程有可能会修改，表示会有多进程并发 	volatile int b; // C++17 支持 	// 使用 inline、const 修饰 static 变量可在类体内进行初始化 	const static int j = 3; static int num; public: Crowd(); Crowd(int x); ~Crowd(); // 类体内函数定义 	// 会被内联处理 	int f() { b++; cout &amp;lt;&amp;lt; &amp;#34;F()\n&amp;#34;; return b; } // const this 指针，参数类型不同，所以可被重载 	int f()const { cout &amp;lt;&amp;lt; &amp;#34;const F()\n&amp;#34;; return b; } static int getNum(); static Crowd&amp;amp; dec(Crowd&amp;amp; a); }; // 静态成员变量类体外初始化 int Crowd::num = 0; Crowd::Crowd() { a = 0; b = 0; Crowd::num++; cout &amp;lt;&amp;lt; &amp;#34;Crowd()\n&amp;#34;; } Crowd::Crowd(int x): a(x) { b = 0; Crowd::num++; cout &amp;lt;&amp;lt; &amp;#34;Crowd(int)\n&amp;#34;; } Crowd::~Crowd() { Crowd::num--; } int Crowd::getNum() { return Crowd::num; } Crowd&amp;amp; Crowd::dec(Crowd&amp;amp; a) { a.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;——volatile、const、constexpr、inline、static</title>
      <link>https://874656645.github.io/posts/227-c&#43;&#43;-const-volatile-constexpr-inline-static/</link>
      <pubDate>Thu, 01 Sep 2022 22:41:07 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/227-c&#43;&#43;-const-volatile-constexpr-inline-static/</guid>
      <description> volatile 和 const 修饰的变量说明该变量在本程序内不应被修改，但其它程序是可以修改的 volatile 修饰变量，告诉编译器不要优化该变量，每次取值都重新从内存中获取 constexpr 和 inline 修饰的变量，编译器都会进行编译期优化 当对 inline 修饰变量进行取地址操作时，优化会失效 inline 修饰函数相当于 static，只能在当前文件中访问 inline 修饰的变量可以用任意表达式初始化，但这样不保证被优化 inline 其它介绍 static 限制修饰的变量和函数的可见作用域（模块内部），其它的都是副本  </description>
    </item>
    
    <item>
      <title>GIS——GeoServer 发布 ArcGIS 切片的 WMTS 服务</title>
      <link>https://874656645.github.io/posts/226-gis-geoserver-%E5%8F%91%E5%B8%83-arcgis-%E5%88%87%E7%89%87%E7%9A%84-wmts-%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Wed, 31 Aug 2022 11:19:28 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/226-gis-geoserver-%E5%8F%91%E5%B8%83-arcgis-%E5%88%87%E7%89%87%E7%9A%84-wmts-%E6%9C%8D%E5%8A%A1/</guid>
      <description>一、部署环境和软件版本 操作系统 版本 win10 JDK 版本 OpenJDK11U-jdk_x64_windows_hotspot_11.0.16.1_1 GeoServer 版本 2.21.1 GeoWebCache 版本 1.21.1 二、说明  安装 JDK，配置 java 环境。 Windows 平台可安装 GeoServer Exe 安装包。 也可以通过 Tomcat 起动服务，需要下载 GeoServer 和 GeoWebCache 的 war 包，并放到 tomcat/webapps 目录下，如果只是发布切片服务，配置 GeoWebCache 即可。  三、软件下载  下载 GeoServer 也可GeoServer 官网下载 下载 GeoWebCache，解压待用  四、配置 GeoServer  将 GeoWebCache 中的 jar 包 \geowebcache\WEB-INF\lib\gwc-arcgiscache-1.21.1.jar 拷贝到 GeoServer 安装目录 \webapps\geoserver\WEB-INF\lib。 解压 GeoServer 安装目录下的 jar 包 \webapps\geoserver\WEB-INF\lib\gs-gwc-2.21.1.jar 到 gs-gwc-2.21.1 文件夹，将 GeoWebCache 中的 \geowebcache\WEB-INF\geowebcache-arcgiscache-context.</description>
    </item>
    
    <item>
      <title>STL——map 排序相关</title>
      <link>https://874656645.github.io/posts/225-stl-map-%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Tue, 30 Aug 2022 14:22:02 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/225-stl-map-%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3/</guid>
      <description>声明变量时指定排序规则  通过指定模板的第三个参数，对象类型，C++ 2a 支持 lambda 对象
struct MyCom{ bool operator()(const string key1, const string key2)const{ return key1 &amp;gt; key2; } }; int main() { // lambda 表达式对象  auto cmp = [](const auto&amp;amp; key1, const auto&amp;amp; key2){return key1 &amp;lt; key2;}; map&amp;lt;string, int, decltype(cmp)&amp;gt; myMap1 = {{&amp;#34;RAM&amp;#34;, 20}, {&amp;#34;GPU&amp;#34;, 15}, {&amp;#34;CPU&amp;#34;, 10} }; // 函数对象  map&amp;lt;string, int, MyCom&amp;gt; myMap2 = {{&amp;#34;CPU&amp;#34;, 10}, {&amp;#34;GPU&amp;#34;, 15}, {&amp;#34;RAM&amp;#34;, 20}}; for(const auto&amp;amp; item : myMap1){ cout &amp;lt;&amp;lt; item.</description>
    </item>
    
    <item>
      <title>ArcGIS Desktop 制作影像切片</title>
      <link>https://874656645.github.io/posts/224-arcgis-desktop-%E5%88%B6%E4%BD%9C%E5%BD%B1%E5%83%8F%E5%88%87%E7%89%87/</link>
      <pubDate>Mon, 29 Aug 2022 11:09:11 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/224-arcgis-desktop-%E5%88%B6%E4%BD%9C%E5%BD%B1%E5%83%8F%E5%88%87%E7%89%87/</guid>
      <description>ArcGIS Desktop 10.6 一、生成切片方案 打开 ArcGIS Desktop，打开 工具箱( Tools Box ) &amp;ndash;&amp;gt; 系统工具箱( System Tools Box ) &amp;ndash;&amp;gt; 数据管理工具( Data Managment Tools ) &amp;ndash;&amp;gt; 切片缓存( Tile Cache )&amp;ndash;&amp;gt; 生成切片缓存切片方案( Generate Tile Cache Tiling Scheme )
重要参数：
 切片格式( Tile Format )：主要是 PNGx、JPEG、MIXED，MIXED 混合格式，指的是在切片的时候，如果检测到瓦片内有透明区域，则这个瓦片使用 PNG32 格式，如果没有，则使用 JPEG 格式。这样做可以在不失去透明通道的前提下，有效降低瓦片数据文件的大小。 切片压缩质量( Tile Compression Quality )：仅对 JPEG（包括 MIXED 中使用 JPEG 的瓦片）有效，参数值需要介于 1-100 之间，默认是 75。 存储格式( Storage Format )：  COMPACT 紧凑格式，也就是把多个瓦片（最多128x128个）存储到一个 bundle 文件的形式，避免出现大量碎文件； EXPLODED 分散格式，就是把每一个瓦片存储成一个图片文件，这个形式的瓦片不能和 tpk 包一起使用。    CGCS2000 切片方案</description>
    </item>
    
    <item>
      <title>GIS——GeoServer 地图服务</title>
      <link>https://874656645.github.io/posts/223-gis-geoserver-%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Tue, 23 Aug 2022 10:34:42 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/223-gis-geoserver-%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1/</guid>
      <description>GeoServer Version 2.21.1 一、WMS 服务   获取服务能力元数据：
  可在网址中指定 version=1.1.0 和 service=WMS 参数
  获取整个 geoserver 的服务能力，默认 WMS_Capabilities 的 version 是 1.3.0 的
http://172.16.17.127:8066/geoserver/wms?request=getCapabilities
http://172.16.17.127:8066/geoserver/wms?request=getCapabilities&amp;amp;version=1.1.0
请求网址中不包含工作空间的 1.1.1 版本的 xml 样例
请求网址中不包含工作空间的 1.3.0 版本的 xml 样例
  获取其中某个工作空间的服务能力，需要在 geoserver 后面添加工作空间名称
http://172.16.17.127:8066/geoserver/cite/wms?request=getCapabilities&amp;amp;version=1.1.0
请求网址中包含工作空间的 1.1.1 版本的 xml 样例
请求网址中包含工作空间的 1.3.0 版本的 xml 样例
  注意：
 1.3.0 版本的空间参考标签为 &amp;lt;CRS&amp;gt;，而 1.1.0 版本的空间参考标签为 &amp;lt;SRS&amp;gt; 如果请求的网址指定了工作空间，图层名中就不需要有工作空间名了（比如：cite:hl_2017 和 hl_2017） 1.1.0 版本的图层中包含 geoserver 以图层组方式发布的服务图层，而 1.</description>
    </item>
    
    <item>
      <title>Compile Nginx on CentOS</title>
      <link>https://874656645.github.io/posts/222-compile-nginx-on-centos/</link>
      <pubDate>Wed, 17 Aug 2022 14:33:56 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/222-compile-nginx-on-centos/</guid>
      <description>安装相关依赖
yum install -y perl-ExtUtils-Embed \ readline-devel zlib-devel pam-devel \ libxml2-devel libxslt-devel openldap-devel \ python-devel openssl-devel cmakepcre-develnanowget \ gcc gcc-c++ ncurses-devel perl git `
  编译命令：
mkdir ~/nginx_sources ~/nginx cd ~/nginx_sources git clone https://github.com/winshining/nginx-http-flv-module.git curl -O -L http://hg.nginx.org/nginx/archive/stable-1.22.tar.gz # 其他版本 http://hg.nginx.org/nginx/archive/release-1.23.1.zip tar xzvf stable-1.22.tar.gz cd nginx-stable-1.22 ./auto/configure --prefix=&amp;#34;$HOME/nginx&amp;#34; --sbin-path=&amp;#34;$HOME/nginx&amp;#34; \ --with-select_module \ --with-poll_module \ --with-file-aio \ --with-http_ssl_module \ --with-http_realip_module \ --with-http_sub_module \ --with-http_flv_module \ --add-module=&amp;#34;../nginx-http-flv-module&amp;#34; \ --with-http_mp4_module \ --with-http_gzip_static_module \ --with-http_secure_link_module \ --with-http_stub_status_module \ --with-http_perl_module \ --with-ld-opt=&amp;#34;-Wl,-E&amp;#34; make make install   注意事项：</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 杂记</title>
      <link>https://874656645.github.io/posts/221-c&#43;&#43;-%E6%9D%82%E8%AE%B0/</link>
      <pubDate>Mon, 15 Aug 2022 21:45:13 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/221-c&#43;&#43;-%E6%9D%82%E8%AE%B0/</guid>
      <description>应用程序内存空间（局部内存堆），程序进程结束时，会被统一都回收释放 公共内存区（全局内存堆）（写设备驱动程序时会使用），使用不当会造成内存泄漏 extern 不能修饰其他模块的静态变量 函数内用 extern 修饰的变量要么来自全局变量，要么来自本身模块的静态变量 extern 只能修饰外部变量（就近原则），不能修饰局部变量  test.cpp：
#include &amp;lt;iostream&amp;gt; int etn = 3;	// 全局变量 static int s_m;	// 模块静态变量  void layout() { std::cout &amp;lt;&amp;lt; &amp;#34;test.cpp\tetn=&amp;#34; &amp;lt;&amp;lt; etn &amp;lt;&amp;lt; std::endl; } another.cpp：
static int etn = 4; // 模块静态变量 void myFunc(){ int etn = 5; // 局部自动变量 	{ extern int etn; int x = etn;// x 是 4 而不是 5 	} } charTest.</description>
    </item>
    
    <item>
      <title>Compile FFmpeg on CentOS</title>
      <link>https://874656645.github.io/posts/220-compile-ffmpeg-on-centos/</link>
      <pubDate>Mon, 15 Aug 2022 14:55:49 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/220-compile-ffmpeg-on-centos/</guid>
      <description>0. 编译的版本  ffmpeg-4.4 nasm-2.14.02 yasm-1.3.0 H.264 H.265 fdk-aac-2.0.0  1. Get the Dependencies   需要 superuser 或者 root 用户
# yum install autoconf automake bzip2 bzip2-devel cmake freetype-devel gcc gcc-c++ git libtool make pkgconfig zlib-devel
  新建 ffmpeg_sources 文件夹，把需要的源代码都放到这个文件夹中
mkdir ~/ffmpeg_sources
  新建 ffmpeg_build 文件夹，把构建的项目文件都放到这个文件夹中
mkdir ~/ffmpeg_build
  新建 bin 文件夹，把编译生成的文件都放到这个文件夹中
mkdir ~/bin
  2. Install NASM assembler 一些库使用的汇编程序。强烈建议这样做，否则构建可能会非常缓慢。
cd ~/ffmpeg_sources curl -O -L https://www.</description>
    </item>
    
    <item>
      <title>Unreal——使用蓝图获取 uasset 资源</title>
      <link>https://874656645.github.io/posts/219-unreal-%E4%BD%BF%E7%94%A8%E8%93%9D%E5%9B%BE%E8%8E%B7%E5%8F%96-uasset-%E8%B5%84%E6%BA%90/</link>
      <pubDate>Thu, 11 Aug 2022 17:40:41 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/219-unreal-%E4%BD%BF%E7%94%A8%E8%93%9D%E5%9B%BE%E8%8E%B7%E5%8F%96-uasset-%E8%B5%84%E6%BA%90/</guid>
      <description>方法一：   可以通过 获取资产注册表（Get Asset Registry） + 按路径获取资产（Get Asset by Path） 获取路径下的所有类型资产；
  通过 获取完整名称（GetFullName） + 包含（Contains） 筛选需要的资产；
  通过 获取资产（GetAsset） 获取资产对象
  资产对象的属性：
  方法二：   可以通过 获取资产注册表（Get Asset Registry） + 按对象路径获取资产（Get Asset by Object Path） 直接获取想要的资产对象；
  再通过 获取资产（GetAsset） + cast 将资产对象转换为需要的对象类型；
  注意：资产路径的格式：
 map : World&#39;/Game/Maps/NewWorld.NewWorld&#39; 蓝图类 : 要加 _C 例如 Blueprint&#39;/Game/Blueprints/MySpringArmPawn.MySpringArmPawn_C&#39;  参考：
 UE4 | BP | 使用蓝图获取Uasset资源 关于UE4动态资源加载(蓝图类)  </description>
    </item>
    
    <item>
      <title>Unreal——蓝图接口</title>
      <link>https://874656645.github.io/posts/218-unreal-%E8%93%9D%E5%9B%BE%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Wed, 10 Aug 2022 11:27:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/218-unreal-%E8%93%9D%E5%9B%BE%E6%8E%A5%E5%8F%A3/</guid>
      <description>  蓝图接口（Blueprint Interface） 是一个或多个函数的集合——只有名称，没有实现。
  由于接口函数没有实现，作为设计人员，所能做的就是指定一系列类型化输入和输出。
  蓝图接口也有一定的局限性：
 不能包含变量 不能编辑图表 不能添加组件    其他蓝图类 Actor 实现蓝图接口：
在 类设置 中添加接口
  参考：
 蓝图接口 【教程】UE4中接口的使用&amp;ndash;蓝图篇（一）  </description>
    </item>
    
    <item>
      <title>Unreal——Actor 蓝图类</title>
      <link>https://874656645.github.io/posts/217-unreal-actor-%E8%93%9D%E5%9B%BE%E7%B1%BB/</link>
      <pubDate>Wed, 10 Aug 2022 11:23:12 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/217-unreal-actor-%E8%93%9D%E5%9B%BE%E7%B1%BB/</guid>
      <description>  所有可以放入关卡的对象都是 Actor，比如摄像机、静态网格体、玩家起始位置。
  Actor支持三维变换，例如平移、旋转和缩放。
  可以通过游戏逻辑代码（C++或蓝图）创建（在蓝图中使用 从类生成Actor 节点）或 销毁Actor。
  每一个 Actor 均有一个 DefaultSceneRoot 组件，它是默认情况下的场景组件（SceneComponent），该组件不支持可视化，在场景中是看不到的，也不可分配网格，只是 Actor 的默认场景根。
  Actor 必须有一个默认场景根。可以使用其他的组件替换默认场景根，但是只要删除所有的其他组件，场景默认根（DefaultSceneRoot）就会自动显示，这个变量名是系统保留，不能用来命名他组件。
  当设置Actor的位置、旋转、缩放时，同时也在设置默认场景根的位置、旋转、缩放。
  注意：
 Actor 不直接保存变换（位置、旋转和缩放）数据，只是一个可以挂载Component的类而已 在某种意义上，Actor 可被视为包含特殊类型 对象（称作组件 Component）的容器 如果 Actor 的根组件存在，则使用它的变换数据    参考：
 Actors UE4-Actor  </description>
    </item>
    
    <item>
      <title>Unreal——通用基类（Actor、Pawn、Character等）</title>
      <link>https://874656645.github.io/posts/216-unreal-%E9%80%9A%E7%94%A8%E5%9F%BA%E7%B1%BBactorpawncharacter%E7%AD%89/</link>
      <pubDate>Wed, 10 Aug 2022 10:02:42 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/216-unreal-%E9%80%9A%E7%94%A8%E5%9F%BA%E7%B1%BBactorpawncharacter%E7%AD%89/</guid>
      <description>Actor
  Actor 是可以放到关卡中的任何对象，例如摄像机、静态网格体或玩家出生点位置
  Actor 支持 3D 变换，例如转换、旋转和缩放
  Actor 在 UE 中是只是一个可以挂载 Component的类而已。所以，需要挂载组件的时候，才应该继承自 Actor 类。很多时候，写一个 Manager 或者一个 Data 又或者只是解析一个Config，只需要写一个 C++ 类就可以了
  可以通过 gameplay 代码（C++ 或蓝图）创建（生成）或销毁 Actor，在蓝图中使用 从类生成Actor 节点，生成后就自动添加到场景中并能在场景中看到
    Pawn
Pawn 是 Actor 的子类，作为游戏内的形象或人像（例如游戏中的角色）。玩家或游戏的 AI 可以控制 Pawn，将其作为非玩家角色（NPC），可以理解为在游戏中的肉体。
  Character
 角色（Character） 是计划用作玩家角色的 Pawn Actor 的子类。角色子类包括碰撞设置、双足运动的输入绑定以及用于玩家控制动作的其他代码 相比于 Pawn 类，Character 类提供了一个Movement 组件，这个组件提供了角色移动基本逻辑功能，包括角色的移动和跳跃，还可以依据需求扩展出不同的移动状态，比如爬行、蹲伏 当对象逻辑简单、不需要过多的逻辑动作（比如方块、飞船）那么可以选择继承 Pawn 而不是继承 Character 类    Controller</description>
    </item>
    
    <item>
      <title>Unreal——蓝图函数、事件和宏</title>
      <link>https://874656645.github.io/posts/215-unreal-%E8%93%9D%E5%9B%BE%E5%87%BD%E6%95%B0%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%AE%8F/</link>
      <pubDate>Tue, 09 Aug 2022 19:38:55 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/215-unreal-%E8%93%9D%E5%9B%BE%E5%87%BD%E6%95%B0%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%AE%8F/</guid>
      <description>  函数调用会等待函数执行结果，事件调用只是触发但不会等待
事件是异步执行，触发后，会在新的线程中执行，所以可以使用 Delay，函数和宏的调用是同步执行，是单线程的，所以在函数中不能使用 Timeline、Delay 和 Http 请求 等操作。
  事件没有返回值，函数和宏可以有返回值
  函数和事件可以跨蓝图类访问，而宏只可以在定义的蓝图类内访问（宏库可以跨蓝图类访问）
  函数可以用局部变量，事件没有局部变量
  因为函数执行顺序有保证，所以优先使用函数
  函数可以被继承，而宏不可以被继承，子类无法使用父类的宏
  没有返回值的函数，在被子类 Overide 时，会变成事件
  参考：
 UE4蓝图之函数、事件、宏的区别 【UE4笔记】Event&amp;amp;Function事件和函数的区别 [UE4]函数和事件的区别  </description>
    </item>
    
    <item>
      <title>Unreal——DefaultGraphicsRHI</title>
      <link>https://874656645.github.io/posts/214-unreal-defaultgraphicsrhi/</link>
      <pubDate>Thu, 04 Aug 2022 14:57:18 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/214-unreal-defaultgraphicsrhi/</guid>
      <description>注意： UE5 默认使用的是 DX12，有可能会在渲染方面出现奇怪的问题，需要特别注意。
RHI 是 Render Hardware Interface 的缩写，虚幻引擎通过 RHI 把各个平台的图形 API 包装成统一接口，供上层渲染来使用，让业务不用过多的关注 API 细节（实际还得关注RHI 细节）。从代码结构上来看，RHI 封装的比较贴合于现代的图形 API(vulkan, metal, DX12)，也支持 opengl/opengles。这个接口是广义上的概念，不仅指 C++ 的纯虚基类，也包括一些全局变量，全局函数等。
参考：
 UE4/UE5的RHI(Vulkan为例)  </description>
    </item>
    
    <item>
      <title>判断点是否在多边形内部</title>
      <link>https://874656645.github.io/posts/213-%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8/</link>
      <pubDate>Tue, 02 Aug 2022 17:43:53 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/213-%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8/</guid>
      <description>  射线法：不需考虑精度误差和多边形点给出的顺序。
  转角法：要求多边形是有顺序的，按照多边形顶点逆时针顺序，从 P 点到顶点 Vi 分别做连线，其中 αi 为 Vi 和 Vi+1 之间的夹角。其中 α 角度逆时针为正，顺时针为负，这样所有到顶点做连线之间夹角和为(环绕数)0，这点P在多边形外部，否则在内部。
  射线法改进：针对有方向的多边形，通过判断射线穿过的边和点的位置（比如点在线的左侧为正，右侧为负），和为 0 则点在外部。
  叉积法：适用凸多边形，如果一个点在多边形所有有向边的左边，那么这个点一定在多边形内部。
  面积法：类似叉积法，适用凸多边形。如果点在多边形内部或者边上，那么点与多边形所有边组成的三角形面积和等于多边形面积。
  参考：
 详谈判断点在多边形内的七种方法（最全面） hdu1756 hrbust1429 为例  </description>
    </item>
    
    <item>
      <title>Qt 多线程</title>
      <link>https://874656645.github.io/posts/212-qt-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 18 Jul 2022 22:17:00 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/212-qt-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>一、注意事项：  线程处理类继承于 QObject 线程处理类对象不能有父对象 处理完成后向外发信号 即使 QThread 线程内部的处理对象运行结束了，QThread 线程对象也不会自动释放，需要手动 quit() + wait() 线程处理类对象创建成功后，需要通过 moveToThread() 函数移动到 QThread 对象中 需要通过其他线程发信号来启动另外线程中的处理类对象的处理函数 子线程中不要操作图形界面  二、connect 第五个参数的作用 指定信号和槽的连接方式：自动连接、直接连接、队列连接，多线程时才有意义，默认为 Qt::AutoConnection。
 Qt::AutoConnection（自动连接）：多线程时是 Qt::QueuedConnection（队列连接），单线程时是 Qt::DirectConnection（直接连接） Qt::QueuedConnection（队列连接）：槽函数所在线程和信号接收者所在线程相同 Qt::DirectConnection（直接连接）：槽函数所在线程和信号发送者所在线程相同  三、代码示例   线程处理类
class MyThreadPro : public QObject { Q_OBJECT public: explicit MyThreadPro(QObject *parent = nullptr); // 后台处理函数  void startProcessing(); // 是否结束标识位  void setFlag(bool b = false); signals: // 向其他线程发送信号  void myTimeout(); private: bool stopRunning; };   主窗口类</description>
    </item>
    
    <item>
      <title>OpenGL 视差贴图（Parallax Mapping）</title>
      <link>https://874656645.github.io/posts/211-opengl-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BEparallax-mapping/</link>
      <pubDate>Mon, 18 Jul 2022 16:06:56 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/211-opengl-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BEparallax-mapping/</guid>
      <description>参考：
 视差贴图（Parallax Mapping）学习笔记 视差映射（Parallax Mapping） Learn about Parallax(视差贴图)  </description>
    </item>
    
    <item>
      <title>OpenGL Gamma 校正和线性工作流</title>
      <link>https://874656645.github.io/posts/210-opengl-gamma-%E6%A0%A1%E6%AD%A3%E5%92%8C%E7%BA%BF%E6%80%A7%E5%B7%A5%E4%BD%9C%E6%B5%81/</link>
      <pubDate>Mon, 18 Jul 2022 14:40:32 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/210-opengl-gamma-%E6%A0%A1%E6%AD%A3%E5%92%8C%E7%BA%BF%E6%80%A7%E5%B7%A5%E4%BD%9C%E6%B5%81/</guid>
      <description> sRGBA 和 RGBA  </description>
    </item>
    
    <item>
      <title>Qt UDP</title>
      <link>https://874656645.github.io/posts/209-qt-udp/</link>
      <pubDate>Fri, 15 Jul 2022 21:44:52 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/209-qt-udp/</guid>
      <description>一、总结  UDP 就像写信，可能会丢包 Linux UDP 通信过程  Qt UDP 通信过程  支持多路组播：D 类地址
 局域网广播 IP： 255.255.255.255  二、每个实例都可以是服务端  只需要一个套接字，绑定到端口号即可  setWindowTitle(QString(&amp;#34;服务器端口为：%1&amp;#34;).arg(port)); udpSocket = new QUdpSocket(this); // 只需要绑定端口号，不用开启监听  udpSocket-&amp;gt;bind(port); connect(udpSocket, &amp;amp;QUdpSocket::readyRead,[=](){ char buf[1024] = {0}; QHostAddress clientAddr; // 发送方 IP  quint16 clientPort; // 发送方 Port  qint64 len = udpSocket-&amp;gt;readDatagram(buf, sizeof (buf), &amp;amp;clientAddr, &amp;amp;clientPort); qDebug() &amp;lt;&amp;lt; &amp;#34;接收到&amp;#34; &amp;lt;&amp;lt; len; if(len &amp;gt; 0){ QString str = QString(&amp;#34;[%1:%2] %3&amp;#34;).</description>
    </item>
    
    <item>
      <title>Qt TCP</title>
      <link>https://874656645.github.io/posts/208-qt-tcp/</link>
      <pubDate>Fri, 15 Jul 2022 21:13:10 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/208-qt-tcp/</guid>
      <description>一、总结  TCP 就像打电话，安全，不会丢包 Linux TCP 通信  Qt TCP 通信   二、服务器端  TCP 服务器端有两个套接字，一个是监听套接字，一个是通信套接字  tcpServer = nullptr; // 服务监听套接字  tcpSocket = nullptr; // 通信套接字  // 创建tcp服务监听套接字  tcpServer = new QTcpServer(this); // tcp服务开启监听（bind端口号并开启监听）  tcpServer-&amp;gt;listen(QHostAddress::Any, 8008); // 绑定连接成功信号  connect(tcpServer, &amp;amp;QTcpServer::newConnection,[=](){ // 获取通信套接字  tcpSocket = tcpServer-&amp;gt;nextPendingConnection(); // 获取客户端 IP 和 端口  QString ip = tcpSocket-&amp;gt;peerAddress().toString(); quint16 port = tcpSocket-&amp;gt;peerPort(); QString msg = QString(&amp;#34;[%1:%2] 连接成功&amp;#34;).</description>
    </item>
    
    <item>
      <title>Qt CMake</title>
      <link>https://874656645.github.io/posts/207-qt-cmake/</link>
      <pubDate>Fri, 15 Jul 2022 16:10:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/207-qt-cmake/</guid>
      <description>cmake_minimum_required(VERSION 3.5)project(07_TCP LANGUAGES CXX)# 将编译目录包含到Include目录 set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTORCC ON)# 根据 Qt 版本的环境变量，设置使用的 Qt 版本 set(CMAKE_PREFIX_PATH $ENV{QTDIR5141_64})set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)# QtCreator supports the following variables for Android, which are identical to qmake Android variables. # Check http://doc.qt.io/qt-5/deployment-android.html for more information. # They need to be set before the find_package(Qt5 ...) call. #if(ANDROID) # set(ANDROID_PACKAGE_SOURCE_DIR &amp;#34;${CMAKE_CURRENT_SOURCE_DIR}/android&amp;#34;) # if (ANDROID_ABI STREQUAL &amp;#34;armeabi-v7a&amp;#34;) # set(ANDROID_EXTRA_LIBS # ${CMAKE_CURRENT_SOURCE_DIR}/path/to/libcrypto.so # ${CMAKE_CURRENT_SOURCE_DIR}/path/to/libssl.so) # endif() #endif() # 工程中会用到的Qt模块 find_package(Qt5 COMPONENTS Widgets Network REQUIRED)if(ANDROID) add_library(07_TCP SHARED main.</description>
    </item>
    
    <item>
      <title>OpenGL Shading Frequencies</title>
      <link>https://874656645.github.io/posts/206-opengl-shading-frequencies/</link>
      <pubDate>Sun, 10 Jul 2022 19:54:49 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/206-opengl-shading-frequencies/</guid>
      <description></description>
    </item>
    
    <item>
      <title>OpenGL 纹理采样</title>
      <link>https://874656645.github.io/posts/205-opengl-%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7/</link>
      <pubDate>Sun, 10 Jul 2022 09:47:35 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/205-opengl-%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7/</guid>
      <description>有两个不同的概念：像素（Pixel）和纹素（Texel）
  在纹理上查询纹素有两种方式：
 点查（Point Query）：小纹理，而要对纹理放大 范围查（Range Query）：动态生成 Mipmap    小纹理：低分辨率纹理应用到高分辨率设备，会产生马赛克问题
 Nearest：邻近点
 Bilinear：双线性插值
 Bicubic：     大纹理：高分辨率纹理应用到低分辨率设备，会有 锯齿（Jaggies） 和 摩尔纹（Moire） 等 走样（Aliasing） 的问题
 多重采样（supersampling）    面采样求平均值
  Mipmap：图像金字塔
 具有速度快、只是近似值且只能是方形范围的特点 会额外占用 1/3 的原始纹理显存空间，总共 4/3 的显存占用    三线性插值（Trilinear interpolation）:
 先在相邻两层 Mipmap 中分别进行 Bilinear 插值，再在结果之上进行线性插值 局限性：会存在 overblur 的问题    各项异性过滤（Anisotropic Filtering）（Ripmap）：
 对于平行于坐标轴的矩形区域查询有较好的表现，但是对于非矩形区域仍是效果不佳 会额外占用 3 倍的显存空间   纹理映射的不规则区域    EWA Filtering:</description>
    </item>
    
    <item>
      <title>OpenGL 重心坐标与插值</title>
      <link>https://874656645.github.io/posts/204-opengl-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87%E4%B8%8E%E6%8F%92%E5%80%BC/</link>
      <pubDate>Sat, 09 Jul 2022 21:22:21 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/204-opengl-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87%E4%B8%8E%E6%8F%92%E5%80%BC/</guid>
      <description> 重心坐标在投影下不是不变的，所以如果要获取光栅化后三角形内部像素点的深度，不能使用光栅化后三角形的重心坐标进行插值，而是要先找到像素点中心位置对应的三维世界的三维坐标，在三维世界中进行深度插值计算。  参考：
 利用重心坐标平滑插值三角形顶点的任何属性 GAMES101-现代计算机图形学入门-闫令琪  </description>
    </item>
    
    <item>
      <title>Unreal——像素流送播放器页面与 UE 通信</title>
      <link>https://874656645.github.io/posts/203-unreal-%E5%83%8F%E7%B4%A0%E6%B5%81%E9%80%81%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B5%E9%9D%A2%E4%B8%8E-ue-%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Fri, 08 Jul 2022 17:50:31 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/203-unreal-%E5%83%8F%E7%B4%A0%E6%B5%81%E9%80%81%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B5%E9%9D%A2%E4%B8%8E-ue-%E9%80%9A%E4%BF%A1/</guid>
      <description>一、HTML 页面  必须包含 webRtcPlayer.js 脚本文件，该文件处理浏览器和虚幻引擎应用间的通信，接受并显示来自服务器的媒体流。在非必要的情况下，请勿修改此JavaScript文件。
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;scripts/webRtcPlayer.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; 建议包含 app.js 脚本文件，此文件将设置处理键盘、鼠标和触摸事件的事件监听器，其还包含数个可在播放器页面使用的函数。
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;scripts/app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; 页面必须含有一个 ID 为 player 的 div 元素。该元素可被流送自 UE4 应用的视频帧所替换。
&amp;lt;div id=&amp;quot;player&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 页面加载时必须调用 app.js 文件提供的 load 函数。  二、访问像素流送蓝图 API 在虚幻引擎中运行的像素流送插件会公开一个蓝图API，可在 gameplay 逻辑中使用该 API 处理播放器 HTML 页面发送的自定义 UI 事件，并将事件从虚幻引擎发送到播放器页面，实现网页客户端与 UE 运行程序之间的交互通信。
推荐将 像素流送插件（Pixel Streaming Input） 组件添加到 PlayerController 中。
三、从播放器页面到 UE 的通信 app.js 文件提供两个可在 HTML 播放器页面进行调用的 JavaScript 函数，以便用户从浏览器向虚幻引擎程序发送事件和命令：emitCommand 和 emitUIInteraction 函数。
  js 代码：
// 从播放器页面到UE4的通信  let testButton = document.</description>
    </item>
    
    <item>
      <title>Unreal——像素流送</title>
      <link>https://874656645.github.io/posts/202-unreal-%E5%83%8F%E7%B4%A0%E6%B5%81%E9%80%81/</link>
      <pubDate>Fri, 08 Jul 2022 15:50:34 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/202-unreal-%E5%83%8F%E7%B4%A0%E6%B5%81%E9%80%81/</guid>
      <description>有两种方式启动三维渲染服务器  一、方式一：使用 UE Editor 作为渲染服务器  启用像素流送插件
【Pixel Streaming】 启用触控设备输入（可选）
【编辑（Edit）】 &amp;gt; 【项目设置（Project Settings）】 &amp;gt; 【引擎（Engine）】 &amp;gt; 【输入（Input category）】 下启用 【固定显示触控界面（Always Show Touch Interface）】 设置 设置额外启动参数
【编辑（Edit）】 &amp;gt; 【编辑器偏好（Editor Preferences&amp;hellip;）】 &amp;gt; 【关卡编辑器（Level Editor）】 &amp;gt; 【播放（Play）】 &amp;gt; 【额外启动参数（Additional Launch Parameters）】中添加参数 -AudioMixer -PixelStreamingIP=localhost -PixelStreamingPort=8888 -AllowPixelStreamingCommands 启动游戏
通过独立进程游戏的模式启动游戏
  二、方式二：通过打包的程序  打包前对 UE Editor 进行配置，参照方式一的前两步 启动【打包项目】
 设置启动程序的命令行标签  按住 Alt 键并拖动 .exe 文件即可在相同文件夹中（或在其他任意处）新建一个快捷方式 右键点击快捷方式并从上下文菜单中选择 属性（Properties） 在 快捷方式属性（Shortcut Properties） 窗口的 快捷方式（Shortcut） 选项卡中，在 目标（Target） 域的末尾附加文本 -AudioMixer -PixelStreamingIP=localhost -PixelStreamingPort=8888 -RenderOffScreen 并点击 确认    三、启动服务器 启动一个服务，在虚幻引擎应用程序和客户端浏览器间建立点对点的连接（WebRTC）</description>
    </item>
    
    <item>
      <title>Unreal Engine 5 打包</title>
      <link>https://874656645.github.io/posts/201-unreal-engine-5-%E6%89%93%E5%8C%85/</link>
      <pubDate>Thu, 07 Jul 2022 10:23:08 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/201-unreal-engine-5-%E6%89%93%E5%8C%85/</guid>
      <description>UE5 打包：
如果平台前面有感叹号表示缺少 SDK 环境
 注意： 安装完 SDK 后要重启电脑   Windows SDK 18362 or Newer .NET Core 3.1  </description>
    </item>
    
    <item>
      <title>PowerShell 修改脚本执行策略</title>
      <link>https://874656645.github.io/posts/200-powershell-%E4%BF%AE%E6%94%B9%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5/</link>
      <pubDate>Wed, 06 Jul 2022 17:49:14 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/200-powershell-%E4%BF%AE%E6%94%B9%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5/</guid>
      <description> 参考asdfasdfabout_Execution_Policies    get-executionpolicy 命令查看
 Restricted 执行策略不允许任何脚本运行 RemoteSigned    执行策略修改
以管理员身份打开 PowerShell， 输入 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 修改执行策略
  </description>
    </item>
    
    <item>
      <title>Unreal——智慧城市项目搭建</title>
      <link>https://874656645.github.io/posts/199-unreal-%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Thu, 30 Jun 2022 15:12:06 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/199-unreal-%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</guid>
      <description>一、项目目录 —— 内容
—— Maps
—— UMG
—— Mesh
—— 材质
—— 蓝图
—— 贴图
—— 团队人员
—— 产品经理
—— 平面
—— UE 美术 —— UE 技术美术 —— 模型师
—— UE 程序
学习网址  可视化展示系列教程 基础  高级UE开发工程师 岗位职责：
 负责 UE 客户端功能的设计、开发实现； 负责与产品对接功能需求，以及其他开发人员讨论需求，合作完成产品开发； 配合美术，策划完成各种效果的实现，与团队成员沟通协调，完成内容制作与优化； 保证代码质量与运行效率，持续进行项目功能优化、迭代、代码调试及 bug 修复；  任职要求：
 本科或以上学历，2年以上 UE 工作经验，至少参与过两个商业项目； 可以撰写 UE 引擎技术文档，并与美术配合将项目资源导入引擎； 熟悉 UE 开发流程和步骤，熟练使用 UE 蓝图编程及插件技术，熟悉 UE C++ 与蓝图的交互机制； 熟悉 UMG 的 GUI 开发等； 有较强的学习能力和解决问题能力，勇于承担责任，具有良好的团队交流和协作能力；  </description>
    </item>
    
    <item>
      <title>Unreal——智慧城市项目技术路线和软件</title>
      <link>https://874656645.github.io/posts/198-unreal-%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%92%8C%E8%BD%AF%E4%BB%B6/</link>
      <pubDate>Wed, 29 Jun 2022 10:18:09 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/198-unreal-%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%92%8C%E8%BD%AF%E4%BB%B6/</guid>
      <description>软件和插件：
 Blender 和 BlenderGis 插件 C4D CityEngine Unreal Engine `Cesium for Unreal Engine&#39; `CityEngine VR Experience for Unreal Engine&#39; datasmith for Unreal Engine CesiumLab 地编素材库（city park environment collection） HDRI 插件和 HDRI 素材 ArchViz Explorer 项目，场景 Pawn 操作 Factory Environment Collection json读取插件：json assets、json library、jsonxmlhelper、varest 网页插件：web ui 视频流：web camera Water 插件 基于精确地理的太阳定位工具  蓝图开发：
 通过鼠标左键、右键和滚轮控制相机移动、缩放和旋转 Cesium 场景搭建 3DTiles 模型加载 3DMax 场景导入 UI界面搭建（用户界面、控件蓝图、商城UI插件Custom UI） 天气切换 控制器切换（自由、人行、驾驶） 长度测量（射线——由通道检测线条，缆索Actor） 面积测量 添加POI  三维效果：</description>
    </item>
    
    <item>
      <title>OpenGL 相机 LookAt 矩阵计算</title>
      <link>https://874656645.github.io/posts/197-opengl-%E7%9B%B8%E6%9C%BA-lookat-%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Tue, 28 Jun 2022 14:23:38 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/197-opengl-%E7%9B%B8%E6%9C%BA-lookat-%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/</guid>
      <description>原理：   相机的运动实际上是对世界坐标系中的物体进行反向运动变换 相机的运动矩阵与其他物体的变换矩阵类似  先缩放变换，再进行旋转，最后进行平移   所以 glm::lookAt 函数返回的是相机变换矩阵的逆矩阵  先对相机的平移矩阵求逆，然后乘以旋转矩阵的逆矩阵（参考计算矩阵乘积的逆矩阵公式）    注意事项：   相机矩阵的 Z轴 与相机的照射方向相反 glm 中的矩阵是列向量优先 正交矩阵的逆矩阵等于它的转置  刚体运动中变换矩阵的逆矩阵求解：   刚体运动变换矩阵： $$\begin{equation} T = \begin{bmatrix*}[c] R &amp;amp; t \newline 0^T &amp;amp; 1 \end{bmatrix*} \end{equation}$$ 分块矩阵求逆公式 $$\begin{equation} M = \begin{bmatrix*}[c] A &amp;amp; B \newline 0 &amp;amp; D \end{bmatrix*} \space\space\space\space M^{-1} = \begin{bmatrix*}[c] A^{-1} &amp;amp; -A^{-1}BD^{-1} \newline 0 &amp;amp; D^{-1} \end{bmatrix*} \end{equation}$$ 刚体运动变换矩阵的逆矩阵： $$\begin{equation} T^{-1} = \begin{bmatrix*}[c] R^{-1} &amp;amp; -R^{-1}t \newline 0^T &amp;amp; 1 \end{bmatrix*} = \begin{bmatrix*}[c] R^T &amp;amp; -R^Tt \newline 0^T &amp;amp; 1 \end{bmatrix*} \end{equation}$$  方法一：  glm::mat4 Camera::calculateLookAtMatrix() { // 1.</description>
    </item>
    
    <item>
      <title>OpenGL 渲染管线</title>
      <link>https://874656645.github.io/posts/196-opengl-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</link>
      <pubDate>Fri, 17 Jun 2022 16:45:02 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/196-opengl-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</guid>
      <description>红宝书第九版，OpenGL Version 4.5
Games101 闫令琪
顶点数据-&amp;gt;顶点着色器（MVP 矩阵变换，NDC 标准化设备坐标）-&amp;gt;细分控制着色器-&amp;gt;细分计算着色器-&amp;gt;几何着色器-&amp;gt;图元装配-&amp;gt;裁剪和剔除-&amp;gt;光栅化-&amp;gt;片元着色器
片元着色器后，可能还有混色、测试等流程，最后将渲染结果输入到 Frame Buffer 中
  顶点着色器： 将传入的顶点坐标进行 MVP 矩阵变换，经过顶点着色器，它们就该是标准化设备坐标。
  细分着色： 细分着色包括细分控制着色器和细分计算着色器，细分控制着色器和细分计算着色器是相互依存的，要么都不要，要么都要。细分着色的作用就是通过面片（patch）来描述一个物体的形状。顶点着色器只能处理每个顶点关联的数据，而细分着色能通过面片的形式分割更多的数据点（比如曲面细分）  细分控制着色器：细分控制着色器的一个常见应用就是将输入面片顶点（控制点）传递给细分计算着色器和通过设置细分层次因素，告诉 OpenGL 怎么生成顶点，每个顶点的标注化二维坐标（细分坐标）以二维向量（也就是说只有其 x 和 y 分量是有效的）的方式保存在变量 gl_TessCorrd 内，该变量会被传递到细分计算着色器中（注：gl_TessCorrd 保存的是一个线段的因子，如一个线段的 0.5 横坐标处，那么 gl_TessCorrd.x=0.5）； 细分计算着色器：细分控制着色器完成后，细分计算着色器就通过控制点和细分坐标生成一系列顶点坐标，输出跟顶点着色器是一样的。 更多细节：可以看文章OpenGL 图元处理    几何着色器： 几何着色器提供了一种更加灵活的图元生成方法，它能够将（这一组）顶点变换为完全不同的图元，并且还能生成比原来更多的顶点。原理上来说，几何着色器通过一些手段也可以完成细分着色器的任务，但是为什么需要细分着色器呢？这是因为在某些图元生成上，细分着色器可以更加精确或者方便，比如生成三角形网格顶点，更多介绍参见几何着色器。可以看到，顶点着色器，细分着色器和几何着色器本质上都是对顶点进行处理。
  图元装配： 前面的着色阶段都对顶点进行操作，关于这些顶点如何被组织成几何图元的信息并传到到 OpenGL 的下个阶段。图元组装阶段将顶点组织成它们相关的几何图形，为裁剪和光栅化做准备。
  裁剪和剔除： 偶尔，顶点会在视口之外（窗口的区域），并对与顶点相关的图元进行修改，使其像素都不在视口之外。这个操作被称为裁剪，并由 OpenGL 自动处理。
  光栅化： 经过以上步骤，基本上一个图形就形成了，但是这个图形的坐标还是在自己的坐标系中，光栅化就是将图形的坐标转化为屏幕像素坐标，最终将图元的数学描述转化为用于显示在屏幕上的片段，然后通过帧缓存就可以在电脑上看到一个个美丽的图形。
  片元着色器： 片元着色器是opengl渲染的最后一个流程，它的主要作用就是赋予我们图形最终的颜色，纹理渲染也在这个阶段
  参考：
 顶点着色器到片元着色器的过程，varying变量 opengl基本流程 OpenGL学习脚印: 投影矩阵和视口变换矩阵(math-projection and viewport matrix) OpenGL入门（五）&amp;ndash; OpenGL渲染流程图解析 Opengl复习笔记（一）——顶点着色器、片段着色器（内含代码） GPU是如何工作的？Shader图形编程入门 GAMES101-现代计算机图形学入门-闫令琪 20分钟让你了解OpenGL——OpenGL全流程详细解读 OpenGL学习：Per-fragment operation(1)-模板测试(stencil test)  </description>
    </item>
    
    <item>
      <title>Qt 信号和槽</title>
      <link>https://874656645.github.io/posts/193-qt-%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/</link>
      <pubDate>Tue, 14 Jun 2022 09:45:15 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/193-qt-%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/</guid>
      <description> 信号函数没有返回值，且只是一个函数声明，必须有 signals: 声明 槽函数的函数标签必须和信号函数相同（相同的返回值类型和形参列表） Qt5 后成员函数也可作为 slots，可以不用 slots: 声明 slots: 声明前要添加访问权限修饰符 信号函数和槽函数其实都可以被重载  // signal 和 slots 都可以重载  // Qt5的方式  void(subWindow::*pFun1)() = &amp;amp;subWindow::showMainWindow; void(MainWindow::*pSlot1)() = &amp;amp;MainWindow::onShowMainWindow; connect(&amp;amp;sw, pFun1, this, pSlot1); void(subWindow::*pFun2)(int,QString) = &amp;amp;subWindow::showMainWindow; void(MainWindow::*pSlot2)(int,QString) = &amp;amp;MainWindow::onShowMainWindow; connect(&amp;amp;sw, pFun2, this, pSlot2); // Qt4的方式  // 1. SIGNAL、SLOT宏会把信号和槽转成字符串，所以就不能进行编译期错误检查  // 2. 槽函数前面必须有 slots 标签，否则无法识别为槽函数  connect(&amp;amp;sw, SIGNAL(showMainWindow()), this, SLOT(onShowMainWindow())); connect(&amp;amp;sw, SIGNAL(showMainWindow(int,QString)) , this, SLOT(onShowMainWindow(int,QString))); // Lambda 表达式  void(subWindow::*pFun1)() = &amp;amp;subWindow::showMainWindow; connect(&amp;amp;sw, pFun1, [](){ qDebug()&amp;lt;&amp;lt;&amp;#34;没有参数的信号&amp;#34;; } ); void(subWindow::*pFun2)(int,QString) = &amp;amp;subWindow::showMainWindow; connect(&amp;amp;sw, pFun2, [](int a, QString msg){ qDebug()&amp;lt;&amp;lt;a&amp;lt;&amp;lt;msg; } ); // Lambda 表达式使用注意事项  // 如果b3是局部变量或者成员变量，lambda不要使用引用传值  QPushButton *b3 = new QPushButton(this); b3-&amp;gt;setText(&amp;#34;Lambda&amp;#34;); int a = 10, b = 100; connect(&amp;amp;b2/*b3*/, &amp;amp;QPushButton::clicked, [=](){ // 此处使用 &amp;amp; 传值会有问题  qDebug()&amp;lt;&amp;lt;a&amp;lt;&amp;lt;b; } ); </description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 关于右值引用、左值引用和通用引用的思考</title>
      <link>https://874656645.github.io/posts/192-c&#43;&#43;11-%E5%85%B3%E4%BA%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E9%80%9A%E7%94%A8%E5%BC%95%E7%94%A8%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Sat, 11 Jun 2022 20:48:22 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/192-c&#43;&#43;11-%E5%85%B3%E4%BA%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E9%80%9A%E7%94%A8%E5%BC%95%E7%94%A8%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>一、通用引用  类型声明形式为 type&amp;amp;&amp;amp; 其中 type 类型是要进行推导的，如果类型推导没有发生，那么 type&amp;amp;&amp;amp; 代表一个右值引用 如果一个对象被声明为 auto&amp;amp;&amp;amp;，这个形参或者对象就是一个通用引用 通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用 如果在一个类模板里面看见了一个函数形参类型为 T&amp;amp;&amp;amp;，也不一定就是通用引用，可能并没有发生类型推导  void f(Widget&amp;amp;&amp;amp; param); //右值引用 Widget&amp;amp;&amp;amp; var1 = Widget(); //右值引用 auto&amp;amp;&amp;amp; var2 = var1; //通用引用（不是右值引用）  template&amp;lt;typename T&amp;gt; void f(std::vector&amp;lt;T&amp;gt;&amp;amp;&amp;amp; param); //右值引用  template&amp;lt;typename T&amp;gt; void f(T&amp;amp;&amp;amp; param); //通用引用（不是右值引用）  template &amp;lt;typename T&amp;gt; void f(const T&amp;amp;&amp;amp; param); //param是一个右值引用，因为添加了 const 限定符  // 函数模板 一般可能是通用引用 template &amp;lt;typename T&amp;gt; void print_reference_type(T &amp;amp;&amp;amp;i) { // T&amp;amp;&amp;amp; 或是 auto&amp;amp;&amp;amp;  if (std::is_lvalue_reference&amp;lt;decltype(i)&amp;gt;::value) { std::cout &amp;lt;&amp;lt; &amp;#34;lvalue: &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; } else if (std::is_rvalue_reference&amp;lt;decltype(i)&amp;gt;::value) { std::cout &amp;lt;&amp;lt; &amp;#34;rvalue: &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; } else { std::cout &amp;lt;&amp;lt; &amp;#34;unknown value: &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; } } // 因为 push_back 在有一个特定的 vector 实例之前不可能存在， // 而实例化 vector 时的类型已经决定了 push_back 的声明 // 所以在这里并没有发生类型推导 template&amp;lt;class T, class Allocator = allocator&amp;lt;T&amp;gt;&amp;gt; //来自C++标准 class vector { public: void push_back(T&amp;amp;&amp;amp; x); … } 一个记录任意函数调用的时间开销的函数模板</description>
    </item>
    
    <item>
      <title>C 实现继承和多态</title>
      <link>https://874656645.github.io/posts/195-c-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</link>
      <pubDate>Tue, 24 May 2022 09:15:13 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/195-c-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</guid>
      <description>C中的继承和多态</description>
    </item>
    
    <item>
      <title>ArcGIS 处理 Shape 字段</title>
      <link>https://874656645.github.io/posts/194-arcgis-%E5%A4%84%E7%90%86-shape-%E5%AD%97%E6%AE%B5/</link>
      <pubDate>Mon, 23 May 2022 17:41:51 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/194-arcgis-%E5%A4%84%E7%90%86-shape-%E5%AD%97%E6%AE%B5/</guid>
      <description>注：ArcMap 版本为 10.6.1
一、将 shape 字段处理为 WKT 文本
 在属性表中添加一个 Text 类型的字段，大小尽量大一些； 使用字段计算功能 shape file 的字符串类型字段的大小有限制（254）  二、
def MySub(feat): partnum = 0 # Count the number of points in the current multipart feature partcount = feat.partCount pntcount = 0 str = &amp;#39;&amp;#39; # Enter while loop for each part in the feature (if a singlepart  # feature, this will occur only once) while partnum &amp;lt; partcount: part = feat.</description>
    </item>
    
    <item>
      <title>使用 VS2022 部署、运行和调试 Linux MSBuild 项目</title>
      <link>https://874656645.github.io/posts/191-%E4%BD%BF%E7%94%A8-vs2022-%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95-linux-msbuild-%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Wed, 18 May 2022 12:02:56 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/191-%E4%BD%BF%E7%94%A8-vs2022-%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95-linux-msbuild-%E9%A1%B9%E7%9B%AE/</guid>
      <description>一、设置 Linux 环境 1. 确保已安装用于 Visual Studio 的 Linux 开发工作负荷 2. Linux 所需环境 sudo apt-get install openssh-server g++ gdb make ninja-build rsync zip
确保 ssh 服务在 Linux 计算机上运行
sudo service ssh start
参考官方文档
二、连接到远程 Linux 打开【工具】&amp;gt;【选项】&amp;gt;【跨平台】&amp;gt;【连接管理器】进行添加设置
也可以连接到 WSL，参考官方文档
三、创建 Linux MSBuild 项目 四、配置 Linux MSBuild 项目 大部分的默认配置都不需要修改，只需关注几个地方
调试设置
包含目录是 Linux 上项目的路径
库目录可使用相对路径
如果依赖的是动态库，需要在 Linux 端设置 LD_LIBRARY_PATH
最后在 Linux 环境中生成的项目目录如下
还可以在【调试】中打开【Linux控制台】
参考官方文档</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 继承构造</title>
      <link>https://874656645.github.io/posts/190-c&#43;&#43;11-%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0/</link>
      <pubDate>Fri, 13 May 2022 16:30:07 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/190-c&#43;&#43;11-%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0/</guid>
      <description>通过 using 可以方便的使用父类的构造函数和其他函数； 优先使用子类的构造和函数，如果没有找到匹配的才会调用基类的； 可在子类的初始化列表中调用父类的构造函数，并对子类的成员进行列表初始化；  class BS { int q; double w; public: BS() : q(0), w(0) {} BS(int k) : q(k), w(100) {} BS(double x) : q(-1), w(x) {} BS(int k, double x) : q(k), w(x) {} void Show() const { std::cout &amp;lt;&amp;lt; q &amp;lt;&amp;lt;&amp;#34;, &amp;#34; &amp;lt;&amp;lt; w &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } int fn(int j) { cout &amp;lt;&amp;lt; &amp;#34;BS::fn(int)\n&amp;#34;; return 0; } double fn(double w) { cout &amp;lt;&amp;lt; &amp;#34;BS::fn(double)\n&amp;#34;; return 0; } void fn(const char * s) { cout &amp;lt;&amp;lt; &amp;#34;BS::fn(const char *)\n&amp;#34;; } }; class DR : public BS { short j; public: using BS::BS; DR() : j(-100) {} // DR needs its own default constructor  DR(double x) : BS(2*x), j(int(x)) {} DR(int i) : j(-2), BS(i, 0.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 委托构造</title>
      <link>https://874656645.github.io/posts/189-c&#43;&#43;11-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0/</link>
      <pubDate>Fri, 13 May 2022 15:37:16 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/189-c&#43;&#43;11-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0/</guid>
      <description>委托构造的使用方法类似成员列表初始化的变种；
注意：
 如果在一个构造函数中使用了本类的委托构造，就不能再对成员使用列表初始化了； 会先执行委托构造函数的函数体，然后再执行本身的函数体； 虽然可以在构造函数中调用其他的构造函数，但已经被初始化的成员变量还会被当前的构造函数进行重置，有可能导致又变为原来的未初始化状态；  class Test{ public: Test():Test(0, 0.1){ s = &amp;#34;Ah&amp;#34;; cout &amp;lt;&amp;lt; &amp;#34;Test()\n&amp;#34;; } Test(int ii):Test(ii, 0.1, &amp;#34;Hi&amp;#34;){ cout &amp;lt;&amp;lt; &amp;#34;Test(int)\n&amp;#34;; } Test(int ii, double dd):Test(ii, dd, &amp;#34;Hi&amp;#34;){ cout &amp;lt;&amp;lt; &amp;#34;Test(int, double)\n&amp;#34;; } Test(int ii, double dd, string ss):i(ii), d(dd), s(ss){ cout &amp;lt;&amp;lt; &amp;#34;Test(int, double, string)\n&amp;#34;; } void print(){ cout &amp;lt;&amp;lt; &amp;#34;i = &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34;\td = &amp;#34; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; &amp;#34;\ts = &amp;#34; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl; } private: int i; double d; string s; }; int main() { Test t(10); t.</description>
    </item>
    
    <item>
      <title>main 函数执行完后所执行的代码</title>
      <link>https://874656645.github.io/posts/188-main-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%90%8E%E6%89%80%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Thu, 12 May 2022 16:02:52 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/188-main-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%90%8E%E6%89%80%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81/</guid>
      <description> 静态变量在 main 函数前执行初始化 on_exit 注册的函数在 main 执行后再执行  void f(int state, void* msg){ cout &amp;lt;&amp;lt; &amp;#34;after main exit.\n&amp;#34;; cout &amp;lt;&amp;lt; &amp;#34;state: &amp;#34; &amp;lt;&amp;lt; state &amp;lt;&amp;lt; &amp;#34;\tmessage: &amp;#34; &amp;lt;&amp;lt; (char*)msg &amp;lt;&amp;lt; endl; } int main() { cout &amp;lt;&amp;lt; &amp;#34;Hello World\n&amp;#34;; on_exit(f, (char*)&amp;#34;this is message&amp;#34;); cout &amp;lt;&amp;lt; &amp;#34;end of main.\n&amp;#34;; return 0; } 输出：
Hello World end of main. after main exit. state: 0	message: this is message </description>
    </item>
    
    <item>
      <title>大端、小端字节序</title>
      <link>https://874656645.github.io/posts/187-%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F/</link>
      <pubDate>Thu, 21 Apr 2022 16:04:58 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/187-%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F/</guid>
      <description>一、概念   计算机系统中内存是以字节为单位进行编址的，每个地址单元都唯一的对应着 1 个字节（8 bit）
  有些类型的长度是超过 1 个字节的，比如 C/C++ 中，short 类型一般是 2 个字节，int 类型一般 4 个字节等。因此这里就存在如何安排多字节数据中，各字节存放顺序的问题。正是因为不同的安排顺序导致了大端存储模式和小端存储模式的存在。
 大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中（高低低高） 小端模式：是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中（高高低低）    假如有一个 4 字节的数据为 0x12345678（十进制：305419896，0x12 为高字节，0x78 为低字节），若将其存放于地址 0x4000 8000 中，则有：
            内存地址 0x4000 8000（低地址） 0x4000 8001 0x4000 8002 0x4000 8003（高地址）   大端模式 0x12 0x34 0x56 0x78   小端模式 0x78 0x56 0x34 0x12      现状：</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 内存对齐 alignof alignas max_align_t</title>
      <link>https://874656645.github.io/posts/186-c&#43;&#43;11-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-alignof-alignas-max_align_t/</link>
      <pubDate>Tue, 19 Apr 2022 19:23:40 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/186-c&#43;&#43;11-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-alignof-alignas-max_align_t/</guid>
      <description>alignof( type-id ) 查询类型的对齐要求，以字节为单位
struct Storage { char a; int b; double c; long long d; }; // struct alignas(alignof(long double)) AlignasStorage { // struct alignas(long double) AlignasStorage { struct alignas(std::max_align_t) AlignasStorage { // max_align_t 相当于 alignof(long double) 内存对齐为 16 字节  // 这三种写法都可以  char a; int b; double c; long long d; }; struct Empty {}; struct alignas(64) Empty64 {}; int main() { std::cout &amp;lt;&amp;lt; alignof(Storage) &amp;lt;&amp;lt; std::endl; // 8  std::cout &amp;lt;&amp;lt; sizeof(Storage) &amp;lt;&amp;lt; std::endl; // 24 内存对齐为 8 字节，所以大小为 8 的整数倍  std::cout &amp;lt;&amp;lt; alignof(AlignasStorage) &amp;lt;&amp;lt; std::endl; // 16  std::cout &amp;lt;&amp;lt; sizeof(AlignasStorage) &amp;lt;&amp;lt; std::endl; // 32 内存对齐为 16 字节，所以大小为 16 的整数倍  int a = 10; int &amp;amp;b = a; std::cout &amp;lt;&amp;lt; alignof(b) &amp;lt;&amp;lt; std::endl; // 4 引用类型返回引用类型的对齐要求  int x[10]; std::cout &amp;lt;&amp;lt; alignof(x) &amp;lt;&amp;lt; std::endl; // 4 数组类型返回元素类型的对齐要求  std::cout &amp;lt;&amp;lt; &amp;#34;Alignment of&amp;#34; &amp;#34;\n&amp;#34; &amp;#34;- char : &amp;#34; &amp;lt;&amp;lt; alignof(char) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34; // 1  &amp;#34;- pointer : &amp;#34; &amp;lt;&amp;lt; alignof(int*) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34; // 8  &amp;#34;- int : &amp;#34; &amp;lt;&amp;lt; alignof(int) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34; // 4  &amp;#34;- long long : &amp;#34; &amp;lt;&amp;lt; alignof(long long) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34; // 8  &amp;#34;- empty class : &amp;#34; &amp;lt;&amp;lt; alignof(Empty) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34; // 1  &amp;#34;- alignas(64) Empty: &amp;#34; &amp;lt;&amp;lt; alignof(Empty64) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; // 64  return 0; } </description>
    </item>
    
    <item>
      <title>Cesium4Unreal——Editing Tileset Materials</title>
      <link>https://874656645.github.io/posts/185-cesium-unreal-editing-tileset-materials/</link>
      <pubDate>Sun, 17 Apr 2022 16:24:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/185-cesium-unreal-editing-tileset-materials/</guid>
      <description>Cesium for Unreal 插件的材质被设计成模块化的，所以可以被很容易地添加和删除。
目标  浏览和理解现有的 Cesium for Unreal 3D Tileset 的材质 基于包含在 Cesium for Unreal 插件内的材质实例文件创建自定义材质 修改 tileset 的材质 了解 tileset mesh 的材质限制  Material Instances Cesium for Unreal 通过使用 Material Instances 实现最大的灵活度，每个材质实例通过使用更多的材质图层来应用图像叠加，水，或其他材质效果。
![MaterialInstances](./img/MaterialInstances.jpg)  图层资产：包含将显示在给定层上的材质图层节点 混合资产：包含一个节点，该节点确定该材质图层将如何与下面的图层混合 每个材质图层和材质图层混合都可以像其他材质对象一样在材质编辑器中编辑  创建应用到整个 tileset 的材质   在插件目录找到 MI_CesiumThreeOverlaysAndClipping 材质实例文件，并把它拷贝到项目的内容文件夹中，将其改名为 MI_GroundTint。
  在【内容】面板右击，创建一个【材质图层】资产，并将其命名为 ML_GroundTint。
  双击 ML_GroundTint，打开材质编辑窗口，点击【SetMaterialAttributes】节点，在【细节】面板中的【属性设置类型】数组中添加两个元素，第一个元素设置为默认值【BaseColor】，第二个元素设置为【Opacity】。
  添加一个【Constant3Vector】节点，并右击节点，将其【转换为参数】，并命名为 Color。
  添加一个【Constant】节点，，将其【转换为参数】，并命名为 Opacity。
  右击 Color 节点，在【细节】面板设置默认颜色，比如红色，设置 Opacity 的默认值为 0.</description>
    </item>
    
    <item>
      <title>Cesium4Unreal——Hide Parts Tilesets</title>
      <link>https://874656645.github.io/posts/184-cesium-unreal-hide-parts-tilesets/</link>
      <pubDate>Sat, 16 Apr 2022 16:24:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/184-cesium-unreal-hide-parts-tilesets/</guid>
      <description>使用 CesiumCartographicPolygon actor，可以定义一个 tileset 的隐藏区域，或应用其他材质效果。CesiumCartographicPolygon 可以通过 Cesium PolygonRasterOverlay 组件添加到一个或多个 tilesets。
在这里，一个 CesiumCartographicPolygon 被用来隐藏 Cesium World Terrain 和 Cesium OSM Buildings，它们与 Aerometrex Denver Photogrammetry 重叠。
注意：虽然 CesiumCartographicPolygon 有助于基于材质的改变，如 clipping，但它们不影响物理。你仍然可以与 tileset 的隐藏部分发生碰撞。
第一步：添加 CesiumCartographicPolygon actor 可以修改多边形的节点（增加、删除、拖拽节点），修改线的颜色，以及地理位置
第二步：将 CesiumCartographicPolygon 连接到 tileset 数据 选择要将 CesiumCartographicPolygon 应用到的 tileset，比如 Cesium World Terrain，添加组件 CesiumPolygonRasterOverlay
关连 CesiumCartographicPolygon
可以手动刷新 tileset （Refresh Tileset）观看效果
 Exclude Tiles Inside： 是专为 clipping 使用。如果这个设置被启用，任何完全位于多边形内部的 tiles 都不会被加载，这可以提高性能。如果你使用这个多边形不是为了 clipping，要禁用这个设置。否则，多边形内的 tiles 将不会被渲染。 Material Layer Key： 将多边形与特定部分的 tileset 的材质连接起来。如果你把这个键换成别的东西，它不会起作用，直到你创建一个使用新键的材质，并将该材质应用到 tileset。  </description>
    </item>
    
    <item>
      <title>Cesium4Unreal——Using Custom Controllers</title>
      <link>https://874656645.github.io/posts/183-cesium-unreal-using-custom-controllers/</link>
      <pubDate>Sat, 16 Apr 2022 10:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/183-cesium-unreal-using-custom-controllers/</guid>
      <description>目标 此步骤将学习如何设置控制器，而不是使用 Cesium 的 DynamicPawn。
第一步：添加摄影测量数据 为了防止地形和摄影测量数据交叉，将 Aerometrex Denver Photogrammetry 的 actor 的位置的 Z 值设置为 600。
第二步：定位到摄影测量数据  方式一：如果有经纬度坐标和高程数据，直接设置 CesiumGeoreference 的数据  Origin Latitude = 39.752827
Origin Longitude = -104.999689
Origin Height = 1570.879421
方式二：在【世界大纲视图】中双击 Aerometrex Denver Photogrammetry，使用场景视图导航到想要放置世界原点的位置，并点击【Place Georeference origin Here】按钮  第三步：导入第三人称角色 可以添加 UE 自带的【Third Person】资源，也可以添加自己做的角色。添加自带的小白人资源有两种方式：
 方式一：通过【添加/导入】中的【添加功能或内容包】  方式二：从其他有【第三人称游戏模板】的项目中，将 ThirdPersonCharacter 迁移到本项目中。  第四步：将 ThirdPersonCharacter 放入到场景中 找到 ThirdPersonCharacter 并将其拖拽到场景里，并调整合适的朝向
效果如下：
设置【自动控制玩家】为【玩家0】，这样在点击【运行】的时候就可以看到小白人了
注意：如果你现在试着玩这个关卡，你会注意到你的演员可能会在丹佛摄影测量完全加载之前开始下降。继续阅读，看看如何解决这个问题。出于这个原因，还建议禁用当前未与之交互的任何物理对象的物理功能。
第五步：设置一个安全的起始位置 在小白人的脚下放置一个立方体，防止开始游戏时，由于 3DTiles 数据在加载过程中，小白人由于受重力影响而掉下去。
第六步：在场景中添加一个车辆控制器 第七步：设置关卡蓝图 通过 C 和 V 切换小白人和车辆控制器的控制权。</description>
    </item>
    
    <item>
      <title>Cesium4Unreal——Transition Between Locations</title>
      <link>https://874656645.github.io/posts/182-cesium-unreal-transition-between-locations/</link>
      <pubDate>Fri, 15 Apr 2022 16:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/182-cesium-unreal-transition-between-locations/</guid>
      <description>目标 学习使用虚幻引擎的蓝图系统编程，实现在地球上的两个位置之间平稳飞行。
 在虚幻引擎中使用地图坐标 在感兴趣的位置创建 viewpoints 创建一个蓝图，使位置的切换变得平滑  第一步：创建一个关卡 参考前面的步骤创关卡，并定位到澳大利亚悉尼
Origin Latitude = -33.871799 Origin Longitude = 151.206696 Origin Height = 3000.0
第二步：添加 DynamicPawn actor 第三步：在蓝图中设置转换   打开关卡蓝图
  蓝图联接图
  创建墨尔本经纬度向量
longitude = 144.9631
latitude = -37.8136
height = 2000
第四步：自定义飞行过渡 设置飞行曲线：
 Fly To Altitude Profile Curve Fly to Maximum Altitude Curve Fly to Progress Curve  添加 Fly To Curves actor，这是一个UCurveFloat，这个函数用来控制计算从源头到目的地的路径插值。
  在【内容】面板右击，选择【其他】【曲线】，选择【CurveFloat】，并命名</description>
    </item>
    
    <item>
      <title>Cesium4Unreal——Building Global Scenes with Georeferenced Sublevels</title>
      <link>https://874656645.github.io/posts/181-cesium-unreal-georeferenced-sublevels/</link>
      <pubDate>Fri, 15 Apr 2022 13:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/181-cesium-unreal-georeferenced-sublevels/</guid>
      <description>目标  Create a persistent global level Put several local sublevels within the persistent level Fill each sublevel with assets and game-logic using your typical Unreal workflow Seamlessly fly between sublevels as well as explore the persistent level Stay aware of pitfalls along the way  第一步：新建由项目组成的世界场景   新建一个空白的项目
参考快速入门，删除【世界大纲试图】中的所有默认的 actors
  创建持久关卡(Persistent Level)
在内容浏览器新建 World 文件夹，把当前的空关卡命名为 Globe 并保存到此文件夹中。
这个关卡就是 Persistent Level，它代表了整个地球。
  世界场景设置
打开【世界场景设置】面板，勾选【启用场景合成】
禁用【启用场景边界检查】，在全球尺度的世界中，物体可以移动非常远的距离，禁用此设置 Unreal 就不会删除远离原点的物体</description>
    </item>
    
    <item>
      <title>Cesium4Unreal——Place Objects On Globe</title>
      <link>https://874656645.github.io/posts/180-cesium-unreal-placeobjectonglobe/</link>
      <pubDate>Fri, 15 Apr 2022 10:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/180-cesium-unreal-placeobjectonglobe/</guid>
      <description>一、添加静态风格体（static meshes） 二、真实世界椭球与游戏世界坐标系 由于地球曲率的影响，距离 CesiumGeoreference 原点越远，铅垂线的方向误差越大，每一公里方向偏差大概 0.01 度。当我们从地球的一端到对面的一端时，重力的方向就转了 180 度。
可以从以下几方面解决（由易到难）：
 待在一个相对较小的区域内，大概100公里左右； 在地球的每个部分设置独立的子关卡，每个子关卡都有自己的 CesiumGeoreference； 使用 CesiumGlobeAnchor 为 actor 添加有限的真实世界信息参考(参见下面的“我们可以将动态对象转换为地理引用对象”); 手动扩展你的游戏对象，以充分考虑真实椭圆地球影响。  三、一般的虚幻引擎对象的位置问题 一般的虚幻引擎对象是固定在游戏世界，而不固定在真实世界的位置
当 CesiumGeoreference 原点改变时，整个虚幻引擎世界将移动到地球上的一个新位置，包括其中的所有对象
开始放置的地方：
修改 CesiumGeoreference 原点后：
四、将动态对象转换为具有地理坐标参考的对象 1. 修改对象为可移动的 2. 添加 Cesium Globe Anchor 组件 通过添加 Cesium Globe Anchor 组件，就将这个 actor 对象转换为具有地理位置参考的对象了。
现在，我们可以更改 Cesium Globe Anchor 的原点，那么该物体将完全保持在地球上的位置。我们还可以直接指定 Longitude / Latitude / Height 或者 Earth-Centered, Earth-Fixed 的坐标，以将物体与精确的数值坐标放置在一起。
需要注意两点：
 只能将 Cesium Globe Anchor 组件添加到可移动的 actor 上； 并不能解决所有的问题，尤其是重力方向的问题；  </description>
    </item>
    
    <item>
      <title>Cesium4Unreal——Photogrammetry 倾斜摄影</title>
      <link>https://874656645.github.io/posts/179-cesium-unreal-photogrammetry/</link>
      <pubDate>Thu, 14 Apr 2022 15:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/179-cesium-unreal-photogrammetry/</guid>
      <description>第一步：新建空白关卡 第二步：添加倾斜摄影数据 去网站将数据资产添加到自己的账户
第三步：以倾斜摄影数据为中心 看起来怪怪的是因为球心坐标系与游戏的坐标系统有所不同， 虚幻编辑器的摄像机 Z 方向是向上的。在地球上（与大多数游戏不同）以地球为中心的坐标系统的向上方向取决于你在世界的位置。
通过点击 CesiumGeoreference 的 Place Georeference Origin Here 按钮快速设置场景坐标原点到当前相机位置
此按钮将重新定位虚幻引擎当前关卡的坐标系统，使其中心点(0,0,0)准确地位于摄像机之前的位置，并对齐虚幻引擎的坐标轴，使+X指向东方，+Y指向南方，+Z指向上方
第四步：添加光照 CesiumSunSky 添加照明并调整时区和时间
第五步：添加地球影像地形 修改摄影测量数据的位置
第六步：从本地目录添加 3D Tileset 1. 在场景中添加了一个新的空白 Cesium3DTileset Actor 2. 设置本地 Tileset 文件路径 定位到添加的 tileset actor，场景和数据朝向很可能是错误的
这是因为 CesiumGeoreference actor 的原点距离 LocalTileset actor 很远。
3. 重新设置原点 修改 3D Tileset 数据的 Z 值
影像地形数据 可以通过在本场发布数据服务的方式，类似这种 http://localhost:portNumber/terrainAsset
经度和时区 摘自知乎
经度与纬度组成了一个坐标系统，称为地理坐标系统。通过经纬度表示地球上的任何一个位置。
国际上规定以通过英国伦敦近郊的格林尼治天文台旧址的经线作为计算经度的起点，即经度零度零分零秒，也称“本初子午线”。在它东面的为东经，共180度；在它西面的为西经，共180度。因为地球是圆的，所以东经180度和西经180度的经线是同一条经线。各国公定180度经线为“国际日期变更线”。为了避免同一地区使用两个不同的日期，国际日期变线在遇陆地时略有偏离。
地球自西向东转，东边时间就要比西边早。规定将全球分为24时区，东西各12时区，每个时区跨经度15度，以英国格林尼治天文台旧址为零时区，两个相邻时区之间相差1小时。
不同时区的时间按照同减异加、东加西减的原则计算。比如，北京位于东8区，纽约在西5区，北京时间要比纽约早13个小时。</description>
    </item>
    
    <item>
      <title>Cesium4Unreal——Hello Cesium for UE</title>
      <link>https://874656645.github.io/posts/178-cesium-unreal-project/</link>
      <pubDate>Thu, 14 Apr 2022 10:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/178-cesium-unreal-project/</guid>
      <description> Ureal Engin 版本 4.27  第一步：安装 Cesium 插件 Cesium for Unreal 插件地址
启动 Epic Games Launcher，搜索 Cesium for Unreal
第二步：新建项目关卡 1. 项目类型——&amp;gt;游戏，模板——&amp;gt;空白，选择不带初学者内容包 2. 激活 Cesium for Unreal 插件 3. 删除【世界大纲视图】中的所有内容，这样就有了一个空的关卡 保存当前关卡
将你上面保存的关卡设置为编辑器开始地图和游戏默认地图
第三步：Connect to Cesium ion 第四步：在场景中添加球 开始会有创建 token 的对话框，完成后，在世界大纲视图中会添加下面几个 Actor 对象
第五步：使用 CesiumSunSky 添加照明 启用【项目设置】【扩展自动曝光设置中的默认亮度范围】
第六步：添加 DynamicPawn  确保 DynamicPawn 自动控制玩家属性为玩家0 设置相对位置变换为 (0, 0, 0)  第七步：通过 CesiumGeoreference 修改场景的初始位置 第八步：通过 CesiumSunSky 设置光照 </description>
    </item>
    
    <item>
      <title>C&#43;&#43;17 折叠表达式</title>
      <link>https://874656645.github.io/posts/177-c&#43;&#43;17-%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Wed, 13 Apr 2022 16:50:15 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/177-c&#43;&#43;17-%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>一元折叠表达式
 ( pack op ... ) : 一元右折叠  (E op ...) 展开后： (E1 op (... op (EN-1 op EN)))   ( ... op pack ) ：一元左折叠  (... op E) 展开后： (((E1 op E2) op ...) op EN)      二元折叠表达式
 ( pack op ... op init ) ：二元右折叠  (E op ... op I) 展开后： (E1 op (... op (EN−1 op (EN op I))))   ( init op .</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17 变长参数模板</title>
      <link>https://874656645.github.io/posts/176-c&#43;&#43;17-%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Wed, 13 Apr 2022 10:49:20 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/176-c&#43;&#43;17-%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/</guid>
      <description>任意个数、任意类别的模板参数
template&amp;lt;typename... Ts&amp;gt; class Magic; // 计算参数的个数 template&amp;lt;typename... Ts&amp;gt; void magic(Ts... args) { std::cout &amp;lt;&amp;lt; sizeof...(args) &amp;lt;&amp;lt; std::endl; }   递归解包：
 C++17 之前  template&amp;lt;typename T0&amp;gt; void my_printf(T0 value) { std::cout &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl; } template&amp;lt;typename T, typename... Ts&amp;gt; void my_printf(T value, Ts... args) { std::cout &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl; my_printf(args...); } int main() { my_printf(1, 2.2, &amp;#34;abc&amp;#34;, &amp;#39;a&amp;#39;); return 0; }  C++17 变参模板展开：  template&amp;lt;typename T, typename.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17 使用结构化绑定来解包绑定的返回值</title>
      <link>https://874656645.github.io/posts/175-c&#43;&#43;17-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E6%9D%A5%E8%A7%A3%E5%8C%85%E7%BB%91%E5%AE%9A%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</link>
      <pubDate>Tue, 12 Apr 2022 19:02:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/175-c&#43;&#43;17-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E6%9D%A5%E8%A7%A3%E5%8C%85%E7%BB%91%E5%AE%9A%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</guid>
      <description>注意：使用结构化绑定时，就不能再使用 std::tie 创建虚拟变量了，所以我们不得不绑定所有值到命名过的变量上。对部分成员进行绑定的做法是高效的，因为编译器可以很容易的对未绑定的变量进行优化
std::pair&amp;lt;int,int&amp;gt; divide_remainder(int dividend, int divisor){ int f = dividend / divisor; int s = dividend % divisor; return {f, s}; } int main() { auto [dividend, remainder] = divide_remainder(16, 3); std::cout &amp;lt;&amp;lt; &amp;#34;16 / 3 is &amp;#34; &amp;lt;&amp;lt; dividend &amp;lt;&amp;lt; &amp;#34; with a remainder of &amp;#34; &amp;lt;&amp;lt; remainder &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; // 之前的写法  int remainder1; std::tie(std::ignore, remainder1) = divide_remainder(16, 5); std::cout &amp;lt;&amp;lt; &amp;#34;16 % 5 is &amp;#34; &amp;lt;&amp;lt; remainder1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; return 0; } </description>
    </item>
    
    <item>
      <title>C&#43;&#43;17 大括号初始化</title>
      <link>https://874656645.github.io/posts/174-c&#43;&#43;17-%E5%A4%A7%E6%8B%AC%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Tue, 12 Apr 2022 18:51:42 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/174-c&#43;&#43;17-%E5%A4%A7%E6%8B%AC%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>( expression-list )：优先调用非聚合初始化，且会存在隐式转换 = expression： { initializer-list }：如果有聚合初始化（initializer_list&amp;lt;&amp;gt;），就调用聚合初始化，没有的话就调用符合条件的非聚合初始化 = { initializer-list }：同上 使用 auto 声明的变量括号初始化，只允许一个参数的情况 {} 与 () 调用构造函数初始化的方式，不同点在于 {} 没有类型的隐式转换，比如 int x(1.2); 和 int x = 1.2; 通过隐式的对浮点值进行向下取整，然后将其转换为整型，从而将 x 的值初始化为 1。相反的， int x{1.2}; 将会遇到编译错误，初始化列表中的初始值，需要与变量声明的类型完全匹配。  测试代码一：
// #define AGGREGATE_INIT class Test{ public: Test(int a, float b, char* c){ cout &amp;lt;&amp;lt; &amp;#34;int float char* initialize...&amp;#34; &amp;lt;&amp;lt; endl; } Test(int a, int b, int c){ cout &amp;lt;&amp;lt; &amp;#34;int int int initialize.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17 constexpr-if 简化编译</title>
      <link>https://874656645.github.io/posts/173-c&#43;&#43;17-constexpr-if-%E7%AE%80%E5%8C%96%E7%BC%96%E8%AF%91/</link>
      <pubDate>Tue, 12 Apr 2022 17:16:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/173-c&#43;&#43;17-constexpr-if-%E7%AE%80%E5%8C%96%E7%BC%96%E8%AF%91/</guid>
      <description>它能处理不同模板类型的特化，因为它可以在完全不同的代码中，选取相应的片段，依据这些片段的类型对模板进行特化
比如我们有一个简单的类，它的成员函数 add ，支持对 U 类型值与 T 类型值的加法
template &amp;lt;typename T&amp;gt; class addable { T val; public: addable(T v) : val{v} {} template &amp;lt;typename U&amp;gt; T add(U x) const { return val + x; } }; 假设类型 T 是 std::vector&amp;lt;something&amp;gt; ，而类型 U 是 int。这里就有问题了，为整个 vector 添加整数是为 了什么呢？应该是对 vector 中的每个元素加上一个整型数。实现这个功能就需要在循环中进行
template &amp;lt;typename U&amp;gt; T add(U x) { auto copy (val); // Get a copy of the vector member  for (auto &amp;amp;n : copy) { n += x; } return copy; } 把两种情况结合在一起：</description>
    </item>
    
    <item>
      <title>const_cast</title>
      <link>https://874656645.github.io/posts/172-const_cast/</link>
      <pubDate>Mon, 11 Apr 2022 17:51:55 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/172-const_cast/</guid>
      <description>函数指针和成员函数指针无法用于 const_cast const_cast 使得指向非 const 类型的 const 引用或指针能够被修改 通过 const_cast 修改 const 对象是未定义的行为  struct type { int i; type(): i(3) {} void f(int v) const { // this-&amp;gt;i = v; // compile error: this is a pointer to const  const_cast&amp;lt;type*&amp;gt;(this)-&amp;gt;i = v; // OK as long as the type object isn&amp;#39;t const  } }; int main() { int i = 3; // i is not declared const  const int&amp;amp; rci = i; // const reference  const_cast&amp;lt;int&amp;amp;&amp;gt;(rci) = 4; // OK: modifies i  std::cout &amp;lt;&amp;lt; &amp;#34;i = &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; const int* pci = &amp;amp;i; // *pci = 5; // error: assignment of read-only location ‘* pci’  *const_cast&amp;lt;int*&amp;gt;(pci) = 5; // OK: modifies i  std::cout &amp;lt;&amp;lt; &amp;#34;i = &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; type t; // if this was const type t, then t.</description>
    </item>
    
    <item>
      <title>类型转换函数</title>
      <link>https://874656645.github.io/posts/171-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 10 Apr 2022 15:39:37 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/171-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</guid>
      <description>一、转换函数 Conversion Functions(operators) 在 C++ 中，使用类作为具体类型，对现实世界对象进行抽象。有时，需要隐式地将一种具体类型转换为另一种具体类型或 C++ 内建数据类型。转换函数在这种情况下发挥着重要作用。它类似于类中的运算符重载函数。
转换函数写法：operator typeName();
 转换函数必须是类的成员函数 转换函数不能指定返回值类型 转换函数不能有形参  例如下面的类：
class Fraction { public: Fraction(int numerator, int denominator = 1) :m_numerator(numerator), m_denominator(denominator) { } //转换函数  operator double() const { return (double)m_numerator / m_denominator; } private: int m_numerator; //分子  int m_denominator; //分母 }; int main() { Fraction f(8,5); double d = 4 + f; cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; endl; return 0; } 输出：</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 constexpr</title>
      <link>https://874656645.github.io/posts/170-c&#43;&#43;11-constexpr/</link>
      <pubDate>Sat, 09 Apr 2022 10:28:47 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/170-c&#43;&#43;11-constexpr/</guid>
      <description>在编译过程中就已经把值计算出来，会做类型检查； define 是在预编译过程中进行简单的文本替换，不会做类型检查； 在对象声明时或非静态成员函数中使用 constexpr 关键字(C++ 14)暗示这个对象或非静态成员函数是 const 的； 在函数或静态数据成员(C++ 17)声明中使用的 constexpr 关键字意味着内联； C++11 中 constexpr 函数可以使用递归，?: 三目运算符，从 C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句； constexpr 修饰的是函数参数，而不是函数返回值，函数返回值是可以被改变的    constexpr 修饰变量必须满足以下要求：
 它的类型必须是一个LiteralType 它必须立即初始化 其初始化的完整表达式，包括所有隐式转换、构造函数调用等，必须是 constexpr 它必须有 constexpr 析构    constexpr 修饰函数必须满足以下要求：
 它不能是 virtual 修饰的(直到 C++20) 它不能是 coroutine 协程(直到 C++20) 它的返回类型（如果有的话）必须是 LiteralType 所有参数必须是 LiteralType    class Test{ public: int x = 10; }; int main() { constexpr Test t; // const  cout &amp;lt;&amp;lt; typeid(t.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 std::function</title>
      <link>https://874656645.github.io/posts/169-c&#43;&#43;11-function/</link>
      <pubDate>Fri, 08 Apr 2022 16:06:06 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/169-c&#43;&#43;11-function/</guid>
      <description>包装指定调用标签（如 double(double) 返回值类型为 double，参数也是 double 类型）的函数； 替代以前的函数指针、函数对象和 lambda 表达式； 类模板 std::function 是一个通用的多态函数包装器。 function 的实例可以存储、复制和调用任何 CopyConstructible Callable 目标：  函数 lambda 表达式 std::bind 表达式 函数对象 指向成员函数的指针 指向成员属性的指针   可以减少生成的模板函数实例化代码的数量，缩小可执行文件的大小；  参考：
std::function</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 std::mem_fn</title>
      <link>https://874656645.github.io/posts/168-c&#43;&#43;11-mem_fn/</link>
      <pubDate>Fri, 08 Apr 2022 10:20:07 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/168-c&#43;&#43;11-mem_fn/</guid>
      <description></description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 std::reference_wrapper</title>
      <link>https://874656645.github.io/posts/167-c&#43;&#43;11-reference_wrapper/</link>
      <pubDate>Thu, 07 Apr 2022 13:43:10 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/167-c&#43;&#43;11-reference_wrapper/</guid>
      <description>创建一个对象或函数的引用，对象必须是 可复制(CopyConstructible)、可赋值(CopyAssignable) 的。
  它经常被用作在标准容器(如 std::vector )中存储引用的机制，而标准容器通常不能保存引用。
  辅助函数 std::ref 与 std::cref 常用于生成 std::reference_wrapper 对象。
  std::reference_wrapper 也用于按引用传递参数给 std::bind 或 std::thread 的构造函数。
  能隐式转换成 T&amp;amp;。
    在 vector 中存储引用类型：
#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;random&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;algorithm&amp;gt; int main() { std::list&amp;lt;int&amp;gt; l(10); std::iota(l.begin(), l.end(), -4); // 从 -4 开始，逐个 +1  std::vector&amp;lt;std::reference_wrapper&amp;lt;int&amp;gt;&amp;gt; v(l.begin(), l.end()); // 不能在 list 上用 shuffle （要求随机访问），但能在 vector 上使用它  std::shuffle(v.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 std::ref, std::cref 与 std::bind</title>
      <link>https://874656645.github.io/posts/166-c&#43;&#43;11-refcref-%E4%B8%8E-bind/</link>
      <pubDate>Thu, 07 Apr 2022 10:40:34 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/166-c&#43;&#43;11-refcref-%E4%B8%8E-bind/</guid>
      <description>函数模板 ref 与 cref 是生成 std::reference_wrapper 类型对象的帮助函数，主要是与 std::bind 一起使用，默认情况下，std::bind 无法使用变量引用传递，即使原来的函数形参是引用类型的
void f(int&amp;amp; n1, int&amp;amp; n2, const int&amp;amp; n3) { std::cout &amp;lt;&amp;lt; &amp;#34;In function: &amp;#34; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; ++n1; // 增加存储于函数对象的 n1 副本  ++n2; // 增加 main() 的 n2  // ++n3; // 编译错误 error: increment of read-only reference ‘n3’ } int main() { int n1 = 1, n2 = 2, n3 = 3; // 函数对象 bound_f  // 默认会将此时变量值的副本做为函数对象的参数（函数参数特例化）  std::function&amp;lt;void()&amp;gt; bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3)); n1 = 10; n2 = 11; n3 = 12; std::cout &amp;lt;&amp;lt; &amp;#34;Before function: &amp;#34; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; bound_f(); std::cout &amp;lt;&amp;lt; &amp;#34;After function: &amp;#34; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } 输出：</description>
    </item>
    
    <item>
      <title>数据结构与算法——队列的应用</title>
      <link>https://874656645.github.io/posts/165-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Wed, 06 Apr 2022 08:56:06 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/165-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>一、队列的应用   只要满足先来先服务特性的应用均可采用队列作为其数据组织方式或中间数据结构
 调度或缓冲  消息缓冲器 邮件缓冲器 计算机硬设备之间的通信也需要队列作为数据缓冲 操作系统的资源管理   宽度优先搜索    广度优先搜索：搜索该步的所有可能状态，再进一步考虑后面的各种情况；（队列应用）
 树的层次遍历    深度优先搜索：沿某一状态走下去，不行再回头。（栈应用）
 树的先序、中序、后续遍历    二、农夫过河问题   问题抽象：
 “人狼羊菜”乘船过河 只有人能撑船，船只有两个位置（包括人） 狼羊、羊菜不能在没有人时共处    数据抽象：
 对每个角色的位置进行描述，农夫、狼、羊和菜，四个目标依次各用一位，目标在起始岸位置：0，目标岸：1。如 0110 表示农夫、白菜在起始岸，而狼、羊在目标岸（此状态为不安全状态） 用整数 status 表示上述四位二进制描述的状态，如整数 0x08 表示的状态 1000，整数 0x0F 表示的状态 1111 如何从上述状态中得到每个角色所在位置？  bool farmer(int status){ return ((status &amp;amp; 0x08) != 0); } bool wolf(int status){ return ((status &amp;amp; 0x04) !</description>
    </item>
    
    <item>
      <title>数据结构与算法——队列的实现方式</title>
      <link>https://874656645.github.io/posts/164-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 05 Apr 2022 12:22:44 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/164-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid>
      <description>栈的物理实现有 顺序队列 和 链式队列
一、顺序队列 用向量存储队列元素，用两个变量分别指向队列的前端(front)和尾端(rear)
 关键是如何防止假溢出    队列溢出
 上溢 下溢 假溢出：当 rear = mSize-1 时，再作插入运算就会产生溢出，如果这时队列的前端还有许多空位置，这种现象称为假溢出    循环队列
 为了解决假溢出的问题，需要采用循环队列的方式： % mSize 另外一个问题就是如何区分空队列还是满队列？空一个队列空间，空队列状态时，令 front = rear，若 (rear + 1) % mSize == front，我们认为此时队列已满，但实际上 rear 指向的空间并没有被利用    循环队列类定义
  template &amp;lt;class T&amp;gt; class arrQueue: public Queue&amp;lt;T&amp;gt; { private: int mSize; // 存放队列的数组的大小  int front; // 表示队头所在位置的下标  int rear; // 表示待入队元素所在位置的下标  T *qu; // 存放类型为T的队列元素的数组 public: // 队列的运算集  arrQueue(int size) { // 创建队列的实例  mSize = size + 1; // 浪费一个存储空间，以区别队列空和队列满  qu = new T[mSize]; front = rear = 0; } ~arrQueue() { // 消除该实例，并释放其空间  delete[] qu; } } // 入队操作 template&amp;lt;class T&amp;gt; bool arrQueue&amp;lt;T&amp;gt; :: enQueue(const T item) { // item入队，插入队尾  if (((rear + 1 ) % mSize) == front) { cout &amp;lt;&amp;lt; &amp;#34;队列已满，溢出&amp;#34; &amp;lt;&amp;lt; endl; return false; } qu[rear] = item; rear = (rear + 1) % mSize; // 循环后继  return true; } // 出队操作 bool arrQueue&amp;lt;T&amp;gt; :: deQueue(T&amp;amp; item) { // 返回队头元素并从队列中删除  if ( front == rear) { cout &amp;lt;&amp;lt; &amp;#34;队列为空&amp;#34; &amp;lt;&amp;lt; endl; return false; } item = qu[front]; front = (front + 1) % mSize; // 这里并没有真的删除队列空间的元素，而是把头指针循环后移  return true; } 二、链式队列   用单链表方式存储，队列中每个元素对于链表中的一个结点</description>
    </item>
    
    <item>
      <title>数据结构与算法——队列</title>
      <link>https://874656645.github.io/posts/163-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/</link>
      <pubDate>Tue, 05 Apr 2022 09:03:06 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/163-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/</guid>
      <description>一、队列   队列特点
 访问受限的线性表 先进先出 插入在一端进行，删除在另一端进行    主要元素
 队头 队尾    主要操作
 入队列 出队列 取队首元素 判断队列是否为空    二、队列的抽象数据类型 template &amp;lt;class T&amp;gt; class Queue { // 队列的运算集 public: // 变为空队列  void clear(); // 将item插入队尾，成功则返回真，否则返回假  bool enQueue(const T item); // 返回队头元素并将其从队列中删除，成功则返回真  bool deQueue(T &amp;amp; item); // 返回队头元素，但不删除，成功则返回真  bool getFront(T &amp;amp; item); // 返回真，若队列已空  bool isEmpty(); // 返回真，若队列已满  bool isFull(); }; 三、队列的实现方式 队列的物理实现又分为顺序队列和链式队列</description>
    </item>
    
    <item>
      <title>数据结构与算法——栈的应用</title>
      <link>https://874656645.github.io/posts/162-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Mon, 04 Apr 2022 14:12:42 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/162-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>栈的特点是后进先出，所以常用来处理具有递归结构的数据
 深度优先搜索 表达式求值 子程序 / 函数调用的管理 消除递归    表达式的递归定义
 基本符号集：${0，1，…，9，+，-，*，/，（，）}$ 语法成分集：{&amp;lt;表达式&amp;gt; , &amp;lt;项&amp;gt; , &amp;lt;因子&amp;gt; , &amp;lt;常数&amp;gt;, &amp;lt;数字&amp;gt; } 中缀表达式：$23\ +\ (34\ *\ 45)\ /\ (5\ +\ 6\ +\ 7)$  后缀表达式：$23\ 34\ 45\ *\ 5\ 6\ +\ 7\ +\ /\ +$
    中缀表达式
 运算符在中间 需要括号改变优先级  例如：$4\ *\ x\ *\ (2\ *\ x\ +\ a)\ –\ c$
  后缀表达式</description>
    </item>
    
    <item>
      <title>数据结构与算法——栈的实现方式</title>
      <link>https://874656645.github.io/posts/161-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sun, 03 Apr 2022 20:03:03 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/161-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid>
      <description>栈的物理实现有 顺序栈 和 链式栈
一、顺序栈（Array-based Stack）  使用向量实现，本质上是顺序表的简化版  栈有固定大小   关键是确定哪一端作为栈顶 注意上溢、下溢问题  类定义：
template &amp;lt;class T&amp;gt; class arrStack : public Stack &amp;lt;T&amp;gt; { private: // 栈的顺序存储  int mSize; // 栈中最多可存放的元素个数  int top; // 栈顶位置，应小于mSize  T *st; // 存放栈元素的数组 public: // 栈的运算的顺序实现  arrStack(int size) { // 创建一个给定长度的顺序栈实例  mSize = size; top = -1; st = new T[mSize]; } arrStack() { // 创建一个顺序栈的实例  top = -1; } ~arrStack() { delete [] st; } void clear() { top = -1; } // 清空栈 }; bool arrStack&amp;lt;T&amp;gt;::push(const T item) { // 入栈  if (top == mSize-1) { // 栈已满  cout &amp;lt;&amp;lt; &amp;#34;栈满溢出&amp;#34; &amp;lt;&amp;lt; endl; return false; } else { // 新元素入栈并修改栈顶指针  st[++top] = item; return true; } } bool arrStack&amp;lt;T&amp;gt;::pop(T&amp;amp; item) { // 出栈  if (top == -1) { // 栈为空  cout &amp;lt;&amp;lt; &amp;#34;栈为空，不能执行出栈操作&amp;#34;&amp;lt;&amp;lt; endl; return false; } else { item = st[top--]; // 返回栈顶，并缩减1  return true; } } 二、链式栈（Linked Stack）  用单链表方式存储，其中指针的方向是从栈顶向下链接 理论上没有大小限制  类定义：</description>
    </item>
    
    <item>
      <title>数据结构与算法——栈</title>
      <link>https://874656645.github.io/posts/160-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88/</link>
      <pubDate>Thu, 31 Mar 2022 22:04:28 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/160-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88/</guid>
      <description>一、栈  后进先出  是一种限制访问端口的线性表   主要操作  进栈（push） 出栈（pop）   应用  表达式求值（中缀表达式、后缀表达式） 消除递归 深度优先搜索（树、图）    二、栈的抽象数据类型 template &amp;lt;class T&amp;gt; class Stack { public: // 栈的运算集  void clear(); // 变为空栈  bool push(const T item); // item入栈，成功返回真，否则假  bool pop(T&amp;amp; item); // 返回栈顶内容并弹出，成功返回真，否则假  bool top(T&amp;amp; item); // 返回栈顶但不弹出，成功返回真，否则假  bool isEmpty(); // 若栈已空返回真  bool isFull(); // 若栈已满返回真 }; 三、思考题   若入栈顺序为 1,2,3,4 的话，则出栈的顺序可以有哪些?</description>
    </item>
    
    <item>
      <title>Emscripten——使用 WebIDL Binder 绑定 C&#43;&#43; 代码</title>
      <link>https://874656645.github.io/posts/159-emscripten-%E4%BD%BF%E7%94%A8-webidl-binder-%E7%BB%91%E5%AE%9A-c&#43;&#43;-%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Tue, 29 Mar 2022 11:00:18 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/159-emscripten-%E4%BD%BF%E7%94%A8-webidl-binder-%E7%BB%91%E5%AE%9A-c&#43;&#43;-%E4%BB%A3%E7%A0%81/</guid>
      <description>WebIDL Binder 提供一种简单、轻量级的方法来绑定 C++ 代码。
WebIDL Binder 使用 WebIDL 定义了一种 接口语言 来把 C++ 和 JavaScript 粘合在一起。
该绑定器支持可以用 WebIDL 表达的 c++ 类型的子集。这个子集对于大多数情况来说已经足够了。
接下来，通过一个简单的例子来看一下绑定的流程，使用 WebIDL Binder 进行绑定的过程分为三个阶段：
 创建一个 WebIDL 文件，用来描述 C++ 接口； 使用绑定器生成 C++ 和 JavaScript 的胶水代码； 使用 EMScripten 编译此胶水代码；  第一步：创建 WebIDL 接口文件 创建一个描述将要绑定的 C++ 类型的 WebIDL 接口文件。该文件将复制 C++ 头文件中的一些信息。比如，我们想绑定下面的 C++ 类（my_classes.h）：
class Foo { public: int getVal(); void setVal(int v); private: int m_val{0}; }; class Bar { public: Bar(long val); ~Bar(); void doSomething(); private: int m_val; }; IDL 接口文件就可以写成下面的形式（my_classes.</description>
    </item>
    
    <item>
      <title>Emscripten——C&#43;&#43; 调用 Js 回调函数</title>
      <link>https://874656645.github.io/posts/158-emscripten-c&#43;&#43;-%E8%B0%83%E7%94%A8-js-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 26 Mar 2022 10:34:44 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/158-emscripten-c&#43;&#43;-%E8%B0%83%E7%94%A8-js-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid>
      <description>WASM 调用 js 代码 Emscripten 提供了两种方式，用于从 C/C++ 调用 JavaScript 的方法：
 使用 emscripten_run_script() 运行脚本 编写 inline JavaScript。    最直接但稍微慢的方式是使用 emscripten_run_script()。这有效地使用 eval() 在 C/C++ 中运行指定的 JavaScript 代码。例如，调用浏览器的 alert() 函数，例如下面的代码：
int EMSCRIPTEN_KEEPALIVE runScript(){ emscripten_run_script(&amp;#34;alert(&amp;#39;hi&amp;#39;)&amp;#34;); emscripten_run_script(&amp;#34;console.log(&amp;#39;hello world!&amp;#39;)&amp;#34;); return 0; }   从 C 中调用 JavaScript 接口的一种更快的方法是编写 inline JavaScript，使用 EM_JS() 或 EM_ASM() (以及其它相关的宏)。
  EM_JS 是在 C 文件中声明一个 JavaScript 函数，使用方法参考这里。
#include &amp;lt;emscripten.h&amp;gt; EM_JS(void, myAlert, (), { alert(&amp;#39;hello world!&amp;#39;); throw &amp;#39;all done&amp;#39;; // exception }); EM_JS(void, take_args, (int x, float y), { console.</description>
    </item>
    
    <item>
      <title>Emscripten——js 调用 C&#43;&#43; 接口</title>
      <link>https://874656645.github.io/posts/157-emscripten-js-%E8%B0%83%E7%94%A8-c&#43;&#43;-%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Fri, 25 Mar 2022 10:06:38 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/157-emscripten-js-%E8%B0%83%E7%94%A8-c&#43;&#43;-%E6%8E%A5%E5%8F%A3/</guid>
      <description>Emscripten 提供了许多方法来在 JavaScript 和编译后的 C 或 c++ 之间连接和交互，我们先来看看 js 调用 WASM 的情况。
一、使用 ccall 或 cwrap callall() 调用带有指定参数的编译过的 C 函数 并返回结果，而 cwrap() 封装了编译过的 C 函数并返回一个可以正常调用的 JavaScript 函数。因此，如果计划多次调用一个编译后的函数，cwrap() 会更有用。
例如下面的 C main.cpp 文件：
#include &amp;lt;math.h&amp;gt; extern &amp;#34;C&amp;#34; { int int_sqrt(int x) { return sqrt(x); } } 使用下面的命令进行编译：
emcc main.cpp -o function.html -s EXPORTED_FUNCTIONS=_int_sqrt -s EXPORTED_RUNTIME_METHODS=ccall,cwrap
EXPORTED_FUNCTIONS 告诉编译器哪些函数我们想要导出（不指定的函数会被删掉），EXPORTED_RUNTIME_METHODS 告诉编译器我们需要用到的运行时方法 ccall 和 cwrap，否则这些方法也会被优化掉
编译后就可以在 js 中通过 cwrap 使用了：
int_sqrt = Module.cwrap(&amp;#39;int_sqrt&amp;#39;, &amp;#39;number&amp;#39;, [&amp;#39;number&amp;#39;]) int_sqrt(12) // return 3 int_sqrt(28) // return 5 第一个参数是被 wrap 的 C 函数的名字（没有下划线），第二个参数是函数返回值在类型（如果没有返回值，使用 JavaScript 的 null 类型），第三个参数是一个参数数组（如果没有参数，可以省略）。</description>
    </item>
    
    <item>
      <title>Emscripten——使用 CMake 构建并用 Make 编译</title>
      <link>https://874656645.github.io/posts/156-emscripten-%E4%BD%BF%E7%94%A8-cmake-%E6%9E%84%E5%BB%BA%E5%B9%B6%E7%94%A8-make-%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 24 Mar 2022 17:45:14 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/156-emscripten-%E4%BD%BF%E7%94%A8-cmake-%E6%9E%84%E5%BB%BA%E5%B9%B6%E7%94%A8-make-%E7%BC%96%E8%AF%91/</guid>
      <description>使用 CMake 构建   在源文件目录添加 CMakeList.txt 文件
# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 set(MyTarget hello)project(${MyTarget} VERSION 1.0)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 编译生成.html文件 set(CMAKE_EXECUTABLE_SUFFIX &amp;#34;.html&amp;#34;)# 添加源码文件和生成的目标文件的名称 # file(GLOB_RECURSE SRC_MAIN ./*.cpp) aux_source_directory(./ SRC_MAIN)aux_source_directory(./thirdParty/ SRC_MAIN)add_executable(${MyTarget} ${SRC_MAIN})# add_executable(${MyTarget} main.cpp) # 设置Emscripten的编译链接参数 set_target_properties(${MyTarget} PROPERTIES LINK_FLAGS &amp;#34; \ -s EXIT_RUNTIME=0 \ -gsource-map \ -s EXPORTED_FUNCTIONS=_main,_sayHello1,_jsonParse,_jsonParse1 \ -s EXPORTED_RUNTIME_METHODS=ccall,cwrap,addFunction \ -s NO_DISABLE_EXCEPTION_CATCHING \ &amp;#34;)# 添加第三方库路径 # target_link_directories(${MyTarget} # PUBLIC &amp;#34;${PROJECT_BINARY_DIR}&amp;#34; # ) # 将第三方库与主程序进行链接 # set(LIBS cjson) # target_link_libraries(sample ${LIBS}) # 添加头文件查找路径 target_include_directories(${MyTarget} PUBLIC &amp;#34;${CMAKE_CURRENT_SOURCE_DIR}&amp;#34; )  创建 build 文件夹，并在 build 文件夹内执行命令 emcmake cmake .</description>
    </item>
    
    <item>
      <title>Emscripten——C&#43;&#43; 函数导出</title>
      <link>https://874656645.github.io/posts/155-emscripten-c&#43;&#43;-%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA/</link>
      <pubDate>Thu, 24 Mar 2022 17:31:30 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/155-emscripten-c&#43;&#43;-%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA/</guid>
      <description>导出 C++ 函数到 js 有多种方式：
  方式一：在编译的时候指定
在编译命令中添加 -sEXPORTED_FUNCTIONS 参数，例如：-s EXPORTED_FUNCTIONS=_myFunction,_sayHello1
  方式二：修改 C++ 函数
在 C++ 代码中需要导出的函数声明前添加 EMSCRIPTEN_KEEPALIVE 宏定义
#include &amp;lt;emscripten.h&amp;gt; extern &amp;#34;C&amp;#34; int EMSCRIPTEN_KEEPALIVE myFunction(int argc, char ** argv) { printf(&amp;#34;我的函数已被调用\n&amp;#34;); return 0; } #ifdef __cplusplus extern &amp;#34;C&amp;#34; { #endif  int EMSCRIPTEN_KEEPALIVE sayHello(){ cout &amp;lt;&amp;lt; &amp;#34;hello from sayHello!&amp;#34; &amp;lt;&amp;lt; endl; return 0; } int sayHello1() { Person p; cout &amp;lt;&amp;lt; p.printInfo() &amp;lt;&amp;lt; endl; return 0; } #ifdef __cplusplus } #endif   方式三：WebIDL Binder</description>
    </item>
    
    <item>
      <title>Emscripten——Hello World</title>
      <link>https://874656645.github.io/posts/154-emscripten-hello-world/</link>
      <pubDate>Thu, 24 Mar 2022 17:03:19 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/154-emscripten-hello-world/</guid>
      <description>编译   新建 main.cpp 文件
#include &amp;lt;iostream&amp;gt;using namespace std; int main(){ cout &amp;lt;&amp;lt; &amp;#34;hello world!&amp;#34; &amp;lt;&amp;lt; endl; return 0; }   使用 emcc 或 em++ 编译 C++ 文件
执行命令 em++ main.cpp，会在同级目录下生成 a.out.js 和 a.out.wasm 两个文件。
  使用 node 测试
测试命令 node a.out.js，会在控制台输出 cout 的内容
  使用 html 页面 测试
执行命令 em++ main.cpp -o hello.html，会在同级目录下生成三个文件：
 hello.html：测试网页 hello.js：相关的胶水代码，包括加载 WASM 文件并执行调用等相关逻辑 hello.wasm：编译得到的核心 WebAssembly执行文件
在本地启动一个静态网站服务器，就可以在浏览器中访问生成的网页了    编译带有 调试 信息的测试页面</description>
    </item>
    
    <item>
      <title>Emscripten——安装</title>
      <link>https://874656645.github.io/posts/153-emscripten-%E5%AE%89%E8%A3%85/</link>
      <pubDate>Thu, 24 Mar 2022 16:41:50 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/153-emscripten-%E5%AE%89%E8%A3%85/</guid>
      <description>启用 Linux 环境 这里使用的是 WSL（Windows Subsystem Linux）环境，环境配置参考这里
Linux 安装 Emscripten Download and install
  安装 python3
sudo apt install python3
  安装 git
sudo apt install git
  创建目录并 clone emsdk
sudo git clone https://github.com/emscripten-core/emsdk.git
  更新 emsdk 并激活
cd emsdk git pull # Download and install the latest SDK tools. ./emsdk install latest # Make the &amp;#34;latest&amp;#34; SDK &amp;#34;active&amp;#34; for the current user. (writes .emscripten file) .</description>
    </item>
    
    <item>
      <title>数据结构与算法——连续子数组最大和</title>
      <link>https://874656645.github.io/posts/152-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/</link>
      <pubDate>Sat, 19 Mar 2022 15:35:35 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/152-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/</guid>
      <description>一、暴力算法 $\mathcal{O}(n^3)$ 遍历数组的所有子数组集合，并对其求和，筛选出和的最大值
int maxSumOfSub1(int* array, int length){ int maxSum = 0; int startIndex = 0, endIndex = 0; for(int i = 0; i &amp;lt; length; i++){ for(int j = i; j &amp;lt; length; j++){ int sum = 0; for(int k = i; k &amp;lt;= j; k++) sum += array[k]; if(maxSum &amp;lt; sum){ maxSum = sum; startIndex = i; endIndex = j; } } } cout &amp;lt;&amp;lt; &amp;#34;Begin:&amp;#34; &amp;lt;&amp;lt; startIndex &amp;lt;&amp;lt; &amp;#34; End:&amp;#34; &amp;lt;&amp;lt; endIndex &amp;lt;&amp;lt; &amp;#34; Num:&amp;#34; &amp;lt;&amp;lt; maxSum &amp;lt;&amp;lt; endl; return maxSum; } 二、前缀和 $\mathcal{O}(n^2)$ 先把数组的前 i 项和求出来并将其保存到数组中，然后计算所有子数组集合的和，筛选其中最大的</description>
    </item>
    
    <item>
      <title>数据结构与算法——线性表</title>
      <link>https://874656645.github.io/posts/151-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E8%A1%A8/</link>
      <pubDate>Mon, 14 Mar 2022 21:30:45 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/151-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E8%A1%A8/</guid>
      <description>线性结构  二元组 B = (K, R) , K = {a0, a1, …, an-1 }, R = {r}，其中 r 为前驱后继关系，具有反对称性和传递性 唯一的开始结点（表头）：没有前驱，只有一个唯一的后继 唯一的终止结点（表尾）：没有后继，只有一个唯一的前驱 内部结点：一个唯一的前驱和一个唯一的后继  线性表 线性表简称表，是零个或多个元素的有穷序列
 表目：线性表中的元素 文件：含有大量记录的线性表又称为文件 索引（下标） 表的长度 空表：长度为零的线性表(n=0)  线性表分类   按访问方式划分：
 直接访问型 顺序访问型 目录索引型    按存储方式：
 顺序表（数组） 链表    按操作：
 线性表：不限操作 栈：在同一端操作，在深度优先搜索、递归等算法中有很好的应用 队列：在两端操作，在宽度优先搜索、层次化处理中有很好的应用    顺序表  顺序表俗称向量，是用数组实现的（固定长度的一维数组） 按索引值从小到大存放在一片相邻的连续区域 结构紧凑，存储密度为1（存储密度 = 数据本身所占存储 / 整个数据结构所占存储） 物理存储关系就能表示逻辑关联关系  链表  链表需要指针表示逻辑关联关系，存储效率不如顺序表 有头链表和无头链表 在一些边界处理的时候，要注意头结点（head）和尾结点（tail）的特殊处理  讨论   线性表的分类方法有哪些？各种线性表名称中，哪些跟存储结构相关？哪些跟运算相关？</description>
    </item>
    
    <item>
      <title>数据结构与算法——算法效率与度量</title>
      <link>https://874656645.github.io/posts/150-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E4%B8%8E%E5%BA%A6%E9%87%8F/</link>
      <pubDate>Sun, 13 Mar 2022 16:29:26 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/150-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E4%B8%8E%E5%BA%A6%E9%87%8F/</guid>
      <description>算法的时间和空间性能非常重要
一、算法的渐近分析 当 n 增大到一定值后，其他的常数项和低幂次项都可以忽略，只需确定是在什么量级（线性、n 方、指数级等）
1. 大 $\mathcal{O}$ 表式法 函数增长率上限
2. 大 $\Omega$ 表式法 函数增值率的下限
3. 大 $\Theta$ 表示法 当上、下限相同时则可用 $\Theta$ 表示法
二、增长率曲线 三、数据结构和算法的选择  仔细分析所要解决的问题  特别是求解问题所涉及的数据类型和数据间逻辑关系（问题抽象、数据抽象） 数据结构的初步设计往往先于算法设计   注意数据结构的可扩展性  考虑当输入数据的规模发生改变时，数据结构是否能够适应求解问题的演变和扩展    三、思考题   数据结构的三个要素任何一个发生改变，都是不同的数据结构，请举例讨论
 双向链表和二叉树的存储结构其实是一样的，他们的不同在于逻辑结构。 数组和向量都是线性表，其存储形式不同，成为不同的数据结构。    算法设计目标是什么？
 时间和空间的权衡 易读 易编码 易调试 易维护 易扩展    算法选择的过程？
  要求在时间复杂度 $\mathcal{O}(n)$、空间复杂度 $\mathcal{O}(1)$，使数组元素循环向右移动 K 位
  </description>
    </item>
    
    <item>
      <title>数据结构与算法——算法特性及分类</title>
      <link>https://874656645.github.io/posts/149-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7%E5%8F%8A%E5%88%86%E7%B1%BB/</link>
      <pubDate>Fri, 11 Mar 2022 22:26:22 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/149-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7%E5%8F%8A%E5%88%86%E7%B1%BB/</guid>
      <description>一、问题——算法——程序  问题：一个函数，从输入到输出在一种映射 算法：对特定问题求解过程的描述，是指令的有限序列 程序：算法在计算机程序设计语言中的具体实现  二、算法的特性  通用性：参数化的，能对一类问题进行参数化输入并问题求解 有效性：有限条有效指令组成的指令序列，保证计算结果的正确性 确定性：算法的下一步执行步骤必须明确 有穷性：执行必须在有限步内结束，不能有死循环  三、基本算法分类  穷举法：
遍历每一个元素，比较低效，但是是一种万能的算法；对于一个问题，如果一时想不出好的算法的话，可对小规模数据采用穷举法剖析问题的特性和数据的特性，进而寻求更高效的算法 回溯、搜索：
能进则进，不能进则换，不能换则退，如树和图的遍历 递归分治：
二分查找，以及快速排序、归并排序，都是经典的分治算法思想 贪心法：
其数据具有贪心性质，每次求解的时候都采用当前的最佳解，最终得到最优解，如 Huffman 编码树、最短路径 Dijkstra 算法、最小生成树 Prim 算法 动态规划：
得到小规模问题的最优解，然后在更大规模的时候去组合这些最优解，最后得到全局的最优解，如图的两两结点之间最短路 Floyd 算法。要求具有最优子结构性质以及无后效性，动态规划的子结构有重叠，而递归分治子结构不重叠。  四、“监视哨”顺序检索 设置“监视哨”后，在查找过程中不用判断 i 是否越界，少一次判断，算法的运行效率会更高</description>
    </item>
    
    <item>
      <title>数据结构与算法——数据结构定义</title>
      <link>https://874656645.github.io/posts/148-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Thu, 10 Mar 2022 21:10:53 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/148-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89/</guid>
      <description>一、什么是数据结构   结构：实体 + 关系，比如分子结构，关系图等
  数据结构：按照逻辑关系组织起来的一批数据，按一定的存储方法所把它存储在计算机中，并在这些数据上定义了一个运算的集合
  二、数据的逻辑结构  线性结构
线性表（表、栈、队列、串等） 非线性结构
树（二叉树、Huffman树、二叉检索树等）
图（有向图、无向图等） 图 ⊇ 树 ⊇ 二叉树 ⊇ 线性表  三、数据的存储结构   将逻辑结构的结点映射到内存中，每一个结点都对应一个唯一的连续存储区域
  内存可以看作从低地址到高地址的一个编码的线性结构，可以根据地址立即访问想要访问的内存单元，不需要搜索
  存储结构主要有顺序、链接、索引和散列四种形式
 顺序存储对应于数组 链接存储对应于链表 索引是对数据建立一个索引表，通过这个表有效的找到相应数据的存储地址 散列是一种特殊的索引结构，本身也是一种存储结构，通过关键码的映射关系，在整个散列表中用单位时间快速地找到其存储地址    四、抽象数据类型 ADT（Abstract Data Type）  定义了一组运算的数学模型 与物理存储结构无关 使软件系统建立在数据之上(面向对象)  五、定义抽象数据类型 抽象数据类型就是在逻辑结构上的运算，可以理解为抽象数据结构二元组 &amp;lt;数据对象D, 数据操作P&amp;gt;
先定义逻辑结构，再定义运算
 逻辑结构：数据对象及其关系 运算：数据操作  就像面向对象语言中所定义的类（特别是抽象类），封装了数据成员和函数成员</description>
    </item>
    
    <item>
      <title>数据结构与算法——简介</title>
      <link>https://874656645.github.io/posts/147-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 08 Mar 2022 20:33:08 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/147-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%80%E4%BB%8B/</guid>
      <description>算法 + 数据结构 = 程序   数据结构与算法是程序的灵魂，以问题求解为导向，进行问题抽象、数据抽象、算法抽象，通过有效地组织数据、设计高效的算法、完成高质量的程序，从而解决实际应用的问题。
  流程：问题 =&amp;gt; 数据 =&amp;gt; 算法
  理论（离散数学、概率统计、图论等） =&amp;gt; 抽象（问题抽象、数据抽象、算法抽象等面向对象思想） =&amp;gt; 设计（实现的某种具体编程语言）
  逻辑抽象 + 运算抽象 =&amp;gt; ADT
  运算 + 存储 =&amp;gt; 算法分析（时间和空间复杂度）
  问题抽象：分析和抽象任务需求，建立问题模型
  数据抽象：确定恰当的数据结构表示数学模型
  算法抽象：在数据模型的基础上设计合适的算法
  </description>
    </item>
    
    <item>
      <title>CMake 打包 Debug 和 Release</title>
      <link>https://874656645.github.io/posts/146-cmake-%E6%89%93%E5%8C%85-debug-%E5%92%8C-release/</link>
      <pubDate>Sun, 06 Mar 2022 14:41:05 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/146-cmake-%E6%89%93%E5%8C%85-debug-%E5%92%8C-release/</guid>
      <description>注意：这个对于单配置生成器是有效的，对于多配置生成器(例如Visual Studio)是无效的。因此在 Windows 平台，通过 MSYS 环境进行演示。
默认情况下（Linux平台），CMake 的一个构建目录(build dir)只包含一个配置，可以是 Debug、Release、MinSizeRel 或 RelWithDebInfo。但是，可以通过设置 CPack 来绑定多个构建目录，并构造一个包含同一项目的多个配置的发行包。
首先，我们希望确保 Debug 和 Release 构建对将要安装的可执行文件和库使用不同的名称。让我们使用 d 作为 Debug 可执行文件和库的后缀。在顶层 CMakeLists.txt 的开始部分添加 CMAKE_DEBUG_POSTFIX
# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 设置 CMAKE_DEBUG_POSTFIX，指定后缀为 d set(CMAKE_DEBUG_POSTFIX d)然后在 Tutorial 可执行文件上添加属性 DEBUG_POSTFIX：
# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# And the DEBUG_POSTFIX property on the tutorial executable set_target_properties(Tutorial PROPERTIES DEBUG_POSTFIX ${CMAKE_DEBUG_POSTFIX})为 MathFunctions 库添加版本号信息，在 Mathfunctions/CMakelists.txt 中，设置 VERSION 和 SOVERSION 属性：
# add the library that runs add_library(MathFunctions MathFunctions.</description>
    </item>
    
    <item>
      <title>CMake 添加导出配置</title>
      <link>https://874656645.github.io/posts/145-cmake-%E6%B7%BB%E5%8A%A0%E5%AF%BC%E5%87%BA%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 06 Mar 2022 10:37:40 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/145-cmake-%E6%B7%BB%E5%8A%A0%E5%AF%BC%E5%87%BA%E9%85%8D%E7%BD%AE/</guid>
      <description>在安装和测试过程中，我们增加了 CMake 安装库文件和项目依赖的头文件(bin、lib、include)的能力。在打包可安装程序的过程中，我们增加了打包这些信息的能力，这样它就可以分发给其他人使用
接下来是如何添加必要的信息，以便其他 CMake 项目可以使用我们的项目，无论是在构建目录、本地安装还是打包的时候
第一步是更新我们的 install(TARGETS) 命令，不仅指定 DESTINATION，还指定 EXPORT。EXPORT 关键字生成一个 CMake 文件，其中包含从安装树导入安装命令中列出的所有目标的代码。
修改 MathFunctions/CMakeLists.txt 文件代码：
# install rules set(installable_libs MathFunctions tutorial_compiler_flags)if(TARGET SqrtLibrary) list(APPEND installable_libs SqrtLibrary)endif()install(TARGETS ${installable_libs} EXPORT MathFunctionsTargets DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)第二步我们还需要显式地安装生成的 MathFunctionsTargets.cmake 文件。在顶层的 CMakeLists.txt 文件底部添加如下代码：
install(EXPORT MathFunctionsTargets FILE MathFunctionsTargets.cmake DESTINATION lib/cmake/MathFunctions )此时构建会有下面的错误：
这是因为在生成导出信息期间，它将导出内在绑定到当前计算机项目的路径，在其他计算机上路径无效。
第三步更新 MathFunctions/CMakeLists.txt 中的 target_include_directories() 用来设置在 build 时和在 install/package 时需要使用不同的 INTERFACE locations。
# 将当前二进制目录添加到包含目录列表中 target_include_directories(MathFunctions # INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}  INTERFACE $&amp;lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}&amp;gt; $&amp;lt;INSTALL_INTERFACE:include&amp;gt; )第四步我们还需要生成一个 MathFunctionsConfig.cmake，这样 CMake 的 find_package() 命令就可以找到我们的项目。在顶层的项目目录添加 Config.</description>
    </item>
    
    <item>
      <title>CMake 添加生成器表达式</title>
      <link>https://874656645.github.io/posts/144-cmake-%E6%B7%BB%E5%8A%A0%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sun, 06 Mar 2022 07:42:05 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/144-cmake-%E6%B7%BB%E5%8A%A0%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>target_compile_features target_compile_options COMPILE_LANG_AND_ID BUILD_INTERFACE  生成器表达式(Generator expressions)允许在许多目标属性的上下文中使用，比如 LINK LIBRARIES、INCLUDE DIRECTORIES、COMPILE DEFINITIONS 等。当使用命令来填充这些属性时，它们也可以被使用，例如 target_link_libraries()、target_include_directories()、target_compile_definitions() 等。
生成器表达式可以用于启用条件链接、编译时使用的条件定义、条件包含目录等。这些条件可能基于构建配置、目标属性、平台信息或任何其他可查询的信息。
有不同类型的生成器表达式，包括逻辑表达式、信息表达式和输出表达式。
逻辑表达式用于创建条件输出。基本的表达式是 0 和 1 表达式。
生成器表达式的一个常见用法是有条件地添加编译器标志，比如那些用于语言级别或警告的标志。一个很好的模式是将该信息关联到一个 INTERFACE 目标，从而允许该信息传播。让我们先构造一个接口目标，并指定所需的 c++ 标准 11，而不是使用 CMAKE CXX 标准。
# 指定 C++ 标准 # set(CMAKE_CXX_STANDARD 11) # set(CMAKE_CXX_STANDARD_REQUIRED True) # 将上面的代码替换为 add_library(tutorial_compiler_flags INTERFACE)target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)接下来，我们为项目添加所需的编译器警告标志。由于警告标志因编译器的不同而不同，我们使用 COMPILE_LANG_AND_ID 生成器表达式来控制给定语言和一组编译器 ID 要应用哪些标志（注：将要使用的生成器表达式是在 3.15 中引入的，所以要更新 cmake_minimum_required 的版本为 3.15），如下所示：
set(gcc_like_cxx &amp;#34;$&amp;lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC&amp;gt;&amp;#34;)set(msvc_cxx &amp;#34;$&amp;lt;COMPILE_LANG_AND_ID:CXX,MSVC&amp;gt;&amp;#34;)target_compile_options(tutorial_compiler_flags INTERFACE &amp;#34;$&amp;lt;${gcc_like_cxx}:$&amp;lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused&amp;gt;&amp;gt;&amp;#34; &amp;#34;$&amp;lt;${msvc_cxx}:$&amp;lt;BUILD_INTERFACE:-W3&amp;gt;&amp;gt;&amp;#34; )我们看到警告标志被封装在一个 BUILD_INTERFACE 条件中。这样做是为了让我们已安装项目的使用者不会继承我们的警告标志。
修改 Mathfunctions/cmakelists.txt，以便所有编译目标都有一个 target_link_libraries() 调用我们设置的编译条件标识 tutorial_compiler_flags。</description>
    </item>
    
    <item>
      <title>CMake 静态库和动态库混合使用</title>
      <link>https://874656645.github.io/posts/143-cmake-%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 05 Mar 2022 19:28:43 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/143-cmake-%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/</guid>
      <description>将原来的 静态库 MathFunctions拆分为动态库 MathFunctions.dll 和静态库 SqrtLibrary.lib 两个库。MathFunctions.dll 动态库会使用 SqrtLibrary.lib 静态库。 BUILD_SHARED_LIBS  在顶层的 CMakeLists.txt 文件中添加 BUILD_SHARED_LIBS，如果这个标记存在且为真，则将导致所有库都被构建为共享库，除非该库被显式地设置为静态库。这个变量通常作为 option() 添加到项目中，以便项目的每个用户可以决定他们是要使用共享库还是静态库构建项目。
顶层的 CMakeLists.txt 文件修改如下：
# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.2)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# control where the static and shared libraries are built so that on windows # we don&amp;#39;t need to tinker with the path to run the executable # 指定静态库和动态库的生成路径 set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY &amp;#34;${PROJECT_BINARY_DIR}&amp;#34;)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY &amp;#34;${PROJECT_BINARY_DIR}&amp;#34;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY &amp;#34;${PROJECT_BINARY_DIR}&amp;#34;)# 生成共享库选项 option(BUILD_SHARED_LIBS &amp;#34;Build using shared libraries&amp;#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.</description>
    </item>
    
    <item>
      <title>CMake 添加对测试仪表板的支持</title>
      <link>https://874656645.github.io/posts/142-cmake-%E6%B7%BB%E5%8A%A0%E5%AF%B9%E6%B5%8B%E8%AF%95%E4%BB%AA%E8%A1%A8%E6%9D%BF%E7%9A%84%E6%94%AF%E6%8C%81/</link>
      <pubDate>Thu, 03 Mar 2022 20:12:47 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/142-cmake-%E6%B7%BB%E5%8A%A0%E5%AF%B9%E6%B5%8B%E8%AF%95%E4%BB%AA%E8%A1%A8%E6%9D%BF%E7%9A%84%E6%94%AF%E6%8C%81/</guid>
      <description>向仪表板提交测试结果 1. 修改最上层的 CMakeLists.txt 文件 将 enable_testing() 替换为 include(CTest)，CTest 模块会自动调用 enable_testing()
# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH &amp;#34;Use tutorial provided math implementation&amp;#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # &amp;#34;${PROJECT_BINARY_DIR}&amp;#34; # &amp;#34;${PROJECT_SOURCE_DIR}/MathFunctions&amp;#34; # ) target_include_directories(Tutorial PUBLIC &amp;#34;${PROJECT_BINARY_DIR}&amp;#34; )## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES &amp;#34;${PROJECT_BINARY_DIR}/TutorialConfig.</description>
    </item>
    
    <item>
      <title>CMake 打包可安装程序</title>
      <link>https://874656645.github.io/posts/141-cmake-%E6%89%93%E5%8C%85%E5%8F%AF%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Tue, 01 Mar 2022 21:45:45 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/141-cmake-%E6%89%93%E5%8C%85%E5%8F%AF%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F/</guid>
      <description>可以在各种平台上提供二进制和源代码发行版。 InstallRequiredSystemLibraries CPack  一、需要在顶层 CMakeLists.txt 文件的底部添加几行代码 # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH &amp;#34;Use tutorial provided math implementation&amp;#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # &amp;#34;${PROJECT_BINARY_DIR}&amp;#34; # &amp;#34;${PROJECT_SOURCE_DIR}/MathFunctions&amp;#34; # ) target_include_directories(Tutorial PUBLIC &amp;#34;${PROJECT_BINARY_DIR}&amp;#34; )## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES &amp;#34;${PROJECT_BINARY_DIR}/TutorialConfig.</description>
    </item>
    
    <item>
      <title>CMake 添加自定义命令和生成文件</title>
      <link>https://874656645.github.io/posts/140-cmake-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E5%92%8C%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 28 Feb 2022 21:13:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/140-cmake-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E5%92%8C%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/</guid>
      <description>add_custom_command  MathFunctions 工程的 CMakeLists.txt # 添加可执行程序 MakeTable add_executable(MakeTable MakeTable.cxx)# 添加一个自定义命令，指定如何通过运行 MakeTable 生成 Table.h add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable )# 将生成的 Table.h 添加到库 MathFunctions 的源代码列表 add_library(MathFunctions mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h )# 将当前二进制目录添加到包含目录列表中，这样 Table.h 才能被 mysqrt.cxx 找到并包含 target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} PRIVATE ${CMAKE_CURRENT_BINARY_DIR} )install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)install(FILES ${CMAKE_CURRENT_BINARY_DIR}/Table.h DESTINATION include)生成的 Table.h 文件 double sqrtTable[] = { 0, 1, 1.41421, 1.73205, 2, 2.23607, 2.44949, 2.64575, 2.82843, 3, 0}; Tutorial.</description>
    </item>
    
    <item>
      <title>CMake 添加系统自检</title>
      <link>https://874656645.github.io/posts/139-cmake-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%87%AA%E6%A3%80/</link>
      <pubDate>Sun, 27 Feb 2022 21:46:10 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/139-cmake-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%87%AA%E6%A3%80/</guid>
      <description>CheckSymbolExists: 考虑在项目中添加一些代码，这些代码依赖于目标平台可能没有的特性 target_compile_definitions  add_library(MathFunctions mysqrt.cxx)target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})# does this system provide the log and exp functions? include(CheckSymbolExists)check_symbol_exists(log &amp;#34;math.h&amp;#34; HAVE_LOG)check_symbol_exists(exp &amp;#34;math.h&amp;#34; HAVE_EXP)# 如果平台中没有找到 log 和 exp，我们需要链接到 m 库 if(NOT (HAVE_LOG AND HAVE_EXP)) unset(HAVE_LOG CACHE) unset(HAVE_EXP CACHE) # 设置 m 库并再次尝试  set(CMAKE_REQUIRED_LIBRARIES &amp;#34;m&amp;#34;) check_symbol_exists(log &amp;#34;math.h&amp;#34; HAVE_LOG) check_symbol_exists(exp &amp;#34;math.h&amp;#34; HAVE_EXP) if(HAVE_LOG AND HAVE_EXP) target_link_libraries(MathFunctions PRIVATE m) endif()endif()# 如果可用，使用 target_compile_definitions() 指定 HAVE LOG 和 HAVE EXP 作为私有编译定义 # 在项目配置 预处理器定义中添加 HAVE LOG 和 HAVE EXP 两个宏定义 if(HAVE_LOG AND HAVE_EXP) target_compile_definitions(MathFunctions PRIVATE &amp;#34;HAVE_LOG&amp;#34; &amp;#34;HAVE_EXP&amp;#34;)endif()# install install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.</description>
    </item>
    
    <item>
      <title>CMake 安装和测试</title>
      <link>https://874656645.github.io/posts/138-cmake-%E5%AE%89%E8%A3%85%E5%92%8C%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Sun, 27 Feb 2022 15:56:29 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/138-cmake-%E5%AE%89%E8%A3%85%E5%92%8C%E6%B5%8B%E8%AF%95/</guid>
      <description>Install Rules 在库的 CMakeLists.txt 文件末尾添加 install
add_library(MathFunctions mysqrt.cxx)target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)在顶层 CMakeLists.txt 的末尾添加
... ... ## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES &amp;#34;${PROJECT_BINARY_DIR}/TutorialConfig.h&amp;#34; DESTINATION include )Testing Support 在顶层 CMakeLists.txt 的末尾添加
... ... ## 测试 enable_testing()# does the application run add_test(NAME Runs COMMAND Tutorial 25)# does the usage message work? add_test(NAME Usage COMMAND Tutorial)# 设置校验信息 set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION &amp;#34;Usage:.*number&amp;#34; )# define a function to simplify adding tests function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction()# do a bunch of result based tests do_test(Tutorial 4 &amp;#34;4 is 2&amp;#34;)do_test(Tutorial 9 &amp;#34;9 is 3&amp;#34;)do_test(Tutorial 5 &amp;#34;5 is 2.</description>
    </item>
    
    <item>
      <title>CMake 添加依赖库和使用条件</title>
      <link>https://874656645.github.io/posts/137-cmake-%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%BA%93%E5%92%8C%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6/</link>
      <pubDate>Sun, 27 Feb 2022 14:30:39 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/137-cmake-%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%BA%93%E5%92%8C%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6/</guid>
      <description>添加依赖库和使用条件 CMakeLists.txt  注意编译选项、生成配置文件和条件编译三部分的顺序  # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH &amp;#34;Use tutorial provided math implementation&amp;#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions) list(APPEND EXTRA_INCLUDES &amp;#34;${PROJECT_SOURCE_DIR}/MathFunctions&amp;#34;)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # &amp;#34;${PROJECT_BINARY_DIR}&amp;#34; # &amp;#34;${PROJECT_SOURCE_DIR}/MathFunctions&amp;#34; # ) target_include_directories(Tutorial PUBLIC &amp;#34;${PROJECT_BINARY_DIR}&amp;#34; ${EXTRA_INCLUDES} )子模块（库）的 CMakeLists.txt 文件 add_library(MathFunctions mysqrt.</description>
    </item>
    
    <item>
      <title>CMake 配置文件传递设置信息</title>
      <link>https://874656645.github.io/posts/136-cmake-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92%E8%AE%BE%E7%BD%AE%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Sat, 26 Feb 2022 21:39:32 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/136-cmake-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92%E8%AE%BE%E7%BD%AE%E4%BF%A1%E6%81%AF/</guid>
      <description>CMakeList # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 2.0)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 生成一个头文件，传递 CMake 的一些设置到源代码 configue_file(TutorialConfig.h.in TutorialConfig.h)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# 添加头文件查找路径 target_include_directories(Tutorial PUBLIC &amp;#34;$(PROJECT_BINARY_DIR)&amp;#34;)TutorialConfig.h.in // #define TUTORIAL_VERSION_MAJOR @Tutorial_VERSION_MAJOR@ #define TUTORIAL_VERSION_MINOR @Tutorial_VERSION_MINOR@ </description>
    </item>
    
    <item>
      <title>CMake 使用</title>
      <link>https://874656645.github.io/posts/135-cmake-%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 26 Feb 2022 20:03:44 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/135-cmake-%E4%BD%BF%E7%94%A8/</guid>
      <description>一、CMakeLists.txt 文件示例 # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 1.0)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)二、CMake 相关命令   cmake .. 含有 CMakeLists.txt 文件的路径，根据 CMakeLists.txt 文件构建对应的工程；
  cmake .. -DUSE_MYMATH=OFF 将 CMake 编译选项 USE_MYMATH 设置为关闭状态，并构建工程
  cmake .. -DCMAKE_BUILD_TYPE=Release 在Linux中设定 Release 版本，可设置的类型有 Debug、MinSizeRel、Release、RelWithDebInfo
  指定编译工具为 MSVC（不同的 CMake 版本，命令写法不同）：
cmake -G &amp;#34;Visual Studio 14 2015 Win64&amp;#34; cmake -G &amp;#34;Visual Studio 16 2019&amp;#34; -A x64 cmake -G &amp;#34;Visual Studio 16 2019&amp;#34; -A Win32   在 Windows 中使用 MinGW</description>
    </item>
    
    <item>
      <title>哈希法与冲突处理</title>
      <link>https://874656645.github.io/posts/134-%E5%93%88%E5%B8%8C%E6%B3%95%E4%B8%8E%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 25 Feb 2022 17:23:49 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/134-%E5%93%88%E5%B8%8C%E6%B3%95%E4%B8%8E%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/</guid>
      <description>哈希表及处理冲突的方法
一、哈希法与哈希表  哈希法又称散列法、杂凑法以及关键字地址计算法等，相应的表称为哈希表。 这种方法的基本思想是：首先在元素的关键字 k 和元素的存储位置 p 之间建立一个对应关系 f，使得 p = f(k)，f 称为哈希函数。 创建哈希表时，把关键字为 k 的元素直接存入地址为 f(k) 的单元；以后当查找关键字为 k 的元素时，再利用哈希函数计算出该元素的存储位置 p=f(k)，从而达到按关键字直接存取元素的目的。  二、冲突 当关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，即 k1 ≠ k2，但 f(k1) = f(k2)，这种现象称为冲突，此时称 k1 和 k2 为同义词。
三、哈希函数构造方法 构造哈希函数的原则是：
 函数本身便于计算； 计算出来的地址分布均匀，即对任一关键字 k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突  常用的构造方法：
 数字分析法 平方取中法 分段叠加法 除留余数法：假设哈希表长为 m，p 为小于等于 m 的最大素数，则哈希函数为 f(k)=k % p 伪随机数法  四、冲突处理方法 1. 开放地址法（Open addressing） 这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi
 线性探测 二次探测 伪随机探测  线性探测再散列的优点是：只要哈希表不满，就一定能找到一个不冲突的哈希地址，而二次探测再散列和伪随机探测再散列则不一定；缺点是线性探测再散列容易产生二次聚集
2. 再哈希法 这种方法是同时构造多个不同的哈希函数，当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 左值、右值和移动语义</title>
      <link>https://874656645.github.io/posts/133-c&#43;&#43;11-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</link>
      <pubDate>Wed, 23 Feb 2022 22:19:35 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/133-c&#43;&#43;11-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</guid>
      <description>一、结论  C 中将数据类型分为左值和右值，在 C++11 中又将右值概念更为细致的分为将亡值（xvalue）和纯右值（prvalue）。 将亡值是 C++11 新增的跟右值引用相关的表达式，通常是将要被移动的对象（移为他用），比如返回右值引用 T&amp;amp;&amp;amp; 的函数返回值、std::move 的返回值。 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。 右值引用可以直接指向右值，也可以通过 std::move 指向左值；而左值引用只能指向左值（const左值引用也能指向右值）。 作为函数形参时，右值引用更灵活。虽然 const 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。 可移动对象在需要拷贝且被拷贝者之后不再被需要的场景，建议使用 std::move 触发移动语义，提升性能。 我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和 std::move 的语言特性。 std::move 本身只做类型转换，对性能无影响。 std::forward 同样也是做类型转换且更强大，move 只能转出来右值，forward 既可以转成右值，又可以转成左值。 函数最好不要返回函数体内局部变量的左值引用或右值引用。  二、注意事项  左值引用是具名变量值的别名 右值引用是不具名（匿名）变量的别名    引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值，但是，const左值引用是可以指向右值的
const int &amp;amp;ref_a = 5; int a = 5; int &amp;amp;ref_a = a; // 左值引用指向左值，编译通过 int &amp;amp;ref_a = 5; // 左值引用指向了右值，会编译失败   右值引用的标志是 &amp;amp;&amp;amp;，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值
int&amp;amp;&amp;amp; ref_a_right = 5; // ok int a = 5; int&amp;amp;&amp;amp; ref_a_left = a; // 编译不过，右值引用不可以指向左值  ref_a_right = 6; // 右值引用的用途：可以修改右值   事实上 std::move 移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(lvalue)。 所以，单纯的 std::move(xxx) 不会有性能提升，从这个角度来讲，右值引用和左值引用的功能相似，都是原始变量的别名，至于移动后原始变量是否可用，取决于被移动的数据类型对于移动语义的具体实现。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 auto_ptr 被废弃与 unique_ptr</title>
      <link>https://874656645.github.io/posts/131-c&#43;&#43;11-auto_ptr-%E8%A2%AB%E5%BA%9F%E5%BC%83%E4%B8%8E-unique_ptr/</link>
      <pubDate>Tue, 22 Feb 2022 22:18:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/131-c&#43;&#43;11-auto_ptr-%E8%A2%AB%E5%BA%9F%E5%BC%83%E4%B8%8E-unique_ptr/</guid>
      <description>一、auto_ptr 特点  支持拷贝构造 支持赋值拷贝 支持 operator-&amp;gt;/operator* 解引用 支持指针变量重置 保证指针持有者唯一（涉及所有权转移）  二、问题一：使用数组存储 auto_ptr std::vector&amp;lt;std::auto_ptr&amp;lt;People&amp;gt;&amp;gt; peoples; // 这里实例化多个people并保存到数组中 ... std::auto_ptr&amp;lt;People&amp;gt; one = peoples[5]; ... std::cout &amp;lt;&amp;lt; peoples[5]-&amp;gt;get_name() &amp;lt;&amp;lt; std::endl; 原因在于 std::auto_ptr 支持 operator=，为了确保指针所有者唯一，这里转移了所有权，people[5] 变成了 null
三、问题二、函数传参 auto_ptr 类型 void do_somthing(std::auto_ptr&amp;lt;People&amp;gt; people){ // 该函数内不对people变量执行各种隐式/显示的所有权转移和释放  ... } std::auto_ptr&amp;lt;People&amp;gt; people(new People(&amp;#34;jony&amp;#34;)); do_something(people); ... std::cout &amp;lt;&amp;lt; people-&amp;gt;get_name() &amp;lt;&amp;lt; std::endl; 原因在于 std::auto_ptr支持拷贝构造，为了确保指针所有者唯一，这里转移了所有权
四、unique_ptr 在11中，可以支持右值以及移动语义了，此时可以完全匹配auto_ptr的所有权管理，新增了 std::unique_ptr。std::unique_ptr 不仅加入了移动语义的支持，同时也关闭了左值拷贝构造和左值赋值功能！杜绝了上述场景的出现！但是，此时，需要使用其他的方案了。比如场景一中，std::unique_ptr类型变量不能使用vector保存了！
所以 std::auto_ptr 废弃了，由 std::unique_ptr 代替！
class Person{ public: int getAge()const{ return m_age; } void setAge(int age){ m_age = age; } private: int m_age{20}; }; unique_ptr&amp;lt;Person&amp;gt; Change(unique_ptr&amp;lt;Person&amp;gt; p){ p-&amp;gt;setAge(30); return p; } int main() { unique_ptr&amp;lt;Person&amp;gt; pP(new Person); cout &amp;lt;&amp;lt; pP-&amp;gt;getAge() &amp;lt;&amp;lt; endl; // unique_ptr&amp;lt;Person&amp;gt; pP2 = Change(pP); // error： unique_ptr 删除了拷贝构造，所以需要使用 move 关键字转移所有权  unique_ptr&amp;lt;Person&amp;gt; pP2 = Change(move(pP)); // pP = pP2; // error：unique_ptr 删除了 = 赋值构造  cout &amp;lt;&amp;lt; &amp;#34;-------------&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; pP2-&amp;gt;getAge() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;-------------&amp;#34; &amp;lt;&amp;lt; endl; if(pP == nullptr){ cout &amp;lt;&amp;lt; &amp;#34;pP 变量已失效&amp;#34; &amp;lt;&amp;lt; endl; } return 0; } 输出：</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 mutable 关键字</title>
      <link>https://874656645.github.io/posts/132-c&#43;&#43;11-mutable-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Tue, 22 Feb 2022 22:18:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/132-c&#43;&#43;11-mutable-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>一、修饰类成员变量 此关键字只能应用于类的非静态和非常量数据成员，mutable 是为了让 const 对象的某些数据成员可以被修改。static 是类的成员，不属于对象，常对象和常函数只会限制类的成员变量修改，所以类的 static 数据成员不需要 mutable 修饰，在常对象和常函数中也能被修改。
class Person{ public: int getAge() const{ m_count++; s_count++; return m_age; } int getCount()const{ return m_count; } private: int m_age{20}; mutable int m_count{0}; public: static int s_count; }; int Person::s_count = 0; int main() { Person p; p.getAge(); p.getAge(); p.getAge(); cout &amp;lt;&amp;lt; p.getCount() &amp;lt;&amp;lt; endl; // 3  cout &amp;lt;&amp;lt; p.s_count &amp;lt;&amp;lt; endl; // 3  return 0; } 二、修饰匿名函数 表示可以修改按值传入的变量的副本（不是值本身），类似于不带 const 关键字的形参。使用 mutable 关键字后对按值传入的变量进行的修改，不会将改变传递到 Lambda 表达式之外。如果不加 mutable 关键字，按值传入的变量是只读的，即使在 Lambda 表达式内部也不可修改</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 auto 与 decltype 关键字</title>
      <link>https://874656645.github.io/posts/130-c&#43;&#43;11-auto-%E4%B8%8E-decltype-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Tue, 22 Feb 2022 20:30:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/130-c&#43;&#43;11-auto-%E4%B8%8E-decltype-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>一、进行自动类型推导  auto 的自动类型推断发生在编译期，所以使用 auto 并不会造成程序运行时效率的降低。 而是否会造成编译期的时间消耗，我认为是不会的，在未使用 auto 时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换。 auto 属于类类型推导 decltype 是包含声明修饰符的声明类型推导  int main() { int a = 10; auto val = a; cout &amp;lt;&amp;lt; typeid(val).name() &amp;lt;&amp;lt; endl; // i  return 0; } 二、在定义函数模板时，用于声明依赖模板参数的变量类型 不到编译的时候，x * y 的真正类型很难确定
template &amp;lt;class _Tx,class _Ty&amp;gt; void Multiply(_Tx x, _Ty y) { auto v = x * y; std::cout &amp;lt;&amp;lt; v; } int main() { int a = 10; double b = 1.</description>
    </item>
    
    <item>
      <title>gdb 调试使用</title>
      <link>https://874656645.github.io/posts/127-gdb-%E8%B0%83%E8%AF%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 20 Feb 2022 08:53:26 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/127-gdb-%E8%B0%83%E8%AF%95%E4%BD%BF%E7%94%A8/</guid>
      <description>一、生成带有调试信息的程序 gcc main.c -o app -g
二、启动调试  启动调试：gdb app 设置参数： set args
set args 123 abc 456 ddd 查看代码： list 或 l  查看代码显示行数：show listsize 设置代码显示行数：set listsize 20 查看当前文件：  l l 行号 l 函数名   查看非当前文件：  l 文件名:行号 l 文件名:函数名      三、断点相关  设置断点：  break 行号 b 行号 b 函数名 b 文件名:行号 b 文件名:函数名   查看断点：info break 或 i b 删除断点：  del 断点Num d Num d Num1 Num2 d Num1-Num10   设置断点无效：dis Num 断点生效：ena Num 设置条件断点：b 行号 if i == 10  四、调试相关  启动运行：  start - s run - r   退出 gdb 调试：quit - q 打印变量的值：p 变量名 打印变量的类型：ptype 变量名 向下单步调试：  next - n step - s   跳出函数体：finish 从循环中跳出（循环体中不能有断点）：until 设置变量的值：set var 变量名 = value 继续运行到下一个断点：continue - c 监视变量：display 变量名 查看所有的监视变量的信息：info(i) display 取消变量监视：undisplay Num  </description>
    </item>
    
    <item>
      <title>Makefile 使用</title>
      <link>https://874656645.github.io/posts/126-makefile-%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 19 Feb 2022 16:36:47 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/126-makefile-%E4%BD%BF%E7%94%A8/</guid>
      <description>一、make  gcc 编译器 make 是 Linux 自带的构建器  二、文件命名  makefile Makefile  三、makefile 中的规则 例如：gcc a.c b.c c.c -o app
  规则由三部分组成：目标、依赖、命令
app:a.c b.c c.c gcc a.c b.c c.c -o app   makefile 中可以有多条规则
  四、makefile 优化   版本一：
app:main.c add.c sub.c gcc main.c add.c sub.c -I ./ -o app 存在的问题： 效率低，其中一个文件修改了，剩余的其它文件都要重新编译
  版本二：
app:main.o add.o sub.o gcc main.o add.o sub.o -I ./ -o app main.</description>
    </item>
    
    <item>
      <title>Linux 静态库与动态库</title>
      <link>https://874656645.github.io/posts/125-linux-%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Thu, 17 Feb 2022 22:25:34 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/125-linux-%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>一、库是什么 库是二进制格式的源代码（二进制加密）
二、库的使用  头文件 制作的库文件  三、静态库的制作和使用  命名规则 libxxx.a 制作步骤  准备源代码文件 将源代码文件生成 .o 文件 gcc -c *.c 将 .o 文件打包（archive） ar rcs libxxx.a *.o 查看 lib 文件 nm libxxx.a   库的使用 gcc main.c -I./include -L ./lib -lmyCalc -o app  -L: 库的路径 -l: 库的名称（去掉 lib 前缀和 .a 后缀）    四、动态库的制作和使用  命名规则 libxxx.so 制作步骤  准备源代码文件 将源代码文件生成 .o 文件 gcc -c -fpic *.c 或者 gcc -c -fPIC *.</description>
    </item>
    
    <item>
      <title>gcc 相关</title>
      <link>https://874656645.github.io/posts/124-gcc-%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Wed, 16 Feb 2022 21:44:06 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/124-gcc-%E7%9B%B8%E5%85%B3/</guid>
      <description>一、gcc 工作流程  预处理 —— -E  宏替换 头文件展开 去掉注释 生成 .i 文件   编译 —— -S  生成 .s 文件 汇编文件   汇编 —— -c  生成 .o 文件 二进制文件   链接  二、gcc 常用参数  -v / --version -I : 编译时指定头文件路径 -c : 生成二进制文件 .o -o : 指定生成的文件名 -g : gdb 调试，生成带有调试信息的二进制文件（Debug模式） -D : 编译时指定一个宏 -Wall : 显示警告信息 -On : 优化代码，n 是优化级别（1，2，3）  </description>
    </item>
    
    <item>
      <title>2022-02-14 杂记</title>
      <link>https://874656645.github.io/posts/123-2022-02-14%E6%9D%82%E8%AE%B0/</link>
      <pubDate>Tue, 15 Feb 2022 15:29:35 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/123-2022-02-14%E6%9D%82%E8%AE%B0/</guid>
      <description>NULL，0，&#39;\0&#39;，&amp;lsquo;0&amp;rsquo;
int main() { char arr[] = {0, &amp;#39;\0&amp;#39;, &amp;#39;0&amp;#39;, 48}; printf(&amp;#34;%c\n&amp;#34;, arr[0]); printf(&amp;#34;%c\n&amp;#34;, arr[1]); printf(&amp;#34;%c\n&amp;#34;, arr[2]); printf(&amp;#34;%c\n&amp;#34;, arr[3]); printf(&amp;#34;---------------\n&amp;#34;); printf(&amp;#34;%d\n&amp;#34;, arr[0]); printf(&amp;#34;%d\n&amp;#34;, arr[1]); printf(&amp;#34;%d\n&amp;#34;, arr[2]); printf(&amp;#34;%d\n&amp;#34;, arr[3]); return 0; } 输出：
0 0 --------------- 0 0 48 48   UTF-8 向下兼容 ASCII 编码，UTF-8 编码中，一个英文字为一个字节，一个中文一般为三个字节（ASCII、Unicode、UTF-8）
 0xxxxxxx：单字节编码形式，这和 ASCII 编码完全一样，因此 UTF-8 是兼容 ASCII 的； 110xxxxx 10xxxxxx：双字节编码形式； 1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式； 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式； UTF-8：每字 1 ~ 6 字节 Unicode（UCS-2）：每字都是 2 bytes UTF-16：每字 2 ~ 4 字节 UTF-32（UCS-4）：每字都是 4 bytes    float 单精度，浮点数在内存中是按科学计数法来存储的，小数点后6位能确定表示，float 是由 1 bit 符号位，8 bit 指数位和 23 bit 尾数位组成，精度是由尾数位决定的（2^23 = 8388608）</description>
    </item>
    
    <item>
      <title>vim 使用</title>
      <link>https://874656645.github.io/posts/122-vim-%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 13 Feb 2022 19:38:16 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/122-vim-%E4%BD%BF%E7%94%A8/</guid>
      <description>一、使用教程   vimtutor
  显示行号:
vim ~/.vimrc 在文件的最后一行输入 set number 并保存退出   二、vim 三种工作模式  命令模式 编辑模式 末行模式
  三、命令模式下的相关操作  保存退出
ZZ 代码格式化
gg=G 光标移动：  左下上右：H J K L 移动到行首：0 移动到行尾：$ 移动到文件首部：gg 移动到文件尾部：G 跳转到第20行：20 + G 从当前位置向下移动 n 行：n + enter   删除命令：  删除光标后的一个字符：x（小写） 删除光标前的一个字符：X（大写） 删除一个单词：dw 删除光标前的所有字符：d0 删除光标后的所有字符：d$ 或者 D 删除光标所在行：dd 删除多行：ndd 删除光标所在行以及下面 n 行 删除光标所在行到文件首部的字符：dgg 删除光标所在行到文件尾部的字符：dG   撤销与反撤销：  撤销：u 反撤销：ctrl + r   复制粘贴：  复制一行：yy 复制多行：nyy 粘贴到光标下一行：p 粘贴到光标上一行：P(大写)   字符可视模式：v  移动光标 复制：y 删除：d 粘贴：p(小写 光标之后) P(大写 光标之前)   行可视模式：V  增加缩进：&amp;gt; 减少缩进：&amp;lt;   块可视模式：ctrl + V  o：将光标在块的左上角和右下角切换 O：将光标移动到所在行的对角 nl：将光标向右移动 n 个字符 nj：将光标向下移动 n 行 I：插入，按两次 ESC 退出（例如：多行注释操作）   替换操作：  r：替换光标后的字符 R：替换光标后的多个字符   查找操作：  /xxx ?</description>
    </item>
    
    <item>
      <title>Windows 10 中的 Linux 子系统</title>
      <link>https://874656645.github.io/posts/121-windows-10-%E4%B8%AD%E7%9A%84-linux-%E5%AD%90%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sun, 13 Feb 2022 11:01:34 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/121-windows-10-%E4%B8%AD%E7%9A%84-linux-%E5%AD%90%E7%B3%BB%E7%BB%9F/</guid>
      <description>WSL 的基本命令
一、自动安装 满足 Win10 系统版本要求的（ Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11）可以使用这种方式
查看方式，Win + R 打开运行窗口，输入 winver 查看
  安装 WSL
wsl --install
  查看可用的 Linux 发行版
wsl -l -o
  查看已安装的 Linux 分发版
wsl -l -v
  注销 Linux 发行版
wsl --unregister Ubuntu
  可以直接从官网下载 Linux 发行版的安装包，然后将 appx 扩展名改为 zip，解压到想要放置的目录，双击 ubuntu.exe 启动，参考手动安装
  二、手动安装  注意：以下命令都是在以管理员权限运行的 PowerShell 中完成   启用 “适用于 Linux 的 Windows 子系统” 可选功能</description>
    </item>
    
    <item>
      <title>Linux 目录介绍</title>
      <link>https://874656645.github.io/posts/120-linux-%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 10 Feb 2022 21:39:52 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/120-linux-%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/</guid>
      <description>         bin 二进制文件，可执行文件   boot 系统开机启动项   dev device 设备（硬盘、显卡、显示器 一切皆文件）   lib 动态库   mnt 手动挂载目录   media 外设自动挂载目录   root 超级用户的家目录   usr unix system resource 头文件include、源文件src、用户安装程序/usr/local   etc 配置文件   opt 安装第三方应用程序   home Linux 所有用户的家目录（操作系统的家目录）   tmp 临时文件目录，系统重启后会被清空    </description>
    </item>
    
    <item>
      <title>递归与递归树</title>
      <link>https://874656645.github.io/posts/119-%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E5%BD%92%E6%A0%91/</link>
      <pubDate>Mon, 07 Feb 2022 21:38:53 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/119-%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E5%BD%92%E6%A0%91/</guid>
      <description>逆序打印字符串
void printReverseString(const char* str){ if(*str == &amp;#39;\0&amp;#39;){ return; } printReverseString(str + 1); printf(&amp;#34;%c&amp;#34;, *str); } int main() { const char* str = &amp;#34;Hello World&amp;#34;; printReverseString(str); // dlroW olleH  return 0; }   逆序输出链表
struct LinkNode{ int data; struct LinkNode* next; }; void printReverseLinkNode(struct LinkNode* header){ if(header == NULL){ return; } printReverseLinkNode(header-&amp;gt;next); printf(&amp;#34;%d\n&amp;#34;, header-&amp;gt;data); } int main() { struct LinkNode* header = malloc(sizeof(struct LinkNode)); struct LinkNode* node1 = malloc(sizeof(struct LinkNode)); node1-&amp;gt;data = 10; node1-&amp;gt;next = NULL; struct LinkNode* node2 = malloc(sizeof(struct LinkNode)); node2-&amp;gt;data = 20; node2-&amp;gt;next = NULL; struct LinkNode* node3 = malloc(sizeof(struct LinkNode)); node3-&amp;gt;data = 30; node3-&amp;gt;next = NULL; header-&amp;gt;next = node1; node1-&amp;gt;next = node2; node2-&amp;gt;next = node3; printReverseLinkNode(header-&amp;gt;next); return 0; }   递归实现给出一个数 8793，依次打印千位数 8、百位数 7、十位数 9、个位数 3</description>
    </item>
    
    <item>
      <title>常用的宏定义</title>
      <link>https://874656645.github.io/posts/118-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Mon, 07 Feb 2022 10:11:16 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/118-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/</guid>
      <description>int main() { printf(&amp;#34;%s\n&amp;#34;, __FILE__); // main.c  printf(&amp;#34;%d\n&amp;#34;, __LINE__); // 14  printf(&amp;#34;%s\n&amp;#34;, __DATE__); // Feb 7 2022  printf(&amp;#34;%s\n&amp;#34;, __TIME__); // 01:59:37  return 0; } // func1.h #ifdef __cplusplus extern &amp;#34;C&amp;#34;{ #endif  void func1(); #ifdef __cplusplus } #endif  // main.h extern &amp;#34;C&amp;#34;{ include &amp;#34;func1.h&amp;#34; } extern &amp;#34;C&amp;#34;{ extern void func1(); } int main() { func1(); return 0; } </description>
    </item>
    
    <item>
      <title>Ubuntu 常用命令</title>
      <link>https://874656645.github.io/posts/117-ubuntu-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 07 Feb 2022 08:33:51 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/117-ubuntu-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>Linux 命令大全
一、更新和升级包 1. 更新和升级包 sudo apt update &amp;amp;&amp;amp; sudo apt upgrade
2. 安装软件 sudo apt install tree
3. 删除不需要的包 sudo apt autoremove
4. 查看已安装的软件 dpkg -l | grep openssh-server
5. 查看软件安装的路径 dpkg -L openssh-server
whereis gdb
二、shell 操作和常用命令 1、查看输入的命令历史 history
2、删除光标前面的字符串 ctrl + u
3、删除光标后面的字符串 ctrl + k
4、光标定位到头部 ctrl + a
5、光标定位到尾部 ctrl + e
6、命令、路径补全 Tab
7、缩写别名 alias
8、查看说明 man 5 passwd
9、宿主目录 ~
10、查看目录内容 tree ~</description>
    </item>
    
    <item>
      <title>char* 数组</title>
      <link>https://874656645.github.io/posts/116-char-%E6%98%9F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 03 Feb 2022 20:29:17 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/116-char-%E6%98%9F%E6%95%B0%E7%BB%84/</guid>
      <description>void printArr(const char ** p, int len){ for(int i = 0; i &amp;lt; len; ++i){ cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; endl; } } void sortSelect(const char ** p, int len){ for(int i = 0; i &amp;lt; len - 1; ++i){ int max = i; for(int j = i + 1; j &amp;lt; len; ++j){ if(p[j] &amp;gt; p[max]){ max = j; } } // 交换  if(i != max){ const char* tmp = p[i]; p[i] = p[max]; p[max] = tmp; } } } int main() { const char* arr[] = {&amp;#34;aa&amp;#34;, &amp;#34;bb&amp;#34;, &amp;#34;cc&amp;#34;, &amp;#34;dd&amp;#34;, &amp;#34;ee&amp;#34;}; int len = sizeof(arr) / sizeof(char*); cout &amp;lt;&amp;lt; len &amp;lt;&amp;lt; endl; printArr(arr, len); sortSelect(arr, len); cout &amp;lt;&amp;lt; &amp;#34;----------------&amp;#34; &amp;lt;&amp;lt; endl; printArr(arr, len); return 0; } 输出：</description>
    </item>
    
    <item>
      <title>装饰器模式</title>
      <link>https://874656645.github.io/posts/115-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 02 Feb 2022 16:59:08 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/115-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代。
装饰模式可以动态给一个类增加功能</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://874656645.github.io/posts/114-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 02 Feb 2022 16:11:14 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/114-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者。</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>https://874656645.github.io/posts/113-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 02 Feb 2022 15:45:50 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/113-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>将一个请求封闭为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作（Action）模式或事务（Transaction）模式。
命令模式可以将请求者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://874656645.github.io/posts/112-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 16:59:42 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/112-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>策略模式定义了一系列的算法，并将每个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</description>
    </item>
    
    <item>
      <title>模板方法模式</title>
      <link>https://874656645.github.io/posts/111-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 16:41:35 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/111-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
class TemplateDrink{ public: virtual void boilWater() = 0; virtual void drew() = 0; virtual void pourCup() = 0; virtual void addSomething() = 0; void make(){ boilWater(); drew(); pourCup(); addSomething(); } }; class Tea : public TemplateDrink{ public: void boilWater() override{ cout &amp;lt;&amp;lt; &amp;#34;煮山泉水...&amp;#34; &amp;lt;&amp;lt; endl; } void drew() override{ cout &amp;lt;&amp;lt; &amp;#34;冲龙井茶...&amp;#34; &amp;lt;&amp;lt; endl; } void pourCup() override{ cout &amp;lt;&amp;lt; &amp;#34;倒入茶杯中...&amp;#34; &amp;lt;&amp;lt; endl; } void addSomething() override{ cout &amp;lt;&amp;lt; &amp;#34;加点柠檬.</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>https://874656645.github.io/posts/110-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 16:07:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/110-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>有一个已经写好的接口，但是不符合需求，适配器就是将已有的接口转化为需要的形式
class MyPrint{ public: void operator()(int a, int b){ cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; endl; } }; class TargetInterface{ public: virtual void operator()(int v) = 0; }; class MyAdaptor : public TargetInterface{ public: MyAdaptor(int param):param(param){} void operator()(int v){ print(v, param); } private: MyPrint print; int param; }; MyAdaptor myBind2nd(int v){ return MyAdaptor(v); } int main() { vector&amp;lt;int&amp;gt; v; for(int i = 0; i &amp;lt; 10; ++i){ v.push_back(i); } for_each(v.begin(), v.</description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>https://874656645.github.io/posts/109-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 15:32:38 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/109-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>将复杂的子系统抽象到同一个接口进行管理，外界只需要通过此接口与子类系统进行交互，而不必直接与复杂的子类系统进行交互
案例：家庭影院外观模式 实现KTV模式：电视打开，灯关掉，音响打开，麦克风打开，DVD打开
实现游戏模式：电视打开，音响打开，游戏机打开</description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>https://874656645.github.io/posts/108-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 07:28:53 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/108-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://874656645.github.io/posts/107-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 31 Jan 2022 20:43:34 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/107-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>单例在内存中只有一份，在内存中不会占用太多，程序退出时会随着程序统一释放内存，所以可以不必特意释放  一、懒汉式 不是线程安全的，所以多线程使用要加锁
class Singleton{ public: static Singleton* getInstance(){ if(s_instance == nullptr){ s_instance = new Singleton; } return s_instance; } // 可有可无，程序结束时，系统会自动回收程序的所有内存  class Garbo{ ~Garbo(){ if(s_instance){ cout &amp;lt;&amp;lt; &amp;#34;gc...&amp;#34; &amp;lt;&amp;lt; endl; delete s_instance; } } }; private: Singleton(){ cout &amp;lt;&amp;lt; &amp;#34;Singleton()...&amp;#34; &amp;lt;&amp;lt; endl; } Singleton(const Singleton&amp;amp;) = delete; Singleton&amp;amp; operator=(const Singleton&amp;amp;) = delete; static Singleton* s_instance; static Garbo s_gc; }; Singleton* Singleton::s_instance = nullptr; int main() { cout &amp;lt;&amp;lt; &amp;#34;main().</description>
    </item>
    
    <item>
      <title>抽象工厂模式</title>
      <link>https://874656645.github.io/posts/106-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 31 Jan 2022 17:44:49 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/106-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description> 抽象工厂针对的是产品族，而不是产品等级 产品族：同一产地或者同一厂商，功能不同 产品等级：功能相同，产地或者厂商不同 对于增加产品族，符合开闭原则 对于增加产品等级，不符合开闭原则  // 抽象工厂模式 class AbstractApple{ public: virtual void showName() = 0; }; class AbstractBanana{ public: virtual void showName() = 0; }; class AbstractPear{ public: virtual void showName() = 0; }; class ChinaApple : public AbstractApple{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是中国苹果！&amp;#34; &amp;lt;&amp;lt; endl; } }; class ChinaBanana : public AbstractBanana{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是中国香蕉！&amp;#34; &amp;lt;&amp;lt; endl; } }; class ChinaPear : public AbstractPear{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是中国鸭梨！&amp;#34; &amp;lt;&amp;lt; endl; } }; class USAApple : public AbstractApple{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是美国苹果！&amp;#34; &amp;lt;&amp;lt; endl; } }; class USABanana : public AbstractBanana{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是美国香蕉！&amp;#34; &amp;lt;&amp;lt; endl; } }; class USAPear : public AbstractPear{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是美国鸭梨！&amp;#34; &amp;lt;&amp;lt; endl; } }; class JapanApple : public AbstractApple{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是日本苹果！&amp;#34; &amp;lt;&amp;lt; endl; } }; class JapanBanana : public AbstractBanana{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是日本香蕉！&amp;#34; &amp;lt;&amp;lt; endl; } }; class JapanPear : public AbstractPear{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是日本鸭梨！&amp;#34; &amp;lt;&amp;lt; endl; } }; class AbstractFactory{ public: virtual AbstractApple* CreateApple() = 0; virtual AbstractBanana* CreateBanana() = 0; virtual AbstractPear* CreatePear() = 0; }; class ChinaFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new ChinaApple; } AbstractBanana* CreateBanana() override{ return new ChinaBanana; } AbstractPear* CreatePear() override{ return new ChinaPear; } }; class USAFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new USAApple; } AbstractBanana* CreateBanana() override{ return new USABanana; } AbstractPear* CreatePear() override{ return new USAPear; } }; class JapanFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new JapanApple; } AbstractBanana* CreateBanana() override{ return new JapanBanana; } AbstractPear* CreatePear() override{ return new JapanPear; } }; int main() { AbstractFactory* factory = nullptr; AbstractApple* apple = nullptr; AbstractBanana* banana = nullptr; AbstractPear* pear = nullptr; // 中国  factory = new ChinaFactory; apple = factory-&amp;gt;CreateApple(); apple-&amp;gt;showName(); banana = factory-&amp;gt;CreateBanana(); banana-&amp;gt;showName(); pear = factory-&amp;gt;CreatePear(); pear-&amp;gt;showName(); delete pear; delete banana; delete apple; delete factory; // 美国  factory = new USAFactory; apple = factory-&amp;gt;CreateApple(); apple-&amp;gt;showName(); banana = factory-&amp;gt;CreateBanana(); banana-&amp;gt;showName(); pear = factory-&amp;gt;CreatePear(); pear-&amp;gt;showName(); delete pear; delete banana; delete apple; delete factory; // 日本  factory = new JapanFactory; apple = factory-&amp;gt;CreateApple(); apple-&amp;gt;showName(); banana = factory-&amp;gt;CreateBanana(); banana-&amp;gt;showName(); pear = factory-&amp;gt;CreatePear(); pear-&amp;gt;showName(); delete pear; delete banana; delete apple; delete factory; return 0; } </description>
    </item>
    
    <item>
      <title>工厂方法模式</title>
      <link>https://874656645.github.io/posts/105-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 31 Jan 2022 15:51:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/105-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>工厂方法模式 = 简单工厂模式 + 开闭原则
类的个数成倍增多，维护成本很高
适用场景：
 客户端不知道它所需要的对象的类 抽象工厂类通过其子类来指定创建哪个对象  // 工厂方法模式 class AbstractFruit{ public: virtual void showName() = 0; }; class Apple : public AbstractFruit{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是苹果！&amp;#34; &amp;lt;&amp;lt; endl; } }; class Banana : public AbstractFruit{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是香蕉！&amp;#34; &amp;lt;&amp;lt; endl; } }; class Pear : public AbstractFruit{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是鸭梨！&amp;#34; &amp;lt;&amp;lt; endl; } }; // 抽象工厂 class AbstractFruitFactory{ public: virtual AbstractFruit* CreateFruit() = 0; }; class AppleFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Apple; } }; class PearFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Pear; } }; class BananaFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Banana; } }; int main() { AbstractFruitFactory* factory = nullptr; AbstractFruit* fruit = nullptr; factory = new AppleFactory; fruit = factory-&amp;gt;CreateFruit(); fruit-&amp;gt;showName(); delete fruit; delete factory; factory = new BananaFactory; fruit = factory-&amp;gt;CreateFruit(); fruit-&amp;gt;showName(); delete fruit; delete factory; factory = new PearFactory; fruit = factory-&amp;gt;CreateFruit(); fruit-&amp;gt;showName(); delete fruit; delete factory; return 0; } </description>
    </item>
    
    <item>
      <title>简单工厂模式</title>
      <link>https://874656645.github.io/posts/104-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 31 Jan 2022 15:14:38 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/104-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description> 实现了客户端与功能类的解耦 但是违反了类的单一职责原则，整个类的代码冗长，阅读难度、维护难度和测试难度也很大 违反了开闭原则，增添功能要修改源代码  适用场景：
 工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂 客户端只知道传入工厂类的参数，对于如何创建对象并不关心  // 简单工厂模式 class AbstractFruit{ public: virtual void showName() = 0; }; class Apple : public AbstractFruit{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是苹果！&amp;#34; &amp;lt;&amp;lt; endl; } }; class Banana : public AbstractFruit{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是香蕉！&amp;#34; &amp;lt;&amp;lt; endl; } }; class Pear : public AbstractFruit{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是鸭梨！&amp;#34; &amp;lt;&amp;lt; endl; } }; class FruitFactory{ public: static AbstractFruit* CreateFruit(string flag){ if(flag == &amp;#34;apple&amp;#34;){ return new Apple; } else if(flag == &amp;#34;banana&amp;#34;){ return new Banana; } else if(flag == &amp;#34;pear&amp;#34;){ return new Pear; } else{ return nullptr; } } }; int main() { AbstractFruit* fruit = FruitFactory::CreateFruit(&amp;#34;apple&amp;#34;); fruit-&amp;gt;showName(); delete fruit; fruit = FruitFactory::CreateFruit(&amp;#34;banana&amp;#34;); fruit-&amp;gt;showName(); delete fruit; fruit = FruitFactory::CreateFruit(&amp;#34;pear&amp;#34;); fruit-&amp;gt;showName(); delete fruit; return 0; } </description>
    </item>
    
    <item>
      <title>依赖倒转原则</title>
      <link>https://874656645.github.io/posts/103-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/</link>
      <pubDate>Mon, 31 Jan 2022 11:35:37 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/103-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/</guid>
      <description>传统过程式设计 传统的过程式设计倾向于使高层次的模块依赖于低层次的模块，抽象层依赖于具体实现层
// 底层实现 class BankWorker{ public: void saveService(){ cout &amp;lt;&amp;lt; &amp;#34;办理存款业务...&amp;#34; &amp;lt;&amp;lt; endl; } void transferService(){ cout &amp;lt;&amp;lt; &amp;#34;办理转账业务...&amp;#34; &amp;lt;&amp;lt; endl; } void payService(){ cout &amp;lt;&amp;lt; &amp;#34;办理支付业务...&amp;#34; &amp;lt;&amp;lt; endl; } }; // 中层封装 void doSaveBusiness(BankWorker* worker){ worker-&amp;gt;saveService(); } void doTransferBusiness(BankWorker* worker){ worker-&amp;gt;transferService(); } void doPayBusiness(BankWorker* worker){ worker-&amp;gt;payService(); } // 高层调用 void test1(){ BankWorker* bw = new BankWorker; doSaveBusiness(bw); doPayBusiness(bw); doTransferBusiness(bw); delete bw; } 依赖倒转 // 抽象层 class AbstractWorker{ public: virtual void doBusiness() = 0; }; // 实现层 class SaveBankWorker:public AbstractWorker{ public: void doBusiness()override{ cout &amp;lt;&amp;lt; &amp;#34;办理存款业务.</description>
    </item>
    
    <item>
      <title>合成复用原则</title>
      <link>https://874656645.github.io/posts/102-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 30 Jan 2022 21:45:22 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/102-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</guid>
      <description>优先使用组合的方式，而不是继承
class AbstractCar{ public: virtual void run() = 0; }; class BMW:public AbstractCar{ public: void run()override{ cout &amp;lt;&amp;lt; &amp;#34;BMW run&amp;#34; &amp;lt;&amp;lt; endl; } }; class DaZhong:public AbstractCar{ public: void run()override{ cout &amp;lt;&amp;lt; &amp;#34;DaZhong run&amp;#34; &amp;lt;&amp;lt; endl; } }; #if 0// 错误的做法 class Person : public BMW{ public: void drive(){ run(); } }; void test1(){ Person p; p.drive(); } #endif // 正确做法 class Person{ public: Person(){ car = nullptr; } Person(AbstractCar* c){ car = c; } void drive(){ car-&amp;gt;run(); delete car; } void drive(AbstractCar* car){ car-&amp;gt;run(); delete car; } private: AbstractCar* car; }; void test2(){ // 方式一：  Person* p = new Person(new BMW); p-&amp;gt;drive(); delete p; p = new Person(new DaZhong); p-&amp;gt;drive(); delete p; // 方式二：  Person pp; pp.</description>
    </item>
    
    <item>
      <title>迪米特法则</title>
      <link>https://874656645.github.io/posts/101-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</link>
      <pubDate>Sun, 30 Jan 2022 20:38:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/101-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</guid>
      <description>又叫最少知识原则
封装一个中间层进行隔离
class AbstractBuilding{ public: virtual string getQuality()const = 0; virtual void sale() = 0; }; class BuildingA:public AbstractBuilding{ public: BuildingA(){ m_quality = &amp;#34;高品质&amp;#34;; } string getQuality()const override{ return m_quality; } void sale()override{ cout &amp;lt;&amp;lt; &amp;#34;楼盘A：&amp;#34; &amp;lt;&amp;lt; m_quality &amp;lt;&amp;lt; endl; } private: string m_quality; }; class BuildingB:public AbstractBuilding{ public: BuildingB(){ m_quality = &amp;#34;低品质&amp;#34;; } string getQuality()const override{ return m_quality; } void sale()override{ cout &amp;lt;&amp;lt; &amp;#34;楼盘B：&amp;#34; &amp;lt;&amp;lt; m_quality &amp;lt;&amp;lt; endl; } private: string m_quality; }; // 错误的做法 // 客户端 void test1(){ string myRequest = &amp;#34;低品质&amp;#34;; BuildingA* bA = new BuildingA; if(bA-&amp;gt;getQuality() == myRequest){ bA-&amp;gt;sale(); delete bA; } BuildingB* bB = new BuildingB; if(bB-&amp;gt;getQuality() == myRequest){ bB-&amp;gt;sale(); delete bB; } } // 正确做法 // 封装一个中间类 class Mediator{ public: Mediator(){ AbstractBuilding* b = new BuildingA; vb.</description>
    </item>
    
    <item>
      <title>开闭原则</title>
      <link>https://874656645.github.io/posts/100-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 30 Jan 2022 20:05:30 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/100-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</guid>
      <description>对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码
如下所示，如果想要扩展乘法、除法、取模等算法，就不用修改原码，只需增加新类
class AbstractCalculator{ public: virtual void setOperatorNum(int a, int b) = 0; virtual int getResult() = 0; }; class PlusCalculator:public AbstractCalculator{ public: void setOperatorNum(int a, int b)override{ m_a = a; m_b = b; } int getResult()override{ return m_a + m_b; } private: int m_a{0}; int m_b{0}; }; class MinusCalculator:public AbstractCalculator{ public: void setOperatorNum(int a, int b)override{ m_a = a; m_b = b; } int getResult()override{ return m_a - m_b; } private: int m_a{0}; int m_b{0}; }; int main() { AbstractCalculator* calculator = new PlusCalculator; calculator-&amp;gt;setOperatorNum(10, 20); cout &amp;lt;&amp;lt; calculator-&amp;gt;getResult() &amp;lt;&amp;lt; endl; delete calculator; calculator = nullptr; calculator = new MinusCalculator; calculator-&amp;gt;setOperatorNum(10, 20); cout &amp;lt;&amp;lt; calculator-&amp;gt;getResult() &amp;lt;&amp;lt; endl; delete calculator; calculator = nullptr; return 0; } </description>
    </item>
    
    <item>
      <title>面向对象设计原则</title>
      <link>https://874656645.github.io/posts/99-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 30 Jan 2022 19:17:09 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/99-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
      <description>原则目的：高内聚，低耦合
 单一职责原则 Single Responsibility Principal（SRP）：类的职责单一，对外只提供一种功能 开闭原则 Open-Closed Principal（OCP）：对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码 里氏代换原则 Liskov Substitution Principal（LSP）：任何抽象类出现的地方都可以用他的实现类进行替换（多态） 依赖倒转原则 Dependence Inversion Principal（DIP）：依赖于抽象（接口），不要依赖具体的实现（类），针对接口编程 接口隔离原则 Interface Segregation Principal（ISP）：一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去 合成复用原则 Composite Reuse Principal（CRP）：对于继承和组合，优先使用组合 迪米特法则 Law of Demeter（LoD）：一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节（黑盒原理）  </description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://874656645.github.io/posts/98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 30 Jan 2022 11:57:37 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式
一、概念  设计模式是在特定环境下人们解决某类重复出现的问题的一套成功或有效的解决方案。 软件模式并非仅限于设计模式，还包括架构模式、分析模式、过程模式等。 在一定环境下，用固定套路解决问题。 设计模式的基础是多态。  二、目的  学习设计模式有助于更加深入的理解面向对象思想 如何将代码分散在几个不同的类中 为什么要有接口 何谓针对抽象编程 何时不应该使用继承 如何不修改源代码增加新功能 更好地阅读和理解现有类库与其它系统中的源代码  三、软件设计模式种类 GoF 提出的设计模式有 23 种，加简单工厂模式，一共 24 种
1、创建型模式 Creational 6种 如何创建对象
 单例模式 简单工厂模式 工厂方法模式 抽象工厂模式 原型模式 建造者模式  2、结构型模式 Structural 7种 如何实现类或对象的组合
让类和类进行组合，获得更大的结构
 适配器模式 桥接模式 组合模式 装饰模式 外观模式 享元模式 代理模式  3、行为型模式 Behavioral 11种 类或对象怎样交互以及怎样分配职责
 职责链模式 命令模式 解释器模式 迭代器模式 中介模式 备忘录模式 观察者模式 状态模式 策略模式 模板方法模式 访问者模式  </description>
    </item>
    
    <item>
      <title>UML 统一建模语言</title>
      <link>https://874656645.github.io/posts/97-uml-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Sat, 29 Jan 2022 19:55:47 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/97-uml-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</guid>
      <description>一、用例图  用例代表系统的某项完整功能 从客户角度来描述系统功能 包括参与者、用例、关系  1. 泛化关系 Generalization  父类和子类的关系  2. 包含关系 Include  一个功能肯定会使用另一个功能  3. 扩展关系 Extend  完成某个功能的时候偶尔会执行另一个功能  二、类图 用来显示系统中的类，接口以及它们之间的关系
1. 泛化关系 Generalization（is a） 一种类与类之间的继承关系
2. 实现关系 Realization（is a） 类与抽象类之间的实现关系
3. 依赖关系 Dependence（use a） 两个相对独立的系统，一个系统负责构造另一个系统的实例，或者依赖另一个系统的服务
类 A 做为类 B 方法的形参，而不是类 B 的成员属性
4. 关联关系 Directed Association 两个相对独立的系统，一个系统的实例与另一个系统的一些实例存在固定的对应关系
  聚合 Aggregation
 聚合关系是关联关系的一种，是更强的关联关系 聚合是整体和部分之间的关系，例如汽车由引擎、轮胎以及其它零件组成 聚合关系也是通过成员变量来实现的，但是，关联关系所涉及的两个类处在同一个层次上，而聚合关系中，两个类处于不同层次上，一个代表整体，一个代表部分 整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享    组合 Composition
  三、对象图 四、时序图 五、活动图 </description>
    </item>
    
    <item>
      <title>函数对象适配器</title>
      <link>https://874656645.github.io/posts/96-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8/</link>
      <pubDate>Thu, 27 Jan 2022 21:55:47 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/96-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8/</guid>
      <description>仿函数适配器 bind1st、bind2nd 将二元仿函数转为一元仿函数
  仿函数适配器 not1、not2
  仿函数适配器 ptr_fun 将普通函数转为函数对象，然后就可以与其它仿函数适配器一起使用了
  仿函数适配器 mem_fun、mem_fun_ref 将成员函数转为适配器
  class MyPrint : public binary_function&amp;lt;int, int, void&amp;gt;{ public: void operator()(int v, int val) const{ cout &amp;lt;&amp;lt; &amp;#34;v: &amp;#34; &amp;lt;&amp;lt; v &amp;lt;&amp;lt; &amp;#34;, val: &amp;#34; &amp;lt;&amp;lt; val &amp;lt;&amp;lt; &amp;#34;, v + val: &amp;#34; &amp;lt;&amp;lt; v + val &amp;lt;&amp;lt; endl; } }; void myPrint(int v, int val){ cout &amp;lt;&amp;lt; v + val &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } class MySort: public binary_function&amp;lt;int, int, bool&amp;gt;{ public: bool operator() (int lhs, int rhs)const{ return lhs &amp;gt; rhs; } }; class MyGreater: public unary_function&amp;lt;int, bool&amp;gt;{ public: bool operator()(int v)const{ return v &amp;gt; 50; } }; void printVec(const vector&amp;lt;int&amp;gt; &amp;amp;v){ for(const auto &amp;amp;p : v){ cout &amp;lt;&amp;lt; p &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } cout &amp;lt;&amp;lt; endl; } class Person{ public: Person(int id, int age):id(id), age(age){} void show(){ cout &amp;lt;&amp;lt; &amp;#34;id: &amp;#34; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &amp;#34;, age: &amp;#34; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; endl; } int id; int age; }; int main(){ vector&amp;lt;int&amp;gt; v; for(int i = 0; i &amp;lt; 10; ++i){ v.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 沉思录笔记</title>
      <link>https://874656645.github.io/posts/95-c&#43;&#43;-%E6%B2%89%E6%80%9D%E5%BD%95%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 26 Jan 2022 17:48:58 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/95-c&#43;&#43;-%E6%B2%89%E6%80%9D%E5%BD%95%E7%AC%94%E8%AE%B0/</guid>
      <description>有的情况下，现在的折衷方案比未来的理想方案好得多
  我考虑问题的本质是什么，再定义一个类抓住这个本质，并确保这个类能独立地工作。然后在遇到符合这个本质的问题时就使用这个类。
  只要类定义正确，我就只能按照我编写它的初衷那样去用它。
  C++ 哲学：抽象，实用，只为用到的东西付出代价。
  类设计者的核查表：
 你的类需要一个构造函数吗？ 你的数据成员是私有的吗？（使用函数，可以延迟计算，不必时时计算，保证数据成员的准确性） 你的类需要一个无参的构造函数吗？（对象数组） 是不是每个构造函数初始化所有的数据成员？ 类需要析构函数吗？ 类需要一个虚析构函数吗？ 你的类需要复制构造函数吗？（是否需要深拷贝） 你的类需要一个赋值操作符吗？ 你的赋值操作符能正确地将对象赋给对象本身吗？ 你的类需要定义关系操作符吗？ 删除数组时你记住了用 delete[] 吗？ 记得在复制构造函数和赋值操作符的参数类型中加上 const 了吗？ 如果函数有引用参数，它们应该是 const 引用吗？ 记得适当地声明成员函数为 const 的了吗？    代理类：用类来表示概念（RAII）
class Vehicle{ public: virtual double weight() = 0; virtual void start() = 0; virtual Vehicle* copy() const = 0; virtual ~Vehicle(){} }; class RoadVehicle: public Vehicle{ /* .</description>
    </item>
    
    <item>
      <title>机房预约系统案例</title>
      <link>https://874656645.github.io/posts/94-%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Mon, 24 Jan 2022 20:53:57 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/94-%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F%E6%A1%88%E4%BE%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>switch 与 if Else 区别</title>
      <link>https://874656645.github.io/posts/93-switch-%E4%B8%8E-if-else-%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 24 Jan 2022 20:01:08 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/93-switch-%E4%B8%8E-if-else-%E5%8C%BA%E5%88%AB/</guid>
      <description> while 循环中的 switch, break 只能中断 switch，不能中断 while 循环  void managerMenue(){ while(true){ cout &amp;lt;&amp;lt; &amp;#34;这是子菜单&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;是否返回主菜单？&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;1 是&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;2 否&amp;#34; &amp;lt;&amp;lt; endl; int i = 0; cin &amp;gt;&amp;gt; i; switch(i){ case 1: break; case 2: return; default: break; } // if(i == 1){  // // system(&amp;#34;reset&amp;#34;);  // break;  // }  // else if(i == 2){  // return;  // }  // else{  // cout &amp;lt;&amp;lt; &amp;#34;输入有误，请重新输入&amp;#34; &amp;lt;&amp;lt; endl;  // }  } cout &amp;lt;&amp;lt; &amp;#34;这是子菜单循环外代码&amp;#34; &amp;lt;&amp;lt; endl; } int main() { while(true){ cout &amp;lt;&amp;lt; &amp;#34;欢迎登陆！&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;这是主菜单&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;请输入选项：&amp;#34; &amp;lt;&amp;lt; endl; int i = 0; cin &amp;gt;&amp;gt; i; // switch(i)  // {  // case 1:  // system(&amp;#34;reset&amp;#34;);  // managerMenue();  // break;  // case 2:  // break;  // }  if(i == 1){ // system(&amp;#34;reset&amp;#34;);  managerMenue(); // break;  } else{ break; } cout &amp;lt;&amp;lt; &amp;#34;switch 外代码&amp;#34; &amp;lt;&amp;lt; endl; } cout &amp;lt;&amp;lt; &amp;#34;while 外代码&amp;#34; &amp;lt;&amp;lt; endl; return 0; } </description>
    </item>
    
    <item>
      <title>演讲比赛流程管理案例</title>
      <link>https://874656645.github.io/posts/92-%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Sat, 22 Jan 2022 17:21:43 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/92-%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>常用算法</title>
      <link>https://874656645.github.io/posts/91-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 22 Jan 2022 09:31:07 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/91-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</guid>
      <description>一、常用遍历算法 1. for_each 2. transform  搬运的目标容器必须要提前开辟空间（resize 而不是 reserve），否则无法正常搬运  int main() { vector&amp;lt;int&amp;gt; v; for(int i = 0; i &amp;lt; 10; ++i){ v.push_back(i); } vector&amp;lt;int&amp;gt; v1; v1.resize(v.size()); // 要用 resize, 不能用 reserve  transform(v.begin(), v.end(), v1.begin(), [](int v){ return v * 2;}); for_each(v1.begin(), v1.end(), [](int v){ cout &amp;lt;&amp;lt; v &amp;lt;&amp;lt; &amp;#34; &amp;#34;; }); cout &amp;lt;&amp;lt; endl; return 0; } 二、常用查找算法 1. find 2. find_if 3. adjacent_find 4. binary_search  无序序列不可用  5.</description>
    </item>
    
    <item>
      <title>内建函数对象 functional</title>
      <link>https://874656645.github.io/posts/90-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-functional/</link>
      <pubDate>Thu, 20 Jan 2022 21:28:13 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/90-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-functional/</guid>
      <description>算术仿函数 template&amp;lt;class T&amp;gt; T plus&amp;lt;T&amp;gt; //加法仿函数 template&amp;lt;class T&amp;gt; T minus&amp;lt;T&amp;gt; //减法仿函数 template&amp;lt;class T&amp;gt; T multiplies&amp;lt;T&amp;gt; //乘法仿函数 template&amp;lt;class T&amp;gt; T divides&amp;lt;T&amp;gt; //除法仿函数 template&amp;lt;class T&amp;gt; T modulus&amp;lt;T&amp;gt; //取模仿函数 template&amp;lt;class T&amp;gt; T negate&amp;lt;T&amp;gt; //取反仿函数 一元谓词 关系仿函数 template&amp;lt;class T&amp;gt; bool equal_to&amp;lt;T&amp;gt; //等于 template&amp;lt;class T&amp;gt; bool not_equal_to&amp;lt;T&amp;gt; //不等于 template&amp;lt;class T&amp;gt; bool greater&amp;lt;T&amp;gt; //大于 template&amp;lt;class T&amp;gt; bool greater_equal&amp;lt;T&amp;gt; //大于等于 template&amp;lt;class T&amp;gt; bool less&amp;lt;T&amp;gt; //小于 template&amp;lt;class T&amp;gt; bool less_equal&amp;lt;T&amp;gt; //小于等于 逻辑仿函数 template&amp;lt;class T&amp;gt; bool logical_and&amp;lt;T&amp;gt; //逻辑与 template&amp;lt;class T&amp;gt; bool logical_or&amp;lt;T&amp;gt; //逻辑或 template&amp;lt;class T&amp;gt; bool logical_not&amp;lt;T&amp;gt; //逻辑非 </description>
    </item>
    
    <item>
      <title>函数对象与 predicate 谓词</title>
      <link>https://874656645.github.io/posts/89-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%B8%8E-predicate-%E8%B0%93%E8%AF%8D/</link>
      <pubDate>Thu, 20 Jan 2022 21:04:13 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/89-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%B8%8E-predicate-%E8%B0%93%E8%AF%8D/</guid>
      <description>函数对象 重载函数调用操作符 () 的 类，其对象常称为函数对象
 函数对象可以有自己的状态 函数对象可以作为参数传递 一个参数的函数对象叫做一元仿函数 两个参数的函数对象叫做二元仿函数  什么是谓词 返回 bool 类型的仿函数称为谓词
一元谓词 如果 operator() 接受一个参数，那么叫做一元谓词
比如 find_if 算法
二元谓词 如果 operator() 接受两个参数，那么叫做二元谓词
比如 sort 算法</description>
    </item>
    
    <item>
      <title>map multimap 容器</title>
      <link>https://874656645.github.io/posts/88-map-multimap-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Thu, 20 Jan 2022 20:18:25 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/88-map-multimap-%E5%AE%B9%E5%99%A8/</guid>
      <description>特点  所有元素都会根据元素的键值自动排序 默认排序规则是从小到大，可以通过仿函数指定排序规则 map / multimap 属于关联式容器，底层结构是用红黑树实现 不可以修改键值，可以通过删除再插入的方式实现 可以根据 key 值快速找到 value 值 可以通过下标 [] 的方式快速查找、插入和更新对应的 value  案例  公司今天招聘了10个员工（ABCDEFGHIJ），10 名员工进入公司之后，需要指派员工在哪个部门工作 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 随机给 10 名员工分配部门和工资 通过 multimap 进行信息的插入 key(部门编号) value(员工) 分部门显示员工信息  思路：
 创建 10 名员工，放到 vector 中 遍历 vector 容器，取出每个员工，进行随机分组 分组后，将员工部门编号作为 key，具体员工作为 value，放入到 multimap 容器中 分部门显示员工信息  class Worker{ public: Worker(string name, int salary){ m_name = name; m_salary = salary; } void printWorker(){ cout &amp;lt;&amp;lt; &amp;#34;姓名：&amp;#34; &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;#34; 工资：&amp;#34; &amp;lt;&amp;lt; m_salary &amp;lt;&amp;lt; endl; } private: string m_name; int m_salary; }; void createWorkers(vector&amp;lt;Worker&amp;gt; &amp;amp;v){ string nameSeed = &amp;#34;ABCDEFGHIJ&amp;#34;; for(int i = 0; i &amp;lt; nameSeed.</description>
    </item>
    
    <item>
      <title>set multiset 容器</title>
      <link>https://874656645.github.io/posts/87-set-multiset-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 18 Jan 2022 21:20:48 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/87-set-multiset-%E5%AE%B9%E5%99%A8/</guid>
      <description>关联式容器 底层结构使用红黑树实现（二叉树-&amp;gt;二叉搜索树-&amp;gt;平衡二叉树-&amp;gt;红黑树） 自动排序 不可以修改值，可以通过删除再插入的方式实现  自定义数据类型：
class Person{ public: Person(string name, int age, int height){ this-&amp;gt;m_name = name; this-&amp;gt;m_age = age; this-&amp;gt;m_height = height; } bool operator&amp;lt;(const Person &amp;amp;p2) const{ // 注意：函数和形参都要添加 const 修饰符  if(this-&amp;gt;m_age == p2.m_age){ return this-&amp;gt;m_height &amp;gt; p2.m_height; } return this-&amp;gt;m_age &amp;lt; p2.m_age; } void printPerson()const{ cout &amp;lt;&amp;lt; &amp;#34;姓名：&amp;#34; &amp;lt;&amp;lt; this-&amp;gt;m_name &amp;lt;&amp;lt; &amp;#34; 年龄：&amp;#34; &amp;lt;&amp;lt; this-&amp;gt;m_age &amp;lt;&amp;lt; &amp;#34; 身高：&amp;#34; &amp;lt;&amp;lt; this-&amp;gt;m_height &amp;lt;&amp;lt; endl; } private: string m_name; int m_age; int m_height; }; int main() { set&amp;lt;Person&amp;gt; lp; lp.</description>
    </item>
    
    <item>
      <title>list 容器</title>
      <link>https://874656645.github.io/posts/86-list-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 18 Jan 2022 20:26:45 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/86-list-%E5%AE%B9%E5%99%A8/</guid>
      <description>注意事项  双向循环链表 不支持随机访问 因为不支持随机访问，所以也不能用全局的排序算法 sort 一般不支持随机访问的容器会自己提供 sort 方法 自定义类型要指定排序规则  排序案例 案例描述：将 Person 自定义数据类型进行排序，Person 中属性有姓名、年龄、身高
排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序
class Person{ public: Person(string name, int age, int height){ this-&amp;gt;m_name = name; this-&amp;gt;m_age = age; this-&amp;gt;m_height = height; } bool operator&amp;lt;(const Person &amp;amp;p2){ if(this-&amp;gt;m_age == p2.m_age){ return this-&amp;gt;m_height &amp;gt; p2.m_height; } return this-&amp;gt;m_age &amp;lt; p2.m_age; } void printPerson()const{ cout &amp;lt;&amp;lt; &amp;#34;姓名：&amp;#34; &amp;lt;&amp;lt; this-&amp;gt;m_name &amp;lt;&amp;lt; &amp;#34; 年龄：&amp;#34; &amp;lt;&amp;lt; this-&amp;gt;m_age &amp;lt;&amp;lt; &amp;#34; 身高：&amp;#34; &amp;lt;&amp;lt; this-&amp;gt;m_height &amp;lt;&amp;lt; endl; } private: string m_name; int m_age; int m_height; }; int main() { list&amp;lt;Person&amp;gt; lp; lp.</description>
    </item>
    
    <item>
      <title>queue 队列容器适配器</title>
      <link>https://874656645.github.io/posts/85-queue-%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Mon, 17 Jan 2022 19:41:48 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/85-queue-%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8/</guid>
      <description>先进先出 不允许遍历元素  queue 队列操作：
size()
empty()</description>
    </item>
    
    <item>
      <title>stack 栈容器适配器</title>
      <link>https://874656645.github.io/posts/84-stack-%E6%A0%88%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sun, 16 Jan 2022 22:17:43 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/84-stack-%E6%A0%88%E5%AE%B9%E5%99%A8/</guid>
      <description>先进后出 栈不允许遍历元素 不能随机存取  stack 栈操作:
size()
empty()</description>
    </item>
    
    <item>
      <title>评委打分案例</title>
      <link>https://874656645.github.io/posts/83-%E8%AF%84%E5%A7%94%E6%89%93%E5%88%86%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Sun, 16 Jan 2022 22:10:49 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/83-%E8%AF%84%E5%A7%94%E6%89%93%E5%88%86%E6%A1%88%E4%BE%8B/</guid>
      <description>有 5 名选手：选手 ABCDE，10 个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。
分析：
 创建五名选手，放到 vector 中 遍历 vector 容器，取出来每一个选手，执行 for 循环，可以把 10 个评委打分存到 deque 容器中 sort 算法对 deque 容器中分数排序，去除最高和最低分 deque 容器遍历一遍，累加总分 获取平均分  class Player{ public: Player(string name){ m_name = name; m_avgScore = 0; } void setAvgScore(int v){ m_avgScore = v; } void printInfo()const{ cout &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;#34;的平均分为：&amp;#34; &amp;lt;&amp;lt; m_avgScore &amp;lt;&amp;lt; endl; } private: string m_name; int m_avgScore; }; void createPlayers(vector&amp;lt;Player&amp;gt; &amp;amp;v){ string nameSeed = &amp;#34;ABCDE&amp;#34;; for(int i = 0; i &amp;lt; nameSeed.</description>
    </item>
    
    <item>
      <title>生成随机数</title>
      <link>https://874656645.github.io/posts/82-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Sun, 16 Jan 2022 22:02:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/82-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      <description>#include &amp;lt;ctime&amp;gt;using namespace std; int main() { srand((unsigned int)time(NULL)); cout &amp;lt;&amp;lt; rand() % 40 &amp;lt;&amp;lt; endl; return 0; } </description>
    </item>
    
    <item>
      <title>deque 容器</title>
      <link>https://874656645.github.io/posts/81-deque-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sun, 16 Jan 2022 20:38:31 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/81-deque-%E5%AE%B9%E5%99%A8/</guid>
      <description>deque 容器的空间不用手动收缩，类内部会自动处理</description>
    </item>
    
    <item>
      <title>巧妙收缩 vector 空间</title>
      <link>https://874656645.github.io/posts/80-%E5%B7%A7%E5%A6%99%E6%94%B6%E7%BC%A9-vector-%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Sun, 16 Jan 2022 19:52:12 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/80-%E5%B7%A7%E5%A6%99%E6%94%B6%E7%BC%A9-vector-%E7%A9%BA%E9%97%B4/</guid>
      <description>resize() 或者 erase() 后 vector 的空间大小不会自动减小  int main() { vector&amp;lt;int&amp;gt; v; for(int i = 0; i &amp;lt; 100000; ++i){ v.push_back(i); } cout &amp;lt;&amp;lt; &amp;#34;size: &amp;#34; &amp;lt;&amp;lt; v.size() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;capacity: &amp;#34; &amp;lt;&amp;lt; v.capacity() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;-----------------------&amp;#34; &amp;lt;&amp;lt; endl; v.resize(10); cout &amp;lt;&amp;lt; &amp;#34;size: &amp;#34; &amp;lt;&amp;lt; v.size() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;capacity: &amp;#34; &amp;lt;&amp;lt; v.capacity() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;-----------------------&amp;#34; &amp;lt;&amp;lt; endl; vector&amp;lt;int&amp;gt;(v).swap(v); cout &amp;lt;&amp;lt; &amp;#34;size: &amp;#34; &amp;lt;&amp;lt; v.</description>
    </item>
    
    <item>
      <title>vector 中的元素存放在堆上还是栈上</title>
      <link>https://874656645.github.io/posts/79-vector-%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E5%AD%98%E6%94%BE%E5%9C%A8%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%A0%88%E4%B8%8A/</link>
      <pubDate>Sun, 16 Jan 2022 15:50:29 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/79-vector-%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E5%AD%98%E6%94%BE%E5%9C%A8%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%A0%88%E4%B8%8A/</guid>
      <description>结论  allocator 分配器是定义内存模型的类，用于标准库的某些部分，尤其是 STL 容器，如果所有标准容器的最后一个(可选)模板参数没有指定，那么它将使用这个分配器，并且它是标准库中唯一一个预定义的分配器 vector 中存放的如果是对象类型，则会通过 allocator 在堆上开辟足够的空间来存放和管理集合中的对象 vector 中存放指针类型，一定要记得手动释放内存  存放对象 class Person{ public: Person(int age, int id){ m_age = age; m_id = id; cout &amp;lt;&amp;lt; &amp;#34;Person(int, int)...&amp;#34; &amp;lt;&amp;lt; endl; } Person(const Person&amp;amp; p){ m_age = p.m_age; m_id = p.m_id; cout &amp;lt;&amp;lt; &amp;#34;Person(const Person&amp;amp; p)...&amp;#34; &amp;lt;&amp;lt; endl; } ~Person(){ cout &amp;lt;&amp;lt; &amp;#34;~Person()...&amp;#34; &amp;lt;&amp;lt; endl; } void* operator new(size_t size){ void* p = malloc(size); cout &amp;lt;&amp;lt; &amp;#34;new()...&amp;#34; &amp;lt;&amp;lt; endl; return p; } void operator delete(void *p){ cout &amp;lt;&amp;lt; &amp;#34;delete().</description>
    </item>
    
    <item>
      <title>STL Hello World</title>
      <link>https://874656645.github.io/posts/78-stl-hello-world/</link>
      <pubDate>Sun, 16 Jan 2022 12:31:08 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/78-stl-hello-world/</guid>
      <description> 平时要有容器、算法、迭代器的思维模式 容器提供迭代器，算法使用迭代器  // 算法 int count(int* begin, int* end, int val){ int n = 0; while(begin != end){ if(*begin == val){ n++; } begin++; } return n; } int main() { // 容器  int arr[] = {1, 3, 0, 5, 1, 3, 1, 0}; // 迭代器  int* begin = arr; int* end = *(&amp;amp;arr + 1); int n = count(begin, end, 1); cout &amp;lt;&amp;lt; &amp;#34;count: &amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; endl; return 0; } </description>
    </item>
    
    <item>
      <title>文件操作</title>
      <link>https://874656645.github.io/posts/77-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 16 Jan 2022 09:47:21 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/77-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>一、文件读写  文件输入流 ifstream 文件输出流 ofstream 文件输入输出流 fstream 文件的打开方式 文件流的状态 文件流的定位：文件指针（输入指针、输出指针）  二、文本文件 #include &amp;lt;iostream&amp;gt;#include &amp;lt;fstream&amp;gt;using namespace std; void ReadWriteFile(){ ifstream ifs(&amp;#34;D:\\Users\\cui_z\\Desktop\\source.txt&amp;#34;, ios::in); ofstream ofs(&amp;#34;D:\\Users\\cui_z\\Desktop\\target.txt&amp;#34;, ios::out | ios::app); if (!ifs) { cout &amp;lt;&amp;lt; &amp;#34;输入文件打开失败&amp;#34; &amp;lt;&amp;lt; endl; return; } if (!ofs) { cout &amp;lt;&amp;lt; &amp;#34;输出文件打开失败&amp;#34; &amp;lt;&amp;lt; endl; return; } char ch; while (ifs.get(ch)) { cout &amp;lt;&amp;lt; ch; ofs &amp;lt;&amp;lt; ch; } ifs.close(); ofs.close(); } 三、二进制文件  文本文件和二进制文件在计算机中都是以二进制的方式存储的 程序中的对象都是二进制存储的 Windows 中的文本文件换行符用 \r\n 表示，二进制是以 \n 存储，所以存储和显示时会做一下转换 Linux 中二进制和文本文件换行都是以 \n 存储和表示  class Person { private: int m_age; int m_id; public: Person():m_age(0), m_id(0){ } Person(int age, int id){ m_age = age; m_id = id; } ~Person() = default; void show(){ cout &amp;lt;&amp;lt; &amp;#34;Age: &amp;#34; &amp;lt;&amp;lt; m_age &amp;lt;&amp;lt; &amp;#34; ID: &amp;#34; &amp;lt;&amp;lt; m_id &amp;lt;&amp;lt; endl; } }; void BinaryReadWrite(){ // 存储二进制  ofstream ofs(&amp;#34;D:\\Users\\cui_z\\Desktop\\target.</description>
    </item>
    
    <item>
      <title>格式化输出</title>
      <link>https://874656645.github.io/posts/76-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</link>
      <pubDate>Sun, 16 Jan 2022 09:12:08 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/76-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</guid>
      <description>#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iomanip&amp;gt; // 控制符头文件using namespace std; // 格式化输出 void func(){ // 方式一：使用成员方法  int number = 10; cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; endl; cout.unsetf(ios::dec); // 八进制  cout.setf(ios::oct); cout.setf(ios::showbase); cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; endl; // 012  // 十六进制  cout.unsetf(ios::oct); cout.setf(ios::hex); cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; endl; // 0xa  // 固定宽度  cout.width(10); cout.fill(&amp;#39;*&amp;#39;); cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; endl; // *******0xa  // 上面的设置只对当前输出有效，下次的输出格式要重新设置  cout.setf(ios::left); cout.width(10); cout.</description>
    </item>
    
    <item>
      <title>异常接口声明</title>
      <link>https://874656645.github.io/posts/75-%E5%BC%82%E5%B8%B8%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Sat, 15 Jan 2022 18:26:49 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/75-%E5%BC%82%E5%B8%B8%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E/</guid>
      <description>C++ 异常
 C++11 不再建议使用异常规范  // 异常规范 只能抛出 int float char 三种类型的异常 C++11以后不再建议使用 void func1() throw(int, float, char){ throw &amp;#34;string&amp;#34;; // terminate called after throwing an instance of &amp;#39;char const*&amp;#39; } // 不能抛出任何类型的异常 OK void func2() throw(){ throw -1; // terminate called after throwing an instance of &amp;#39;int&amp;#39; } // 可以抛出任何类型的异常 void func3(){ throw &amp;#34;error&amp;#34;; } int main() { try{ func1(); } catch(char const * e){ cout &amp;lt;&amp;lt; e &amp;lt;&amp;lt; endl; } catch(.</description>
    </item>
    
    <item>
      <title>栈解旋 Unwinding</title>
      <link>https://874656645.github.io/posts/74-%E6%A0%88%E8%A7%A3%E6%97%8B-unwinding/</link>
      <pubDate>Sat, 15 Jan 2022 18:07:46 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/74-%E6%A0%88%E8%A7%A3%E6%97%8B-unwinding/</guid>
      <description>异常被抛出后，从进入 try 块起到异常被抛出前，这期间在栈上构造的所有对象都会被自动析构，析构的顺序与构造的顺序相反。
与 return 类似
class Test{ public: Test(string name){ m_name = name; cout &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;#34;被构造了&amp;#34; &amp;lt;&amp;lt; endl; } ~Test(){ cout &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;#34;被析构了&amp;#34; &amp;lt;&amp;lt; endl; } private: string m_name; }; double func1(int x, int y){ Test t1(&amp;#34;t1&amp;#34;), t2(&amp;#34;t2&amp;#34;); if(y == 0){ throw y; } return x / y; } int main() { try{ Test t3(&amp;#34;t3&amp;#34;), t4(&amp;#34;t4&amp;#34;); func1(10, 0); } catch(int e){ cout &amp;lt;&amp;lt; &amp;#34;除数为 &amp;#34; &amp;lt;&amp;lt; e &amp;lt;&amp;lt; endl; } return 0; } t3被构造了 t4被构造了 t1被构造了 t2被构造了 t2被析构了 t1被析构了 t4被析构了 t3被析构了 除数为 0 </description>
    </item>
    
    <item>
      <title>异常</title>
      <link>https://874656645.github.io/posts/57-%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Sat, 15 Jan 2022 17:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/57-%E5%BC%82%E5%B8%B8/</guid>
      <description>一、try、catch、throw  可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型 C++ 异常机制是跨函数的，且是必须处理的。如果中间函数没有处理就一直抛到最顶层，如果 main 函数也不处理，程序就会挂掉  int main( ) { try{ throw &amp;#34;exception&amp;#34;; }catch(const char * e){ cout &amp;lt;&amp;lt; e &amp;lt;&amp;lt; endl; }catch(...){ // 捕获所有异常  cout &amp;lt;&amp;lt; &amp;#34;...&amp;#34; &amp;lt;&amp;lt; endl; } { cout &amp;lt;&amp;lt; &amp;#34;finally&amp;#34; &amp;lt;&amp;lt; endl; } return 0; } 输出：
Start exception finally 0 Finish 二、std::exception class exception { public: exception() throw(); exception(const exception&amp;amp; rhs) throw(); exception&amp;amp; operator=(const exception&amp;amp; rhs) throw(); virtual ~exception() throw(); virtual const char *what() const throw(); }; 派生了两个异常类：</description>
    </item>
    
    <item>
      <title>类型转换</title>
      <link>https://874656645.github.io/posts/73-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sat, 15 Jan 2022 15:55:28 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/73-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>1. static_cast&amp;lt;&amp;gt;  可以转换内置数据类型； 不可以转换没有关系的指针或引用； 可以转换有继承关系的指针或引用（父类转子类或子类转父类都可以）；  // static_cast&amp;lt;&amp;gt;  // 1. 内置对象  int a = 97; char c = static_cast&amp;lt;char&amp;gt;(a); // OK  cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl; // 2. 自定义类型对象  // Building bb;  // Animal aa = static_cast&amp;lt;Animal&amp;gt;(bb); // error: no matching function for call to ‘Animal::Animal(Building&amp;amp;)’  // 3. 不同类型的指针转换  // int *p = &amp;amp;a;  // char *pc = static_cast&amp;lt;char*&amp;gt;(p); // error: invalid static_cast from type ‘int*’ to type ‘char*’  // cout &amp;lt;&amp;lt; pc &amp;lt;&amp;lt; endl;  // Animal * pa = NULL;  // Building *pb = static_cast&amp;lt;Building*&amp;gt;(pa); // error: invalid static_cast from type ‘Animal*’ to type ‘Building*’  // 4.</description>
    </item>
    
    <item>
      <title>自定义数组实现</title>
      <link>https://874656645.github.io/posts/72-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 15 Jan 2022 13:36:04 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/72-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>要求  可以对内置数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及 operator= 防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量  实现 template&amp;lt;class T&amp;gt; class MyArray{ public: MyArray(int capacity){ this-&amp;gt;m_capacity = capacity; this-&amp;gt;m_size = 0; this-&amp;gt;m_addr = new T[this-&amp;gt;m_capacity]; } MyArray(const MyArray&amp;amp; arr){ if(arr.m_addr == NULL){ return; } // 深拷贝  this-&amp;gt;m_capacity = arr.m_capacity; this-&amp;gt;m_size = arr.m_size; this-&amp;gt;m_addr = new T[this-&amp;gt;m_capacity]; for(int i = 0; i &amp;lt; m_size; ++i){ // T 类型是可拷贝的，= 运算符也是深拷贝  this-&amp;gt;m_addr[i] = arr.m_addr[i]; } } MyArray&amp;amp; operator=(const MyArray&amp;amp; arr){ if(this == &amp;amp;arr){ return *this; } if(this-&amp;gt;m_addr !</description>
    </item>
    
    <item>
      <title>类模板</title>
      <link>https://874656645.github.io/posts/71-%E7%B1%BB%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Wed, 12 Jan 2022 22:47:51 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/71-%E7%B1%BB%E6%A8%A1%E6%9D%BF/</guid>
      <description>一、类模板写法 1. 声明和定义写在一起 template&amp;lt;class T&amp;gt; class Person{ public: Person(T age){ this-&amp;gt;m_age = age; } void Show(){ cout &amp;lt;&amp;lt; this-&amp;gt;m_age &amp;lt;&amp;lt; endl; } private: T m_age; }; int main() { Person&amp;lt;int&amp;gt; p(20); p.Show(); cout &amp;lt;&amp;lt; p &amp;lt;&amp;lt; endl; printP(p); return 0; } 2. 声明和定义分开写，但在同一文件中 template&amp;lt;class T&amp;gt; class Person{ public: Person(T age); void Show(); private: T m_age; }; template&amp;lt;class T&amp;gt; Person&amp;lt;T&amp;gt;::Person(T age){ this-&amp;gt;m_age = age; } template&amp;lt;class T&amp;gt; void Person&amp;lt;T&amp;gt;::Show(){ cout &amp;lt;&amp;lt; this-&amp;gt;m_age &amp;lt;&amp;lt; endl; } int main() { Person&amp;lt;int&amp;gt; p(20); p.</description>
    </item>
    
    <item>
      <title>编译过程</title>
      <link>https://874656645.github.io/posts/70-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Wed, 12 Jan 2022 20:12:00 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/70-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</guid>
      <description>各个 .cpp 文件是独立编译的，如果有其它的类和函数会先在本 .o 文件中生成符号，由最后的链接器去其它 .o 文件找具体的函数定义
 .c .cpp 文件经过 预编译器拷贝头文件、宏展开 生成 .i 文件（文本文件）
g++ -E main.cpp -o main.i .i 文件经过 编译器 生成汇编程序 .s（文本文件）
g++ -S main.i -o main.s .s 文件经过 汇编器 生成可定位目标文件 .o （二进制）
Windows:
g++ -c main.s -o main.obj
Linux:
g++ -c main.s -o main.o .o 文件经过 链接器 生成可执行目标文件 .exe .dll
g++ main.s -o main  </description>
    </item>
    
    <item>
      <title>函数模板</title>
      <link>https://874656645.github.io/posts/69-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Tue, 11 Jan 2022 21:40:09 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/69-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</guid>
      <description>函数模板必须严格类型匹配，普通函数则可以进行数据类型隐式转换 对于内置数据类型，函数模板可进行推导，自定义类型不可以 函数模板可被重载 C++ 编译器优先考虑普通函数 可以通过空模板实参列表的语法限定编译器只能通过模板匹配 如果函数模板可以产生一个更好的匹配，就选择模板 编译器根据函数模板调用情况，从函数模板和具体类型产生不同的函数
编译器会对函数模板进行两次编译  在声明的地方对模板代码本身进行编译； 在调用的地方对参数替换后的代码进行编译    template&amp;lt;class T&amp;gt; T MyAdd(T a, T b){ return a + b; } // 函数一 int MyAdd(int a, int b){ return a + b; } // 函数二 int MyAdd(int a, char c){ return a + c; } int main() { cout &amp;lt;&amp;lt; MyAdd(1, 2) &amp;lt;&amp;lt; endl; // 优先调用普通函数  cout &amp;lt;&amp;lt; MyAdd&amp;lt;&amp;gt;(1, 2) &amp;lt;&amp;lt; endl; // 强制调用模板函数  cout &amp;lt;&amp;lt; MyAdd(1.</description>
    </item>
    
    <item>
      <title>C 语言面向接口编程</title>
      <link>https://874656645.github.io/posts/68-c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 10 Jan 2022 22:23:34 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/68-c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/</guid>
      <description>通过函数指针实现多态，注册回调函数的方式
void printAllArray(void* arr, int eleSize, int len, void(*myPrint)(void*)){ char* arrStart = (char*)arr; for(int i = 0; i &amp;lt; len; ++i){ char* eleStart = arrStart + i * eleSize; myPrint(eleStart); } printf(&amp;#34;\n&amp;#34;); } void printInt(void* data){ int* ele = (int*)data; printf(&amp;#34;%d &amp;#34;, *ele); } struct Person{ char name[64]; int age; }; void printPerson(void* data){ struct Person* ele = (struct Person*)data; printf(&amp;#34;Name: %s, Age: %d \n&amp;#34;, ele-&amp;gt;name, ele-&amp;gt;age); } int main() { int arr[] = {1, 2, 3, 4, 5}; printAllArray(arr, sizeof(int), 5, printInt); struct Person personArr[] = { {&amp;#34;aaa&amp;#34;, 20}, {&amp;#34;bbb&amp;#34;, 30}, {&amp;#34;ccc&amp;#34;, 40}, {&amp;#34;ddd&amp;#34;, 50}, {&amp;#34;eee&amp;#34;, 60}, }; printAllArray(personArr, sizeof(struct Person), 5, printPerson); return 0; } 输出：</description>
    </item>
    
    <item>
      <title>面向抽象类编程</title>
      <link>https://874656645.github.io/posts/67-%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sun, 09 Jan 2022 19:12:37 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/67-%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%BC%96%E7%A8%8B/</guid>
      <description>三层架构：业务逻辑层、抽象层、实现层
原则：依赖倒转
案例一：动物园 设计实现：
 抽象层：Animal
提供接口 voice 实现层：Dog、Cat
分别实现 voice ，发出不同的声音 业务层：main 函数调用，只通过 Animal 的指针统一实现业务  案例二：编写一个 C++ 程序, 计算程序员( programmer )工资  要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer )的工资 要求利用抽象类统一界面，方便程序的扩展，比如:新增，计算架构师( architect ) 的工资  设计实现：
 抽象层：Programmer
提供计算工资的接口 实现层：JuniorProgrammer、MidProgrammer、AdvProgrammer
分别对计算工资接口进行实现 业务层：通过 Programmer 类统一管理，实现业务逻辑，同时业务的可扩展性更强，如新增架构师类型  案例三：电脑组装，面向抽象层编程  组装电脑有 3 个抽象类，抽象的 cpu，抽象的显卡，抽象的内存。 现在要求组装两台电脑，一台是 Intel 的 CPU，Intel 的显卡和 Intel 的内存。另一台是 Intel 的 CPU、Nvidia 的显卡和 Kingston 的内存条。 针对抽象层编程。  设计实现：</description>
    </item>
    
    <item>
      <title>实现一个简单的字符串类</title>
      <link>https://874656645.github.io/posts/66-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/</link>
      <pubDate>Sat, 08 Jan 2022 14:01:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/66-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/</guid>
      <description>MyString.h
#ifndef __MYSTRING_H_ #define __MYSTRING_H_  #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; class MyString { // 重载 &amp;lt;&amp;lt;  // 最好是 const 的，可以输出匿名变量（匿名变量不能被非 const 的左值引用接收）  friend ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream &amp;amp;os, const MyString &amp;amp;s); // 重载 &amp;gt;&amp;gt;  friend istream&amp;amp; operator&amp;gt;&amp;gt;(istream &amp;amp;is, MyString &amp;amp;s); private: // 字符串的有效长度  int m_len; // 字符串指针  char* m_pStr; public: MyString(); MyString(const char *); MyString(const MyString &amp;amp;); ~MyString(); // 重载 =  MyString&amp;amp; operator=(const MyString &amp;amp;); // 重载 []  char&amp;amp; operator[](int index); // 重载 +  MyString operator+(const MyString &amp;amp;); // 重载 +=  MyString&amp;amp; operator+=(const MyString &amp;amp;); // 重载 ==  bool operator==(const MyString &amp;amp;); // 重载 !</description>
    </item>
    
    <item>
      <title>静态数组初始化</title>
      <link>https://874656645.github.io/posts/65-%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Sat, 08 Jan 2022 13:50:12 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/65-%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>1. 声明静态数组后一定要进行初始化，否则里面的值都是未知的 int main() { int ia[3] = {0}; // 这虽然只是给第一个元素赋了值，但剩余未赋值的元素都会初始化为0  char ca[3] = {0}; double da[3]; bool ba[3]; short sa[3]; float fa[3]; for(auto &amp;amp; i : da){ cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } return 0; } 输出：
6.95128e-310 4.63759e-310 0 2. C++ 数组指针和数组类型  数组类型和数组指针（数组名）不是一种类型，只是恰好指向的地址相同而已 数组名是指针常量（int * const），代表数组中第一个元素的地址 数组类型代表整个数组  int main() { int arr[10]; cout &amp;lt;&amp;lt; arr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; arr + 1 &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;----------&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;amp;arr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;amp;arr + 1 &amp;lt;&amp;lt; endl; return 0; } 输出：</description>
    </item>
    
    <item>
      <title>VS Code 搭建 c&#43;&#43; gdb 开发环境</title>
      <link>https://874656645.github.io/posts/64-vs-code-%E6%90%AD%E5%BB%BA-c&#43;&#43;-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 06 Jan 2022 20:24:21 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/64-vs-code-%E6%90%AD%E5%BB%BA-c&#43;&#43;-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>一、安装 C++ 开发环境 Using GCC with MinGW
 安装 MSYS2 更新 MSYS2 pacman -Syu 在开始菜单中运行 MSYS2 MSYS，更新其余的基本包 pacman -Su 安装 C++ 开发环境：  clang++ x64 gdb: pacman -S --needed base-devel mingw-w64-ucrt-x86_64-clang mingw-w64-ucrt-x86_64-gdb g++ gdb: pacman -S --needed base-devel mingw-w64-x86_64-toolchain clang++ lldb: pacman -S --needed base-devel mingw-w64-clang-x86_64-lldb
这个库会把 clang clang++ 等库安装到 msys64/clang64/bin 目录，但是 lldb 在 Windows 上的调试效果不如 gdb clang++ x86：pacman -S --needed base-devel mingw-w64-i686-clang   添加环境变量 D:\msys64\ucrt64\bin 检查是否安装成功  clang++ --version g++ --version gdb --version    pacman -Syu // 更新整个系统 pacman -Su // 更新已安装的包 pacman -Ss 关键字 // 搜索含关键字的包 pacman -S 包名 // 安装包，也可以同时安装多个包，只需以空格分隔包名即可 pacman -Rs 包名 // 删除包及其依赖 pacman -R 包名 // 删除包 二、配置 VS Code 主要是修改 task.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 内存对齐</title>
      <link>https://874656645.github.io/posts/63-c&#43;&#43;-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Thu, 06 Jan 2022 18:13:09 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/63-c&#43;&#43;-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</guid>
      <description>C/C++内存对齐详解
内存对齐规则  对齐系数（也叫对齐模数）：gcc中默认 #pragma pack(4)，可以通过预编译命令 #pragma pack(n)，n = 1,2,4,8,16 来改变这一系数 有效对齐值：是给定值 #pragma pack(n) 和结构体中 最长数据类型长度中较小的那个。有效对齐值也叫 对齐单位    规则一：结构体第一个成员的偏移量 offset 为 0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节
  规则二：结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节
注意：上面两条规则都需要得到满足
注意：成员变量首地址偏移和对齐都是与【有效对齐值】进行比较，而有效对齐值是对齐系数与结构体中最长数据类型中的较小者
  // 64 位程序 struct { int i; char c1; char c2; }x1; struct{ char c1; int i; char c2; }x2; struct{ char c1; char c2; int i; }x3; struct { short i; char c1; char c2; }y1; struct{ char c1; short i; char c2; }y2; struct{ char c1; char c2; short i; }y3; int main() { printf(&amp;#34;%ld\n&amp;#34;,sizeof(x1)); // 输出8  printf(&amp;#34;%ld\n&amp;#34;,sizeof(x2)); // 输出12  printf(&amp;#34;%ld\n&amp;#34;,sizeof(x3)); // 输出8  cout &amp;lt;&amp;lt; &amp;#34;----------------&amp;#34; &amp;lt;&amp;lt; endl; printf(&amp;#34;%ld\n&amp;#34;,sizeof(y1)); // 输出4  printf(&amp;#34;%ld\n&amp;#34;,sizeof(y2)); // 输出6  printf(&amp;#34;%ld\n&amp;#34;,sizeof(y3)); // 输出4  return 0; } 既要考虑首地址偏移，又要是有效对齐值（对齐单位）的整数倍 y1 y2 y3结构体：</description>
    </item>
    
    <item>
      <title>自定义智能指针</title>
      <link>https://874656645.github.io/posts/62-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 04 Jan 2022 21:07:15 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/62-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description>使用模板类 重载 -&amp;gt; 操作符 重载 * 操作符  template&amp;lt;typename T&amp;gt; class MyAutoPtr{ public: MyAutoPtr(T * t){ ptr = t; } ~MyAutoPtr(){ if(ptr != NULL){ delete ptr; ptr = NULL; } } T* operator-&amp;gt;(){ // 相当于 ptr-&amp;gt; , 所以返回 ptr 指针即可，将所有操作转发给真正的指针变量  return ptr; } T&amp;amp; operator*(){ // 相当于 (*ptr) ，所以返回 ptr 指向的对象引用即可  return *ptr; } private: T* ptr; }; class A{ public: A(int a){ cout &amp;lt;&amp;lt; &amp;#34;A(int)...&amp;#34; &amp;lt;&amp;lt; endl; this-&amp;gt;a = a; } ~A(){ cout &amp;lt;&amp;lt; &amp;#34;~A().</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 多线程</title>
      <link>https://874656645.github.io/posts/61-c&#43;&#43;-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 04 Jan 2022 14:02:20 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/61-c&#43;&#43;-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>一、进程与线程  进程是资源分配和调度的一个独立单位；而线程是进程的一个实体，是 CPU 调度和分配的基本单位 同一个进程中的多个线程的内存资源是共享的，各线程都可以改变进程中的变量。因此在执行多线程运算的时候要注意执行顺序  二、并行与并发  并行（parallellism）指的是多个任务在同一时刻同时在执行 并发（concurrency）是指在一个时间段内，多个任务交替进行。虽然看起来像在同时执行，但其实是交替的  三、多任务处理 多线程是多任务处理的一种特殊形式，一般情况下，有基于进程和基于线程的两种类型的多任务处理方式。
 基于进程的多任务处理是程序的并发执行 基于线程的多任务处理是同一程序的片段的并发执行  四、C++11 线程管理 thread 库  C++11 提供了多线程库，使用时需要 #include &amp;lt;thread&amp;gt; 头文件，该头文件主要包含了对线程的管理类 std::thread 以及其他管理线程相关的类 每个应用程序至少有一个进程，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个子线程。每个线程都需要一个入口函数，入口函数返回退出，该线程也会退出，主线程就是以 main 函数作为入口函数的线程 主线程退出后，运行中的子线程也会被销毁 std::thread 的构造函数需要的是可调用（callable）类型，除了函数外，还可以调用 lambda 表达式、重载了 () 运算符的类的实例 把函数对象传入 std::thread 时，应传入函数名称（不带括号） 当启动一个线程后，一定要在该线程 thread 销毁前，调用 join() 或者 detach()，确定以何种方式等待线程执行结束  detach 方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束 join 方式，等待关联的线程完成，才会继续执行 join() 后的代码 在以 detach 的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用按值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束    1、调用全局函数启动线程 #include &amp;lt;thread&amp;gt; using namespace std; void func(int i){ cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } int main() { for(int i = 0; i &amp;lt; 4; ++i){ // 创建一个线程t，第一个参数为调用的函数，第二个参数为传递的参数  thread t(func, i); // 表示允许该线程在后台运行  t.</description>
    </item>
    
    <item>
      <title>临时变量不能绑定 no-const 左值引用类型</title>
      <link>https://874656645.github.io/posts/60-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BAno-const%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0/</link>
      <pubDate>Tue, 04 Jan 2022 10:31:45 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/60-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BAno-const%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0/</guid>
      <description>error: cannot bind non-const lvalue reference of type ‘T&amp;amp;’ to an rvalue of type ‘T’
如果一个参数是以非 const 引用传入，c++ 编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。
但如果你 把一个临时变量当作非 const 引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉。
所以，修改一个临时变量是毫无意义的。据此，c++ 编译器加入了临时变量不能作为非 const 引用的这个语义限制。
c++ 中临时变量是右值类型，不能取引用，只能在当前行使用，不能作为非 const 的引用参数
std::move() 返回的也是一个右值
对于临时变量或字面量的右值引用可以使用 cosnt &amp;amp; 或 &amp;amp;&amp;amp; 类型的参数接收
一般来说，右值的地址不能通过解引用来获得，因为它们是字面量，或者因为它们本质上是临时的(例如由函数或显式构造函数调用返回的值)。通过将一个对象传递给这个函数，可以获得一个引用它的右值。
class T{ public: T(int v){ a = v; } T operator+(T &amp;amp;t){ T temp = this-&amp;gt;a + t.a; return temp; } void printT(T &amp;amp;t){ cout &amp;lt;&amp;lt; &amp;#34;a = &amp;#34; &amp;lt;&amp;lt; t.</description>
    </item>
    
    <item>
      <title>操作符重载</title>
      <link>https://874656645.github.io/posts/59-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Mon, 03 Jan 2022 13:54:11 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/59-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
      <description>还有类型转换函数
#include &amp;lt;iostream&amp;gt; using namespace std; class Complex{ // friend Complex complexAdd(Complex &amp;amp;c1, Complex &amp;amp;c2);  // friend Complex operator+(Complex &amp;amp;c1, Complex &amp;amp;c2);  // friend Complex&amp;amp; operator+= (Complex &amp;amp;c1, Complex &amp;amp;c2);  friend ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream &amp;amp;os, Complex &amp;amp;c); friend istream&amp;amp; operator&amp;gt;&amp;gt;(istream &amp;amp;is, Complex &amp;amp;c); public: Complex(){ cout &amp;lt;&amp;lt; &amp;#34;Complex()...&amp;#34; &amp;lt;&amp;lt; endl; a = 0; b = 0; } Complex(int a, int b){ cout &amp;lt;&amp;lt; &amp;#34;Complex(int, int)...&amp;#34; &amp;lt;&amp;lt; endl; this-&amp;gt;a = a; this-&amp;gt;b = b; } ~Complex(){ cout &amp;lt;&amp;lt; &amp;#34;~Complex().</description>
    </item>
    
    <item>
      <title>具有链表特性的类</title>
      <link>https://874656645.github.io/posts/58-%E5%85%B7%E6%9C%89%E9%93%BE%E8%A1%A8%E7%89%B9%E6%80%A7%E7%9A%84%E7%B1%BB/</link>
      <pubDate>Mon, 03 Jan 2022 09:21:17 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/58-%E5%85%B7%E6%9C%89%E9%93%BE%E8%A1%A8%E7%89%B9%E6%80%A7%E7%9A%84%E7%B1%BB/</guid>
      <description>买卖货物问题：
#include &amp;lt;iostream&amp;gt; using namespace std; class Goods{ public: Goods(){ m_pNext = nullptr; m_weight = 0; cout &amp;lt;&amp;lt; &amp;#34;买入了货物，重量是：&amp;#34; &amp;lt;&amp;lt; m_weight &amp;lt;&amp;lt; endl; } Goods(int weight){ m_pNext = nullptr; m_weight = weight; total_weight += m_weight; cout &amp;lt;&amp;lt; &amp;#34;买入了货物，重量是：&amp;#34; &amp;lt;&amp;lt; m_weight &amp;lt;&amp;lt; endl; } ~Goods(){ total_weight -= m_weight; // m_pNext 不是在本类中 new 的，所以也不用 delete  this-&amp;gt;m_pNext = nullptr; cout &amp;lt;&amp;lt; &amp;#34;卖出了货物，重量是：&amp;#34; &amp;lt;&amp;lt; m_weight &amp;lt;&amp;lt; endl; } static int getTotalWeight(){ return total_weight; } Goods *m_pNext; private: int m_weight; static int total_weight; }; int Goods::total_weight = 0; void buy(Goods *&amp;amp;head, int weight){ Goods *pNewGoods = new Goods(weight); if(head == nullptr){ head = pNewGoods; } else{ pNewGoods-&amp;gt;m_pNext = head; head = pNewGoods; } } void sale(Goods *&amp;amp;head){ if(head == nullptr){ cout &amp;lt;&amp;lt; &amp;#34;没有货物了&amp;#34; &amp;lt;&amp;lt; endl; return; } Goods *temp = head; head = head-&amp;gt;m_pNext; delete temp; temp = nullptr; } int main( ) { Goods *head = nullptr; int choice; do{ // 提供菜单  cout &amp;lt;&amp;lt; &amp;#34;输入 1 进货&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;输入 2 出货&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;输入 0 退出&amp;#34; &amp;lt;&amp;lt; endl; cin &amp;gt;&amp;gt; choice; switch(choice){ case 0: // 退出  return 0; case 1: { // 进货  int w = 0; cout &amp;lt;&amp;lt; &amp;#34;输入货物重量：&amp;#34; &amp;lt;&amp;lt; endl; cin &amp;gt;&amp;gt; w; buy(head, w); break; } case 2: // 出货  sale(head); break; } cout &amp;lt;&amp;lt; &amp;#34;目前货物的总重量是：&amp;#34; &amp;lt;&amp;lt; Goods::getTotalWeight() &amp;lt;&amp;lt; endl; }while(1); return 0; } 输出：</description>
    </item>
    
    <item>
      <title>STL 总结</title>
      <link>https://874656645.github.io/posts/56-stl-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 30 Dec 2021 10:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/56-stl-%E6%80%BB%E7%BB%93/</guid>
      <description>1、六大组件介绍  容器：数据结构，用来存放数据 算法：常用算法 迭代器：容器和算法之间的胶合剂，“范型指针” 仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数 配置器：为容器分配并管理内存 适配器：修改其他组件接口  2、STL 常用的容器有哪些以及各自的特点是什么?    名称 特点     vector 底层数据结构为数组，支持快速随机访问   list 底层数据结构为双向链表，支持快速增删   deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问   stack 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   queue 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   priority_queue 底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现   set 底层数据结构为红黑树，有序，不重复   multiset 底层数据结构为红黑树，有序，可重复   map 底层数据结构为红黑树，有序，不重复   multimap 底层数据结构为红黑树，有序，可重复   unordered_set 底层数据结构为hash表，无序，不重复   unordered_multiset 底层数据结构为hash表，无序，可重复   unordered_map 底层数据结构为hash表，无序，不重复   unordered_multimap 底层数据结构为hash表，无序，可重复    3、vector 和 list 的区别  vector底层实现是数组，所以在内存中是连续存放的，随机读取效率高，但插入、删除效率低；list底层实现是双向链表，所以在内存中是任意存放的，插入、删除效率高，但访问元素效率低 vector在中间节点进行插入、删除会导致内存拷贝，而list不会 vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请  4、vector 扩容原理 以原内存空间大小的两倍配置一份新的内存空间，并将原空间数据拷贝过来进行初始化</description>
    </item>
    
    <item>
      <title>vector</title>
      <link>https://874656645.github.io/posts/55-vector/</link>
      <pubDate>Wed, 29 Dec 2021 19:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/55-vector/</guid>
      <description>vector 常用操作 #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt; int main() { //1.定义和初始化  vector&amp;lt;int&amp;gt; vec1; //默认初始化，vec1为空  vector&amp;lt;int&amp;gt; vec2(vec1); //使用vec1初始化vec2  vector&amp;lt;int&amp;gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2  vector&amp;lt;int&amp;gt; vec4(10); //10个值为0的元素  vector&amp;lt;int&amp;gt; vec5(10,4); //10个值为4的元素  //2.常用操作方法  //2.1 添加函数  vec1.push_back(100); // 尾部添加元素  vec1.insert(vec1.end(),5,3); // 从vec1.back位置插入5个值为3的元素  //2.2 删除函数  vec1.pop_back(); // 删除末尾元素  vec1.erase(vec1.begin(),vec1.begin()+2); // 删除vec1[0]-vec1[2]之间的元素，不包括vec1[2]其他元素前移  vec1.clear(); // 清空元素，元素在内存中并未消失，通常使用swap()来清空  vector&amp;lt;int&amp;gt;().swap(V); // 利用swap函数和临时对象交换内存，交换以后，临时对象消失，释放内存。  // 必须是同类型的 vector  // 且只有存储对象时才有效  //2.3 遍历函数  vec1[0]; //取得第一个元素  vec1.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL</title>
      <link>https://874656645.github.io/posts/54-c&#43;&#43;-stl/</link>
      <pubDate>Wed, 29 Dec 2021 17:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/54-c&#43;&#43;-stl/</guid>
      <description>STL六大组件
STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。STL中包括六大组件：容器、算法、迭代器、适配器、仿函数、空间配置器
适配器：适配器是一种设计模式(设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结)，该中模式是将一个类的接口转换成客户希望的另外一个接口。
一、容器 序列式容器（vector、deque、list）、关联式容器（map、set）、容器适配器（stack、queue、priority_queue）
1. vector 是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。由于具有连续的存储空间，所以在插入和删除操作方面，效率比较慢
2. deque deque 是 double ended queue 的缩写，双向队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。与 vector 不同，deque 不能保证将所有元素存储在连续的存储空间上
3. list list 是 STL 实现的双向链表，与 vector 相比, 它允许快速的插入和删除，但是随机访问却比较慢
4. map、multimap、unordered_map、unordered_multimap  map 是 STL 的一个关联容器，它是一种键值对容器，里面的数据都是成对出现的，且键值是唯一的，可在我们处理一对一数据的时候，在编程上提供快速通道。map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。 multimap 中的元素也是有序的，但允许存在相同键值的 unordered_map 中的元素是唯一的，但无序（也不是插入顺序），而是根据它们的散列值（hash values）组织成桶（buckets），从而允许通过键值直接快速访问单个元素（速度一般比 map 更快） unordered_multimap 无序且不唯一  5. set、multiset、unordered_set、unordered_multiset  set 的含义是集合，它是一个有序的容器，里面的元素都是唯一且排序好的，支持插入、删除、查找等操作，就像一个集合一样，所有的操作都是严格在 logn时间内完成，效率非常高，使用方法类似 list multiset 也是排序好的，但是可以存有相同的元素 unordered_set 无序但元素是不可重复的 unordered_multiset 无序，元素也不唯一  二、容器适配器 虽然 stack、queue、priority_queue 中也可以存放元素，但在 STL 中并没有将其划分在容器的行列，而是将其称为容器适配器，这是因为每个容器在底层都有自己的实现方式，而 stack、queue、priority_queue 只是在底层将其他容器进行了封装
std::stack template&amp;lt;class T, class Container = deque&amp;lt;T&amp;gt;&amp;gt; class stack; std::queue template&amp;lt;class T, class Container = deque&amp;lt;T&amp;gt;&amp;gt; class queue; std::priority_queue template&amp;lt;class T, class Container = vector&amp;lt;T&amp;gt;, class Compare = less&amp;lt;typename Container::value_type&amp;gt;&amp;gt; class priority_queue; 为什么选择 deque 作为 stack 和 queue 的底层默认容器？</description>
    </item>
    
    <item>
      <title>new、delete 与内存</title>
      <link>https://874656645.github.io/posts/53-new-delete-%E4%B8%8E%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 29 Dec 2021 15:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/53-new-delete-%E4%B8%8E%E5%86%85%E5%AD%98/</guid>
      <description>C++ 中 new 操作符内幕：new operator、operator new、placement new 
1、new / delete 具体步骤 new
 第一步：调用 operator new 函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值 第三部：对象构造完成后，返回一个指向该对象的指针  delete
 第一步：调用对象的析构函数 第二步：编译器调用 operator delete 函数释放内存空间  2、new/delete 与 malloc/free 的区别是什么？  malloc/free 是 C 语言的标准库函数， new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存 malloc/free 不会去自动调用构造和析构函数，对于基本数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求 malloc/free 需要指定分配内存的大小，而 new/delete 会自动计算所需内存大小 new 返回的是指定对象的指针，而 malloc 返回的是 void*，因此 malloc 的返回值一般都需要进行强制类型转换  operator new 重载：
class Person{ public: Person(){ id = 0; score = 0; cout &amp;lt;&amp;lt; &amp;#34;Person()&amp;#34; &amp;lt;&amp;lt; endl; } Person(int id, int score):id(id),score(score){ cout &amp;lt;&amp;lt; &amp;#34;Person(int, int)&amp;#34; &amp;lt;&amp;lt; endl; } Person(const Person &amp;amp;p){ cout &amp;lt;&amp;lt; &amp;#34;Person(const Person &amp;amp;p)&amp;#34; &amp;lt;&amp;lt; endl; id = p.</description>
    </item>
    
    <item>
      <title>new 二维数组</title>
      <link>https://874656645.github.io/posts/52-new-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 29 Dec 2021 14:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/52-new-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>在堆上声明一个数组 int main( ) { #if 0// 方式一： int** pArr = NULL; pArr = new int*[4]; for(int i = 0; i &amp;lt; 4; i++){ pArr[i] = new int[8]; } for(int i = 0; i &amp;lt; 4; ++i){ for(int j = 0; j &amp;lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i &amp;lt; 4; ++i){ for(int j = 0; j &amp;lt; 8; ++j){ if(j == 0) cout &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; pArr[i][j] &amp;lt;&amp;lt; &amp;#39;\t&amp;#39;; } } // 删除 for(int i = 0; i &amp;lt; 4; ++i){ delete [] pArr[i]; } delete [] pArr; #endif  // 方式二：  cout &amp;lt;&amp;lt; sizeof(int[5]) &amp;lt;&amp;lt; endl; // 初始化  int(*pArr)[8] = new int[4][8]; memset(pArr, 0, sizeof(int[4][8])); // 或者  // int(*pArr)[8] = new int[4][8]{{0}};  cout &amp;lt;&amp;lt; sizeof(int[4][8]) &amp;lt;&amp;lt; endl; for(int i = 0; i &amp;lt; 4; ++i){ for(int j = 0; j &amp;lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i &amp;lt; 4; ++i){ for(int j = 0; j &amp;lt; 8; ++j){ cout &amp;lt;&amp;lt; pArr[i][j] &amp;lt;&amp;lt; &amp;#39;\t&amp;#39;; } cout &amp;lt;&amp;lt; endl; } cout &amp;lt;&amp;lt; endl; delete[] pArr; // 取地址  int arr[3][4]{{0}}; int(*p)[3][4] = &amp;amp;arr; cout &amp;lt;&amp;lt; arr[2][3] &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; *p[2][3] &amp;lt;&amp;lt; endl; return 0; } 输出：</description>
    </item>
    
    <item>
      <title>类其它总结</title>
      <link>https://874656645.github.io/posts/51-%E7%B1%BB%E5%85%B6%E5%AE%83%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 28 Dec 2021 17:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/51-%E7%B1%BB%E5%85%B6%E5%AE%83%E6%80%BB%E7%BB%93/</guid>
      <description>1. this指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用该成员函数的对象的首地址
 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值 this 是个右值，所以不能取 this 的地址  2. delete this  类的成员函数中可以调用 delete this，但是在释放后，对象后续调用的方法不能再用到 this 指针 delete this 释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，此时其中的值是不确定的 delete 的本质是为将被释放的内存调用一个或多个析构函数，如果在类的析构函数中调用 delete this，会陷入无限递归，造成栈溢出  3. 一个空类class中有什么？ 构造函数、拷贝构造函数、析构函数、赋值运算符重载、取地址操作符重载、被 const 修饰的取地址操作符重载
4. C++ 计算一个类的 sizeof  一个空的类 sizeof 返回 1，因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址 类内的普通成员函数不参与 sizeof 的统计，因为 sizeof 是针对实例的，而普通成员函数，是针对类体的 一个类如果含有虚函数，则这个类中有一个指向虚函数表的指针（虚函数指针），32位程序占4个字节，64位程序占8个字节 静态成员不影响类的大小，被编译器放在程序的数据段中 普通继承的类sizeof，会得到基类的大小加上派生类自身成员的大小 当存在虚拟继承时，派生类中会有一个指向虚基类表的指针。所以其大小应为普通继承的大小，再加上虚基类表的指针大小  5. 构造函数和析构函数能被继承吗? 不能。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么
6. 构造函数能不能是虚函数？ 不能。虚函数对应一个虚函数表，可是这个虚函数表存储在对象的内存空间的。问题就在于，如果构造函数是虚的，就需要通过 虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，就不会有虚函数表</description>
    </item>
    
    <item>
      <title>构造函数重载与互调</title>
      <link>https://874656645.github.io/posts/50-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BA%92%E8%B0%83/</link>
      <pubDate>Tue, 28 Dec 2021 16:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/50-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BA%92%E8%B0%83/</guid>
      <description>构造函数可以互调，但不能在函数体内，只能通过初始化列表的形式 构造函数中不要写业务逻辑 析构函数中不要 delete this ，这会导致析构递归，最终导致栈溢出  class Test{ public: Test(int a, int b, int c){ _a = a; _b = b; _c = c; } // 正确  Test(int a, int b):Test(a, b, 100){ } /* // 错误 Test(int a, int b){ _a = a; _b = b; Test(a, b, 100); // 此处只是产生一个临时对象，马上又被释放掉了，没有任何意义 } */ int getA(){ return _a; } int getB(){ return _b; } int getC(){ return _c; } private: int _a; int _b; int _c; }; int main( ) { Test t1(10, 20); cout &amp;lt;&amp;lt; t1.</description>
    </item>
    
    <item>
      <title>类的成员函数作为回调函数</title>
      <link>https://874656645.github.io/posts/49-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 28 Dec 2021 14:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/49-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid>
      <description>思路是借助类的静态成员函数
方式一：
class A{ public: A(int a){ m_a = a; } void print(){ cout &amp;lt;&amp;lt; &amp;#34;m_a = &amp;#34; &amp;lt;&amp;lt; m_a &amp;lt;&amp;lt; endl; } void setCur(){ s_curA = this; } static void callback(){ s_curA-&amp;gt;print(); } private: static A* s_curA; int m_a; }; A* A::s_curA = nullptr; typedef void (*FUN_S)(); void Handle(FUN_S call){ call(); } int main( ) { A a(10), b(20); a.setCur(); Handle(A::callback); b.setCur(); Handle(A::callback); return 0; } 方式二：
class A{ public: A(int a){ m_a = a; } void print(){ cout &amp;lt;&amp;lt; &amp;#34;m_a = &amp;#34; &amp;lt;&amp;lt; m_a &amp;lt;&amp;lt; endl; } static void callback(void *a){ ((A*)a)-&amp;gt;print(); } private: int m_a; }; typedef void (*FUN)(void *); void Handle(void *a, FUN call){ call(a); } int main( ) { A a(10), b(20); Handle(&amp;amp;a, A::callback); Handle(&amp;amp;b, A::callback); return 0; } 输出：</description>
    </item>
    
    <item>
      <title>类的兼容性原则</title>
      <link>https://874656645.github.io/posts/48-%E7%B1%BB%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8E%9F%E5%88%99/</link>
      <pubDate>Tue, 28 Dec 2021 11:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/48-%E7%B1%BB%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8E%9F%E5%88%99/</guid>
      <description>父类指针可以new子类对象，子类指针不可以new父类对象，但是可以接收强转的已经存在的父类指针 父类指针指向本类对象，调用的虚函数和普通函数都是自己的 将子类指针指向父类对象，虚函数执行的是父类的，也可以调用子类函数（这种操作是错误的，编译会报错，虽然可通过指针强转，但是不建议这样做，可能会导致未知错误） 父类指针指向子类对象，虚函数执行的是子类的，并且不能调用子类的函数 父类指针与子类指针之间赋值可以理解为指针所指内容的一种浅拷贝
Father *f = (Father*)Child * 子类的虚函数指针覆盖父类的，并且子类特有的函数指针不会拷贝过去
Child *c = (Child*)new Father父类的虚函数指针覆盖子类的，同时也有子类特有的函数指针  class A{ public: void printA(){ cout &amp;lt;&amp;lt; &amp;#34;printA()&amp;#34; &amp;lt;&amp;lt; endl; } virtual void print(){ cout &amp;lt;&amp;lt; &amp;#34;A::print()&amp;#34; &amp;lt;&amp;lt; endl; } }; class B:public A{ public: void printB(){ cout &amp;lt;&amp;lt; &amp;#34;printB()&amp;#34; &amp;lt;&amp;lt; endl; } virtual void print() override{ cout &amp;lt;&amp;lt; &amp;#34;B::print() b = &amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; } private: int b; }; int main( ) { // 1、指向自己的类对象（将父类对象赋值给父类指针）  A *a = new A; // 1.</description>
    </item>
    
    <item>
      <title>构造函数私有</title>
      <link>https://874656645.github.io/posts/47-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%A7%81%E6%9C%89/</link>
      <pubDate>Tue, 28 Dec 2021 10:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/47-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%A7%81%E6%9C%89/</guid>
      <description> 如果类的内部没有专门创建实例的代码，则是无法创建任何实例的 如果父类构造函数设置成了私有的，则子类无法编译，因为在初始化子类时会先执行父类的构造  class A{ public: private: A(int ){ } }; class B:public A{ public: int x; }; int main( ) { B b; b.x = 0; return 0; } 输出：
Start prog.cc:19:7: error: call to implicitly-deleted default constructor of &amp;#39;B&amp;#39; B b; ^ prog.cc:13:9: note: default constructor of &amp;#39;B&amp;#39; is implicitly deleted because base class &amp;#39;A&amp;#39; has an inaccessible default constructor class B:public A{ ^ 1 error generated. 1 Finish </description>
    </item>
    
    <item>
      <title>定义一个只能在堆上（栈上）生成对象的类</title>
      <link>https://874656645.github.io/posts/46-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/</link>
      <pubDate>Mon, 27 Dec 2021 17:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/46-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/</guid>
      <description>一、只能在堆上 方法：将析构函数设置为私有
原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象
class Test { public: void printT(){ cout &amp;lt;&amp;lt; &amp;#34;printT&amp;#34; &amp;lt;&amp;lt; endl; } void freeT(){ delete this; } private: ~Test(){ cout &amp;lt;&amp;lt; &amp;#34;~Test()&amp;#34; &amp;lt;&amp;lt; endl; } }; int main( ) { // 不能在栈上创建对象  //Test t; // prog.cc:25:10: error: variable of type &amp;#39;Test&amp;#39; has private destructor  // 只能在堆上创建对象  Test *t = new Test; t-&amp;gt;printT(); // 销毁对象  t-&amp;gt;freeT(); return 0; } 输出：
Start printT ~Test() 0 Finish 二、只能在栈上 方法：将 new 和 delete 重载为私有</description>
    </item>
    
    <item>
      <title>抽象类、接口类、聚合类</title>
      <link>https://874656645.github.io/posts/45-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E7%B1%BB%E8%81%9A%E5%90%88%E7%B1%BB/</link>
      <pubDate>Mon, 27 Dec 2021 16:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/45-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E7%B1%BB%E8%81%9A%E5%90%88%E7%B1%BB/</guid>
      <description>抽象类：含有纯虚函数的类，不能实例化对象 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
1）所有成员都是 public，没有私有和受保护的非静态成员；
2）没有定义任何构造函数；
3）没有类内初始化；
4）没有基类，也没有 virtual 函数  // 接口类 class A { virtual void printA() = 0; // 纯虚函数 }; // 抽象类 class AA:public A { public: // 覆写接口类的纯虚函数  void printA() override { cout &amp;lt;&amp;lt; &amp;#34;class AA printA()&amp;#34; &amp;lt;&amp;lt; endl; } virtual void printAA() = 0; }; // 可实例化的类 class B:public AA { public: // 覆写父类（抽象类）的纯虚函数  void printAA() override { cout &amp;lt;&amp;lt; &amp;#34;class B printAA()&amp;#34; &amp;lt;&amp;lt; endl; } void printB() { cout &amp;lt;&amp;lt; &amp;#34;printB()&amp;#34; &amp;lt;&amp;lt; endl; } }; // 聚合类 class C { public: int x; int y; void print(){ cc(); } private: void cc(){ cout &amp;lt;&amp;lt; &amp;#34;x = &amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;, y = &amp;#34; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; &amp;#34;, z = &amp;#34; &amp;lt;&amp;lt; z &amp;lt;&amp;lt; endl; } static int z; }; int C::z = 0; class D { public: int a; int b; C c; void print(){ cout &amp;lt;&amp;lt; &amp;#34;a = &amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34;, b = &amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; c.</description>
    </item>
    
    <item>
      <title>虚继承和虚基类</title>
      <link>https://874656645.github.io/posts/44-%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB/</link>
      <pubDate>Mon, 27 Dec 2021 13:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/44-%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB/</guid>
      <description>虚继承和虚基类 参考
 在C++中，在定义公共基类A的派生类B、C&amp;hellip;的时候，如果在继承方式前使用关键字virtual对继承方式限定，这样的继承方式就是虚拟继承，公共基类A成为虚基类。这样，在具有公共基类的、使用了虚拟继承方式的多个派生类B、C&amp;hellip;的公共派生类D中，该基类A的成员就只有一份拷贝 一个类有多个基类，这样的继承关系称为多继承。在多继承的情况下，如果不同基类的成员名称相同，匹配度相同, 则会造成二义性。为了避免多继承产生的二义性，在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 会在虚继承的类中生成一个指向虚基类的指针 {vbptr} 会在内存中生成一个虚基类表 D::$vbtable@B@  微软的Visual Studio提供给用户显示C++对象在内存中的布局的选项
cl [filename].cpp /d1 reportSingleClassLayout[className]
一般继承：
class A { public: int dataA; }; class B:public A { public: int dataB; }; class C:public A { public: int dataC; }; class D : public B, public C { public: int dataD; }; 输出：
class D size(20): +--- 0 | +--- (base class B) 0 | | +--- (base class A) 0 | | | dataA | | +--- 4 | | dataB | +--- 8 | +--- (base class C) 8 | | +--- (base class A) 8 | | | dataA | | +--- 12 | | dataC | +--- 16 | dataD +--- 调用：</description>
    </item>
    
    <item>
      <title>多态总结</title>
      <link>https://874656645.github.io/posts/43-%E5%A4%9A%E6%80%81%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 27 Dec 2021 10:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/43-%E5%A4%9A%E6%80%81%E6%80%BB%E7%BB%93/</guid>
      <description>1. C++ 多态分类及实现  重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载（静态多态、静态编译） 子类多态（Subtype Polymorphism，运行期）：虚函数（动态多态、动态编译） 参数多态（Parametric Polymorphism，编译期）：类模板（泛型）、函数模板（函数指针） 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换  2. 虚表指针、虚函数指针、虚函数表  虚表指针：在含有虚函数的类的对象中，指向虚函数表的指针，在运行时确定 虚函数指针：指向虚函数的地址的指针 {vfptr} 虚函数表：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚函数表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建 Shape::$vftable@  class Shape { public: virtual ~Shape(){ cout &amp;lt;&amp;lt; &amp;#34;~Shape()&amp;#34; &amp;lt;&amp;lt; endl; } }; class Point { public: ~Point(){ cout &amp;lt;&amp;lt; &amp;#34;~Point()&amp;#34; &amp;lt;&amp;lt; endl; } private: int m_x{0}; int m_y{0}; char m_c; }; class Circle : public Shape { public: ~Circle(){ cout &amp;lt;&amp;lt; &amp;#34;~Circle()&amp;#34; &amp;lt;&amp;lt; endl; } private: Point m_p; }; int main( ) { // 8 类中存有指向虚函数表的指针  cout &amp;lt;&amp;lt; sizeof(Shape) &amp;lt;&amp;lt; endl; // 16 类中存有指向虚函数表的指针  // 以及Point对象的大小（此时Point类中不包含任何变量），虽然真实大小是 8 + 1  // 但是额外多的1个字节导致内存大小扩增了 8(每次扩增的最小数值是8 &amp;lt;alignment member&amp;gt; (size=7))  cout &amp;lt;&amp;lt; sizeof(Circle) &amp;lt;&amp;lt; endl; // 8 类中的int占4个字节，char占1个字节  // 但每次扩增的最小数值是4(&amp;lt;alignment member&amp;gt; (size=3))  cout &amp;lt;&amp;lt; sizeof(Point) &amp;lt;&amp;lt; endl; Circle c; return 0; } Start 8 24 12 ~Circle() ~Point() ~Shape() 0 Finish Shape 类</description>
    </item>
    
    <item>
      <title>函数默认参数和占位参数</title>
      <link>https://874656645.github.io/posts/42-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%92%8C%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sun, 26 Dec 2021 15:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/42-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%92%8C%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0/</guid>
      <description>1. 函数默认参数和占位参数（亚元） 形参中的占位参数又叫亚元，并没有什么实际意义，只在函数重载中起到作用
// 亚元，设置了默认值所以调用时可以不传参数 // 否则就必须传入两个参数 void foo(int a, int = 0){ cout &amp;lt;&amp;lt; &amp;#34;a = &amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; } int main() { foo(20); return 0; } 2. 函数重载  函数名相同，形参列表不同（形参个数、类型、顺序） 函数返回值不起作用 函数重载和默认参数不要同时使用（函数调用时容易产生二义性） 倾轧技术（name mangling），底层会将函数名进行编译  用 v c i f l d 表示 void char int float long double 及其引用 int fun(int) =&amp;gt; fun_i
int fun(int, char, double) =&amp;gt; fun_icd   重载函数匹配顺序  如果能够严格匹配，则调用完全匹配的 如果没有完全匹配的，则调用隐式转换的 都匹配不上，编译失败    3.</description>
    </item>
    
    <item>
      <title>内存区间划分</title>
      <link>https://874656645.github.io/posts/41-%E5%86%85%E5%AD%98%E5%8C%BA%E9%97%B4%E5%88%92%E5%88%86/</link>
      <pubDate>Sun, 26 Dec 2021 14:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/41-%E5%86%85%E5%AD%98%E5%8C%BA%E9%97%B4%E5%88%92%E5%88%86/</guid>
      <description>一、程序运行前  代码区（只读的、共享） 数据区（全局变量和静态变量）  二、程序运行后  栈区 堆区 全局静态区（全局变量、静态变量、常量） 代码区  Linux程序运行内存虚拟地址空间：
三、全局变量与静态变量的区别 作用域不同
全局变量默认是 extern 的
静态变量是文件作用域
C/C++ 中 extern 关键字详解</description>
    </item>
    
    <item>
      <title>指针引用</title>
      <link>https://874656645.github.io/posts/40-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/</link>
      <pubDate>Sat, 25 Dec 2021 21:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/40-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/</guid>
      <description>指针也是一种变量，作为函数形参和返回值的时候也是值拷贝（拷贝的是一个地址） 使用指针引用的方式，代码更加简洁，逻辑更加清晰 释放掉指针指向的空间后，一定记得把指针置空 声明指针时就进行初始化或将其指向 NULL 是个好习惯  指针值拷贝：
void test(int * a){ a = new int(20); //*a = 20;  cout &amp;lt;&amp;lt; &amp;#34;test point a = &amp;#34; &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;test:&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34;\ta = &amp;#34; &amp;lt;&amp;lt; *a &amp;lt;&amp;lt; endl; } int main() { int *a = new int(10); cout &amp;lt;&amp;lt; &amp;#34;main point a = &amp;#34; &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;main:&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34;\ta = &amp;#34; &amp;lt;&amp;lt; *a &amp;lt;&amp;lt; endl; test(a); cout &amp;lt;&amp;lt; &amp;#34;main:&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34;\ta = &amp;#34; &amp;lt;&amp;lt; *a &amp;lt;&amp;lt; endl; return 0; } 输出：</description>
    </item>
    
    <item>
      <title>抽象、封装、继承、多态</title>
      <link>https://874656645.github.io/posts/39-%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/</link>
      <pubDate>Fri, 24 Dec 2021 15:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/39-%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/</guid>
      <description>一、抽象、封装 数据抽象：是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制，是一种依赖于接口实现分离的设计技术
数据封装：是一种把数据和操作数据的函数捆绑在一起的机制
1. 好处  类的内部受到保护，不会因无意的用户级错误导致对象状态受损 类实现可能随着时间的推移而发生变化，数据抽象可以更好的应对不断变化的需求  2. 策略  通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。 抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可  3. 接口 接口描述了类的行为和功能，而不需要完成类的特定实现。如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类
设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。
可用于实例化对象的类被称为具体类
接口的好处实现了解耦合的作用。 可以将软件架构分为业务逻辑层、抽象层和实现层
二、继承 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。类派生列表以一个或多个基类命名
派生类可以访问基类中所有的非私有成员，同时，一个派生类继承了所有的基类方法，但下列情况除外：
 基类的构造函数、析构函数和拷贝构造函数 基类的重载运算符 基类的友元函数  三、多态 虚函数：虚函数是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链编到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链编，或后期绑定。
 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数 一般要将父类的析构函数设置为虚函数，如果不把父类的析构函数设置为虚函数，在 delete 父类指针时就不会调用子类的析构了 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数 若在基类中不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数，在函数参数后直接加 = 0 告诉编译器，函数没有主体，这种虚函数即是纯虚函数  测试类：
// 基类 Shape class Shape { protected: int width, height; public: Shape(int a = 0, int b = 0) { width = a; height = b; } virtual ~Shape() { cout &amp;lt;&amp;lt; &amp;#34;Shape destructor&amp;#34; &amp;lt;&amp;lt; endl; } // pure virtual function  virtual int area() = 0; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { auto res = area * 70; cout &amp;lt;&amp;lt; &amp;#34;PaintCost: &amp;#34; &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl; return res; } }; class Rectangle: public Shape, public PaintCost { public: Rectangle(int a = 0, int b = 0):Shape(a, b) { } ~Rectangle() { cout &amp;lt;&amp;lt; &amp;#34;Rectangle destructor&amp;#34; &amp;lt;&amp;lt; endl; } void printPro() { // 访问父类的成员变量（不能访问父类的私有成员）  cout &amp;lt;&amp;lt; &amp;#34;width: &amp;#34; &amp;lt;&amp;lt; width &amp;lt;&amp;lt; &amp;#34;\theight: &amp;#34; &amp;lt;&amp;lt; height &amp;lt;&amp;lt; endl; } int area () { auto area = width * height; cout &amp;lt;&amp;lt; &amp;#34;Rectangle class area: &amp;#34; &amp;lt;&amp;lt; area &amp;lt;&amp;lt;endl; return area; } }; class Triangle: public Shape { public: Triangle(int a = 0, int b = 0):Shape(a, b) { } ~Triangle() { cout &amp;lt;&amp;lt; &amp;#34;Triangle destructor&amp;#34; &amp;lt;&amp;lt; endl; } int area () { auto area = width * height / 2; cout &amp;lt;&amp;lt; &amp;#34;Triangle class area: &amp;#34; &amp;lt;&amp;lt; area &amp;lt;&amp;lt;endl; return area; } }; 多继承：</description>
    </item>
    
    <item>
      <title>类的静态成员</title>
      <link>https://874656645.github.io/posts/38-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</link>
      <pubDate>Fri, 24 Dec 2021 13:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/38-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</guid>
      <description>使用 static 关键字来把类成员定义为静态的。静态成员在类的所有对象中是共享的，当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本 如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零 不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数） 普通成员函数有 this 指针，可以访问类中的任意成员；  class A { string name {&amp;#34;C++&amp;#34;}; int id {1024}; static int objCount; public: A(); friend void printA(const A &amp;amp;a); void printA(); static void printC(); }; // 静态成员类外初始化 int A::objCount = 0; A::A(){ objCount++; } void A::printA(){ cout &amp;lt;&amp;lt; &amp;#34;objCount = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;objCount &amp;lt;&amp;lt; &amp;#34;\tname = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;name &amp;lt;&amp;lt; &amp;#34;\tid = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;id &amp;lt;&amp;lt; endl; } void A::printC(){ // 静态函数内没有this指针  cout &amp;lt;&amp;lt; &amp;#34;objCount = &amp;#34; &amp;lt;&amp;lt; objCount &amp;lt;&amp;lt; endl; // error: &amp;#39;this&amp;#39; is unavailable for static member functions  // cout &amp;lt;&amp;lt; &amp;#34;objCount = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;objCount &amp;lt;&amp;lt; endl; } void printA(const A &amp;amp;a){ cout &amp;lt;&amp;lt; &amp;#34;objCount = &amp;#34; &amp;lt;&amp;lt; a.</description>
    </item>
    
    <item>
      <title>友元函数与友元类</title>
      <link>https://874656645.github.io/posts/37-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8B%E5%85%83%E7%B1%BB/</link>
      <pubDate>Fri, 24 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/37-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8B%E5%85%83%E7%B1%BB/</guid>
      <description>友元利弊：
友元不是类的成员但能访问类中的私有成员。友元的作用在于提高程序的运行效率，但也破坏了类的封装。
  注意事项：
（1）友元关系不能被继承；
（2）友元关系是单向的，不具有交换性；
（3）友元关系不具有传递性；
  一、友元函数  类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员 尽管友元函数的原型有在类的定义中出现过，但是 友元函数并不是成员函数 this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针  1. 友元函数是全局函数
class A { friend void printA(const A &amp;amp;a); public: void printA(); private: string name {&amp;#34;C++&amp;#34;}; int id {1024}; }; void A::printA(){ cout &amp;lt;&amp;lt; &amp;#34;name = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;name &amp;lt;&amp;lt; &amp;#34;\tid = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;id &amp;lt;&amp;lt; endl; } // 请注意：printA() 不是任何类的成员函数 void printA(const A &amp;amp;a){ cout &amp;lt;&amp;lt; &amp;#34;name = &amp;#34; &amp;lt;&amp;lt; a.</description>
    </item>
    
    <item>
      <title>构造、拷贝构造、赋值构造</title>
      <link>https://874656645.github.io/posts/36-%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0/</link>
      <pubDate>Thu, 23 Dec 2021 14:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/36-%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0/</guid>
      <description>结论：
 拷贝构造函数是函数，赋值运算符是运算符的重载； 拷贝构造函数会生成新的类对象，赋值运算符不会； 拷贝构造函数是用一个已存在的对象去构造一个不存在的对象；而赋值运算符重载函数是用一个存在的对象去给另一个已存在并初始化过的对象进行赋值; 若接受返回值的对象已经初始化过，则会调用赋值运算符，且该对象还会调用析构函数，当对象中包含指针时，会使该指针失效，因此需要重载赋值运算符，使用类似深拷贝或移动构造函数的方法赋值，才能避免指针失效。 如果只有显示的构造函数，系统会提供默认的拷贝构造； 如果显示提供了拷贝构造，系统就不会提供默认的无参构造了，用户必需显示提供构造函数； 当既没有显式的构造函数，也没有拷贝构造时，系统才会提供默认的无参构造； 显示提供拷贝构造就必需显示提供构造函数； 显示提供赋值运算符重载就必需显示提供拷贝构造；  成员初始化列表  使用成员变量初始化列表，少了一次调用默认构造函数的过程，提高效率 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 成员变量初始化的顺序跟在初始化列表的顺序无关，与变量声明的顺序有关  测试类 class A { public: A(){ cout &amp;lt;&amp;lt; &amp;#34;default constructor&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;adrres: &amp;#34; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;#34;\tpoint x: &amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;\ty: &amp;#34; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl; } A(int t){ x = new int(0); y = t; cout &amp;lt;&amp;lt; &amp;#34;second constructor&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;adrres: &amp;#34; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;#34;\tpoint x: &amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;\ty: &amp;#34; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl; } A(const A &amp;amp;a){ cout &amp;lt;&amp;lt; &amp;#34;const copy constructor&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;adrres: &amp;#34; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;#34;\tpoint x: &amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;\ty: &amp;#34; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl; this-&amp;gt;x = a.</description>
    </item>
    
    <item>
      <title>函数重载、重写、隐藏、模板</title>
      <link>https://874656645.github.io/posts/35-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Thu, 23 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/35-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F%E6%A8%A1%E6%9D%BF/</guid>
      <description>重载： 在同一作用域中，两个函数名相同，但是参数列表不同（个数、类型、顺序），返回值类型没有要求； 重写（覆盖）： 子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写或覆盖； 重定义： 派生类中函数与基类中的函数同名（形参没有要求），但是这个函数在基类中并没有被定义为虚函数 隐藏： 派生类中重定义了父类的函数，此时基类的函数会被隐藏； 模板： 函数模板是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表，只适用于 参数个数相同而类型不同 的函数。 构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数  1、重载  类的静态函数也可以重载； 形参中一级指针和二级指针被认为是不同类型的参数；  class A{ public: A(int a){ m_a = a; } void print(){ cout &amp;lt;&amp;lt; &amp;#34;print()&amp;#34; &amp;lt;&amp;lt; &amp;#34;m_a = &amp;#34; &amp;lt;&amp;lt; m_a &amp;lt;&amp;lt; endl; } void freeP(A ** p){ if(p == NULL){ return; } if(*p != NULL){ free(*p); *p = NULL; } } void freeP(A * p){ if(p != NULL){ free(p); p = NULL; } } static void printS(){ cout &amp;lt;&amp;lt; &amp;#34;printS() s_a = &amp;#34; &amp;lt;&amp;lt; s_a &amp;lt;&amp;lt; endl; } static void printS(int s){ cout &amp;lt;&amp;lt; &amp;#34;printS(int s) &amp;#34; &amp;lt;&amp;lt; s_a * s &amp;lt;&amp;lt; endl; } static void printS(void *p, int s){ cout &amp;lt;&amp;lt; &amp;#34;printS(void *p, int s) &amp;#34; &amp;lt;&amp;lt; ((A*)p)-&amp;gt;m_a * s &amp;lt;&amp;lt; endl; } static int s_a; private: int m_a; }; int A::s_a = 0; int main( ) { A *a = new A(1); a-&amp;gt;printS(a, 20); a-&amp;gt;print(); A::s_a = 10; a-&amp;gt;printS(); a-&amp;gt;printS(10); a-&amp;gt;freeP(a); if(a == NULL){ cout &amp;lt;&amp;lt; &amp;#34;*a is not valid&amp;#34; &amp;lt;&amp;lt; endl; return 0; } cout &amp;lt;&amp;lt; &amp;#34;*a is valid&amp;#34; &amp;lt;&amp;lt; endl; a-&amp;gt;print(); return 0; } 输出：</description>
    </item>
    
    <item>
      <title>inline 内联函数</title>
      <link>https://874656645.github.io/posts/34-inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 23 Dec 2021 11:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/34-inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</guid>
      <description>当一个函数被声明为内联函数之后，在编译阶段，编译器会用内联函数的函数体取替换程序中出现的内联函数调用表达式，而其他的函数都是在运行时才被替换，这其实就是用空间换时间，提高了函数调用的效率。同时，内联函数具有几个特点：
 适用于函数体积很小并频繁使用的函数 内联函数中不可以出现循环、递归或开关操作 内联函数的声明必须在函数定义之前 内联函数的定义必须出现在内联函数的第一次调用前 在类中声明同时定义的成员函数（除了虚函数）会自动隐式的当成内联函数 虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联  优点：
 内联函数在被调用处进行代码展开，省去了参数压栈、跳转返回、栈帧开辟与回收，结果返回等操作，从而提高程序运行速度； 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换，而宏定义则不会； 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能； 内联函数在运行时可调试，而宏定义不可以。  缺点：
 代码膨胀，消耗了更多的内存空间； inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接； 内联函数其实是不可控的，它只是对编译器的建议，是否对函数内联，决定权在于编译器; 不能对函数进行取址操作  </description>
    </item>
    
    <item>
      <title>fork Unix</title>
      <link>https://874656645.github.io/posts/33-fork-unix/</link>
      <pubDate>Thu, 23 Dec 2021 10:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/33-fork-unix/</guid>
      <description>Unix 的 fork 函数 fork函数可以创建一个和当前映像一样的子进程，这个函数会返回两个值：从子进程返回0，从父进程返回子进程的PID；
 1）在父进程中，fork返回新创建子进程的进程ID； 2）在子进程中，fork返回0； 3）如果出现错误，fork返回一个负值；  #include &amp;lt;iostream&amp;gt;#include &amp;lt;unistd.h&amp;gt; using namespace std; int main() { pid_t fpid; //fpid表示fork函数返回的值  int count = 0; cout &amp;lt;&amp;lt; &amp;amp;count &amp;lt;&amp;lt; endl; fpid = fork(); if (fpid &amp;lt; 0) printf(&amp;#34;error in fork!\n&amp;#34;); else if (fpid == 0) { printf(&amp;#34;i am the child process, my process id is %d\n&amp;#34;,getpid()); cout &amp;lt;&amp;lt; &amp;amp;count &amp;lt;&amp;lt; endl; count++; } else { printf(&amp;#34;i am the parent process, my process id is %d\n&amp;#34;,getpid()); cout &amp;lt;&amp;lt; &amp;amp;count &amp;lt;&amp;lt; endl; count++; } printf(&amp;#34;统计结果是: %d\n&amp;#34;,count); return 0; } 输出：</description>
    </item>
    
    <item>
      <title>C 与 C&#43;&#43; 的差异</title>
      <link>https://874656645.github.io/posts/32-c-%E4%B8%8E-c&#43;&#43;-%E7%9A%84%E5%B7%AE%E5%BC%82/</link>
      <pubDate>Wed, 22 Dec 2021 22:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/32-c-%E4%B8%8E-c&#43;&#43;-%E7%9A%84%E5%B7%AE%E5%BC%82/</guid>
      <description>C++ 是 C 的超集和增强，校验更加严格
C 主要是面向过程，C++ 是面向对象，面向过程是函数驱动，面向对象是对象驱动
1 新增命名空间  给{}作用域起了个名称，后面不用加分号; 命名空间可以嵌套  namespace X { namespace Y { } } 2 新增引用类型  引用在一定程度上可以替代指针，作用与常指针类似 int * const a 引用没有定义，是一种关系声明，声明它和原有某一变量（实体）的关系，
故而类型与原类型保持一致，且不分配内存，与被引用的变量有相同的地址 声明时必须初始化，一经声明，不可变更 可对引用再次引用，多次引用的结果是某一变量具有多个别名 &amp;amp; 符号在 = 号左边是引用，在 = 号右边为取地址  3 枚举检测增强  不能将整型隐式转化为枚举  4 变量定义增强  C++ 变量不必都声明在函数顶部，可以随使用随定义  5 全局变量定义检测严格  C 全局变量重复定义，C++ 不可以，全局变量检测增强  // C 语言 int g_val; // bss段 int g_val = 10; // data段 6 函数形参个数和函数返回值检测增强 // C 语言 f() // 默认返回值 int { return 10; } int g(int a) { return 10; } // 调用 g(10, 20, 30, 40); // 可编译通过，但是有警告 7 struct 结构体增强  功能与类基本等同，只不过 class 默认是 private 权限，struct 默认是 public 权限  // C 语言声明结构体变量 struct Student s; // C++ 语言声明结构体变量 Student s; 8 新增 bool 关键字，1 个字节  C 用 0 表示 false，非 0 表示 true C++ 中 bool 为 1 个字节，但是只有 true 和 false 两个值  9 三目运算符增强（语法糖）  C 中三目运算符不可以当左值  // C 语言 int a = 10, b = 20; ((a &amp;lt; b) ?</description>
    </item>
    
    <item>
      <title>函数形参从右到左入栈</title>
      <link>https://874656645.github.io/posts/31-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%E5%85%A5%E6%A0%88/</link>
      <pubDate>Wed, 22 Dec 2021 15:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/31-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%E5%85%A5%E6%A0%88/</guid>
      <description>int add(int count, ...) { // 指针大小与程序位数有关（32位指针是4个字节，64位指针是8个字节）  int intSize = sizeof(int*) / sizeof(int); int sum = 0; // cout &amp;lt;&amp;lt; &amp;amp;count &amp;lt;&amp;lt; endl;  int *p = &amp;amp;count + intSize; // cout &amp;lt;&amp;lt; p &amp;lt;&amp;lt; endl;  for (int i = 0; i &amp;lt; count; ++i) { sum += *p; cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl; p += intSize; } return sum; } int main() { cout &amp;lt;&amp;lt; add(3, 1, 2, 3) &amp;lt;&amp;lt; endl; return 0; } 输出：</description>
    </item>
    
    <item>
      <title>指针 &#43; 1</title>
      <link>https://874656645.github.io/posts/30-%E6%8C%87%E9%92%88-&#43;1/</link>
      <pubDate>Wed, 22 Dec 2021 15:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/30-%E6%8C%87%E9%92%88-&#43;1/</guid>
      <description>1. 32 位和 64 位程序指针是多少位 32位指针大小为4个字节，64位指针大小位8个字节
2. 指针加 1，是对该指针增加 1 个储存单位 “存储单位”，指的是指针指向的数据类型所占的内存的字节数。不同类型的指针加1后，增加的大小不同。
int main() { int a[] = {1, 2, 3, 4, 5}; // &amp;amp;a是数组指针，其类型为 int (*)[5]，a是长度为5的int数组指针，所以要加 5*sizeof(int)，所以ptr实际是a[5]；  // &amp;amp;a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）  // 但是prt与(&amp;amp;a+1)类型是不一样的(这点很重要，prt指向的是整形)，所以prt-1只会减去sizeof(int)  int *ptr = (int*)(&amp;amp;a + 1); cout &amp;lt;&amp;lt; *(a + 1) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; *(ptr - 1) &amp;lt;&amp;lt; endl; return 0; } 输出：
2 5 注： a，&amp;amp;a的地址是一样的，但意思不一样：
 a是数组首地址，也就是a[0]的地址，a+1是数组下一元素的地址，即a[1] &amp;amp;a是对象（整个数组作为一个对象）首地址，而&amp;amp;a+1是下一个对象的地址，即a[5].  </description>
    </item>
    
    <item>
      <title>模板类</title>
      <link>https://874656645.github.io/posts/29-%E6%A8%A1%E6%9D%BF%E7%B1%BB/</link>
      <pubDate>Wed, 22 Dec 2021 10:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/29-%E6%A8%A1%E6%9D%BF%E7%B1%BB/</guid>
      <description>template&amp;lt;class T&amp;gt; class Test { public: Test(T t){ m_t = t;}; // explicit Test(T t){ m_t = t;};  T getValue(){ return m_t; }; private: T m_t; }; int main() { Test&amp;lt;int&amp;gt; tInt(1); cout &amp;lt;&amp;lt; tInt.getValue() &amp;lt;&amp;lt; endl; Test&amp;lt;double&amp;gt; tD(1.15); cout &amp;lt;&amp;lt; tD.getValue() &amp;lt;&amp;lt; endl; Test&amp;lt;float&amp;gt; tF = 1.3f; // 构造函数没有explicit修饰，可以隐式转换  cout &amp;lt;&amp;lt; tF.getValue() &amp;lt;&amp;lt; endl; return 0; } 输出：
Start 1 1.15 1.3 0 Finish </description>
    </item>
    
    <item>
      <title>模板函数</title>
      <link>https://874656645.github.io/posts/28-%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 22 Dec 2021 09:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/28-%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</guid>
      <description>template &amp;lt;typename T&amp;gt; inline const T&amp;amp; Max (const T&amp;amp; a, const T&amp;amp; b) { return a &amp;lt; b ? b:a; }; int main() { int i = 39; int j = 20; cout &amp;lt;&amp;lt; &amp;#34;Max(i, j): &amp;#34; &amp;lt;&amp;lt; Max(i, j) &amp;lt;&amp;lt; endl; double f1 = 13.5; double f2 = 20.7; cout &amp;lt;&amp;lt; &amp;#34;Max(f1, f2): &amp;#34; &amp;lt;&amp;lt; Max(f1, f2) &amp;lt;&amp;lt; endl; string s1 = &amp;#34;Hello&amp;#34;; string s2 = &amp;#34;World&amp;#34;; cout &amp;lt;&amp;lt; &amp;#34;Max(s1, s2): &amp;#34; &amp;lt;&amp;lt; Max(s1, s2) &amp;lt;&amp;lt; endl; return 0; } 输出：</description>
    </item>
    
    <item>
      <title>ArcMap 加载天地图服务</title>
      <link>https://874656645.github.io/posts/27-arcmap-%E5%8A%A0%E8%BD%BD%E5%A4%A9%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Fri, 17 Dec 2021 22:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/27-arcmap-%E5%8A%A0%E8%BD%BD%E5%A4%A9%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1/</guid>
      <description>注：软件版本为10.6，需要 服务端 token 注：天地图官网的服务（https://t0.tianditu.gov.cn/img_w/wmts）使用的 dpi 大小采用的是国家标准，并不是 OGC 标准，会导致 ArcMap 加载影像后，矢量化的坐标不对  影像底图：
http://t0.tianditu.com/img_c/esri/wmts 天地图影像（经纬度，CGCS2000）
http://t0.tianditu.com/cia_c/esri/wmts 天地图影像注记（经纬度，CGCS2000）
http://t0.tianditu.com/img_w/esri/wmts 天地图影像（墨卡托，WGS1984）
http://t0.tianditu.com/cia_w/esri/wmts 天地图影像注记（墨卡托，WGS1984）
矢量底图：
http://t0.tianditu.com/vec_c/esri/wmts 天地图矢量（经纬度，CGCS2000）
http://t0.tianditu.com/cva_c/esri/wmts 天地图矢量注记（经纬度，CGCS2000）
http://t0.tianditu.com/vec_w/esri/wmts 天地图矢量（墨卡托，WGS1984）
http://t0.tianditu.com/cva_w/esri/wmts 天地图矢量注记（墨卡托，WGS1984）
ArcMap WMTS</description>
    </item>
    
    <item>
      <title>函数指针</title>
      <link>https://874656645.github.io/posts/26-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 16 Dec 2021 14:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/26-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</guid>
      <description>#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdlib&amp;gt;using namespace std; // 声明函数指针变量 int (*fn)(int) = NULL; // 定义函数指针类型 typedef int (*Fn)(int); int cal(int v){ return v; }; int max(int a, int b){ return a &amp;gt; b ? a : b; } // 函数指针做为参数 void proc(int v, Fn f){ cout &amp;lt;&amp;lt; f(v) &amp;lt;&amp;lt; endl; }; // 函数指针作为函数返回值 int (* retFP(string fName))(int, int){ // lambda 表达式作为函数指针返回  int (*fp)(int,int) = [](int x, int y){ return x &amp;gt; y ?</description>
    </item>
    
    <item>
      <title>指针函数和函数指针</title>
      <link>https://874656645.github.io/posts/25-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 16 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/25-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</guid>
      <description>  指针函数本质是一个函数，返回值是一个指针；
  函数指针是指向函数的一个指针变量；
  #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdlib&amp;gt; using namespace std; // 指针函数fun char * fun(const char * p) { cout &amp;lt;&amp;lt; &amp;#34;fun: &amp;#34; &amp;lt;&amp;lt; p &amp;lt;&amp;lt; endl; return nullptr; }; // 函数指针pf char * (*pf)(const char * p); int main() { pf = fun; // 函数指针pf指向函数fun  pf(&amp;#34;Hello&amp;#34;); return 0; } </description>
    </item>
    
    <item>
      <title>explicit（显式）关键字</title>
      <link>https://874656645.github.io/posts/24-explicit-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Wed, 15 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/24-explicit-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>修饰构造函数，防止隐式转换，赋值初始化，赋值列表初始化 修饰转换函数，可以防止隐式转换，但按语境转换除外 explicit 可加在带多个参数的构造方法上(converting to ‘XXX’ from initializer list)  struct B { explicit B(int) {} explicit operator bool() const { return true; } }; int main() { B b1(1); // OK：直接初始化  B b2 = 1; // 错误：被 explicit 修饰构造函数的对象不可以赋值初始化  B b3{ 1 }; // OK：直接列表初始化  B b4 = { 1 }; // 错误：被 explicit 修饰构造函数的对象不可以赋值列表初始化  B b5 = (B)1; // OK：允许 static_cast 的显式转换  if (b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b6(b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b7 = b1; // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换  bool b8 = static_cast&amp;lt;bool&amp;gt;(b1); // OK：static_cast 进行直接初始化  return 0; } 从初始化列表隐式转换：</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 字符串常量存储</title>
      <link>https://874656645.github.io/posts/23-c&#43;&#43;-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8/</link>
      <pubDate>Mon, 13 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/23-c&#43;&#43;-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8/</guid>
      <description>局部变量、静态局部变量、全局变量、全局静态变量、字符串常量以及动态申请的内存区
 局部变量存储在栈中 全局变量、静态变量（全局和局部静态变量）存储在静态存储区 new申请的内存是在堆中 字符串常量也是存储在静态存储区   栈中的变量内存会随着定义所在区间的结束自动释放；而对于堆，需要手动free，否则它就一直存在，直到程序结束； 对于静态存储区，其中的变量常量在程序运行期间会一直存在，不会释放，且变量常量在其中只有一份拷贝，不会出现相同的变量和常量的不同拷贝。  #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdlib&amp;gt; using namespace std; //返回的是局部变量的地址，该地址位于动态数据区，栈里 char *s1() { char* p1 = &amp;#34;qqq&amp;#34;;//为了测试‘char p[]=&amp;#34;Hello world!&amp;#34;’中的字符串在静态存储区是否也有一份拷贝  char p[]=&amp;#34;Hello world!&amp;#34;; char* p2 = &amp;#34;w&amp;#34;;//为了测试‘char p[]=&amp;#34;Hello world!&amp;#34;’中的字符串在静态存储区是否也有一份拷贝  printf(&amp;#34;in s1 p=%p\n&amp;#34;, p); printf(&amp;#34;in s1 p1=%p\n&amp;#34;, p1); printf(&amp;#34;in s1: string&amp;#39;s address: %p\n&amp;#34;, &amp;amp;(&amp;#34;Hello world!&amp;#34;)); printf(&amp;#34;in s1 p2=%p\n&amp;#34;, p2); return p1; // 这里不能返回局部变量 p } //返回的是字符串常量的地址，该地址位于静态数据区 char *s2() { char *q=&amp;#34;Hello world!&amp;#34;; printf(&amp;#34;in s2 q=%p\n&amp;#34;, q); printf(&amp;#34;in s2: string&amp;#39;s address: %p\n&amp;#34;, &amp;amp;(&amp;#34;Hello world!</description>
    </item>
    
    <item>
      <title>const 修饰符</title>
      <link>https://874656645.github.io/posts/22-const-%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Fri, 10 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/22-const-%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>1、const 修饰指针和引用 常对象：const Class A 只能调用 const 成员函数
常量指针：const int * 所指的地址内容为 常量只读，但是可指向其它对象的地址（可以重指向）
指针常量：int * const 指针所指的地址不能变（不可以重指向），但地址的内容可以被修改，与引用变量效果类似
常量引用：const int &amp;amp; 相当于是对象的一个别名，对象内容为 只读，并且不能指向其它对象
const int &amp;amp;a = 40 与 constexpr int a = 40 效果类似，但后者只能在全局区声明
const int &amp;amp;a = 40 等同于 const int * const a = new int(40)（指针的指向和存放的内容都不可更改）
ClassA myA(10), myB(-10); const ClassA a; // 常对象（只能调用常成员函数） const ClassA * b = &amp;amp;myA; // 常量指针 ClassA * const b = &amp;amp;myA; // 指针常量 const ClassA &amp;amp;bb = myB; // 常量引用  b = &amp;amp;myB; // 合法（可以指向其它对象） b-&amp;gt;setA(10); // 错误（只读） bb.</description>
    </item>
    
    <item>
      <title>Qt QProcess 使用</title>
      <link>https://874656645.github.io/posts/21-qprocess-%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 06 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/21-qprocess-%E4%BD%BF%E7%94%A8/</guid>
      <description>  路径中有空格
m_process-&amp;gt;startDetached(strAppDir + &amp;quot;/ThreeDScreen.exe&amp;quot;, QStringList())
  杀死一个进程（注：-t 参数会将创建的子进程一起杀死）
QProcess::startDetached(&amp;quot;taskkill -t -f /IM iexplore.exe&amp;quot;);
  </description>
    </item>
    
    <item>
      <title>Qt QString 中文乱码</title>
      <link>https://874656645.github.io/posts/20-qstring-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</link>
      <pubDate>Mon, 06 Dec 2021 11:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/20-qstring-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</guid>
      <description> QString使用的是UTF-8编码 从字符常量中获取中文  QString msg = QString::fromLocal8Bit(&amp;quot;This is a debug message at 中文&amp;quot;);
以QString做为形参变量传递  qDebug(msg.toUtf8());
QString与操作系统间读写，会自动将UTF-8与操作系统的编码做转换（比如日志系统）  void QtLog::WriteLine(const QString &amp;amp;logFileName, const QString &amp;amp;logMsg) { QFile file(logFileName); file.open(QIODevice::WriteOnly | QIODevice::Append); QTextStream text_stream(&amp;amp;file); text_stream &amp;lt;&amp;lt; logMsg &amp;lt;&amp;lt; &amp;#34;\r\n&amp;#34;; file.flush(); file.close(); } QString strAppDir = QCoreApplication::applicationDirPath(); // 不用转码  QString message, text, fileName = strAppDir + &amp;#34;/Log/&amp;#34;; QDir dir(fileName); if (!dir.exists()) { // 注：不能创建两级文件夹  bool ismkdir = dir.mkdir(fileName); } </description>
    </item>
    
    <item>
      <title>IE 64位插件</title>
      <link>https://874656645.github.io/posts/19-ie64-%E4%BD%8D%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Sat, 04 Dec 2021 11:36:17 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/19-ie64-%E4%BD%8D%E6%8F%92%E4%BB%B6/</guid>
      <description>1、设置IE为单进程模式  64位操作系统的 IE 默认每个 Tab 页都是一个进程，并且 Tab 页的进程是 32 位的，主进程是 64 位的，如下图所示  值为0时是单进程模式，1是多进程</description>
    </item>
    
    <item>
      <title>3DMax 操作</title>
      <link>https://874656645.github.io/posts/18-3dmax-%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Thu, 25 Nov 2021 11:36:19 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/18-3dmax-%E6%93%8D%E4%BD%9C/</guid>
      <description>1、查看纹理 渲染——材质编辑器——精简材质编辑器
2、合并Mesh——附加 3、资源跟踪器快捷键 Shift + T </description>
    </item>
    
    <item>
      <title>ArcGIS 字段计算（自增、随机数）</title>
      <link>https://874656645.github.io/posts/17-arcgis-%E5%AD%97%E6%AE%B5%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Thu, 25 Nov 2021 11:36:19 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/17-arcgis-%E5%AD%97%E6%AE%B5%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      <description>1、随机数 python 脚本
import random def randNum(): res = random.randint(1, 7) return res 2、自增 python 脚本
total = 0 def accumulate(increment): global total if total: total += increment else: total = increment return total </description>
    </item>
    
    <item>
      <title>查看 dll 版本</title>
      <link>https://874656645.github.io/posts/15-%E6%9F%A5%E7%9C%8B-dll-%E7%89%88%E6%9C%AC/</link>
      <pubDate>Wed, 05 Jun 2019 11:36:19 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/15-%E6%9F%A5%E7%9C%8B-dll-%E7%89%88%E6%9C%AC/</guid>
      <description>查看库的版本（win32 or 64） 1、通过 vs 自带工具 dumpbin.exe dumpbin.exe /headers dll文件路径
2、使用 notepad++ 直接用 记事本 或者 notepad++ 打开exe文件（dll文件），会有很多乱码，不要头疼，接下来只需要在第二段中找到 PE 两个字母，在其后的不远出会出现d 或者L。若是d，则证明该程序是64位；若是L，则证明是32位。</description>
    </item>
    
    <item>
      <title>Conda Learn</title>
      <link>https://874656645.github.io/posts/14-conda-learn/</link>
      <pubDate>Tue, 04 Jun 2019 10:16:11 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/14-conda-learn/</guid>
      <description>miniconda包管理器常用命令 0、指定conda的工作平台 set CONDA_FORCE_32BIT=1 // 指定 conda 的工作平台为 win-32
set CONDA_FORCE_32BIT= // 指定 conda 的工作平台为 x64
1、指定conda的资源镜像 # 推荐使用中科大的 conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free # 清华的镜像好像用不了了 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free # 设置搜索时显示通道地址 conda config --set show_channel_urls yes 执行此命令后会在当前的用户文件夹下生成一个 .condarc 的配置文件
2、搜索某个库的所有版本 conda search gdal
3、查看当前环境下已安装的包 conda list
4、创建一个虚拟环境 conda create --name python34 python=3.4
5、激活某个环境 activate python34 // for windows
source activate python34 // for Linux &amp;amp; Mac
6、取消激活 conda deactivate // for windows</description>
    </item>
    
    <item>
      <title>Restart Cortana</title>
      <link>https://874656645.github.io/posts/13-restart-cortana/</link>
      <pubDate>Tue, 09 Apr 2019 10:35:41 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/13-restart-cortana/</guid>
      <description>win10 小娜开始菜单无法搜索应用 1.用管理员权限打开 powershell.exe 或者 cmd;
2.在其中输入下列命令，重新注册激活小娜
Get-AppXPackage -Name Microsoft.Windows.Cortana | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register &amp;quot;$($_.InstallLocation)\AppXManifest.xml&amp;quot;}</description>
    </item>
    
    <item>
      <title>Cmake Learn</title>
      <link>https://874656645.github.io/posts/12-cmake-learn/</link>
      <pubDate>Fri, 22 Mar 2019 11:34:12 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/12-cmake-learn/</guid>
      <description>cmake命令
1、生成 VS 2015 win64 版本的解决方案 注：下面的命令要在cmd下使用，power shell不可以
cmake -H. -B./cmk_build/Win64 -G &amp;quot;Visual Studio 15 2017 Win64&amp;quot;
2、指定目标版本 cmake -D CMAKE_SYSTEM_VERSION=8.1 -H. -B./cmk_build/Win64 -G &amp;quot;Visual Studio 15 2017 Win64&amp;quot;
3、使用 MinGW 编译器 cmake -H. -B./cmk_build/MinGW -G &amp;quot;MinGW Makefiles&amp;quot;</description>
    </item>
    
    <item>
      <title>Vcpkg Learn</title>
      <link>https://874656645.github.io/posts/11-vcpkg-learn/</link>
      <pubDate>Fri, 22 Mar 2019 11:06:01 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/11-vcpkg-learn/</guid>
      <description>vcpkg安装及使用
注意：需要安装vs的英文语言包1、指定 vcpkg 中 msvc 的编译版本 在 vcpkg/triplets/文件夹下的所有cmake文件中添加代码 set(VCPKG_PLATFORM_TOOLSET v140)
如果同时安装了vs2017，需要确保安装vs2017的英文语言包</description>
    </item>
    
    <item>
      <title>Power Shell ExecutionPolicy</title>
      <link>https://874656645.github.io/posts/10-power-shell-executionpolicy/</link>
      <pubDate>Thu, 28 Feb 2019 17:01:31 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/10-power-shell-executionpolicy/</guid>
      <description>Power shell执行策略 原文网址
1、查看当前的安全策略 Get-ExecutionPolicy
2、修改执行策略 ps:这种方法会将执行策略保存到注册表
Set-ExecutionPolicy UnRestricted
or
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
3、查看所有支持的执行策略 [System.Enum]::GetNames([Microsoft.PowerShell.ExecutionPolicy])
4、获取影响当前会话的所有执行策略 Get-ExecutionPolicy -List
6、为当前 Windows PowerShell 会话设置执行策略 PowerShell.exe -ExecutionPolicy RemoteSigned</description>
    </item>
    
    <item>
      <title>Crawl Pictures From Website</title>
      <link>https://874656645.github.io/posts/9-crawl-pictures-from-website/</link>
      <pubDate>Thu, 28 Feb 2019 15:00:16 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/9-crawl-pictures-from-website/</guid>
      <description>1、使用requests库访问网址 2、使用xpath技术提取网页目标图片网址 3、通过os库保存图片到本地 #coding = utf-8 import requests import os from lxml import etree from urllib.parse import quote,unquote # import urllib.request class DmdSpider(object): name = &amp;#34;dmd&amp;#34; save_path = &amp;#39;E:/python/manhuadao/pics/&amp;#39; __picNo = 0 # 访问漫画岛网页 def start_request(self, url): header = {&amp;#39;User-Agent&amp;#39;: &amp;#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36&amp;#39;} r = requests.get(url, params=header) # print(r.text) self.__get_imgs(r) # 自动跳转下一页 html = etree.HTML(r.text) next_urls = html.xpath(&amp;#39;//div[@class=&amp;#34;read-bottom&amp;#34;]//a[@class=&amp;#34;next&amp;#34;]/@href&amp;#39;) # print(next) for href in next_urls: nexturl = href.</description>
    </item>
    
    <item>
      <title>Python Virtualenv</title>
      <link>https://874656645.github.io/posts/8-python-virtualenv/</link>
      <pubDate>Sat, 16 Feb 2019 11:20:20 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/8-python-virtualenv/</guid>
      <description>原文网址
在python中使用virtualenv创建虚拟环境 注意：要使用cmd命令行，不能使用Power Shell1、使用pip安装 pip install virtualenv
2、创建项目目录并用cd进入 mkdir E:\python\Virtualenv cd E:\python\Virtualenv 3、创建虚拟环境 virtualenv -p c:\Python36\python.exe env
或者
virtualenv env
此命令会在当前目录下创建一个env目录
4、启动虚拟环境 env\Scripts\activate
5、离开虚拟环境 deactivate
6、删除env文件夹即可 </description>
    </item>
    
    <item>
      <title>Scrapy Learn</title>
      <link>https://874656645.github.io/posts/7-scrapy-learn/</link>
      <pubDate>Fri, 15 Feb 2019 15:40:48 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/7-scrapy-learn/</guid>
      <description>原文网址
1. Using a virtual environment (recommended) pip install virtualenv
详细操作
2. Creating a new Scrapy project scrapy startproject tutorial
3. Writing a spider to crawl a site and extract data This is the code for our first Spider. Save it in a file named quotes_spider.py under the tutorial/spiders directory in your project:
import scrapy class QuotesSpider(scrapy.Spider): name = &amp;#34;quotes&amp;#34; def start_requests(self): urls = [ &amp;#39;http://quotes.toscrape.com/page/1/&amp;#39;, &amp;#39;http://quotes.toscrape.com/page/2/&amp;#39;, ] for url in urls: yield scrapy.</description>
    </item>
    
    <item>
      <title>Npm Commond Learning</title>
      <link>https://874656645.github.io/posts/6-npm-commond-learning/</link>
      <pubDate>Thu, 31 Jan 2019 17:36:00 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/6-npm-commond-learning/</guid>
      <description>1. 配置npm镜像源 1.1 临时使用 npm --registry https://registry.npm.taobao.org install --save-dev electron
1.2 持久使用 npm config set registry https://registry.npm.taobao.org
1.3 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info electron 1.4 通过cnpm使用 npm install -g cnpm --registry=https://registry.npm.taobao.org
1.5 使用 cnpm install express</description>
    </item>
    
    <item>
      <title>Learn Electron</title>
      <link>https://874656645.github.io/posts/5-learn-electron/</link>
      <pubDate>Thu, 31 Jan 2019 15:44:09 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/5-learn-electron/</guid>
      <description>1. Use npm run example 1.1 Clone repository git clone https://github.com/electron/electron-quick-start
1.2 Go into the repository cd electron-quick-start
1.3 Install dependencies PS:为了加快下载依赖模块的速度，通过修改镜像源ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ npm install
或者是
npm install --registry=https://registry.npm.taobao.org
1.4 Run the app npm start
2. Use yarn create a electron program 2.1 Create a program folder md electron-yarn-cz
进入项目文件夹
cd electron-yarn-cz
2.2 Create a program config file yarn init
2.3 Instal electron environment yarn add electron --dev --registry=https://registry.npm.taobao.org
2.4 Add main.</description>
    </item>
    
    <item>
      <title>Netstat</title>
      <link>https://874656645.github.io/posts/4-netstat/</link>
      <pubDate>Fri, 28 Dec 2018 16:10:00 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/4-netstat/</guid>
      <description>win10查看端口使用情况 1. 察看所有已使用的端口 netstat -ano
2. 查看特定端口的使用 netstat -ano|findstr &amp;quot;443&amp;quot;
3. 查看占用端口的进程PID tasklist|findstr &amp;quot;7648&amp;quot;</description>
    </item>
    
    <item>
      <title>Git Commond</title>
      <link>https://874656645.github.io/posts/3-git-commond/</link>
      <pubDate>Sat, 15 Dec 2018 22:45:47 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/3-git-commond/</guid>
      <description>Git 常用命令.</description>
    </item>
    
    <item>
      <title>Hugo Create a New Site by Hugo</title>
      <link>https://874656645.github.io/posts/2-hugo-create-a-new-site/</link>
      <pubDate>Fri, 14 Dec 2018 22:40:04 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/2-hugo-create-a-new-site/</guid>
      <description>This is a Hugo manual.</description>
    </item>
    
    <item>
      <title>spatialite 随机数</title>
      <link>https://874656645.github.io/posts/16-spatialite-%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://874656645.github.io/posts/16-spatialite-%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      <description>1、随机数 SQL 脚本
update &amp;#34;CYBuildings2&amp;#34; set &amp;#34;imgIndex&amp;#34; = FLOOR(1 + (RANDOM()+9223372036854775808)/2.0/9223372036854775808 * 7); </description>
    </item>
    
  </channel>
</rss>
