<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43; on Slow is Smooth and Smooth is Fast</title>
    <link>https://874656645.github.io/rick/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Slow is Smooth and Smooth is Fast</description>
    <image>
      <url>https://874656645.github.io/rick/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://874656645.github.io/rick/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 23 Feb 2022 22:19:35 +0800</lastBuildDate><atom:link href="https://874656645.github.io/rick/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;11 左值、右值和移动语义</title>
      <link>https://874656645.github.io/rick/posts/133-c&#43;&#43;11-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</link>
      <pubDate>Wed, 23 Feb 2022 22:19:35 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/133-c&#43;&#43;11-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</guid>
      <description>认识C++移动语义与右值引用
一文读懂C++右值引用和std::move
一、结论  C 中将数据类型分为左值和右值，在 C++11 中又将右值概念更为细致的分为将亡值（xvalue）和纯右值（prvalue）。 将亡值是 C++11 新增的跟右值引用相关的表达式，通常是将要被移动的对象（移为他用），比如返回右值引用 T&amp;amp;&amp;amp; 的函数返回值、std::move 的返回值。 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。 右值引用可以直接指向右值，也可以通过 std::move 指向左值；而左值引用只能指向左值（const左值引用也能指向右值）。 作为函数形参时，右值引用更灵活。虽然 const 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。 可移动对象在需要拷贝且被拷贝者之后不再被需要的场景，建议使用 std::move 触发移动语义，提升性能。 我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和 std::move 的语言特性。 std::move 本身只做类型转换，对性能无影响。 std::forward 同样也是做类型转换且更强大，move 只能转出来右值，forward 既可以转成右值，又可以转成左值。 函数最好不要返回函数体内局部变量的左值引用或右值引用。  二、注意事项  左值引用是具名变量值的别名 右值引用是不具名（匿名）变量的别名    引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值，但是，const左值引用是可以指向右值的
const int &amp;amp;ref_a = 5; int a = 5; int &amp;amp;ref_a = a; // 左值引用指向左值，编译通过 int &amp;amp;ref_a = 5; // 左值引用指向了右值，会编译失败   右值引用的标志是 &amp;amp;&amp;amp;，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值
int&amp;amp;&amp;amp; ref_a_right = 5; // ok int a = 5; int&amp;amp;&amp;amp; ref_a_left = a; // 编译不过，右值引用不可以指向左值  ref_a_right = 6; // 右值引用的用途：可以修改右值   事实上 std::move 移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(lvalue)。 所以，单纯的 std::move(xxx) 不会有性能提升，从这个角度来讲，右值引用和左值引用的功能相似，都是原始变量的别名，至于移动后原始变量是否可用，取决于被移动的数据类型对于移动语义的具体实现。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 auto_ptr 被废弃与 unique_ptr</title>
      <link>https://874656645.github.io/rick/posts/131-c&#43;&#43;11-auto_ptr-%E8%A2%AB%E5%BA%9F%E5%BC%83%E4%B8%8E-unique_ptr/</link>
      <pubDate>Tue, 22 Feb 2022 22:18:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/131-c&#43;&#43;11-auto_ptr-%E8%A2%AB%E5%BA%9F%E5%BC%83%E4%B8%8E-unique_ptr/</guid>
      <description>一、auto_ptr 特点  支持拷贝构造 支持赋值拷贝 支持 operator-&amp;gt;/operator* 解引用 支持指针变量重置 保证指针持有者唯一（涉及所有权转移）  二、问题一：使用数组存储 auto_ptr std::vector&amp;lt;std::auto_ptr&amp;lt;People&amp;gt;&amp;gt; peoples; // 这里实例化多个people并保存到数组中 ... std::auto_ptr&amp;lt;People&amp;gt; one = peoples[5]; ... std::cout &amp;lt;&amp;lt; peoples[5]-&amp;gt;get_name() &amp;lt;&amp;lt; std::endl; 原因在于 std::auto_ptr 支持 operator=，为了确保指针所有者唯一，这里转移了所有权，people[5] 变成了 null
三、问题二、函数传参 auto_ptr 类型 void do_somthing(std::auto_ptr&amp;lt;People&amp;gt; people){ // 该函数内不对people变量执行各种隐式/显示的所有权转移和释放  ... } std::auto_ptr&amp;lt;People&amp;gt; people(new People(&amp;#34;jony&amp;#34;)); do_something(people); ... std::cout &amp;lt;&amp;lt; people-&amp;gt;get_name() &amp;lt;&amp;lt; std::endl; 原因在于 std::auto_ptr支持拷贝构造，为了确保指针所有者唯一，这里转移了所有权
四、unique_ptr 在11中，可以支持右值以及移动语义了，此时可以完全匹配auto_ptr的所有权管理，新增了 std::unique_ptr。std::unique_ptr 不仅加入了移动语义的支持，同时也关闭了左值拷贝构造和左值赋值功能！杜绝了上述场景的出现！但是，此时，需要使用其他的方案了。比如场景一中，std::unique_ptr类型变量不能使用vector保存了！
所以 std::auto_ptr 废弃了，由 std::unique_ptr 代替！
class Person{ public: int getAge()const{ return m_age; } void setAge(int age){ m_age = age; } private: int m_age{20}; }; unique_ptr&amp;lt;Person&amp;gt; Change(unique_ptr&amp;lt;Person&amp;gt; p){ p-&amp;gt;setAge(30); return p; } int main() { unique_ptr&amp;lt;Person&amp;gt; pP(new Person); cout &amp;lt;&amp;lt; pP-&amp;gt;getAge() &amp;lt;&amp;lt; endl; // unique_ptr&amp;lt;Person&amp;gt; pP2 = Change(pP); // error： unique_ptr 删除了拷贝构造，所以需要使用 move 关键字转移所有权  unique_ptr&amp;lt;Person&amp;gt; pP2 = Change(move(pP)); // pP = pP2; // error：unique_ptr 删除了 = 赋值构造  cout &amp;lt;&amp;lt; &amp;#34;-------------&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; pP2-&amp;gt;getAge() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;-------------&amp;#34; &amp;lt;&amp;lt; endl; if(pP == nullptr){ cout &amp;lt;&amp;lt; &amp;#34;pP 变量已失效&amp;#34; &amp;lt;&amp;lt; endl; } return 0; } 输出：</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 mutable 关键字</title>
      <link>https://874656645.github.io/rick/posts/132-c&#43;&#43;11-mutable-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Tue, 22 Feb 2022 22:18:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/132-c&#43;&#43;11-mutable-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>一、修饰类成员变量 此关键字只能应用于类的非静态和非常量数据成员，mutable 是为了让 const 对象的某些数据成员可以被修改。static 是类的成员，不属于对象，常对象和常函数只会限制类的成员变量修改，所以类的 static 数据成员不需要 mutable 修饰，在常对象和常函数中也能被修改。
class Person{ public: int getAge() const{ m_count++; s_count++; return m_age; } int getCount()const{ return m_count; } private: int m_age{20}; mutable int m_count{0}; public: static int s_count; }; int Person::s_count = 0; int main() { Person p; p.getAge(); p.getAge(); p.getAge(); cout &amp;lt;&amp;lt; p.getCount() &amp;lt;&amp;lt; endl; // 3  cout &amp;lt;&amp;lt; p.s_count &amp;lt;&amp;lt; endl; // 3  return 0; } 二、修饰匿名函数 表示可以修改按值传入的变量的副本（不是值本身），类似于不带 const 关键字的形参。使用 mutable 关键字后对按值传入的变量进行的修改，不会将改变传递到 Lambda 表达式之外。如果不加 mutable 关键字，按值传入的变量是只读的，即使在 Lambda 表达式内部也不可修改</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 auto 与 decltype 关键字</title>
      <link>https://874656645.github.io/rick/posts/130-c&#43;&#43;11-auto-%E4%B8%8E-decltype-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Tue, 22 Feb 2022 20:30:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/130-c&#43;&#43;11-auto-%E4%B8%8E-decltype-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>一、进行自动类型推导  auto 的自动类型推断发生在编译期，所以使用 auto 并不会造成程序运行时效率的降低。 而是否会造成编译期的时间消耗，我认为是不会的，在未使用 auto 时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换。  int main() { int a = 10; auto val = a; cout &amp;lt;&amp;lt; typeid(val).name() &amp;lt;&amp;lt; endl; // i  return 0; } 二、在定义模板函数时，用于声明依赖模板参数的变量类型 不到编译的时候，x * y 的真正类型很难确定
template &amp;lt;class _Tx,class _Ty&amp;gt; void Multiply(_Tx x, _Ty y) { auto v = x * y; std::cout &amp;lt;&amp;lt; v; } int main() { int a = 10; double b = 1.53; Multiply(a, b); // 15.</description>
    </item>
    
    <item>
      <title>2022-02-14 杂记</title>
      <link>https://874656645.github.io/rick/posts/123-2022-02-14%E6%9D%82%E8%AE%B0/</link>
      <pubDate>Tue, 15 Feb 2022 15:29:35 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/123-2022-02-14%E6%9D%82%E8%AE%B0/</guid>
      <description>NULL，0，&#39;\0&#39;，&amp;lsquo;0&amp;rsquo;
int main() { char arr[] = {0, &amp;#39;\0&amp;#39;, &amp;#39;0&amp;#39;, 48}; printf(&amp;#34;%c\n&amp;#34;, arr[0]); printf(&amp;#34;%c\n&amp;#34;, arr[1]); printf(&amp;#34;%c\n&amp;#34;, arr[2]); printf(&amp;#34;%c\n&amp;#34;, arr[3]); printf(&amp;#34;---------------\n&amp;#34;); printf(&amp;#34;%d\n&amp;#34;, arr[0]); printf(&amp;#34;%d\n&amp;#34;, arr[1]); printf(&amp;#34;%d\n&amp;#34;, arr[2]); printf(&amp;#34;%d\n&amp;#34;, arr[3]); return 0; } 输出：
0 0 --------------- 0 0 48 48   UTF-8 向下兼容 ASCII 编码，UTF-8 编码中，一个英文字为一个字节，一个中文一般为三个字节（ASCII、Unicode、UTF-8）
 0xxxxxxx：单字节编码形式，这和 ASCII 编码完全一样，因此 UTF-8 是兼容 ASCII 的； 110xxxxx 10xxxxxx：双字节编码形式； 1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式； 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式； UTF-8：每字 1 ~ 6 字节 Unicode（UCS-2）：每字都是 2 bytes UTF-16：每字 2 ~ 4 字节 UTF-32（UCS-4）：每字都是 4 bytes    float 单精度，浮点数在内存中是按科学计数法来存储的，小数点后6位能确定表示，float 是由 1 bit 符号位，8 bit 指数位和 23 bit 尾数位组成，精度是由尾数位决定的（2^23 = 8388608）</description>
    </item>
    
    <item>
      <title>递归</title>
      <link>https://874656645.github.io/rick/posts/119-%E9%80%92%E5%BD%92/</link>
      <pubDate>Mon, 07 Feb 2022 21:38:53 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/119-%E9%80%92%E5%BD%92/</guid>
      <description>逆序打印字符串
void printReverseString(const char* str){ if(*str == &amp;#39;\0&amp;#39;){ return; } printReverseString(str + 1); printf(&amp;#34;%c&amp;#34;, *str); } int main() { const char* str = &amp;#34;Hello World&amp;#34;; printReverseString(str); // dlroW olleH  return 0; }   逆序输出链表
struct LinkNode{ int data; struct LinkNode* next; }; void printReverseLinkNode(struct LinkNode* header){ if(header == NULL){ return; } printReverseLinkNode(header-&amp;gt;next); printf(&amp;#34;%d\n&amp;#34;, header-&amp;gt;data); } int main() { struct LinkNode* header = malloc(sizeof(struct LinkNode)); struct LinkNode* node1 = malloc(sizeof(struct LinkNode)); node1-&amp;gt;data = 10; node1-&amp;gt;next = NULL; struct LinkNode* node2 = malloc(sizeof(struct LinkNode)); node2-&amp;gt;data = 20; node2-&amp;gt;next = NULL; struct LinkNode* node3 = malloc(sizeof(struct LinkNode)); node3-&amp;gt;data = 30; node3-&amp;gt;next = NULL; header-&amp;gt;next = node1; node1-&amp;gt;next = node2; node2-&amp;gt;next = node3; printReverseLinkNode(header-&amp;gt;next); return 0; }   递归实现给出一个数 8793，依次打印千位数 8、百位数 7、十位数 9、个位数 3</description>
    </item>
    
    <item>
      <title>常用的宏定义</title>
      <link>https://874656645.github.io/rick/posts/118-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Mon, 07 Feb 2022 10:11:16 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/118-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/</guid>
      <description>int main() { printf(&amp;#34;%s\n&amp;#34;, __FILE__); // main.c  printf(&amp;#34;%d\n&amp;#34;, __LINE__); // 14  printf(&amp;#34;%s\n&amp;#34;, __DATE__); // Feb 7 2022  printf(&amp;#34;%s\n&amp;#34;, __TIME__); // 01:59:37  return 0; } // func1.h #ifdef __cplusplus extern &amp;#34;C&amp;#34;{ #endif  void func1(); #ifdef __cplusplus } #endif  // main.h extern &amp;#34;C&amp;#34;{ include &amp;#34;func1.h&amp;#34; } extern &amp;#34;C&amp;#34;{ extern void func1(); } int main() { func1(); return 0; } </description>
    </item>
    
    <item>
      <title>char* 数组</title>
      <link>https://874656645.github.io/rick/posts/116-char-%E6%98%9F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 03 Feb 2022 20:29:17 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/116-char-%E6%98%9F%E6%95%B0%E7%BB%84/</guid>
      <description>void printArr(const char ** p, int len){ for(int i = 0; i &amp;lt; len; ++i){ cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; endl; } } void sortSelect(const char ** p, int len){ for(int i = 0; i &amp;lt; len - 1; ++i){ int max = i; for(int j = i + 1; j &amp;lt; len; ++j){ if(p[j] &amp;gt; p[max]){ max = j; } } // 交换  if(i != max){ const char* tmp = p[i]; p[i] = p[max]; p[max] = tmp; } } } int main() { const char* arr[] = {&amp;#34;aa&amp;#34;, &amp;#34;bb&amp;#34;, &amp;#34;cc&amp;#34;, &amp;#34;dd&amp;#34;, &amp;#34;ee&amp;#34;}; int len = sizeof(arr) / sizeof(char*); cout &amp;lt;&amp;lt; len &amp;lt;&amp;lt; endl; printArr(arr, len); sortSelect(arr, len); cout &amp;lt;&amp;lt; &amp;#34;----------------&amp;#34; &amp;lt;&amp;lt; endl; printArr(arr, len); return 0; } 输出：</description>
    </item>
    
    <item>
      <title>装饰器模式</title>
      <link>https://874656645.github.io/rick/posts/115-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 02 Feb 2022 16:59:08 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/115-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代。
装饰模式可以动态给一个类增加功能</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://874656645.github.io/rick/posts/114-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 02 Feb 2022 16:11:14 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/114-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者。</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>https://874656645.github.io/rick/posts/113-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 02 Feb 2022 15:45:50 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/113-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>将一个请求封闭为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作（Action）模式或事务（Transaction）模式。
命令模式可以将请求者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://874656645.github.io/rick/posts/112-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 16:59:42 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/112-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>策略模式定义了一系列的算法，并将每个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</description>
    </item>
    
    <item>
      <title>模板方法模式</title>
      <link>https://874656645.github.io/rick/posts/111-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 16:41:35 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/111-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
class TemplateDrink{ public: virtual void boilWater() = 0; virtual void drew() = 0; virtual void pourCup() = 0; virtual void addSomething() = 0; void make(){ boilWater(); drew(); pourCup(); addSomething(); } }; class Tea : public TemplateDrink{ public: void boilWater() override{ cout &amp;lt;&amp;lt; &amp;#34;煮山泉水...&amp;#34; &amp;lt;&amp;lt; endl; } void drew() override{ cout &amp;lt;&amp;lt; &amp;#34;冲龙井茶...&amp;#34; &amp;lt;&amp;lt; endl; } void pourCup() override{ cout &amp;lt;&amp;lt; &amp;#34;倒入茶杯中...&amp;#34; &amp;lt;&amp;lt; endl; } void addSomething() override{ cout &amp;lt;&amp;lt; &amp;#34;加点柠檬.</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>https://874656645.github.io/rick/posts/110-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 16:07:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/110-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>有一个已经写好的接口，但是不符合需求，适配器就是将已有的接口转化为需要的形式
class MyPrint{ public: void operator()(int a, int b){ cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; endl; } }; class TargetInterface{ public: virtual void operator()(int v) = 0; }; class MyAdaptor : public TargetInterface{ public: MyAdaptor(int param):param(param){} void operator()(int v){ print(v, param); } private: MyPrint print; int param; }; MyAdaptor myBind2nd(int v){ return MyAdaptor(v); } int main() { vector&amp;lt;int&amp;gt; v; for(int i = 0; i &amp;lt; 10; ++i){ v.push_back(i); } for_each(v.begin(), v.</description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>https://874656645.github.io/rick/posts/109-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 15:32:38 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/109-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>将复杂的子系统抽象到同一个接口进行管理，外界只需要通过此接口与子类系统进行交互，而不必直接与复杂的子类系统进行交互
案例：家庭影院外观模式 实现KTV模式：电视打开，灯关掉，音响打开，麦克风打开，DVD打开
实现游戏模式：电视打开，音响打开，游戏机打开</description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>https://874656645.github.io/rick/posts/108-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 07:28:53 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/108-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://874656645.github.io/rick/posts/107-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 31 Jan 2022 20:43:34 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/107-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>单例在内存中只有一份，在内存中不会占用太多，程序退出时会随着程序统一释放内存，所以可以不必特意释放  一、懒汉式 不是线程安全的，所以多线程使用要加锁
class Singleton{ public: static Singleton* getInstance(){ if(s_instance == nullptr){ s_instance = new Singleton; } return s_instance; } // 可有可无，程序结束时，系统会自动回收程序的所有内存  class Garbo{ ~Garbo(){ if(s_instance){ cout &amp;lt;&amp;lt; &amp;#34;gc...&amp;#34; &amp;lt;&amp;lt; endl; delete s_instance; } } }; private: Singleton(){ cout &amp;lt;&amp;lt; &amp;#34;Singleton()...&amp;#34; &amp;lt;&amp;lt; endl; } Singleton(const Singleton&amp;amp;) = delete; Singleton&amp;amp; operator=(const Singleton&amp;amp;) = delete; static Singleton* s_instance; static Garbo s_gc; }; Singleton* Singleton::s_instance = nullptr; int main() { cout &amp;lt;&amp;lt; &amp;#34;main().</description>
    </item>
    
    <item>
      <title>抽象工厂模式</title>
      <link>https://874656645.github.io/rick/posts/106-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 31 Jan 2022 17:44:49 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/106-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description> 抽象工厂针对的是产品族，而不是产品等级 产品族：同一产地或者同一厂商，功能不同 产品等级：功能相同，产地或者厂商不同 对于增加产品族，符合开闭原则 对于增加产品等级，不符合开闭原则  // 抽象工厂模式 class AbstractApple{ public: virtual void showName() = 0; }; class AbstractBanana{ public: virtual void showName() = 0; }; class AbstractPear{ public: virtual void showName() = 0; }; class ChinaApple : public AbstractApple{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是中国苹果！&amp;#34; &amp;lt;&amp;lt; endl; } }; class ChinaBanana : public AbstractBanana{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是中国香蕉！&amp;#34; &amp;lt;&amp;lt; endl; } }; class ChinaPear : public AbstractPear{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是中国鸭梨！&amp;#34; &amp;lt;&amp;lt; endl; } }; class USAApple : public AbstractApple{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是美国苹果！&amp;#34; &amp;lt;&amp;lt; endl; } }; class USABanana : public AbstractBanana{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是美国香蕉！&amp;#34; &amp;lt;&amp;lt; endl; } }; class USAPear : public AbstractPear{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是美国鸭梨！&amp;#34; &amp;lt;&amp;lt; endl; } }; class JapanApple : public AbstractApple{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是日本苹果！&amp;#34; &amp;lt;&amp;lt; endl; } }; class JapanBanana : public AbstractBanana{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是日本香蕉！&amp;#34; &amp;lt;&amp;lt; endl; } }; class JapanPear : public AbstractPear{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是日本鸭梨！&amp;#34; &amp;lt;&amp;lt; endl; } }; class AbstractFactory{ public: virtual AbstractApple* CreateApple() = 0; virtual AbstractBanana* CreateBanana() = 0; virtual AbstractPear* CreatePear() = 0; }; class ChinaFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new ChinaApple; } AbstractBanana* CreateBanana() override{ return new ChinaBanana; } AbstractPear* CreatePear() override{ return new ChinaPear; } }; class USAFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new USAApple; } AbstractBanana* CreateBanana() override{ return new USABanana; } AbstractPear* CreatePear() override{ return new USAPear; } }; class JapanFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new JapanApple; } AbstractBanana* CreateBanana() override{ return new JapanBanana; } AbstractPear* CreatePear() override{ return new JapanPear; } }; int main() { AbstractFactory* factory = nullptr; AbstractApple* apple = nullptr; AbstractBanana* banana = nullptr; AbstractPear* pear = nullptr; // 中国  factory = new ChinaFactory; apple = factory-&amp;gt;CreateApple(); apple-&amp;gt;showName(); banana = factory-&amp;gt;CreateBanana(); banana-&amp;gt;showName(); pear = factory-&amp;gt;CreatePear(); pear-&amp;gt;showName(); delete pear; delete banana; delete apple; delete factory; // 美国  factory = new USAFactory; apple = factory-&amp;gt;CreateApple(); apple-&amp;gt;showName(); banana = factory-&amp;gt;CreateBanana(); banana-&amp;gt;showName(); pear = factory-&amp;gt;CreatePear(); pear-&amp;gt;showName(); delete pear; delete banana; delete apple; delete factory; // 日本  factory = new JapanFactory; apple = factory-&amp;gt;CreateApple(); apple-&amp;gt;showName(); banana = factory-&amp;gt;CreateBanana(); banana-&amp;gt;showName(); pear = factory-&amp;gt;CreatePear(); pear-&amp;gt;showName(); delete pear; delete banana; delete apple; delete factory; return 0; } </description>
    </item>
    
    <item>
      <title>工厂方法模式</title>
      <link>https://874656645.github.io/rick/posts/105-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 31 Jan 2022 15:51:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/105-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>工厂方法模式 = 简单工厂模式 + 开闭原则
类的个数成倍增多，维护成本很高
适用场景：
 客户端不知道它所需要的对象的类 抽象工厂类通过其子类来指定创建哪个对象  // 工厂方法模式 class AbstractFruit{ public: virtual void showName() = 0; }; class Apple : public AbstractFruit{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是苹果！&amp;#34; &amp;lt;&amp;lt; endl; } }; class Banana : public AbstractFruit{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是香蕉！&amp;#34; &amp;lt;&amp;lt; endl; } }; class Pear : public AbstractFruit{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是鸭梨！&amp;#34; &amp;lt;&amp;lt; endl; } }; // 抽象工厂 class AbstractFruitFactory{ public: virtual AbstractFruit* CreateFruit() = 0; }; class AppleFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Apple; } }; class PearFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Pear; } }; class BananaFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Banana; } }; int main() { AbstractFruitFactory* factory = nullptr; AbstractFruit* fruit = nullptr; factory = new AppleFactory; fruit = factory-&amp;gt;CreateFruit(); fruit-&amp;gt;showName(); delete fruit; delete factory; factory = new BananaFactory; fruit = factory-&amp;gt;CreateFruit(); fruit-&amp;gt;showName(); delete fruit; delete factory; factory = new PearFactory; fruit = factory-&amp;gt;CreateFruit(); fruit-&amp;gt;showName(); delete fruit; delete factory; return 0; } </description>
    </item>
    
    <item>
      <title>简单工厂模式</title>
      <link>https://874656645.github.io/rick/posts/104-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 31 Jan 2022 15:14:38 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/104-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description> 实现了客户端与功能类的解耦 但是违反了类的单一职责原则，整个类的代码冗长，阅读难度、维护难度和测试难度也很大 违反了开闭原则，增添功能要修改源代码  适用场景：
 工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂 客户端只知道传入工厂类的参数，对于如何创建对象并不关心  // 简单工厂模式 class AbstractFruit{ public: virtual void showName() = 0; }; class Apple : public AbstractFruit{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是苹果！&amp;#34; &amp;lt;&amp;lt; endl; } }; class Banana : public AbstractFruit{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是香蕉！&amp;#34; &amp;lt;&amp;lt; endl; } }; class Pear : public AbstractFruit{ public: void showName() override{ cout &amp;lt;&amp;lt; &amp;#34;我是鸭梨！&amp;#34; &amp;lt;&amp;lt; endl; } }; class FruitFactory{ public: static AbstractFruit* CreateFruit(string flag){ if(flag == &amp;#34;apple&amp;#34;){ return new Apple; } else if(flag == &amp;#34;banana&amp;#34;){ return new Banana; } else if(flag == &amp;#34;pear&amp;#34;){ return new Pear; } else{ return nullptr; } } }; int main() { AbstractFruit* fruit = FruitFactory::CreateFruit(&amp;#34;apple&amp;#34;); fruit-&amp;gt;showName(); delete fruit; fruit = FruitFactory::CreateFruit(&amp;#34;banana&amp;#34;); fruit-&amp;gt;showName(); delete fruit; fruit = FruitFactory::CreateFruit(&amp;#34;pear&amp;#34;); fruit-&amp;gt;showName(); delete fruit; return 0; } </description>
    </item>
    
    <item>
      <title>依赖倒转原则</title>
      <link>https://874656645.github.io/rick/posts/103-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/</link>
      <pubDate>Mon, 31 Jan 2022 11:35:37 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/103-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/</guid>
      <description>传统过程式设计 传统的过程式设计倾向于使高层次的模块依赖于低层次的模块，抽象层依赖于具体实现层
// 底层实现 class BankWorker{ public: void saveService(){ cout &amp;lt;&amp;lt; &amp;#34;办理存款业务...&amp;#34; &amp;lt;&amp;lt; endl; } void transferService(){ cout &amp;lt;&amp;lt; &amp;#34;办理转账业务...&amp;#34; &amp;lt;&amp;lt; endl; } void payService(){ cout &amp;lt;&amp;lt; &amp;#34;办理支付业务...&amp;#34; &amp;lt;&amp;lt; endl; } }; // 中层封装 void doSaveBusiness(BankWorker* worker){ worker-&amp;gt;saveService(); } void doTransferBusiness(BankWorker* worker){ worker-&amp;gt;transferService(); } void doPayBusiness(BankWorker* worker){ worker-&amp;gt;payService(); } // 高层调用 void test1(){ BankWorker* bw = new BankWorker; doSaveBusiness(bw); doPayBusiness(bw); doTransferBusiness(bw); delete bw; } 依赖倒转 // 抽象层 class AbstractWorker{ public: virtual void doBusiness() = 0; }; // 实现层 class SaveBankWorker:public AbstractWorker{ public: void doBusiness()override{ cout &amp;lt;&amp;lt; &amp;#34;办理存款业务.</description>
    </item>
    
    <item>
      <title>合成复用原则</title>
      <link>https://874656645.github.io/rick/posts/102-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 30 Jan 2022 21:45:22 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/102-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</guid>
      <description>优先使用组合的方式，而不是继承
class AbstractCar{ public: virtual void run() = 0; }; class BMW:public AbstractCar{ public: void run()override{ cout &amp;lt;&amp;lt; &amp;#34;BMW run&amp;#34; &amp;lt;&amp;lt; endl; } }; class DaZhong:public AbstractCar{ public: void run()override{ cout &amp;lt;&amp;lt; &amp;#34;DaZhong run&amp;#34; &amp;lt;&amp;lt; endl; } }; #if 0// 错误的做法 class Person : public BMW{ public: void drive(){ run(); } }; void test1(){ Person p; p.drive(); } #endif // 正确做法 class Person{ public: Person(){ car = nullptr; } Person(AbstractCar* c){ car = c; } void drive(){ car-&amp;gt;run(); delete car; } void drive(AbstractCar* car){ car-&amp;gt;run(); delete car; } private: AbstractCar* car; }; void test2(){ // 方式一：  Person* p = new Person(new BMW); p-&amp;gt;drive(); delete p; p = new Person(new DaZhong); p-&amp;gt;drive(); delete p; // 方式二：  Person pp; pp.</description>
    </item>
    
    <item>
      <title>迪米特法则</title>
      <link>https://874656645.github.io/rick/posts/101-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</link>
      <pubDate>Sun, 30 Jan 2022 20:38:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/101-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</guid>
      <description>又叫最少知识原则
封装一个中间层进行隔离
class AbstractBuilding{ public: virtual string getQuality()const = 0; virtual void sale() = 0; }; class BuildingA:public AbstractBuilding{ public: BuildingA(){ m_quality = &amp;#34;高品质&amp;#34;; } string getQuality()const override{ return m_quality; } void sale()override{ cout &amp;lt;&amp;lt; &amp;#34;楼盘A：&amp;#34; &amp;lt;&amp;lt; m_quality &amp;lt;&amp;lt; endl; } private: string m_quality; }; class BuildingB:public AbstractBuilding{ public: BuildingB(){ m_quality = &amp;#34;低品质&amp;#34;; } string getQuality()const override{ return m_quality; } void sale()override{ cout &amp;lt;&amp;lt; &amp;#34;楼盘B：&amp;#34; &amp;lt;&amp;lt; m_quality &amp;lt;&amp;lt; endl; } private: string m_quality; }; // 错误的做法 // 客户端 void test1(){ string myRequest = &amp;#34;低品质&amp;#34;; BuildingA* bA = new BuildingA; if(bA-&amp;gt;getQuality() == myRequest){ bA-&amp;gt;sale(); delete bA; } BuildingB* bB = new BuildingB; if(bB-&amp;gt;getQuality() == myRequest){ bB-&amp;gt;sale(); delete bB; } } // 正确做法 // 封装一个中间类 class Mediator{ public: Mediator(){ AbstractBuilding* b = new BuildingA; vb.</description>
    </item>
    
    <item>
      <title>开闭原则</title>
      <link>https://874656645.github.io/rick/posts/100-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 30 Jan 2022 20:05:30 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/100-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</guid>
      <description>对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码
如下所示，如果想要扩展乘法、除法、取模等算法，就不用修改原码，只需增加新类
class AbstractCalculator{ public: virtual void setOperatorNum(int a, int b) = 0; virtual int getResult() = 0; }; class PlusCalculator:public AbstractCalculator{ public: void setOperatorNum(int a, int b)override{ m_a = a; m_b = b; } int getResult()override{ return m_a + m_b; } private: int m_a{0}; int m_b{0}; }; class MinusCalculator:public AbstractCalculator{ public: void setOperatorNum(int a, int b)override{ m_a = a; m_b = b; } int getResult()override{ return m_a - m_b; } private: int m_a{0}; int m_b{0}; }; int main() { AbstractCalculator* calculator = new PlusCalculator; calculator-&amp;gt;setOperatorNum(10, 20); cout &amp;lt;&amp;lt; calculator-&amp;gt;getResult() &amp;lt;&amp;lt; endl; delete calculator; calculator = nullptr; calculator = new MinusCalculator; calculator-&amp;gt;setOperatorNum(10, 20); cout &amp;lt;&amp;lt; calculator-&amp;gt;getResult() &amp;lt;&amp;lt; endl; delete calculator; calculator = nullptr; return 0; } </description>
    </item>
    
    <item>
      <title>面向对象设计原则</title>
      <link>https://874656645.github.io/rick/posts/99-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 30 Jan 2022 19:17:09 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/99-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
      <description>原则目的：高内聚，低耦合
 单一职责原则 Single Responsibility Principal（SRP）：类的职责单一，对外只提供一种功能 开闭原则 Open-Closed Principal（OCP）：对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码 里氏代换原则 Liskov Substitution Principal（LSP）：任何抽象类出现的地方都可以用他的实现类进行替换（多态） 依赖倒转原则 Dependence Inversion Principal（DIP）：依赖于抽象（接口），不要依赖具体的实现（类），针对接口编程 接口隔离原则 Interface Segregation Principal（ISP）：一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去 合成复用原则 Composite Reuse Principal（CRP）：对于继承和组合，优先使用组合 迪米特法则 Law of Demeter（LoD）：一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节（黑盒原理）  </description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://874656645.github.io/rick/posts/98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 30 Jan 2022 11:57:37 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式
一、概念  设计模式是在特定环境下人们解决某类重复出现的问题的一套成功或有效的解决方案。 软件模式并非仅限于设计模式，还包括架构模式、分析模式、过程模式等。 在一定环境下，用固定套路解决问题。 设计模式的基础是多态。  二、目的  学习设计模式有助于更加深入的理解面向对象思想 如何将代码分散在几个不同的类中 为什么要有接口 何谓针对抽象编程 何时不应该使用继承 如何不修改源代码增加新功能 更好地阅读和理解现有类库与其它系统中的源代码  三、软件设计模式种类 GoF 提出的设计模式有 23 种，加简单工厂模式，一共 24 种
1、创建型模式 Creational 6种 如何创建对象
 单例模式 简单工厂模式 工厂方法模式 抽象工厂模式 原型模式 建造者模式  2、结构型模式 Structural 7种 如何实现类或对象的组合
让类和类进行组合，获得更大的结构
 适配器模式 桥接模式 组合模式 装饰模式 外观模式 享元模式 代理模式  3、行为型模式 Behavioral 11种 类或对象怎样交互以及怎样分配职责
 职责链模式 命令模式 解释器模式 迭代器模式 中介模式 备忘录模式 观察者模式 状态模式 策略模式 模板方法模式 访问者模式  </description>
    </item>
    
    <item>
      <title>UML 统一建模语言</title>
      <link>https://874656645.github.io/rick/posts/97-uml-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Sat, 29 Jan 2022 19:55:47 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/97-uml-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</guid>
      <description>一、用例图  用例代表系统的某项完整功能 从客户角度来描述系统功能 包括参与者、用例、关系  1. 泛化关系 Generalization  父类和子类的关系  2. 包含关系 Include  一个功能肯定会使用另一个功能  3. 扩展关系 Extend  完成某个功能的时候偶尔会执行另一个功能  二、类图 用来显示系统中的类，接口以及它们之间的关系
1. 泛化关系 Generalization（is a） 一种类与类之间的继承关系
2. 实现关系 Realization（is a） 类与抽象类之间的实现关系
3. 依赖关系 Dependence（use a） 两个相对独立的系统，一个系统负责构造另一个系统的实例，或者依赖另一个系统的服务
类 A 做为类 B 方法的形参，而不是类 B 的成员属性
4. 关联关系 Directed Association 两个相对独立的系统，一个系统的实例与另一个系统的一些实例存在固定的对应关系
  聚合 Aggregation
 聚合关系是关联关系的一种，是更强的关联关系 聚合是整体和部分之间的关系，例如汽车由引擎、轮胎以及其它零件组成 聚合关系也是通过成员变量来实现的，但是，关联关系所涉及的两个类处在同一个层次上，而聚合关系中，两个类处于不同层次上，一个代表整体，一个代表部分 整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享    组合 Composition
  三、对象图 四、时序图 五、活动图 </description>
    </item>
    
    <item>
      <title>函数对象适配器</title>
      <link>https://874656645.github.io/rick/posts/96-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8/</link>
      <pubDate>Thu, 27 Jan 2022 21:55:47 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/96-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8/</guid>
      <description>仿函数适配器 bind1st、bind2nd 将二元仿函数转为一元仿函数
  仿函数适配器 not1、not2
  仿函数适配器 ptr_fun 将普通函数转为函数对象，然后就可以与其它仿函数适配器一起使用了
  仿函数适配器 mem_fun、mem_fun_ref 将成员函数转为适配器
  class MyPrint : public binary_function&amp;lt;int, int, void&amp;gt;{ public: void operator()(int v, int val) const{ cout &amp;lt;&amp;lt; &amp;#34;v: &amp;#34; &amp;lt;&amp;lt; v &amp;lt;&amp;lt; &amp;#34;, val: &amp;#34; &amp;lt;&amp;lt; val &amp;lt;&amp;lt; &amp;#34;, v + val: &amp;#34; &amp;lt;&amp;lt; v + val &amp;lt;&amp;lt; endl; } }; void myPrint(int v, int val){ cout &amp;lt;&amp;lt; v + val &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } class MySort: public binary_function&amp;lt;int, int, bool&amp;gt;{ public: bool operator() (int lhs, int rhs)const{ return lhs &amp;gt; rhs; } }; class MyGreater: public unary_function&amp;lt;int, bool&amp;gt;{ public: bool operator()(int v)const{ return v &amp;gt; 50; } }; void printVec(const vector&amp;lt;int&amp;gt; &amp;amp;v){ for(const auto &amp;amp;p : v){ cout &amp;lt;&amp;lt; p &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } cout &amp;lt;&amp;lt; endl; } class Person{ public: Person(int id, int age):id(id), age(age){} void show(){ cout &amp;lt;&amp;lt; &amp;#34;id: &amp;#34; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &amp;#34;, age: &amp;#34; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; endl; } int id; int age; }; int main(){ vector&amp;lt;int&amp;gt; v; for(int i = 0; i &amp;lt; 10; ++i){ v.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 沉思录笔记</title>
      <link>https://874656645.github.io/rick/posts/95-c&#43;&#43;-%E6%B2%89%E6%80%9D%E5%BD%95%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 26 Jan 2022 17:48:58 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/95-c&#43;&#43;-%E6%B2%89%E6%80%9D%E5%BD%95%E7%AC%94%E8%AE%B0/</guid>
      <description>有的情况下，现在的折衷方案比未来的理想方案好得多
  我考虑问题的本质是什么，再定义一个类抓住这个本质，并确保这个类能独立地工作。然后在遇到符合这个本质的问题时就使用这个类。
  只要类定义正确，我就只能按照我编写它的初衷那样去用它。
  C++ 哲学：抽象，实用，只为用到的东西付出代价。
  类设计者的核查表：
 你的类需要一个构造函数吗？ 你的数据成员是私有的吗？（使用函数，可以延迟计算，不必时时计算，保证数据成员的准确性） 你的类需要一个无参的构造函数吗？（对象数组） 是不是每个构造函数初始化所有的数据成员？ 类需要析构函数吗？ 类需要一个虚析构函数吗？ 你的类需要复制构造函数吗？（是否需要深拷贝） 你的类需要一个赋值操作符吗？ 你的赋值操作符能正确地将对象赋给对象本身吗？ 你的类需要定义关系操作符吗？ 删除数组时你记住了用 delete[] 吗？ 记得在复制构造函数和赋值操作符的参数类型中加上 const 了吗？ 如果函数有引用参数，它们应该是 const 引用吗？ 记得适当地声明成员函数为 const 的了吗？    代理类：用类来表示概念（RAII）
class Vehicle{ public: virtual double weight() = 0; virtual void start() = 0; virtual Vehicle* copy() const = 0; virtual ~Vehicle(){} }; class RoadVehicle: public Vehicle{ /* .</description>
    </item>
    
    <item>
      <title>机房预约系统案例</title>
      <link>https://874656645.github.io/rick/posts/94-%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Mon, 24 Jan 2022 20:53:57 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/94-%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F%E6%A1%88%E4%BE%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>switch 与 if Else 区别</title>
      <link>https://874656645.github.io/rick/posts/93-switch-%E4%B8%8E-if-else-%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 24 Jan 2022 20:01:08 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/93-switch-%E4%B8%8E-if-else-%E5%8C%BA%E5%88%AB/</guid>
      <description> while 循环中的 switch, break 只能中断 switch，不能中断 while 循环  void managerMenue(){ while(true){ cout &amp;lt;&amp;lt; &amp;#34;这是子菜单&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;是否返回主菜单？&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;1 是&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;2 否&amp;#34; &amp;lt;&amp;lt; endl; int i = 0; cin &amp;gt;&amp;gt; i; switch(i){ case 1: break; case 2: return; default: break; } // if(i == 1){  // // system(&amp;#34;reset&amp;#34;);  // break;  // }  // else if(i == 2){  // return;  // }  // else{  // cout &amp;lt;&amp;lt; &amp;#34;输入有误，请重新输入&amp;#34; &amp;lt;&amp;lt; endl;  // }  } cout &amp;lt;&amp;lt; &amp;#34;这是子菜单循环外代码&amp;#34; &amp;lt;&amp;lt; endl; } int main() { while(true){ cout &amp;lt;&amp;lt; &amp;#34;欢迎登陆！&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;这是主菜单&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;请输入选项：&amp;#34; &amp;lt;&amp;lt; endl; int i = 0; cin &amp;gt;&amp;gt; i; // switch(i)  // {  // case 1:  // system(&amp;#34;reset&amp;#34;);  // managerMenue();  // break;  // case 2:  // break;  // }  if(i == 1){ // system(&amp;#34;reset&amp;#34;);  managerMenue(); // break;  } else{ break; } cout &amp;lt;&amp;lt; &amp;#34;switch 外代码&amp;#34; &amp;lt;&amp;lt; endl; } cout &amp;lt;&amp;lt; &amp;#34;while 外代码&amp;#34; &amp;lt;&amp;lt; endl; return 0; } </description>
    </item>
    
    <item>
      <title>演讲比赛流程管理案例</title>
      <link>https://874656645.github.io/rick/posts/92-%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Sat, 22 Jan 2022 17:21:43 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/92-%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>常用算法</title>
      <link>https://874656645.github.io/rick/posts/91-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 22 Jan 2022 09:31:07 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/91-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</guid>
      <description>一、常用遍历算法 1. for_each 2. transform  搬运的目标容器必须要提前开辟空间（resize 而不是 reserve），否则无法正常搬运  int main() { vector&amp;lt;int&amp;gt; v; for(int i = 0; i &amp;lt; 10; ++i){ v.push_back(i); } vector&amp;lt;int&amp;gt; v1; v1.resize(v.size()); // 要用 resize, 不能用 reserve  transform(v.begin(), v.end(), v1.begin(), [](int v){ return v * 2;}); for_each(v1.begin(), v1.end(), [](int v){ cout &amp;lt;&amp;lt; v &amp;lt;&amp;lt; &amp;#34; &amp;#34;; }); cout &amp;lt;&amp;lt; endl; return 0; } 二、常用查找算法 1. find 2. find_if 3. adjacent_find 4. binary_search  无序序列不可用  5.</description>
    </item>
    
    <item>
      <title>内建函数对象 functional</title>
      <link>https://874656645.github.io/rick/posts/90-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-functional/</link>
      <pubDate>Thu, 20 Jan 2022 21:28:13 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/90-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-functional/</guid>
      <description>算术仿函数 template&amp;lt;class T&amp;gt; T plus&amp;lt;T&amp;gt; //加法仿函数 template&amp;lt;class T&amp;gt; T minus&amp;lt;T&amp;gt; //减法仿函数 template&amp;lt;class T&amp;gt; T multiplies&amp;lt;T&amp;gt; //乘法仿函数 template&amp;lt;class T&amp;gt; T divides&amp;lt;T&amp;gt; //除法仿函数 template&amp;lt;class T&amp;gt; T modulus&amp;lt;T&amp;gt; //取模仿函数 template&amp;lt;class T&amp;gt; T negate&amp;lt;T&amp;gt; //取反仿函数 一元谓词 关系仿函数 template&amp;lt;class T&amp;gt; bool equal_to&amp;lt;T&amp;gt; //等于 template&amp;lt;class T&amp;gt; bool not_equal_to&amp;lt;T&amp;gt; //不等于 template&amp;lt;class T&amp;gt; bool greater&amp;lt;T&amp;gt; //大于 template&amp;lt;class T&amp;gt; bool greater_equal&amp;lt;T&amp;gt; //大于等于 template&amp;lt;class T&amp;gt; bool less&amp;lt;T&amp;gt; //小于 template&amp;lt;class T&amp;gt; bool less_equal&amp;lt;T&amp;gt; //小于等于 逻辑仿函数 template&amp;lt;class T&amp;gt; bool logical_and&amp;lt;T&amp;gt; //逻辑与 template&amp;lt;class T&amp;gt; bool logical_or&amp;lt;T&amp;gt; //逻辑或 template&amp;lt;class T&amp;gt; bool logical_not&amp;lt;T&amp;gt; //逻辑非 </description>
    </item>
    
    <item>
      <title>函数对象与 predicate 谓词</title>
      <link>https://874656645.github.io/rick/posts/89-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%B8%8E-predicate-%E8%B0%93%E8%AF%8D/</link>
      <pubDate>Thu, 20 Jan 2022 21:04:13 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/89-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%B8%8E-predicate-%E8%B0%93%E8%AF%8D/</guid>
      <description>函数对象 重载函数调用操作符 () 的 类，其对象常称为函数对象
 函数对象可以有自己的状态 函数对象可以作为参数传递 一个参数的函数对象叫做一元仿函数 两个参数的函数对象叫做二元仿函数  什么是谓词 返回 bool 类型的仿函数称为谓词
一元谓词 如果 operator() 接受一个参数，那么叫做一元谓词
比如 find_if 算法
二元谓词 如果 operator() 接受两个参数，那么叫做二元谓词
比如 sort 算法</description>
    </item>
    
    <item>
      <title>map multimap 容器</title>
      <link>https://874656645.github.io/rick/posts/88-map-multimap-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Thu, 20 Jan 2022 20:18:25 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/88-map-multimap-%E5%AE%B9%E5%99%A8/</guid>
      <description>特点  所有元素都会根据元素的键值自动排序 默认排序规则是从小到大，可以通过仿函数指定排序规则 map / multimap 属于关联式容器，底层结构是用红黑树实现 不可以修改键值，可以通过删除再插入的方式实现 可以根据 key 值快速找到 value 值 可以通过下标 [] 的方式快速查找、插入和更新对应的 value  案例  公司今天招聘了10个员工（ABCDEFGHIJ），10 名员工进入公司之后，需要指派员工在哪个部门工作 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 随机给 10 名员工分配部门和工资 通过 multimap 进行信息的插入 key(部门编号) value(员工) 分部门显示员工信息  思路：
 创建 10 名员工，放到 vector 中 遍历 vector 容器，取出每个员工，进行随机分组 分组后，将员工部门编号作为 key，具体员工作为 value，放入到 multimap 容器中 分部门显示员工信息  class Worker{ public: Worker(string name, int salary){ m_name = name; m_salary = salary; } void printWorker(){ cout &amp;lt;&amp;lt; &amp;#34;姓名：&amp;#34; &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;#34; 工资：&amp;#34; &amp;lt;&amp;lt; m_salary &amp;lt;&amp;lt; endl; } private: string m_name; int m_salary; }; void createWorkers(vector&amp;lt;Worker&amp;gt; &amp;amp;v){ string nameSeed = &amp;#34;ABCDEFGHIJ&amp;#34;; for(int i = 0; i &amp;lt; nameSeed.</description>
    </item>
    
    <item>
      <title>set multiset 容器</title>
      <link>https://874656645.github.io/rick/posts/87-set-multiset-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 18 Jan 2022 21:20:48 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/87-set-multiset-%E5%AE%B9%E5%99%A8/</guid>
      <description>关联式容器 底层结构使用红黑树实现（二叉树-&amp;gt;二叉搜索树-&amp;gt;平衡二叉树-&amp;gt;红黑树） 自动排序 不可以修改值，可以通过删除再插入的方式实现  自定义数据类型：
class Person{ public: Person(string name, int age, int height){ this-&amp;gt;m_name = name; this-&amp;gt;m_age = age; this-&amp;gt;m_height = height; } bool operator&amp;lt;(const Person &amp;amp;p2) const{ // 注意：函数和形参都要添加 const 修饰符  if(this-&amp;gt;m_age == p2.m_age){ return this-&amp;gt;m_height &amp;gt; p2.m_height; } return this-&amp;gt;m_age &amp;lt; p2.m_age; } void printPerson()const{ cout &amp;lt;&amp;lt; &amp;#34;姓名：&amp;#34; &amp;lt;&amp;lt; this-&amp;gt;m_name &amp;lt;&amp;lt; &amp;#34; 年龄：&amp;#34; &amp;lt;&amp;lt; this-&amp;gt;m_age &amp;lt;&amp;lt; &amp;#34; 身高：&amp;#34; &amp;lt;&amp;lt; this-&amp;gt;m_height &amp;lt;&amp;lt; endl; } private: string m_name; int m_age; int m_height; }; int main() { set&amp;lt;Person&amp;gt; lp; lp.</description>
    </item>
    
    <item>
      <title>list 容器</title>
      <link>https://874656645.github.io/rick/posts/86-list-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 18 Jan 2022 20:26:45 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/86-list-%E5%AE%B9%E5%99%A8/</guid>
      <description>注意事项  双向循环链表 不支持随机访问 因为不支持随机访问，所以也不能用全局的排序算法 sort 一般不支持随机访问的容器会自己提供 sort 方法 自定义类型要指定排序规则  排序案例 案例描述：将 Person 自定义数据类型进行排序，Person 中属性有姓名、年龄、身高
排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序
class Person{ public: Person(string name, int age, int height){ this-&amp;gt;m_name = name; this-&amp;gt;m_age = age; this-&amp;gt;m_height = height; } bool operator&amp;lt;(const Person &amp;amp;p2){ if(this-&amp;gt;m_age == p2.m_age){ return this-&amp;gt;m_height &amp;gt; p2.m_height; } return this-&amp;gt;m_age &amp;lt; p2.m_age; } void printPerson()const{ cout &amp;lt;&amp;lt; &amp;#34;姓名：&amp;#34; &amp;lt;&amp;lt; this-&amp;gt;m_name &amp;lt;&amp;lt; &amp;#34; 年龄：&amp;#34; &amp;lt;&amp;lt; this-&amp;gt;m_age &amp;lt;&amp;lt; &amp;#34; 身高：&amp;#34; &amp;lt;&amp;lt; this-&amp;gt;m_height &amp;lt;&amp;lt; endl; } private: string m_name; int m_age; int m_height; }; int main() { list&amp;lt;Person&amp;gt; lp; lp.</description>
    </item>
    
    <item>
      <title>queue 队列容器适配器</title>
      <link>https://874656645.github.io/rick/posts/85-queue-%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Mon, 17 Jan 2022 19:41:48 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/85-queue-%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8/</guid>
      <description>先进先出 不允许遍历元素  queue 队列操作：
size()
empty()</description>
    </item>
    
    <item>
      <title>stack 栈容器适配器</title>
      <link>https://874656645.github.io/rick/posts/84-stack-%E6%A0%88%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sun, 16 Jan 2022 22:17:43 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/84-stack-%E6%A0%88%E5%AE%B9%E5%99%A8/</guid>
      <description>先进后出 栈不允许遍历元素 不能随机存取  stack 栈操作:
size()
empty()</description>
    </item>
    
    <item>
      <title>评委打分案例</title>
      <link>https://874656645.github.io/rick/posts/83-%E8%AF%84%E5%A7%94%E6%89%93%E5%88%86%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Sun, 16 Jan 2022 22:10:49 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/83-%E8%AF%84%E5%A7%94%E6%89%93%E5%88%86%E6%A1%88%E4%BE%8B/</guid>
      <description>有 5 名选手：选手 ABCDE，10 个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。
分析：
 创建五名选手，放到 vector 中 遍历 vector 容器，取出来每一个选手，执行 for 循环，可以把 10 个评委打分存到 deque 容器中 sort 算法对 deque 容器中分数排序，去除最高和最低分 deque 容器遍历一遍，累加总分 获取平均分  class Player{ public: Player(string name){ m_name = name; m_avgScore = 0; } void setAvgScore(int v){ m_avgScore = v; } void printInfo()const{ cout &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;#34;的平均分为：&amp;#34; &amp;lt;&amp;lt; m_avgScore &amp;lt;&amp;lt; endl; } private: string m_name; int m_avgScore; }; void createPlayers(vector&amp;lt;Player&amp;gt; &amp;amp;v){ string nameSeed = &amp;#34;ABCDE&amp;#34;; for(int i = 0; i &amp;lt; nameSeed.</description>
    </item>
    
    <item>
      <title>生成随机数</title>
      <link>https://874656645.github.io/rick/posts/82-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Sun, 16 Jan 2022 22:02:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/82-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      <description>#include &amp;lt;ctime&amp;gt;using namespace std; int main() { srand((unsigned int)time(NULL)); cout &amp;lt;&amp;lt; rand() % 40 &amp;lt;&amp;lt; endl; return 0; } </description>
    </item>
    
    <item>
      <title>deque 容器</title>
      <link>https://874656645.github.io/rick/posts/81-deque-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sun, 16 Jan 2022 20:38:31 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/81-deque-%E5%AE%B9%E5%99%A8/</guid>
      <description>deque 容器的空间不用手动收缩，类内部会自动处理</description>
    </item>
    
    <item>
      <title>巧妙收缩 vector 空间</title>
      <link>https://874656645.github.io/rick/posts/80-%E5%B7%A7%E5%A6%99%E6%94%B6%E7%BC%A9-vector-%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Sun, 16 Jan 2022 19:52:12 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/80-%E5%B7%A7%E5%A6%99%E6%94%B6%E7%BC%A9-vector-%E7%A9%BA%E9%97%B4/</guid>
      <description>resize() 或者 erase() 后 vector 的空间大小不会自动减小  int main() { vector&amp;lt;int&amp;gt; v; for(int i = 0; i &amp;lt; 100000; ++i){ v.push_back(i); } cout &amp;lt;&amp;lt; &amp;#34;size: &amp;#34; &amp;lt;&amp;lt; v.size() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;capacity: &amp;#34; &amp;lt;&amp;lt; v.capacity() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;-----------------------&amp;#34; &amp;lt;&amp;lt; endl; v.resize(10); cout &amp;lt;&amp;lt; &amp;#34;size: &amp;#34; &amp;lt;&amp;lt; v.size() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;capacity: &amp;#34; &amp;lt;&amp;lt; v.capacity() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;-----------------------&amp;#34; &amp;lt;&amp;lt; endl; vector&amp;lt;int&amp;gt;(v).swap(v); cout &amp;lt;&amp;lt; &amp;#34;size: &amp;#34; &amp;lt;&amp;lt; v.</description>
    </item>
    
    <item>
      <title>vector 中的元素存放在堆上还是栈上</title>
      <link>https://874656645.github.io/rick/posts/79-vector-%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E5%AD%98%E6%94%BE%E5%9C%A8%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%A0%88%E4%B8%8A/</link>
      <pubDate>Sun, 16 Jan 2022 15:50:29 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/79-vector-%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E5%AD%98%E6%94%BE%E5%9C%A8%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%A0%88%E4%B8%8A/</guid>
      <description>结论  allocator 分配器是定义内存模型的类，用于标准库的某些部分，尤其是 STL 容器，如果所有标准容器的最后一个(可选)模板参数没有指定，那么它将使用这个分配器，并且它是标准库中唯一一个预定义的分配器 vector 中存放的如果是对象类型，则会通过 allocator 在堆上开辟足够的空间来存放和管理集合中的对象 vector 中存放指针类型，一定要记得手动释放内存  存放对象 class Person{ public: Person(int age, int id){ m_age = age; m_id = id; cout &amp;lt;&amp;lt; &amp;#34;Person(int, int)...&amp;#34; &amp;lt;&amp;lt; endl; } Person(const Person&amp;amp; p){ m_age = p.m_age; m_id = p.m_id; cout &amp;lt;&amp;lt; &amp;#34;Person(const Person&amp;amp; p)...&amp;#34; &amp;lt;&amp;lt; endl; } ~Person(){ cout &amp;lt;&amp;lt; &amp;#34;~Person()...&amp;#34; &amp;lt;&amp;lt; endl; } void* operator new(size_t size){ void* p = malloc(size); cout &amp;lt;&amp;lt; &amp;#34;new()...&amp;#34; &amp;lt;&amp;lt; endl; return p; } void operator delete(void *p){ cout &amp;lt;&amp;lt; &amp;#34;delete().</description>
    </item>
    
    <item>
      <title>STL Hello World</title>
      <link>https://874656645.github.io/rick/posts/78-stl-hello-world/</link>
      <pubDate>Sun, 16 Jan 2022 12:31:08 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/78-stl-hello-world/</guid>
      <description> 平时要有容器、算法、迭代器的思维模式 容器提供迭代器，算法使用迭代器  // 算法 int count(int* begin, int* end, int val){ int n = 0; while(begin != end){ if(*begin == val){ n++; } begin++; } return n; } int main() { // 容器  int arr[] = {1, 3, 0, 5, 1, 3, 1, 0}; // 迭代器  int* begin = arr; int* end = *(&amp;amp;arr + 1); int n = count(begin, end, 1); cout &amp;lt;&amp;lt; &amp;#34;count: &amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; endl; return 0; } </description>
    </item>
    
    <item>
      <title>文件操作</title>
      <link>https://874656645.github.io/rick/posts/77-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 16 Jan 2022 09:47:21 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/77-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>一、文件读写  文件输入流 ifstream 文件输出流 ofstream 文件输入输出流 fstream 文件的打开方式 文件流的状态 文件流的定位：文件指针（输入指针、输出指针）  二、文本文件 #include &amp;lt;iostream&amp;gt;#include &amp;lt;fstream&amp;gt;using namespace std; void ReadWriteFile(){ ifstream ifs(&amp;#34;D:\\Users\\cui_z\\Desktop\\source.txt&amp;#34;, ios::in); ofstream ofs(&amp;#34;D:\\Users\\cui_z\\Desktop\\target.txt&amp;#34;, ios::out | ios::app); if (!ifs) { cout &amp;lt;&amp;lt; &amp;#34;输入文件打开失败&amp;#34; &amp;lt;&amp;lt; endl; return; } if (!ofs) { cout &amp;lt;&amp;lt; &amp;#34;输出文件打开失败&amp;#34; &amp;lt;&amp;lt; endl; return; } char ch; while (ifs.get(ch)) { cout &amp;lt;&amp;lt; ch; ofs &amp;lt;&amp;lt; ch; } ifs.close(); ofs.close(); } 三、二进制文件  文本文件和二进制文件在计算机中都是以二进制的方式存储的 程序中的对象都是二进制存储的 Windows 中的文本文件换行符用 \r\n 表示，二进制是以 \n 存储，所以存储和显示时会做一下转换 Linux 中二进制和文本文件换行都是以 \n 存储和表示  class Person { private: int m_age; int m_id; public: Person():m_age(0), m_id(0){ } Person(int age, int id){ m_age = age; m_id = id; } ~Person() = default; void show(){ cout &amp;lt;&amp;lt; &amp;#34;Age: &amp;#34; &amp;lt;&amp;lt; m_age &amp;lt;&amp;lt; &amp;#34; ID: &amp;#34; &amp;lt;&amp;lt; m_id &amp;lt;&amp;lt; endl; } }; void BinaryReadWrite(){ // 存储二进制  ofstream ofs(&amp;#34;D:\\Users\\cui_z\\Desktop\\target.</description>
    </item>
    
    <item>
      <title>格式化输出</title>
      <link>https://874656645.github.io/rick/posts/76-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</link>
      <pubDate>Sun, 16 Jan 2022 09:12:08 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/76-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</guid>
      <description>#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iomanip&amp;gt; // 控制符头文件using namespace std; // 格式化输出 void func(){ // 方式一：使用成员方法  int number = 10; cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; endl; cout.unsetf(ios::dec); // 八进制  cout.setf(ios::oct); cout.setf(ios::showbase); cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; endl; // 012  // 十六进制  cout.unsetf(ios::oct); cout.setf(ios::hex); cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; endl; // 0xa  // 固定宽度  cout.width(10); cout.fill(&amp;#39;*&amp;#39;); cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; endl; // *******0xa  // 上面的设置只对当前输出有效，下次的输出格式要重新设置  cout.setf(ios::left); cout.width(10); cout.</description>
    </item>
    
    <item>
      <title>异常接口声明</title>
      <link>https://874656645.github.io/rick/posts/75-%E5%BC%82%E5%B8%B8%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Sat, 15 Jan 2022 18:26:49 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/75-%E5%BC%82%E5%B8%B8%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E/</guid>
      <description>C++ 异常
 C++11 不再建议使用异常规范  // 异常规范 只能抛出 int float char 三种类型的异常 C++11以后不再建议使用 void func1() throw(int, float, char){ throw &amp;#34;string&amp;#34;; // terminate called after throwing an instance of &amp;#39;char const*&amp;#39; } // 不能抛出任何类型的异常 OK void func2() throw(){ throw -1; // terminate called after throwing an instance of &amp;#39;int&amp;#39; } // 可以抛出任何类型的异常 void func3(){ throw &amp;#34;error&amp;#34;; } int main() { try{ func1(); } catch(char const * e){ cout &amp;lt;&amp;lt; e &amp;lt;&amp;lt; endl; } catch(.</description>
    </item>
    
    <item>
      <title>栈解旋 Unwinding</title>
      <link>https://874656645.github.io/rick/posts/74-%E6%A0%88%E8%A7%A3%E6%97%8B-unwinding/</link>
      <pubDate>Sat, 15 Jan 2022 18:07:46 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/74-%E6%A0%88%E8%A7%A3%E6%97%8B-unwinding/</guid>
      <description>异常被抛出后，从进入 try 块起到异常被抛出前，这期间在栈上构造的所有对象都会被自动析构，析构的顺序与构造的顺序相反。
与 return 类似
class Test{ public: Test(string name){ m_name = name; cout &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;#34;被构造了&amp;#34; &amp;lt;&amp;lt; endl; } ~Test(){ cout &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;#34;被析构了&amp;#34; &amp;lt;&amp;lt; endl; } private: string m_name; }; double func1(int x, int y){ Test t1(&amp;#34;t1&amp;#34;), t2(&amp;#34;t2&amp;#34;); if(y == 0){ throw y; } return x / y; } int main() { try{ Test t3(&amp;#34;t3&amp;#34;), t4(&amp;#34;t4&amp;#34;); func1(10, 0); } catch(int e){ cout &amp;lt;&amp;lt; &amp;#34;除数为 &amp;#34; &amp;lt;&amp;lt; e &amp;lt;&amp;lt; endl; } return 0; } t3被构造了 t4被构造了 t1被构造了 t2被构造了 t2被析构了 t1被析构了 t4被析构了 t3被析构了 除数为 0 </description>
    </item>
    
    <item>
      <title>异常</title>
      <link>https://874656645.github.io/rick/posts/57-%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Sat, 15 Jan 2022 17:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/57-%E5%BC%82%E5%B8%B8/</guid>
      <description>一、try、catch、throw  可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型 C++ 异常机制是跨函数的，且是必须处理的。如果中间函数没有处理就一直抛到最顶层，如果 main 函数也不处理，程序就会挂掉  int main( ) { try{ throw &amp;#34;exception&amp;#34;; }catch(const char * e){ cout &amp;lt;&amp;lt; e &amp;lt;&amp;lt; endl; }catch(...){ // 捕获所有异常  cout &amp;lt;&amp;lt; &amp;#34;...&amp;#34; &amp;lt;&amp;lt; endl; } { cout &amp;lt;&amp;lt; &amp;#34;finally&amp;#34; &amp;lt;&amp;lt; endl; } return 0; } 输出：
Start exception finally 0 Finish 二、std::exception class exception { public: exception() throw(); exception(const exception&amp;amp; rhs) throw(); exception&amp;amp; operator=(const exception&amp;amp; rhs) throw(); virtual ~exception() throw(); virtual const char *what() const throw(); }; 派生了两个异常类：</description>
    </item>
    
    <item>
      <title>类型转换</title>
      <link>https://874656645.github.io/rick/posts/73-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sat, 15 Jan 2022 15:55:28 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/73-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>1. static_cast&amp;lt;&amp;gt;  可以转换内置数据类型； 不可以转换没有关系的指针或引用； 可以转换有继承关系的指针或引用（父类转子类或子类转父类都可以）；  // static_cast&amp;lt;&amp;gt;  // 1. 内置对象  int a = 97; char c = static_cast&amp;lt;char&amp;gt;(a); // OK  cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl; // 2. 自定义类型对象  // Building bb;  // Animal aa = static_cast&amp;lt;Animal&amp;gt;(bb); // error: no matching function for call to ‘Animal::Animal(Building&amp;amp;)’  // 3. 不同类型的指针转换  // int *p = &amp;amp;a;  // char *pc = static_cast&amp;lt;char*&amp;gt;(p); // error: invalid static_cast from type ‘int*’ to type ‘char*’  // cout &amp;lt;&amp;lt; pc &amp;lt;&amp;lt; endl;  // Animal * pa = NULL;  // Building *pb = static_cast&amp;lt;Building*&amp;gt;(pa); // error: invalid static_cast from type ‘Animal*’ to type ‘Building*’  // 4.</description>
    </item>
    
    <item>
      <title>自定义数组实现</title>
      <link>https://874656645.github.io/rick/posts/72-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 15 Jan 2022 13:36:04 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/72-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>要求  可以对内置数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及 operator= 防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量  实现 template&amp;lt;class T&amp;gt; class MyArray{ public: MyArray(int capacity){ this-&amp;gt;m_capacity = capacity; this-&amp;gt;m_size = 0; this-&amp;gt;m_addr = new T[this-&amp;gt;m_capacity]; } MyArray(const MyArray&amp;amp; arr){ if(arr.m_addr == NULL){ return; } // 深拷贝  this-&amp;gt;m_capacity = arr.m_capacity; this-&amp;gt;m_size = arr.m_size; this-&amp;gt;m_addr = new T[this-&amp;gt;m_capacity]; for(int i = 0; i &amp;lt; m_size; ++i){ // T 类型是可拷贝的，= 运算符也是深拷贝  this-&amp;gt;m_addr[i] = arr.m_addr[i]; } } MyArray&amp;amp; operator=(const MyArray&amp;amp; arr){ if(this == &amp;amp;arr){ return *this; } if(this-&amp;gt;m_addr !</description>
    </item>
    
    <item>
      <title>类模板</title>
      <link>https://874656645.github.io/rick/posts/71-%E7%B1%BB%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Wed, 12 Jan 2022 22:47:51 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/71-%E7%B1%BB%E6%A8%A1%E6%9D%BF/</guid>
      <description>一、类模板写法 1. 声明和定义写在一起 template&amp;lt;class T&amp;gt; class Person{ // 友元重载  friend ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream &amp;amp;os, Person&amp;lt;T&amp;gt; &amp;amp;p){ cout &amp;lt;&amp;lt; p.m_age; return os; } // 普通友元函数  friend void printP(Person&amp;lt;T&amp;gt; p){ cout &amp;lt;&amp;lt; p.m_age &amp;lt;&amp;lt; endl; } public: Person(T age){ this-&amp;gt;m_age = age; } void Show(){ cout &amp;lt;&amp;lt; this-&amp;gt;m_age &amp;lt;&amp;lt; endl; } private: T m_age; }; int main() { Person&amp;lt;int&amp;gt; p(20); p.Show(); cout &amp;lt;&amp;lt; p &amp;lt;&amp;lt; endl; printP(p); return 0; } 2. 声明和定义分开写，但在同一文件中 template&amp;lt;class T&amp;gt; class Person{ public: Person(T age); void Show(); private: T m_age; }; template&amp;lt;class T&amp;gt; Person&amp;lt;T&amp;gt;::Person(T age){ this-&amp;gt;m_age = age; } template&amp;lt;class T&amp;gt; void Person&amp;lt;T&amp;gt;::Show(){ cout &amp;lt;&amp;lt; this-&amp;gt;m_age &amp;lt;&amp;lt; endl; } int main() { Person&amp;lt;int&amp;gt; p(20); p.</description>
    </item>
    
    <item>
      <title>编译过程</title>
      <link>https://874656645.github.io/rick/posts/70-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Wed, 12 Jan 2022 20:12:00 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/70-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</guid>
      <description>各个 .cpp 文件是独立编译的，如果有其它的类和函数会先在本 .o 文件中生成符号，由最后的链接器去其它 .o 文件找具体的函数定义
 .c .cpp 文件经过 预编译器拷贝头文件、宏展开 生成 .i 文件（文本文件）
g++ -E main.cpp -o main.i .i 文件经过 编译器 生成汇编程序 .s（文本文件）
g++ -S main.i -o main.s .s 文件经过 汇编器 生成可定位目标文件 .o （二进制）
Windows:
g++ -c main.s -o main.obj
Linux:
g++ -c main.s -o main.o .o 文件经过 链接器 生成可执行目标文件 .exe .dll
g++ main.s -o main  </description>
    </item>
    
    <item>
      <title>函数模板</title>
      <link>https://874656645.github.io/rick/posts/69-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Tue, 11 Jan 2022 21:40:09 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/69-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</guid>
      <description>函数模板必须严格类型匹配，普通函数则可以进行数据类型隐式转换 对于内置数据类型，函数模板可进行推导，自定义类型不可以 函数模板可被重载 C++ 编译器优先考虑普通函数 可以通过空模板实参列表的语法限定编译器只能通过模板匹配 如果函数模板可以产生一个更好的匹配，就选择模板 编译器根据函数模板调用情况，从函数模板和具体类型产生不同的函数
编译器会对函数模板进行两次编译  在声明的地方对模板代码本身进行编译； 在调用的地方对参数替换后的代码进行编译    template&amp;lt;class T&amp;gt; T MyAdd(T a, T b){ return a + b; } // 函数一 int MyAdd(int a, int b){ return a + b; } // 函数二 int MyAdd(int a, char c){ return a + c; } int main() { cout &amp;lt;&amp;lt; MyAdd(1, 2) &amp;lt;&amp;lt; endl; // 优先调用普通函数  cout &amp;lt;&amp;lt; MyAdd&amp;lt;&amp;gt;(1, 2) &amp;lt;&amp;lt; endl; // 强制调用模板函数  cout &amp;lt;&amp;lt; MyAdd(1.</description>
    </item>
    
    <item>
      <title>C 语言面向接口编程</title>
      <link>https://874656645.github.io/rick/posts/68-c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 10 Jan 2022 22:23:34 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/68-c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/</guid>
      <description>通过函数指针实现多态，注册回调函数的方式
void printAllArray(void* arr, int eleSize, int len, void(*myPrint)(void*)){ char* arrStart = (char*)arr; for(int i = 0; i &amp;lt; len; ++i){ char* eleStart = arrStart + i * eleSize; myPrint(eleStart); } printf(&amp;#34;\n&amp;#34;); } void printInt(void* data){ int* ele = (int*)data; printf(&amp;#34;%d &amp;#34;, *ele); } struct Person{ char name[64]; int age; }; void printPerson(void* data){ struct Person* ele = (struct Person*)data; printf(&amp;#34;Name: %s, Age: %d \n&amp;#34;, ele-&amp;gt;name, ele-&amp;gt;age); } int main() { int arr[] = {1, 2, 3, 4, 5}; printAllArray(arr, sizeof(int), 5, printInt); struct Person personArr[] = { {&amp;#34;aaa&amp;#34;, 20}, {&amp;#34;bbb&amp;#34;, 30}, {&amp;#34;ccc&amp;#34;, 40}, {&amp;#34;ddd&amp;#34;, 50}, {&amp;#34;eee&amp;#34;, 60}, }; printAllArray(personArr, sizeof(struct Person), 5, printPerson); return 0; } 输出：</description>
    </item>
    
    <item>
      <title>面向抽象类编程</title>
      <link>https://874656645.github.io/rick/posts/67-%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sun, 09 Jan 2022 19:12:37 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/67-%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%BC%96%E7%A8%8B/</guid>
      <description>三层架构：业务逻辑层、抽象层、实现层
原则：依赖倒转
案例一：动物园 设计实现：
 抽象层：Animal
提供接口 voice 实现层：Dog、Cat
分别实现 voice ，发出不同的声音 业务层：main 函数调用，只通过 Animal 的指针统一实现业务  案例二：编写一个 C++ 程序, 计算程序员( programmer )工资  要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer )的工资 要求利用抽象类统一界面，方便程序的扩展，比如:新增，计算架构师( architect ) 的工资  设计实现：
 抽象层：Programmer
提供计算工资的接口 实现层：JuniorProgrammer、MidProgrammer、AdvProgrammer
分别对计算工资接口进行实现 业务层：通过 Programmer 类统一管理，实现业务逻辑，同时业务的可扩展性更强，如新增架构师类型  案例三：电脑组装，面向抽象层编程  组装电脑有 3 个抽象类，抽象的 cpu，抽象的显卡，抽象的内存。 现在要求组装两台电脑，一台是 Intel 的 CPU，Intel 的显卡和 Intel 的内存。另一台是 Intel 的 CPU、Nvidia 的显卡和 Kingston 的内存条。 针对抽象层编程。  设计实现：</description>
    </item>
    
    <item>
      <title>实现一个简单的字符串类</title>
      <link>https://874656645.github.io/rick/posts/66-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/</link>
      <pubDate>Sat, 08 Jan 2022 14:01:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/66-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/</guid>
      <description>MyString.h
#ifndef __MYSTRING_H_ #define __MYSTRING_H_  #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; class MyString { // 重载 &amp;lt;&amp;lt;  // 最好是 const 的，可以输出匿名变量（匿名变量不能被非 const 的左值引用接收）  friend ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream &amp;amp;os, const MyString &amp;amp;s); // 重载 &amp;gt;&amp;gt;  friend istream&amp;amp; operator&amp;gt;&amp;gt;(istream &amp;amp;is, MyString &amp;amp;s); private: // 字符串的有效长度  int m_len; // 字符串指针  char* m_pStr; public: MyString(); MyString(const char *); MyString(const MyString &amp;amp;); ~MyString(); // 重载 =  MyString&amp;amp; operator=(const MyString &amp;amp;); // 重载 []  char&amp;amp; operator[](int index); // 重载 +  MyString operator+(const MyString &amp;amp;); // 重载 +=  MyString&amp;amp; operator+=(const MyString &amp;amp;); // 重载 ==  bool operator==(const MyString &amp;amp;); // 重载 !</description>
    </item>
    
    <item>
      <title>静态数组初始化</title>
      <link>https://874656645.github.io/rick/posts/65-%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Sat, 08 Jan 2022 13:50:12 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/65-%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>1. 声明静态数组后一定要进行初始化，否则里面的值都是未知的 int main() { int ia[3] = {0}; // 这虽然只是给第一个元素赋了值，但剩余未赋值的元素都会初始化为0  char ca[3] = {0}; double da[3]; bool ba[3]; short sa[3]; float fa[3]; for(auto &amp;amp; i : da){ cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } return 0; } 输出：
6.95128e-310 4.63759e-310 0 2. C++ 数组指针和数组类型  数组类型和数组指针（数组名）不是一种类型，只是恰好指向的地址相同而已 数组名是指针常量（int * const），代表数组中第一个元素的地址 数组类型代表整个数组  int main() { int arr[10]; cout &amp;lt;&amp;lt; arr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; arr + 1 &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;----------&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;amp;arr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;amp;arr + 1 &amp;lt;&amp;lt; endl; return 0; } 输出：</description>
    </item>
    
    <item>
      <title>VS Code 搭建 c&#43;&#43; gdb 开发环境</title>
      <link>https://874656645.github.io/rick/posts/64-vs-code-%E6%90%AD%E5%BB%BA-c&#43;&#43;-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 06 Jan 2022 20:24:21 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/64-vs-code-%E6%90%AD%E5%BB%BA-c&#43;&#43;-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>一、安装 C++ 开发环境 Using GCC with MinGW
 安装 MSYS2 更新 MSYS2 pacman -Syu 在开始菜单中运行 MSYS2 MSYS，更新其余的基本包 pacman -Su 安装 C++ 开发环境：  clang++ x64 gdb: pacman -S --needed base-devel mingw-w64-ucrt-x86_64-clang mingw-w64-ucrt-x86_64-gdb g++ gdb: pacman -S --needed base-devel mingw-w64-x86_64-toolchain clang++ lldb: pacman -S --needed base-devel mingw-w64-clang-x86_64-lldb
这个库会把 clang clang++ 等库安装到 msys64/clang64/bin 目录，但是 lldb 在 Windows 上的调试效果不如 gdb clang++ x86：pacman -S --needed base-devel mingw-w64-i686-clang   添加环境变量 D:\msys64\ucrt64\bin 检查是否安装成功  clang++ --version g++ --version gdb --version    pacman -Syu // 更新整个系统 pacman -Su // 更新已安装的包 pacman -Ss 关键字 // 搜索含关键字的包 pacman -S 包名 // 安装包，也可以同时安装多个包，只需以空格分隔包名即可 pacman -Rs 包名 // 删除包及其依赖 pacman -R 包名 // 删除包 二、配置 VS Code 主要是修改 task.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 内存对齐</title>
      <link>https://874656645.github.io/rick/posts/63-c&#43;&#43;-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Thu, 06 Jan 2022 18:13:09 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/63-c&#43;&#43;-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</guid>
      <description>C/C++内存对齐详解
内存对齐规则  对齐系数（也叫对齐模数）：gcc中默认 #pragma pack(4)，可以通过预编译命令 #pragma pack(n)，n = 1,2,4,8,16 来改变这一系数 有效对齐值：是给定值 #pragma pack(n) 和结构体中 最长数据类型长度中较小的那个。有效对齐值也叫 对齐单位    规则一：结构体第一个成员的偏移量 offset 为 0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节
  规则二：结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节
注意：上面两条规则都需要得到满足
注意：成员变量首地址偏移和对齐都是与【有效对齐值】进行比较，而有效对齐值是对齐系数与结构体中最长数据类型中的较小者
  // 64 位程序 struct { int i; char c1; char c2; }x1; struct{ char c1; int i; char c2; }x2; struct{ char c1; char c2; int i; }x3; struct { short i; char c1; char c2; }y1; struct{ char c1; short i; char c2; }y2; struct{ char c1; char c2; short i; }y3; int main() { printf(&amp;#34;%ld\n&amp;#34;,sizeof(x1)); // 输出8  printf(&amp;#34;%ld\n&amp;#34;,sizeof(x2)); // 输出12  printf(&amp;#34;%ld\n&amp;#34;,sizeof(x3)); // 输出8  cout &amp;lt;&amp;lt; &amp;#34;----------------&amp;#34; &amp;lt;&amp;lt; endl; printf(&amp;#34;%ld\n&amp;#34;,sizeof(y1)); // 输出4  printf(&amp;#34;%ld\n&amp;#34;,sizeof(y2)); // 输出6  printf(&amp;#34;%ld\n&amp;#34;,sizeof(y3)); // 输出4  return 0; } 既要考虑首地址偏移，又要是有效对齐值（对齐单位）的整数倍 y1 y2 y3结构体：</description>
    </item>
    
    <item>
      <title>自定义智能指针</title>
      <link>https://874656645.github.io/rick/posts/62-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 04 Jan 2022 21:07:15 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/62-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description>使用模板类 重载 -&amp;gt; 操作符 重载 * 操作符  template&amp;lt;typename T&amp;gt; class MyAutoPtr{ public: MyAutoPtr(T * t){ ptr = t; } ~MyAutoPtr(){ if(ptr != NULL){ delete ptr; ptr = NULL; } } T* operator-&amp;gt;(){ // 相当于 ptr-&amp;gt; , 所以返回 ptr 指针即可，将所有操作转发给真正的指针变量  return ptr; } T&amp;amp; operator*(){ // 相当于 (*ptr) ，所以返回 ptr 指向的对象引用即可  return *ptr; } private: T* ptr; }; class A{ public: A(int a){ cout &amp;lt;&amp;lt; &amp;#34;A(int)...&amp;#34; &amp;lt;&amp;lt; endl; this-&amp;gt;a = a; } ~A(){ cout &amp;lt;&amp;lt; &amp;#34;~A().</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 多线程</title>
      <link>https://874656645.github.io/rick/posts/61-c&#43;&#43;-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 04 Jan 2022 14:02:20 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/61-c&#43;&#43;-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>一、进程与线程  进程是资源分配和调度的一个独立单位；而线程是进程的一个实体，是 CPU 调度和分配的基本单位 同一个进程中的多个线程的内存资源是共享的，各线程都可以改变进程中的变量。因此在执行多线程运算的时候要注意执行顺序  二、并行与并发  并行（parallellism）指的是多个任务在同一时刻同时在执行 并发（concurrency）是指在一个时间段内，多个任务交替进行。虽然看起来像在同时执行，但其实是交替的  三、多任务处理 多线程是多任务处理的一种特殊形式，一般情况下，有基于进程和基于线程的两种类型的多任务处理方式。
 基于进程的多任务处理是程序的并发执行 基于线程的多任务处理是同一程序的片段的并发执行  四、C++11 线程管理 thread 库  C++11 提供了多线程库，使用时需要 #include &amp;lt;thread&amp;gt; 头文件，该头文件主要包含了对线程的管理类 std::thread 以及其他管理线程相关的类 每个应用程序至少有一个进程，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个子线程。每个线程都需要一个入口函数，入口函数返回退出，该线程也会退出，主线程就是以 main 函数作为入口函数的线程 主线程退出后，运行中的子线程也会被销毁 std::thread 的构造函数需要的是可调用（callable）类型，除了函数外，还可以调用 lambda 表达式、重载了 () 运算符的类的实例 把函数对象传入 std::thread 时，应传入函数名称（不带括号） 当启动一个线程后，一定要在该线程 thread 销毁前，调用 join() 或者 detach()，确定以何种方式等待线程执行结束  detach 方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束 join 方式，等待关联的线程完成，才会继续执行 join() 后的代码 在以 detach 的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用按值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束    1、调用全局函数启动线程 #include &amp;lt;thread&amp;gt; using namespace std; void func(int i){ cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } int main() { for(int i = 0; i &amp;lt; 4; ++i){ // 创建一个线程t，第一个参数为调用的函数，第二个参数为传递的参数  thread t(func, i); // 表示允许该线程在后台运行  t.</description>
    </item>
    
    <item>
      <title>临时变量不能绑定 no-const 左值引用类型</title>
      <link>https://874656645.github.io/rick/posts/60-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BAno-const%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0/</link>
      <pubDate>Tue, 04 Jan 2022 10:31:45 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/60-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BAno-const%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0/</guid>
      <description>error: cannot bind non-const lvalue reference of type ‘T&amp;amp;’ to an rvalue of type ‘T’
如果一个参数是以非 const 引用传入，c++ 编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。
但如果你 把一个临时变量当作非 const 引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉。
所以，修改一个临时变量是毫无意义的。据此，c++ 编译器加入了临时变量不能作为非 const 引用的这个语义限制。
c++ 中临时变量是右值类型，不能取引用，只能在当前行使用，不能作为非 const 的引用参数
std::move() 返回的也是一个右值
对于临时变量或字面量的右值引用可以使用 cosnt &amp;amp; 或 &amp;amp;&amp;amp; 类型的参数接收
一般来说，右值的地址不能通过解引用来获得，因为它们是字面量，或者因为它们本质上是临时的(例如由函数或显式构造函数调用返回的值)。通过将一个对象传递给这个函数，可以获得一个引用它的右值。
class T{ public: T(int v){ a = v; } T operator+(T &amp;amp;t){ T temp = this-&amp;gt;a + t.a; return temp; } void printT(T &amp;amp;t){ cout &amp;lt;&amp;lt; &amp;#34;a = &amp;#34; &amp;lt;&amp;lt; t.</description>
    </item>
    
    <item>
      <title>操作符重载</title>
      <link>https://874656645.github.io/rick/posts/59-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Mon, 03 Jan 2022 13:54:11 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/59-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
      <description>#include &amp;lt;iostream&amp;gt; using namespace std; class Complex{ // friend Complex complexAdd(Complex &amp;amp;c1, Complex &amp;amp;c2);  // friend Complex operator+(Complex &amp;amp;c1, Complex &amp;amp;c2);  // friend Complex&amp;amp; operator+= (Complex &amp;amp;c1, Complex &amp;amp;c2);  friend ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream &amp;amp;os, Complex &amp;amp;c); friend istream&amp;amp; operator&amp;gt;&amp;gt;(istream &amp;amp;is, Complex &amp;amp;c); public: Complex(){ cout &amp;lt;&amp;lt; &amp;#34;Complex()...&amp;#34; &amp;lt;&amp;lt; endl; a = 0; b = 0; } Complex(int a, int b){ cout &amp;lt;&amp;lt; &amp;#34;Complex(int, int)...&amp;#34; &amp;lt;&amp;lt; endl; this-&amp;gt;a = a; this-&amp;gt;b = b; } ~Complex(){ cout &amp;lt;&amp;lt; &amp;#34;~Complex().</description>
    </item>
    
    <item>
      <title>具有链表特性的类</title>
      <link>https://874656645.github.io/rick/posts/58-%E5%85%B7%E6%9C%89%E9%93%BE%E8%A1%A8%E7%89%B9%E6%80%A7%E7%9A%84%E7%B1%BB/</link>
      <pubDate>Mon, 03 Jan 2022 09:21:17 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/58-%E5%85%B7%E6%9C%89%E9%93%BE%E8%A1%A8%E7%89%B9%E6%80%A7%E7%9A%84%E7%B1%BB/</guid>
      <description>买卖货物问题：
#include &amp;lt;iostream&amp;gt; using namespace std; class Goods{ public: Goods(){ m_pNext = nullptr; m_weight = 0; cout &amp;lt;&amp;lt; &amp;#34;买入了货物，重量是：&amp;#34; &amp;lt;&amp;lt; m_weight &amp;lt;&amp;lt; endl; } Goods(int weight){ m_pNext = nullptr; m_weight = weight; total_weight += m_weight; cout &amp;lt;&amp;lt; &amp;#34;买入了货物，重量是：&amp;#34; &amp;lt;&amp;lt; m_weight &amp;lt;&amp;lt; endl; } ~Goods(){ total_weight -= m_weight; // m_pNext 不是在本类中 new 的，所以也不用 delete  this-&amp;gt;m_pNext = nullptr; cout &amp;lt;&amp;lt; &amp;#34;卖出了货物，重量是：&amp;#34; &amp;lt;&amp;lt; m_weight &amp;lt;&amp;lt; endl; } static int getTotalWeight(){ return total_weight; } Goods *m_pNext; private: int m_weight; static int total_weight; }; int Goods::total_weight = 0; void buy(Goods *&amp;amp;head, int weight){ Goods *pNewGoods = new Goods(weight); if(head == nullptr){ head = pNewGoods; } else{ pNewGoods-&amp;gt;m_pNext = head; head = pNewGoods; } } void sale(Goods *&amp;amp;head){ if(head == nullptr){ cout &amp;lt;&amp;lt; &amp;#34;没有货物了&amp;#34; &amp;lt;&amp;lt; endl; return; } Goods *temp = head; head = head-&amp;gt;m_pNext; delete temp; temp = nullptr; } int main( ) { Goods *head = nullptr; int choice; do{ // 提供菜单  cout &amp;lt;&amp;lt; &amp;#34;输入 1 进货&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;输入 2 出货&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;输入 0 退出&amp;#34; &amp;lt;&amp;lt; endl; cin &amp;gt;&amp;gt; choice; switch(choice){ case 0: // 退出  return 0; case 1: { // 进货  int w = 0; cout &amp;lt;&amp;lt; &amp;#34;输入货物重量：&amp;#34; &amp;lt;&amp;lt; endl; cin &amp;gt;&amp;gt; w; buy(head, w); break; } case 2: // 出货  sale(head); break; } cout &amp;lt;&amp;lt; &amp;#34;目前货物的总重量是：&amp;#34; &amp;lt;&amp;lt; Goods::getTotalWeight() &amp;lt;&amp;lt; endl; }while(1); return 0; } 输出：</description>
    </item>
    
    <item>
      <title>STL 总结</title>
      <link>https://874656645.github.io/rick/posts/56-stl-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 30 Dec 2021 10:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/56-stl-%E6%80%BB%E7%BB%93/</guid>
      <description>1、六大组件介绍  容器：数据结构，用来存放数据 算法：常用算法 迭代器：容器和算法之间的胶合剂，“范型指针” 仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数 配置器：为容器分配并管理内存 适配器：修改其他组件接口  2、STL 常用的容器有哪些以及各自的特点是什么?    名称 特点     vector 底层数据结构为数组，支持快速随机访问   list 底层数据结构为双向链表，支持快速增删   deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问   stack 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   queue 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   priority_queue 底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现   set 底层数据结构为红黑树，有序，不重复   multiset 底层数据结构为红黑树，有序，可重复   map 底层数据结构为红黑树，有序，不重复   multimap 底层数据结构为红黑树，有序，可重复   unordered_set 底层数据结构为hash表，无序，不重复   unordered_multiset 底层数据结构为hash表，无序，可重复   unordered_map 底层数据结构为hash表，无序，不重复   unordered_multimap 底层数据结构为hash表，无序，可重复    3、vector 和 list 的区别  vector底层实现是数组，所以在内存中是连续存放的，随机读取效率高，但插入、删除效率低；list底层实现是双向链表，所以在内存中是任意存放的，插入、删除效率高，但访问元素效率低 vector在中间节点进行插入、删除会导致内存拷贝，而list不会 vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请  4、vector 扩容原理 以原内存空间大小的两倍配置一份新的内存空间，并将原空间数据拷贝过来进行初始化</description>
    </item>
    
    <item>
      <title>vector</title>
      <link>https://874656645.github.io/rick/posts/55-vector/</link>
      <pubDate>Wed, 29 Dec 2021 19:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/55-vector/</guid>
      <description>vector 常用操作 #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt; int main() { //1.定义和初始化  vector&amp;lt;int&amp;gt; vec1; //默认初始化，vec1为空  vector&amp;lt;int&amp;gt; vec2(vec1); //使用vec1初始化vec2  vector&amp;lt;int&amp;gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2  vector&amp;lt;int&amp;gt; vec4(10); //10个值为0的元素  vector&amp;lt;int&amp;gt; vec5(10,4); //10个值为4的元素  //2.常用操作方法  //2.1 添加函数  vec1.push_back(100); // 尾部添加元素  vec1.insert(vec1.end(),5,3); // 从vec1.back位置插入5个值为3的元素  //2.2 删除函数  vec1.pop_back(); // 删除末尾元素  vec1.erase(vec1.begin(),vec1.begin()+2); // 删除vec1[0]-vec1[2]之间的元素，不包括vec1[2]其他元素前移  vec1.clear(); // 清空元素，元素在内存中并未消失，通常使用swap()来清空  vector&amp;lt;int&amp;gt;().swap(V); // 利用swap函数和临时对象交换内存，交换以后，临时对象消失，释放内存。  // 必须是同类型的 vector  // 且只有存储对象时才有效  //2.3 遍历函数  vec1[0]; //取得第一个元素  vec1.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL</title>
      <link>https://874656645.github.io/rick/posts/54-c&#43;&#43;-stl/</link>
      <pubDate>Wed, 29 Dec 2021 17:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/54-c&#43;&#43;-stl/</guid>
      <description>STL六大组件
STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。STL中包括六大组件：容器、算法、迭代器、适配器、仿函数、空间配置器
适配器：适配器是一种设计模式(设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结)，该中模式是将一个类的接口转换成客户希望的另外一个接口。
一、容器 序列式容器（vector、deque、list）、关联式容器（map、set）、容器适配器（stack、queue、priority_queue）
1. vector 是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。由于具有连续的存储空间，所以在插入和删除操作方面，效率比较慢
2. deque deque 是 double ended queue 的缩写，双向队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。与 vector 不同，deque 不能保证将所有元素存储在连续的存储空间上
3. list list 是 STL 实现的双向链表，与 vector 相比, 它允许快速的插入和删除，但是随机访问却比较慢
4. map、multimap、unordered_map、unordered_multimap  map 是 STL 的一个关联容器，它是一种键值对容器，里面的数据都是成对出现的，且键值是唯一的，可在我们处理一对一数据的时候，在编程上提供快速通道。map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。 multimap 中的元素也是有序的，但允许存在相同键值的 unordered_map 中的元素是唯一的，但无序（也不是插入顺序），而是根据它们的散列值（hash values）组织成桶（buckets），从而允许通过键值直接快速访问单个元素（速度一般比 map 更快） unordered_multimap 无序且不唯一  5. set、multiset、unordered_set、unordered_multiset  set 的含义是集合，它是一个有序的容器，里面的元素都是唯一且排序好的，支持插入、删除、查找等操作，就像一个集合一样，所有的操作都是严格在 logn时间内完成，效率非常高，使用方法类似 list multiset 也是排序好的，但是可以存有相同的元素 unordered_set 无序但元素是不可重复的 unordered_multiset 无序，元素也不唯一  二、容器适配器 虽然 stack、queue、priority_queue 中也可以存放元素，但在 STL 中并没有将其划分在容器的行列，而是将其称为容器适配器，这是因为每个容器在底层都有自己的实现方式，而 stack、queue、priority_queue 只是在底层将其他容器进行了封装
std::stack template&amp;lt;class T, class Container = deque&amp;lt;T&amp;gt;&amp;gt; class stack; std::queue template&amp;lt;class T, class Container = deque&amp;lt;T&amp;gt;&amp;gt; class queue; std::priority_queue template&amp;lt;class T, class Container = vector&amp;lt;T&amp;gt;, class Compare = less&amp;lt;typename Container::value_type&amp;gt;&amp;gt; class priority_queue; 为什么选择 deque 作为 stack 和 queue 的底层默认容器？</description>
    </item>
    
    <item>
      <title>new delete 与内存</title>
      <link>https://874656645.github.io/rick/posts/53-new-delete-%E4%B8%8E%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 29 Dec 2021 15:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/53-new-delete-%E4%B8%8E%E5%86%85%E5%AD%98/</guid>
      <description>C++ 中 new 操作符内幕：new operator、operator new、placement new 
1、new / delete 具体步骤 new
 第一步：调用 operator new 函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值 第三部：对象构造完成后，返回一个指向该对象的指针  delete
 第一步：调用对象的析构函数 第二步：编译器调用 operator delete 函数释放内存空间  2、new/delete 与 malloc/free 的区别是什么？  malloc/free 是 C 语言的标准库函数， new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存 malloc/free 不会去自动调用构造和析构函数，对于基本数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求 malloc/free 需要指定分配内存的大小，而 new/delete 会自动计算所需内存大小 new 返回的是指定对象的指针，而 malloc 返回的是 void*，因此 malloc 的返回值一般都需要进行强制类型转换  operator new 重载：
class Person{ public: Person(){ id = 0; score = 0; cout &amp;lt;&amp;lt; &amp;#34;Person()&amp;#34; &amp;lt;&amp;lt; endl; } Person(int id, int score):id(id),score(score){ cout &amp;lt;&amp;lt; &amp;#34;Person(int, int)&amp;#34; &amp;lt;&amp;lt; endl; } Person(const Person &amp;amp;p){ cout &amp;lt;&amp;lt; &amp;#34;Person(const Person &amp;amp;p)&amp;#34; &amp;lt;&amp;lt; endl; id = p.</description>
    </item>
    
    <item>
      <title>new 二维数组</title>
      <link>https://874656645.github.io/rick/posts/52-new-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 29 Dec 2021 14:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/52-new-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>在堆上声明一个数组 int main( ) { #if 0// 方式一： int** pArr = NULL; pArr = new int*[4]; for(int i = 0; i &amp;lt; 4; i++){ pArr[i] = new int[8]; } for(int i = 0; i &amp;lt; 4; ++i){ for(int j = 0; j &amp;lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i &amp;lt; 4; ++i){ for(int j = 0; j &amp;lt; 8; ++j){ if(j == 0) cout &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; pArr[i][j] &amp;lt;&amp;lt; &amp;#39;\t&amp;#39;; } } // 删除 for(int i = 0; i &amp;lt; 4; ++i){ delete [] pArr[i]; } delete [] pArr; #endif  // 方式二：  cout &amp;lt;&amp;lt; sizeof(int[5]) &amp;lt;&amp;lt; endl; // 初始化  int(*pArr)[8] = new int[4][8]; memset(pArr, 0, sizeof(int[4][8])); // 或者  // int(*pArr)[8] = new int[4][8]{{0}};  cout &amp;lt;&amp;lt; sizeof(int[4][8]) &amp;lt;&amp;lt; endl; for(int i = 0; i &amp;lt; 4; ++i){ for(int j = 0; j &amp;lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i &amp;lt; 4; ++i){ for(int j = 0; j &amp;lt; 8; ++j){ cout &amp;lt;&amp;lt; pArr[i][j] &amp;lt;&amp;lt; &amp;#39;\t&amp;#39;; } cout &amp;lt;&amp;lt; endl; } cout &amp;lt;&amp;lt; endl; delete[] pArr; // 取地址  int arr[3][4]{{0}}; int(*p)[3][4] = &amp;amp;arr; cout &amp;lt;&amp;lt; arr[2][3] &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; *p[2][3] &amp;lt;&amp;lt; endl; return 0; } 输出：</description>
    </item>
    
    <item>
      <title>类其它总结</title>
      <link>https://874656645.github.io/rick/posts/51-%E7%B1%BB%E5%85%B6%E5%AE%83%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 28 Dec 2021 17:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/51-%E7%B1%BB%E5%85%B6%E5%AE%83%E6%80%BB%E7%BB%93/</guid>
      <description>1. this指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用该成员函数的对象的首地址
 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值 this 是个右值，所以不能取 this 的地址  2. delete this  类的成员函数中可以调用 delete this，但是在释放后，对象后续调用的方法不能再用到 this 指针 delete this 释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，此时其中的值是不确定的 delete 的本质是为将被释放的内存调用一个或多个析构函数，如果在类的析构函数中调用 delete this，会陷入无限递归，造成栈溢出  3. 一个空类class中有什么？ 构造函数、拷贝构造函数、析构函数、赋值运算符重载、取地址操作符重载、被 const 修饰的取地址操作符重载
4. C++ 计算一个类的 sizeof  一个空的类 sizeof 返回 1，因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址 类内的普通成员函数不参与 sizeof 的统计，因为 sizeof 是针对实例的，而普通成员函数，是针对类体的 一个类如果含有虚函数，则这个类中有一个指向虚函数表的指针（虚函数指针），32位程序占4个字节，64位程序占8个字节 静态成员不影响类的大小，被编译器放在程序的数据段中 普通继承的类sizeof，会得到基类的大小加上派生类自身成员的大小 当存在虚拟继承时，派生类中会有一个指向虚基类表的指针。所以其大小应为普通继承的大小，再加上虚基类表的指针大小  5. 构造函数和析构函数能被继承吗? 不能。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么
6. 构造函数能不能是虚函数？ 不能。虚函数对应一个虚函数表，可是这个虚函数表存储在对象的内存空间的。问题就在于，如果构造函数是虚的，就需要通过 虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，就不会有虚函数表</description>
    </item>
    
    <item>
      <title>构造函数重载与互调</title>
      <link>https://874656645.github.io/rick/posts/50-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BA%92%E8%B0%83/</link>
      <pubDate>Tue, 28 Dec 2021 16:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/50-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BA%92%E8%B0%83/</guid>
      <description>构造函数可以互调，但不能在函数体内，只能通过初始化列表的形式 构造函数中不要写业务逻辑 析构函数中不要 delete this ，这会导致析构递归，最终导致栈溢出  class Test{ public: Test(int a, int b, int c){ _a = a; _b = b; _c = c; } // 正确  Test(int a, int b):Test(a, b, 100){ } /* // 错误 Test(int a, int b){ _a = a; _b = b; Test(a, b, 100); // 此处只是产生一个临时对象，马上又被释放掉了，没有任何意义 } */ int getA(){ return _a; } int getB(){ return _b; } int getC(){ return _c; } private: int _a; int _b; int _c; }; int main( ) { Test t1(10, 20); cout &amp;lt;&amp;lt; t1.</description>
    </item>
    
    <item>
      <title>类的成员函数作为回调函数</title>
      <link>https://874656645.github.io/rick/posts/49-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 28 Dec 2021 14:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/49-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid>
      <description>思路是借助类的静态成员函数
方式一：
class A{ public: A(int a){ m_a = a; } void print(){ cout &amp;lt;&amp;lt; &amp;#34;m_a = &amp;#34; &amp;lt;&amp;lt; m_a &amp;lt;&amp;lt; endl; } void setCur(){ s_curA = this; } static void callback(){ s_curA-&amp;gt;print(); } private: static A* s_curA; int m_a; }; A* A::s_curA = nullptr; typedef void (*FUN_S)(); void Handle(FUN_S call){ call(); } int main( ) { A a(10), b(20); a.setCur(); Handle(A::callback); b.setCur(); Handle(A::callback); return 0; } 方式二：
class A{ public: A(int a){ m_a = a; } void print(){ cout &amp;lt;&amp;lt; &amp;#34;m_a = &amp;#34; &amp;lt;&amp;lt; m_a &amp;lt;&amp;lt; endl; } static void callback(void *a){ ((A*)a)-&amp;gt;print(); } private: int m_a; }; typedef void (*FUN)(void *); void Handle(void *a, FUN call){ call(a); } int main( ) { A a(10), b(20); Handle(&amp;amp;a, A::callback); Handle(&amp;amp;b, A::callback); return 0; } 输出：</description>
    </item>
    
    <item>
      <title>类的兼容性原则</title>
      <link>https://874656645.github.io/rick/posts/48-%E7%B1%BB%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8E%9F%E5%88%99/</link>
      <pubDate>Tue, 28 Dec 2021 11:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/48-%E7%B1%BB%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8E%9F%E5%88%99/</guid>
      <description>父类指针可以new子类对象，子类指针不可以new父类对象，但是可以接收强转的已经存在的父类指针 父类指针指向本类对象，调用的虚函数和普通函数都是自己的 将子类指针指向父类对象，虚函数执行的是父类的，也可以调用子类函数（这种操作是错误的，编译会报错，虽然可通过指针强转，但是不建议这样做，可能会导致未知错误） 父类指针指向子类对象，虚函数执行的是子类的，并且不能调用子类的函数 父类指针与子类指针之间赋值可以理解为指针所指内容的一种浅拷贝
Father *f = (Father*)Child * 子类的虚函数指针覆盖父类的，并且子类特有的函数指针不会拷贝过去
Child *c = (Child*)new Father父类的虚函数指针覆盖子类的，同时也有子类特有的函数指针  class A{ public: void printA(){ cout &amp;lt;&amp;lt; &amp;#34;printA()&amp;#34; &amp;lt;&amp;lt; endl; } virtual void print(){ cout &amp;lt;&amp;lt; &amp;#34;A::print()&amp;#34; &amp;lt;&amp;lt; endl; } }; class B:public A{ public: void printB(){ cout &amp;lt;&amp;lt; &amp;#34;printB()&amp;#34; &amp;lt;&amp;lt; endl; } virtual void print() override{ cout &amp;lt;&amp;lt; &amp;#34;B::print() b = &amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; } private: int b; }; int main( ) { // 1、指向自己的类对象（将父类对象赋值给父类指针）  A *a = new A; // 1.</description>
    </item>
    
    <item>
      <title>构造函数私有</title>
      <link>https://874656645.github.io/rick/posts/47-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%A7%81%E6%9C%89/</link>
      <pubDate>Tue, 28 Dec 2021 10:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/47-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%A7%81%E6%9C%89/</guid>
      <description> 如果类的内部没有专门创建实例的代码，则是无法创建任何实例的 如果父类构造函数设置成了私有的，则子类无法编译，因为在初始化子类时会先执行父类的构造  class A{ public: private: A(int ){ } }; class B:public A{ public: int x; }; int main( ) { B b; b.x = 0; return 0; } 输出：
Start prog.cc:19:7: error: call to implicitly-deleted default constructor of &amp;#39;B&amp;#39; B b; ^ prog.cc:13:9: note: default constructor of &amp;#39;B&amp;#39; is implicitly deleted because base class &amp;#39;A&amp;#39; has an inaccessible default constructor class B:public A{ ^ 1 error generated. 1 Finish </description>
    </item>
    
    <item>
      <title>定义一个只能在堆上（栈上）生成对象的类</title>
      <link>https://874656645.github.io/rick/posts/46-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/</link>
      <pubDate>Mon, 27 Dec 2021 17:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/46-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/</guid>
      <description>一、只能在堆上 方法：将析构函数设置为私有
原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象
class Test { public: void printT(){ cout &amp;lt;&amp;lt; &amp;#34;printT&amp;#34; &amp;lt;&amp;lt; endl; } void freeT(){ delete this; } private: ~Test(){ cout &amp;lt;&amp;lt; &amp;#34;~Test()&amp;#34; &amp;lt;&amp;lt; endl; } }; int main( ) { // 不能在栈上创建对象  //Test t; // prog.cc:25:10: error: variable of type &amp;#39;Test&amp;#39; has private destructor  // 只能在堆上创建对象  Test *t = new Test; t-&amp;gt;printT(); // 销毁对象  t-&amp;gt;freeT(); return 0; } 输出：
Start printT ~Test() 0 Finish 二、只能在栈上 方法：将 new 和 delete 重载为私有</description>
    </item>
    
    <item>
      <title>抽象类、接口类、聚合类</title>
      <link>https://874656645.github.io/rick/posts/45-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E7%B1%BB%E8%81%9A%E5%90%88%E7%B1%BB/</link>
      <pubDate>Mon, 27 Dec 2021 16:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/45-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E7%B1%BB%E8%81%9A%E5%90%88%E7%B1%BB/</guid>
      <description>抽象类：含有纯虚函数的类，不能实例化对象 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
1）所有成员都是 public，没有私有和受保护的非静态成员；
2）没有定义任何构造函数；
3）没有类内初始化；
4）没有基类，也没有 virtual 函数  // 接口类 class A { virtual void printA() = 0; // 纯虚函数 }; // 抽象类 class AA:public A { public: // 覆写接口类的纯虚函数  void printA() override { cout &amp;lt;&amp;lt; &amp;#34;class AA printA()&amp;#34; &amp;lt;&amp;lt; endl; } virtual void printAA() = 0; }; // 可实例化的类 class B:public AA { public: // 覆写父类（抽象类）的纯虚函数  void printAA() override { cout &amp;lt;&amp;lt; &amp;#34;class B printAA()&amp;#34; &amp;lt;&amp;lt; endl; } void printB() { cout &amp;lt;&amp;lt; &amp;#34;printB()&amp;#34; &amp;lt;&amp;lt; endl; } }; // 聚合类 class C { public: int x; int y; void print(){ cc(); } private: void cc(){ cout &amp;lt;&amp;lt; &amp;#34;x = &amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;, y = &amp;#34; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; &amp;#34;, z = &amp;#34; &amp;lt;&amp;lt; z &amp;lt;&amp;lt; endl; } static int z; }; int C::z = 0; class D { public: int a; int b; C c; void print(){ cout &amp;lt;&amp;lt; &amp;#34;a = &amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34;, b = &amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; c.</description>
    </item>
    
    <item>
      <title>虚继承和虚基类</title>
      <link>https://874656645.github.io/rick/posts/44-%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB/</link>
      <pubDate>Mon, 27 Dec 2021 13:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/44-%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB/</guid>
      <description>虚继承和虚基类 参考
 在C++中，在定义公共基类A的派生类B、C&amp;hellip;的时候，如果在继承方式前使用关键字virtual对继承方式限定，这样的继承方式就是虚拟继承，公共基类A成为虚基类。这样，在具有公共基类的、使用了虚拟继承方式的多个派生类B、C&amp;hellip;的公共派生类D中，该基类A的成员就只有一份拷贝 一个类有多个基类，这样的继承关系称为多继承。在多继承的情况下，如果不同基类的成员名称相同，匹配度相同, 则会造成二义性。为了避免多继承产生的二义性，在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 会在虚继承的类中生成一个指向虚基类的指针 {vbptr} 会在内存中生成一个虚基类表 D::$vbtable@B@  微软的Visual Studio提供给用户显示C++对象在内存中的布局的选项
cl [filename].cpp /d1 reportSingleClassLayout[className]
一般继承：
class A { public: int dataA; }; class B:public A { public: int dataB; }; class C:public A { public: int dataC; }; class D : public B, public C { public: int dataD; }; 输出：
class D size(20): +--- 0 | +--- (base class B) 0 | | +--- (base class A) 0 | | | dataA | | +--- 4 | | dataB | +--- 8 | +--- (base class C) 8 | | +--- (base class A) 8 | | | dataA | | +--- 12 | | dataC | +--- 16 | dataD +--- 调用：</description>
    </item>
    
    <item>
      <title>多态总结</title>
      <link>https://874656645.github.io/rick/posts/43-%E5%A4%9A%E6%80%81%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 27 Dec 2021 10:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/43-%E5%A4%9A%E6%80%81%E6%80%BB%E7%BB%93/</guid>
      <description>1. C++ 多态分类及实现  重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载（静态多态、静态编译） 子类多态（Subtype Polymorphism，运行期）：虚函数（动态多态、动态编译） 参数多态（Parametric Polymorphism，编译期）：类模板（泛型）、函数模板（函数指针） 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换  2. 虚表指针、虚函数指针、虚函数表  虚表指针：在含有虚函数的类的对象中，指向虚函数表的指针，在运行时确定 虚函数指针：指向虚函数的地址的指针 {vfptr} 虚函数表：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚函数表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建 Shape::$vftable@  class Shape { public: virtual ~Shape(){ cout &amp;lt;&amp;lt; &amp;#34;~Shape()&amp;#34; &amp;lt;&amp;lt; endl; } }; class Point { public: ~Point(){ cout &amp;lt;&amp;lt; &amp;#34;~Point()&amp;#34; &amp;lt;&amp;lt; endl; } private: int m_x{0}; int m_y{0}; char m_c; }; class Circle : public Shape { public: ~Circle(){ cout &amp;lt;&amp;lt; &amp;#34;~Circle()&amp;#34; &amp;lt;&amp;lt; endl; } private: Point m_p; }; int main( ) { // 8 类中存有指向虚函数表的指针  cout &amp;lt;&amp;lt; sizeof(Shape) &amp;lt;&amp;lt; endl; // 16 类中存有指向虚函数表的指针  // 以及Point对象的大小（此时Point类中不包含任何变量），虽然真实大小是 8 + 1  // 但是额外多的1个字节导致内存大小扩增了 8(每次扩增的最小数值是8 &amp;lt;alignment member&amp;gt; (size=7))  cout &amp;lt;&amp;lt; sizeof(Circle) &amp;lt;&amp;lt; endl; // 8 类中的int占4个字节，char占1个字节  // 但每次扩增的最小数值是4(&amp;lt;alignment member&amp;gt; (size=3))  cout &amp;lt;&amp;lt; sizeof(Point) &amp;lt;&amp;lt; endl; Circle c; return 0; } Start 8 24 12 ~Circle() ~Point() ~Shape() 0 Finish Shape 类</description>
    </item>
    
    <item>
      <title>函数默认参数和占位参数</title>
      <link>https://874656645.github.io/rick/posts/42-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%92%8C%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sun, 26 Dec 2021 15:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/42-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%92%8C%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0/</guid>
      <description>1. 函数默认参数和占位参数（亚元） 形参中的占位参数又叫亚元，并没有什么实际意义，只在函数重载中起到作用
// 亚元，设置了默认值所以调用时可以不传参数 // 否则就必须传入两个参数 void foo(int a, int = 0){ cout &amp;lt;&amp;lt; &amp;#34;a = &amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; } int main() { foo(20); return 0; } 2. 函数重载  函数名相同，形参列表不同（形参个数、类型、顺序） 函数返回值不起作用 函数重载和默认参数不要同时使用（函数调用时容易产生二义性） 倾轧技术（name mangling），底层会将函数名进行编译  用 v c i f l d 表示 void char int float long double 及其引用 int fun(int) =&amp;gt; fun_i
int fun(int, char, double) =&amp;gt; fun_icd   重载函数匹配顺序  如果能够严格匹配，则调用完全匹配的 如果没有完全匹配的，则调用隐式转换的 都匹配不上，编译失败    3.</description>
    </item>
    
    <item>
      <title>内存区间划分</title>
      <link>https://874656645.github.io/rick/posts/41-%E5%86%85%E5%AD%98%E5%8C%BA%E9%97%B4%E5%88%92%E5%88%86/</link>
      <pubDate>Sun, 26 Dec 2021 14:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/41-%E5%86%85%E5%AD%98%E5%8C%BA%E9%97%B4%E5%88%92%E5%88%86/</guid>
      <description>一、程序运行前  代码区（只读的、共享） 数据区（全局变量和静态变量）  二、程序运行后  栈区 堆区 全局静态区（全局变量、静态变量、常量） 代码区  Linux程序运行内存虚拟地址空间：
三、全局变量与静态变量的区别 作用域不同
全局变量默认是 extern 的
静态变量是文件作用域
C/C++中extern关键字详解</description>
    </item>
    
    <item>
      <title>指针引用</title>
      <link>https://874656645.github.io/rick/posts/40-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/</link>
      <pubDate>Sat, 25 Dec 2021 21:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/40-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/</guid>
      <description>指针也是一种变量，作为函数形参和返回值的时候也是值拷贝（拷贝的是一个地址） 使用指针引用的方式，代码更加简洁，逻辑更加清晰 释放掉指针指向的空间后，一定记得把指针置空 声明指针时就进行初始化或将其指向 NULL 是个好习惯  指针值拷贝：
void test(int * a){ a = new int(20); //*a = 20;  cout &amp;lt;&amp;lt; &amp;#34;test point a = &amp;#34; &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;test:&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34;\ta = &amp;#34; &amp;lt;&amp;lt; *a &amp;lt;&amp;lt; endl; } int main() { int *a = new int(10); cout &amp;lt;&amp;lt; &amp;#34;main point a = &amp;#34; &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;main:&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34;\ta = &amp;#34; &amp;lt;&amp;lt; *a &amp;lt;&amp;lt; endl; test(a); cout &amp;lt;&amp;lt; &amp;#34;main:&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34;\ta = &amp;#34; &amp;lt;&amp;lt; *a &amp;lt;&amp;lt; endl; return 0; } 输出：</description>
    </item>
    
    <item>
      <title>抽象、封装、继承、多态</title>
      <link>https://874656645.github.io/rick/posts/39-%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/</link>
      <pubDate>Fri, 24 Dec 2021 15:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/39-%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/</guid>
      <description>一、抽象、封装 数据抽象：是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制，是一种依赖于接口实现分离的设计技术
数据封装：是一种把数据和操作数据的函数捆绑在一起的机制
1. 好处  类的内部受到保护，不会因无意的用户级错误导致对象状态受损 类实现可能随着时间的推移而发生变化，数据抽象可以更好的应对不断变化的需求  2. 策略  通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。 抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可  3. 接口 接口描述了类的行为和功能，而不需要完成类的特定实现。如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类
设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。
可用于实例化对象的类被称为具体类
接口的好处实现了解耦合的作用。 可以将软件架构分为业务逻辑层、抽象层和实现层
二、继承 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。类派生列表以一个或多个基类命名
派生类可以访问基类中所有的非私有成员，同时，一个派生类继承了所有的基类方法，但下列情况除外：
 基类的构造函数、析构函数和拷贝构造函数 基类的重载运算符 基类的友元函数  三、多态 虚函数：虚函数是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链编到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链编，或后期绑定。
 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数 一般要将父类的析构函数设置为虚函数，如果不把父类的析构函数设置为虚函数，在 delete 父类指针时就不会调用子类的析构了 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数 若在基类中不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数，在函数参数后直接加 = 0 告诉编译器，函数没有主体，这种虚函数即是纯虚函数  测试类：
// 基类 Shape class Shape { protected: int width, height; public: Shape(int a = 0, int b = 0) { width = a; height = b; } virtual ~Shape() { cout &amp;lt;&amp;lt; &amp;#34;Shape destructor&amp;#34; &amp;lt;&amp;lt; endl; } // pure virtual function  virtual int area() = 0; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { auto res = area * 70; cout &amp;lt;&amp;lt; &amp;#34;PaintCost: &amp;#34; &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl; return res; } }; class Rectangle: public Shape, public PaintCost { public: Rectangle(int a = 0, int b = 0):Shape(a, b) { } ~Rectangle() { cout &amp;lt;&amp;lt; &amp;#34;Rectangle destructor&amp;#34; &amp;lt;&amp;lt; endl; } void printPro() { // 访问父类的成员变量（不能访问父类的私有成员）  cout &amp;lt;&amp;lt; &amp;#34;width: &amp;#34; &amp;lt;&amp;lt; width &amp;lt;&amp;lt; &amp;#34;\theight: &amp;#34; &amp;lt;&amp;lt; height &amp;lt;&amp;lt; endl; } int area () { auto area = width * height; cout &amp;lt;&amp;lt; &amp;#34;Rectangle class area: &amp;#34; &amp;lt;&amp;lt; area &amp;lt;&amp;lt;endl; return area; } }; class Triangle: public Shape { public: Triangle(int a = 0, int b = 0):Shape(a, b) { } ~Triangle() { cout &amp;lt;&amp;lt; &amp;#34;Triangle destructor&amp;#34; &amp;lt;&amp;lt; endl; } int area () { auto area = width * height / 2; cout &amp;lt;&amp;lt; &amp;#34;Triangle class area: &amp;#34; &amp;lt;&amp;lt; area &amp;lt;&amp;lt;endl; return area; } }; 多继承：</description>
    </item>
    
    <item>
      <title>类的静态成员</title>
      <link>https://874656645.github.io/rick/posts/38-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</link>
      <pubDate>Fri, 24 Dec 2021 13:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/38-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</guid>
      <description>使用 static 关键字来把类成员定义为静态的。静态成员在类的所有对象中是共享的，当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本 如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零 不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数） 普通成员函数有 this 指针，可以访问类中的任意成员；  class A { string name {&amp;#34;C++&amp;#34;}; int id {1024}; static int objCount; public: A(); friend void printA(const A &amp;amp;a); void printA(); static void printC(); }; // 静态成员类外初始化 int A::objCount = 0; A::A(){ objCount++; } void A::printA(){ cout &amp;lt;&amp;lt; &amp;#34;objCount = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;objCount &amp;lt;&amp;lt; &amp;#34;\tname = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;name &amp;lt;&amp;lt; &amp;#34;\tid = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;id &amp;lt;&amp;lt; endl; } void A::printC(){ // 静态函数内没有this指针  cout &amp;lt;&amp;lt; &amp;#34;objCount = &amp;#34; &amp;lt;&amp;lt; objCount &amp;lt;&amp;lt; endl; // error: &amp;#39;this&amp;#39; is unavailable for static member functions  // cout &amp;lt;&amp;lt; &amp;#34;objCount = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;objCount &amp;lt;&amp;lt; endl; } void printA(const A &amp;amp;a){ cout &amp;lt;&amp;lt; &amp;#34;objCount = &amp;#34; &amp;lt;&amp;lt; a.</description>
    </item>
    
    <item>
      <title>友元函数与友元类</title>
      <link>https://874656645.github.io/rick/posts/37-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8B%E5%85%83%E7%B1%BB/</link>
      <pubDate>Fri, 24 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/37-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8B%E5%85%83%E7%B1%BB/</guid>
      <description>友元利弊：
友元不是类的成员但能访问类中的私有成员。友元的作用在于提高程序的运行效率，但也破坏了类的封装。
  注意事项：
（1）友元关系不能被继承；
（2）友元关系是单向的，不具有交换性；
（3）友元关系不具有传递性；
  一、友元函数  类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员 尽管友元函数的原型有在类的定义中出现过，但是 友元函数并不是成员函数 this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针  1. 友元函数是全局函数
class A { friend void printA(const A &amp;amp;a); public: void printA(); private: string name {&amp;#34;C++&amp;#34;}; int id {1024}; }; void A::printA(){ cout &amp;lt;&amp;lt; &amp;#34;name = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;name &amp;lt;&amp;lt; &amp;#34;\tid = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;id &amp;lt;&amp;lt; endl; } // 请注意：printA() 不是任何类的成员函数 void printA(const A &amp;amp;a){ cout &amp;lt;&amp;lt; &amp;#34;name = &amp;#34; &amp;lt;&amp;lt; a.</description>
    </item>
    
    <item>
      <title>构造、拷贝构造、赋值构造</title>
      <link>https://874656645.github.io/rick/posts/36-%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0/</link>
      <pubDate>Thu, 23 Dec 2021 14:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/36-%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0/</guid>
      <description>结论：
 拷贝构造函数是函数，赋值运算符是运算符的重载； 拷贝构造函数会生成新的类对象，赋值运算符不会； 拷贝构造函数是用一个已存在的对象去构造一个不存在的对象；而赋值运算符重载函数是用一个存在的对象去给另一个已存在并初始化过的对象进行赋值; 若接受返回值的对象已经初始化过，则会调用赋值运算符，且该对象还会调用析构函数，当对象中包含指针时，会使该指针失效，因此需要重载赋值运算符，使用类似深拷贝或移动构造函数的方法赋值，才能避免指针失效。 如果只有显示的构造函数，系统会提供默认的拷贝构造； 如果显示提供了拷贝构造，系统就不会提供默认的无参构造了，用户必需显示提供构造函数； 当既没有显式的构造函数，也没有拷贝构造时，系统才会提供默认的无参构造； 显示提供拷贝构造就必需显示提供构造函数； 显示提供赋值运算符重载就必需显示提供拷贝构造；  成员初始化列表  使用成员变量初始化列表，少了一次调用默认构造函数的过程，提高效率 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 成员变量初始化的顺序跟在初始化列表的顺序无关，与变量声明的顺序有关  测试类 class A { public: A(){ cout &amp;lt;&amp;lt; &amp;#34;default constructor&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;adrres: &amp;#34; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;#34;\tpoint x: &amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;\ty: &amp;#34; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl; } A(int t){ x = new int(0); y = t; cout &amp;lt;&amp;lt; &amp;#34;second constructor&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;adrres: &amp;#34; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;#34;\tpoint x: &amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;\ty: &amp;#34; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl; } A(const A &amp;amp;a){ cout &amp;lt;&amp;lt; &amp;#34;const copy constructor&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;adrres: &amp;#34; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;#34;\tpoint x: &amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;\ty: &amp;#34; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl; this-&amp;gt;x = a.</description>
    </item>
    
    <item>
      <title>函数重载、重写、隐藏、模板</title>
      <link>https://874656645.github.io/rick/posts/35-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Thu, 23 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/35-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F%E6%A8%A1%E6%9D%BF/</guid>
      <description>重载： 在同一作用域中，两个函数名相同，但是参数列表不同（个数、类型、顺序），返回值类型没有要求； 重写： 子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写； 重定义： 派生类中函数与基类中的函数同名，但是这个函数在基类中并没有被定义为虚函数 隐藏： 派生类中重定义了父类的函数，此时基类的函数会被隐藏； 模板： 函数模板是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表，只适用于 参数个数相同而类型不同 的函数。 构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数  1、重载  类的静态函数也可以重载； 形参中一级指针和二级指针被认为是不同类型的参数；  class A{ public: A(int a){ m_a = a; } void print(){ cout &amp;lt;&amp;lt; &amp;#34;print()&amp;#34; &amp;lt;&amp;lt; &amp;#34;m_a = &amp;#34; &amp;lt;&amp;lt; m_a &amp;lt;&amp;lt; endl; } void freeP(A ** p){ if(p == NULL){ return; } if(*p != NULL){ free(*p); *p = NULL; } } void freeP(A * p){ if(p != NULL){ free(p); p = NULL; } } static void printS(){ cout &amp;lt;&amp;lt; &amp;#34;printS() s_a = &amp;#34; &amp;lt;&amp;lt; s_a &amp;lt;&amp;lt; endl; } static void printS(int s){ cout &amp;lt;&amp;lt; &amp;#34;printS(int s) &amp;#34; &amp;lt;&amp;lt; s_a * s &amp;lt;&amp;lt; endl; } static void printS(void *p, int s){ cout &amp;lt;&amp;lt; &amp;#34;printS(void *p, int s) &amp;#34; &amp;lt;&amp;lt; ((A*)p)-&amp;gt;m_a * s &amp;lt;&amp;lt; endl; } static int s_a; private: int m_a; }; int A::s_a = 0; int main( ) { A *a = new A(1); a-&amp;gt;printS(a, 20); a-&amp;gt;print(); A::s_a = 10; a-&amp;gt;printS(); a-&amp;gt;printS(10); a-&amp;gt;freeP(a); if(a == NULL){ cout &amp;lt;&amp;lt; &amp;#34;*a is not valid&amp;#34; &amp;lt;&amp;lt; endl; return 0; } cout &amp;lt;&amp;lt; &amp;#34;*a is valid&amp;#34; &amp;lt;&amp;lt; endl; a-&amp;gt;print(); return 0; } 输出：</description>
    </item>
    
    <item>
      <title>inline 内联函数</title>
      <link>https://874656645.github.io/rick/posts/34-inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 23 Dec 2021 11:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/34-inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</guid>
      <description>当一个函数被声明为内联函数之后，在编译阶段，编译器会用内联函数的函数体取替换程序中出现的内联函数调用表达式，而其他的函数都是在运行时才被替换，这其实就是用空间换时间，提高了函数调用的效率。同时，内联函数具有几个特点：
 适用于函数体积很小并频繁使用的函数 内联函数中不可以出现循环、递归或开关操作 内联函数的声明必须在函数定义之前 内联函数的定义必须出现在内联函数的第一次调用前 在类中声明同时定义的成员函数（除了虚函数）会自动隐式的当成内联函数 虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联  优点：
 内联函数在被调用处进行代码展开，省去了参数压栈、跳转返回、栈帧开辟与回收，结果返回等操作，从而提高程序运行速度； 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换，而宏定义则不会； 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能； 内联函数在运行时可调试，而宏定义不可以。  缺点：
 代码膨胀，消耗了更多的内存空间； inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接； 内联函数其实是不可控的，它只是对编译器的建议，是否对函数内联，决定权在于编译器; 不能对函数进行取址操作  </description>
    </item>
    
    <item>
      <title>fork Unix</title>
      <link>https://874656645.github.io/rick/posts/33-fork-unix/</link>
      <pubDate>Thu, 23 Dec 2021 10:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/33-fork-unix/</guid>
      <description>Unix 的 fork 函数 fork函数可以创建一个和当前映像一样的子进程，这个函数会返回两个值：从子进程返回0，从父进程返回子进程的PID；
 1）在父进程中，fork返回新创建子进程的进程ID； 2）在子进程中，fork返回0； 3）如果出现错误，fork返回一个负值；  #include &amp;lt;iostream&amp;gt;#include &amp;lt;unistd.h&amp;gt; using namespace std; int main() { pid_t fpid; //fpid表示fork函数返回的值  int count = 0; cout &amp;lt;&amp;lt; &amp;amp;count &amp;lt;&amp;lt; endl; fpid = fork(); if (fpid &amp;lt; 0) printf(&amp;#34;error in fork!\n&amp;#34;); else if (fpid == 0) { printf(&amp;#34;i am the child process, my process id is %d\n&amp;#34;,getpid()); cout &amp;lt;&amp;lt; &amp;amp;count &amp;lt;&amp;lt; endl; count++; } else { printf(&amp;#34;i am the parent process, my process id is %d\n&amp;#34;,getpid()); cout &amp;lt;&amp;lt; &amp;amp;count &amp;lt;&amp;lt; endl; count++; } printf(&amp;#34;统计结果是: %d\n&amp;#34;,count); return 0; } 输出：</description>
    </item>
    
    <item>
      <title>C 与 C&#43;&#43; 的差异</title>
      <link>https://874656645.github.io/rick/posts/32-c-%E4%B8%8E-c&#43;&#43;-%E7%9A%84%E5%B7%AE%E5%BC%82/</link>
      <pubDate>Wed, 22 Dec 2021 22:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/32-c-%E4%B8%8E-c&#43;&#43;-%E7%9A%84%E5%B7%AE%E5%BC%82/</guid>
      <description>C++ 是 C 的超集和增强，校验更加严格
C 主要是面向过程，C++ 是面向对象，面向过程是函数驱动，面向对象是对象驱动
1 新增命名空间  给{}作用域起了个名称，后面不用加分号; 命名空间可以嵌套  namespace X { namespace Y { } } 2 新增引用类型  引用在一定程度上可以替代指针，作用与常指针类似 int * const a 引用没有定义，是一种关系声明，声明它和原有某一变量（实体）的关系，
故而类型与原类型保持一致，且不分配内存，与被引用的变量有相同的地址 声明时必须初始化，一经声明，不可变更 可对引用再次引用，多次引用的结果是某一变量具有多个别名 &amp;amp; 符号在 = 号左边是引用，在 = 号右边为取地址  3 枚举检测增强  不能将整型隐式转化为枚举  4 变量定义增强  C++ 变量不必都声明在函数顶部，可以随使用随定义  5 全局变量定义检测严格  C 全局变量重复定义，C++ 不可以，全局变量检测增强  // C 语言 int g_val; // bss段 int g_val = 10; // data段 6 函数形参个数和函数返回值检测增强 // C 语言 f() // 默认返回值 int { return 10; } int g(int a) { return 10; } // 调用 g(10, 20, 30, 40); // 可编译通过，但是有警告 7 struct 结构体增强  功能与类基本等同，只不过 class 默认是 private 权限，struct 默认是 public 权限  // C 语言声明结构体变量 struct Student s; // C++ 语言声明结构体变量 Student s; 8 新增 bool 关键字，1 个字节  C 用 0 表示 false，非 0 表示 true C++ 中 bool 为 1 个字节，但是只有 true 和 false 两个值  9 三目运算符增强（语法糖）  C 中三目运算符不可以当左值  // C 语言 int a = 10, b = 20; ((a &amp;lt; b) ?</description>
    </item>
    
    <item>
      <title>函数形参从右到左入栈</title>
      <link>https://874656645.github.io/rick/posts/31-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%E5%85%A5%E6%A0%88/</link>
      <pubDate>Wed, 22 Dec 2021 15:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/31-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%E5%85%A5%E6%A0%88/</guid>
      <description>int add(int count, ...) { // 指针大小与程序位数有关（32位指针是4个字节，64位指针是8个字节）  int intSize = sizeof(int*) / sizeof(int); int sum = 0; // cout &amp;lt;&amp;lt; &amp;amp;count &amp;lt;&amp;lt; endl;  int *p = &amp;amp;count + intSize; // cout &amp;lt;&amp;lt; p &amp;lt;&amp;lt; endl;  for (int i = 0; i &amp;lt; count; ++i) { sum += *p; cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl; p += intSize; } return sum; } int main() { cout &amp;lt;&amp;lt; add(3, 1, 2, 3) &amp;lt;&amp;lt; endl; return 0; } 输出：</description>
    </item>
    
    <item>
      <title>指针 &#43; 1</title>
      <link>https://874656645.github.io/rick/posts/30-%E6%8C%87%E9%92%88-&#43;1/</link>
      <pubDate>Wed, 22 Dec 2021 15:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/30-%E6%8C%87%E9%92%88-&#43;1/</guid>
      <description>1. 32 位和 64 位程序指针是多少位 32位指针大小为4个字节，64位指针大小位8个字节
2. 指针加 1，是对该指针增加 1 个储存单位 “存储单位”，指的是指针指向的数据类型所占的内存的字节数。不同类型的指针加1后，增加的大小不同。
int main() { int a[] = {1, 2, 3, 4, 5}; // &amp;amp;a是数组指针，其类型为 int (*)[5]，a是长度为5的int数组指针，所以要加 5*sizeof(int)，所以ptr实际是a[5]；  // &amp;amp;a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）  // 但是prt与(&amp;amp;a+1)类型是不一样的(这点很重要，prt指向的是整形)，所以prt-1只会减去sizeof(int)  int *ptr = (int*)(&amp;amp;a + 1); cout &amp;lt;&amp;lt; *(a + 1) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; *(ptr - 1) &amp;lt;&amp;lt; endl; return 0; } 输出：
2 5 注： a，&amp;amp;a的地址是一样的，但意思不一样：
 a是数组首地址，也就是a[0]的地址，a+1是数组下一元素的地址，即a[1] &amp;amp;a是对象（整个数组作为一个对象）首地址，而&amp;amp;a+1是下一个对象的地址，即a[5].  </description>
    </item>
    
    <item>
      <title>模板类</title>
      <link>https://874656645.github.io/rick/posts/29-%E6%A8%A1%E6%9D%BF%E7%B1%BB/</link>
      <pubDate>Wed, 22 Dec 2021 10:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/29-%E6%A8%A1%E6%9D%BF%E7%B1%BB/</guid>
      <description>template&amp;lt;class T&amp;gt; class Test { public: Test(T t){ m_t = t;}; // explicit Test(T t){ m_t = t;};  T getValue(){ return m_t; }; private: T m_t; }; int main() { Test&amp;lt;int&amp;gt; tInt(1); cout &amp;lt;&amp;lt; tInt.getValue() &amp;lt;&amp;lt; endl; Test&amp;lt;double&amp;gt; tD(1.15); cout &amp;lt;&amp;lt; tD.getValue() &amp;lt;&amp;lt; endl; Test&amp;lt;float&amp;gt; tF = 1.3f; // 构造函数没有explicit修饰，可以隐式转换  cout &amp;lt;&amp;lt; tF.getValue() &amp;lt;&amp;lt; endl; return 0; } 输出：
Start 1 1.15 1.3 0 Finish </description>
    </item>
    
    <item>
      <title>模板函数</title>
      <link>https://874656645.github.io/rick/posts/28-%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 22 Dec 2021 09:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/28-%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</guid>
      <description>template &amp;lt;typename T&amp;gt; inline const T&amp;amp; Max (const T&amp;amp; a, const T&amp;amp; b) { return a &amp;lt; b ? b:a; }; int main() { int i = 39; int j = 20; cout &amp;lt;&amp;lt; &amp;#34;Max(i, j): &amp;#34; &amp;lt;&amp;lt; Max(i, j) &amp;lt;&amp;lt; endl; double f1 = 13.5; double f2 = 20.7; cout &amp;lt;&amp;lt; &amp;#34;Max(f1, f2): &amp;#34; &amp;lt;&amp;lt; Max(f1, f2) &amp;lt;&amp;lt; endl; string s1 = &amp;#34;Hello&amp;#34;; string s2 = &amp;#34;World&amp;#34;; cout &amp;lt;&amp;lt; &amp;#34;Max(s1, s2): &amp;#34; &amp;lt;&amp;lt; Max(s1, s2) &amp;lt;&amp;lt; endl; return 0; } 输出：</description>
    </item>
    
    <item>
      <title>函数指针</title>
      <link>https://874656645.github.io/rick/posts/26-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 16 Dec 2021 14:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/26-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</guid>
      <description>#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdlib&amp;gt;using namespace std; // 声明函数指针变量 int (*fn)(int) = NULL; // 定义函数指针类型 typedef int (*Fn)(int); int cal(int v){ return v; }; // 函数指针做为形参 void proc(int v, Fn f){ cout &amp;lt;&amp;lt; f(v) &amp;lt;&amp;lt; endl; }; int main() { fn = cal; cout &amp;lt;&amp;lt; (*fn)(10) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; fn(10) &amp;lt;&amp;lt; endl; Fn f1 = cal; cout &amp;lt;&amp;lt; (*f1)(20) &amp;lt;&amp;lt; endl; proc(30, cal); return 0; } Start 10 10 20 30 0 Finish </description>
    </item>
    
    <item>
      <title>指针函数和函数指针</title>
      <link>https://874656645.github.io/rick/posts/25-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 16 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/25-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</guid>
      <description>  指针函数本质是一个函数，返回值是一个指针；
  函数指针是指向函数的一个指针变量；
  #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdlib&amp;gt; using namespace std; // 指针函数fun char * fun(const char * p) { cout &amp;lt;&amp;lt; &amp;#34;fun: &amp;#34; &amp;lt;&amp;lt; p &amp;lt;&amp;lt; endl; return nullptr; }; // 函数指针pf char * (*pf)(const char * p); int main() { pf = fun; // 函数指针pf指向函数fun  pf(&amp;#34;Hello&amp;#34;); return 0; } </description>
    </item>
    
    <item>
      <title>explicit（显式）关键字</title>
      <link>https://874656645.github.io/rick/posts/24-explicit-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Wed, 15 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/24-explicit-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>修饰构造函数，防止隐式转换，赋值初始化，赋值列表初始化 修饰转换函数，可以防止隐式转换，但按语境转换除外 explicit 可加在带多个参数的构造方法上(converting to ‘XXX’ from initializer list)  struct B { explicit B(int) {} explicit operator bool() const { return true; } }; int main() { B b1(1); // OK：直接初始化  B b2 = 1; // 错误：被 explicit 修饰构造函数的对象不可以赋值初始化  B b3{ 1 }; // OK：直接列表初始化  B b4 = { 1 }; // 错误：被 explicit 修饰构造函数的对象不可以赋值列表初始化  B b5 = (B)1; // OK：允许 static_cast 的显式转换  if (b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b6(b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b7 = b1; // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换  bool b8 = static_cast&amp;lt;bool&amp;gt;(b1); // OK：static_cast 进行直接初始化  return 0; } 从初始化列表隐式转换：</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 字符串常量存储</title>
      <link>https://874656645.github.io/rick/posts/23-c&#43;&#43;-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8/</link>
      <pubDate>Mon, 13 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/23-c&#43;&#43;-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8/</guid>
      <description>局部变量、静态局部变量、全局变量、全局静态变量、字符串常量以及动态申请的内存区
 局部变量存储在栈中 全局变量、静态变量（全局和局部静态变量）存储在静态存储区 new申请的内存是在堆中 字符串常量也是存储在静态存储区   栈中的变量内存会随着定义所在区间的结束自动释放；而对于堆，需要手动free，否则它就一直存在，直到程序结束； 对于静态存储区，其中的变量常量在程序运行期间会一直存在，不会释放，且变量常量在其中只有一份拷贝，不会出现相同的变量和常量的不同拷贝。  #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdlib&amp;gt; using namespace std; //返回的是局部变量的地址，该地址位于动态数据区，栈里 char *s1() { char* p1 = &amp;#34;qqq&amp;#34;;//为了测试‘char p[]=&amp;#34;Hello world!&amp;#34;’中的字符串在静态存储区是否也有一份拷贝  char p[]=&amp;#34;Hello world!&amp;#34;; char* p2 = &amp;#34;w&amp;#34;;//为了测试‘char p[]=&amp;#34;Hello world!&amp;#34;’中的字符串在静态存储区是否也有一份拷贝  printf(&amp;#34;in s1 p=%p\n&amp;#34;, p); printf(&amp;#34;in s1 p1=%p\n&amp;#34;, p1); printf(&amp;#34;in s1: string&amp;#39;s address: %p\n&amp;#34;, &amp;amp;(&amp;#34;Hello world!&amp;#34;)); printf(&amp;#34;in s1 p2=%p\n&amp;#34;, p2); return p1; // 这里不能返回局部变量 p } //返回的是字符串常量的地址，该地址位于静态数据区 char *s2() { char *q=&amp;#34;Hello world!&amp;#34;; printf(&amp;#34;in s2 q=%p\n&amp;#34;, q); printf(&amp;#34;in s2: string&amp;#39;s address: %p\n&amp;#34;, &amp;amp;(&amp;#34;Hello world!</description>
    </item>
    
    <item>
      <title>const 修饰符</title>
      <link>https://874656645.github.io/rick/posts/22-const-%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Fri, 10 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/22-const-%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>1、const 修饰指针和引用 常对象：const Class A 只能调用 const 成员函数
常量指针：const int * 所指的地址内容为 常量只读，但是可指向其它对象的地址（可以重指向）
指针常量：int * const 指针所指的地址不能变（不可以重指向），但地址的内容可以被修改，与引用变量效果类似
常量引用：const int &amp;amp; 相当于是对象的一个别名，对象内容为 只读，并且不能指向其它对象
const int &amp;amp;a = 40 与 constexpr int a = 40 效果类似，但后者只能在全局区声明
const int &amp;amp;a = 40 等同于 const int * const a = new int(40)（指针的指向和存放的内容都不可更改）
ClassA myA(10), myB(-10); const ClassA a; // 常对象（只能调用常成员函数） const ClassA * b = &amp;amp;myA; // 常量指针 ClassA * const b = &amp;amp;myA; // 指针常量 const ClassA &amp;amp;bb = myB; // 常量引用  b = &amp;amp;myB; // 合法（可以指向其它对象） b-&amp;gt;setA(10); // 错误（只读） bb.</description>
    </item>
    
    <item>
      <title>QProcess 使用</title>
      <link>https://874656645.github.io/rick/posts/21-qprocess-%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 06 Dec 2021 12:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/21-qprocess-%E4%BD%BF%E7%94%A8/</guid>
      <description>路径中有空格  m_process-&amp;gt;startDetached(strAppDir + &amp;quot;/ThreeDScreen.exe&amp;quot;, QStringList())
杀死一个进程（注：-t 参数会将创建的子进程一起杀死）  QProcess::startDetached(&amp;quot;taskkill -t -f /IM iexplore.exe&amp;quot;);</description>
    </item>
    
    <item>
      <title>QString 中文乱码</title>
      <link>https://874656645.github.io/rick/posts/20-qstring-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</link>
      <pubDate>Mon, 06 Dec 2021 11:34:27 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/20-qstring-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</guid>
      <description> QString使用的是UTF-8编码 从字符常量中获取中文  QString msg = QString::fromLocal8Bit(&amp;quot;This is a debug message at 中文&amp;quot;);
以QString做为形参变量传递  qDebug(msg.toUtf8());
QString与操作系统间读写，会自动将UTF-8与操作系统的编码做转换（比如日志系统）  void QtLog::WriteLine(const QString &amp;amp;logFileName, const QString &amp;amp;logMsg) { QFile file(logFileName); file.open(QIODevice::WriteOnly | QIODevice::Append); QTextStream text_stream(&amp;amp;file); text_stream &amp;lt;&amp;lt; logMsg &amp;lt;&amp;lt; &amp;#34;\r\n&amp;#34;; file.flush(); file.close(); } QString strAppDir = QCoreApplication::applicationDirPath(); // 不用转码  QString message, text, fileName = strAppDir + &amp;#34;/Log/&amp;#34;; QDir dir(fileName); if (!dir.exists()) { // 注：不能创建两级文件夹  bool ismkdir = dir.mkdir(fileName); } </description>
    </item>
    
  </channel>
</rss>
