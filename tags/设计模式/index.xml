<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>设计模式 on Slow is Smooth and Smooth is Fast</title>
    <link>https://874656645.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on Slow is Smooth and Smooth is Fast</description>
    <image>
      <url>https://874656645.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://874656645.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 02 Feb 2022 16:59:08 +0800</lastBuildDate><atom:link href="https://874656645.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>装饰器模式</title>
      <link>https://874656645.github.io/posts/115-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 02 Feb 2022 16:59:08 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/115-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代。
装饰模式可以动态给一个类增加功能</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://874656645.github.io/posts/114-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 02 Feb 2022 16:11:14 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/114-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者。</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>https://874656645.github.io/posts/113-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 02 Feb 2022 15:45:50 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/113-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>将一个请求封闭为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作（Action）模式或事务（Transaction）模式。
命令模式可以将请求者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://874656645.github.io/posts/112-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 16:59:42 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/112-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>策略模式定义了一系列的算法，并将每个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</description>
    </item>
    
    <item>
      <title>模板方法模式</title>
      <link>https://874656645.github.io/posts/111-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 16:41:35 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/111-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
class TemplateDrink{ public:  virtual void boilWater() = 0;  virtual void drew() = 0;  virtual void pourCup() = 0;  virtual void addSomething() = 0;   void make(){  boilWater();  drew();  pourCup();  addSomething();  } }; class Tea : public TemplateDrink{ public:  void boilWater() override{  cout &amp;lt;&amp;lt; &amp;#34;煮山泉水...&amp;#34; &amp;lt;&amp;lt; endl;  }  void drew() override{  cout &amp;lt;&amp;lt; &amp;#34;冲龙井茶...&amp;#34; &amp;lt;&amp;lt; endl;  }  void pourCup() override{  cout &amp;lt;&amp;lt; &amp;#34;倒入茶杯中.</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>https://874656645.github.io/posts/110-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 16:07:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/110-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>有一个已经写好的接口，但是不符合需求，适配器就是将已有的接口转化为需要的形式
class MyPrint{ public:  void operator()(int a, int b){  cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; endl;  } }; class TargetInterface{ public:  virtual void operator()(int v) = 0; }; class MyAdaptor : public TargetInterface{ public:  MyAdaptor(int param):param(param){}  void operator()(int v){  print(v, param);  } private:  MyPrint print;  int param; }; MyAdaptor myBind2nd(int v){  return MyAdaptor(v); } int main() {  vector&amp;lt;int&amp;gt; v;  for(int i = 0; i &amp;lt; 10; ++i){  v.</description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>https://874656645.github.io/posts/109-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 15:32:38 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/109-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>将复杂的子系统抽象到同一个接口进行管理，外界只需要通过此接口与子类系统进行交互，而不必直接与复杂的子类系统进行交互
案例：家庭影院外观模式 实现KTV模式：电视打开，灯关掉，音响打开，麦克风打开，DVD打开
实现游戏模式：电视打开，音响打开，游戏机打开</description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>https://874656645.github.io/posts/108-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 01 Feb 2022 07:28:53 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/108-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://874656645.github.io/posts/107-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 31 Jan 2022 20:43:34 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/107-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>单例在内存中只有一份，在内存中不会占用太多，程序退出时会随着程序统一释放内存，所以可以不必特意释放  一、懒汉式 不是线程安全的，所以多线程使用要加锁
class Singleton{ public:  static Singleton* getInstance(){  if(s_instance == nullptr){  s_instance = new Singleton;  }  return s_instance;  }   // 可有可无，程序结束时，系统会自动回收程序的所有内存  class Garbo{  ~Garbo(){  if(s_instance){  cout &amp;lt;&amp;lt; &amp;#34;gc...&amp;#34; &amp;lt;&amp;lt; endl;  delete s_instance;  }  }  };  private:  Singleton(){  cout &amp;lt;&amp;lt; &amp;#34;Singleton()...&amp;#34; &amp;lt;&amp;lt; endl;  }  Singleton(const Singleton&amp;amp;) = delete;  Singleton&amp;amp; operator=(const Singleton&amp;amp;) = delete;   static Singleton* s_instance;  static Garbo s_gc; }; Singleton* Singleton::s_instance = nullptr; int main() {  cout &amp;lt;&amp;lt; &amp;#34;main().</description>
    </item>
    
    <item>
      <title>抽象工厂模式</title>
      <link>https://874656645.github.io/posts/106-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 31 Jan 2022 17:44:49 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/106-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description> 抽象工厂针对的是产品族，而不是产品等级 产品族：同一产地或者同一厂商，功能不同 产品等级：功能相同，产地或者厂商不同 对于增加产品族，符合开闭原则 对于增加产品等级，不符合开闭原则  // 抽象工厂模式 class AbstractApple{ public:  virtual void showName() = 0; }; class AbstractBanana{ public:  virtual void showName() = 0; }; class AbstractPear{ public:  virtual void showName() = 0; }; class ChinaApple : public AbstractApple{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是中国苹果！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class ChinaBanana : public AbstractBanana{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是中国香蕉！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class ChinaPear : public AbstractPear{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是中国鸭梨！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class USAApple : public AbstractApple{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是美国苹果！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class USABanana : public AbstractBanana{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是美国香蕉！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class USAPear : public AbstractPear{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是美国鸭梨！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class JapanApple : public AbstractApple{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是日本苹果！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class JapanBanana : public AbstractBanana{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是日本香蕉！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class JapanPear : public AbstractPear{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是日本鸭梨！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class AbstractFactory{ public:  virtual AbstractApple* CreateApple() = 0;  virtual AbstractBanana* CreateBanana() = 0;  virtual AbstractPear* CreatePear() = 0; }; class ChinaFactory : public AbstractFactory{ public:  AbstractApple* CreateApple() override{  return new ChinaApple;  }  AbstractBanana* CreateBanana() override{  return new ChinaBanana;  }  AbstractPear* CreatePear() override{  return new ChinaPear;  } }; class USAFactory : public AbstractFactory{ public:  AbstractApple* CreateApple() override{  return new USAApple;  }  AbstractBanana* CreateBanana() override{  return new USABanana;  }  AbstractPear* CreatePear() override{  return new USAPear;  } }; class JapanFactory : public AbstractFactory{ public:  AbstractApple* CreateApple() override{  return new JapanApple;  }  AbstractBanana* CreateBanana() override{  return new JapanBanana;  }  AbstractPear* CreatePear() override{  return new JapanPear;  } }; int main() {  AbstractFactory* factory = nullptr;  AbstractApple* apple = nullptr;  AbstractBanana* banana = nullptr;  AbstractPear* pear = nullptr;  // 中国  factory = new ChinaFactory;  apple = factory-&amp;gt;CreateApple();  apple-&amp;gt;showName();  banana = factory-&amp;gt;CreateBanana();  banana-&amp;gt;showName();  pear = factory-&amp;gt;CreatePear();  pear-&amp;gt;showName();  delete pear;  delete banana;  delete apple;  delete factory;  // 美国  factory = new USAFactory;  apple = factory-&amp;gt;CreateApple();  apple-&amp;gt;showName();  banana = factory-&amp;gt;CreateBanana();  banana-&amp;gt;showName();  pear = factory-&amp;gt;CreatePear();  pear-&amp;gt;showName();  delete pear;  delete banana;  delete apple;  delete factory;  // 日本  factory = new JapanFactory;  apple = factory-&amp;gt;CreateApple();  apple-&amp;gt;showName();  banana = factory-&amp;gt;CreateBanana();  banana-&amp;gt;showName();  pear = factory-&amp;gt;CreatePear();  pear-&amp;gt;showName();  delete pear;  delete banana;  delete apple;  delete factory;  return 0; } </description>
    </item>
    
    <item>
      <title>工厂方法模式</title>
      <link>https://874656645.github.io/posts/105-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 31 Jan 2022 15:51:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/105-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>工厂方法模式 = 简单工厂模式 + 开闭原则
类的个数成倍增多，维护成本很高
适用场景：
 客户端不知道它所需要的对象的类 抽象工厂类通过其子类来指定创建哪个对象  // 工厂方法模式 class AbstractFruit{ public:  virtual void showName() = 0; }; class Apple : public AbstractFruit{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是苹果！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class Banana : public AbstractFruit{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是香蕉！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class Pear : public AbstractFruit{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是鸭梨！&amp;#34; &amp;lt;&amp;lt; endl;  } }; // 抽象工厂 class AbstractFruitFactory{ public:  virtual AbstractFruit* CreateFruit() = 0; }; class AppleFactory : public AbstractFruitFactory{ public:  AbstractFruit* CreateFruit() override{  return new Apple;  } }; class PearFactory : public AbstractFruitFactory{ public:  AbstractFruit* CreateFruit() override{  return new Pear;  } }; class BananaFactory : public AbstractFruitFactory{ public:  AbstractFruit* CreateFruit() override{  return new Banana;  } }; int main() {  AbstractFruitFactory* factory = nullptr;  AbstractFruit* fruit = nullptr;  factory = new AppleFactory;  fruit = factory-&amp;gt;CreateFruit();  fruit-&amp;gt;showName();  delete fruit;  delete factory;  factory = new BananaFactory;  fruit = factory-&amp;gt;CreateFruit();  fruit-&amp;gt;showName();  delete fruit;  delete factory;  factory = new PearFactory;  fruit = factory-&amp;gt;CreateFruit();  fruit-&amp;gt;showName();  delete fruit;  delete factory;  return 0; } </description>
    </item>
    
    <item>
      <title>简单工厂模式</title>
      <link>https://874656645.github.io/posts/104-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 31 Jan 2022 15:14:38 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/104-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description> 实现了客户端与功能类的解耦 但是违反了类的单一职责原则，整个类的代码冗长，阅读难度、维护难度和测试难度也很大 违反了开闭原则，增添功能要修改源代码  适用场景：
 工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂 客户端只知道传入工厂类的参数，对于如何创建对象并不关心  // 简单工厂模式 class AbstractFruit{ public:  virtual void showName() = 0; }; class Apple : public AbstractFruit{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是苹果！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class Banana : public AbstractFruit{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是香蕉！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class Pear : public AbstractFruit{ public:  void showName() override{  cout &amp;lt;&amp;lt; &amp;#34;我是鸭梨！&amp;#34; &amp;lt;&amp;lt; endl;  } }; class FruitFactory{ public:  static AbstractFruit* CreateFruit(string flag){  if(flag == &amp;#34;apple&amp;#34;){  return new Apple;  }  else if(flag == &amp;#34;banana&amp;#34;){  return new Banana;  }  else if(flag == &amp;#34;pear&amp;#34;){  return new Pear;  }  else{  return nullptr;  }  } }; int main() {  AbstractFruit* fruit = FruitFactory::CreateFruit(&amp;#34;apple&amp;#34;);  fruit-&amp;gt;showName();  delete fruit;  fruit = FruitFactory::CreateFruit(&amp;#34;banana&amp;#34;);  fruit-&amp;gt;showName();  delete fruit;  fruit = FruitFactory::CreateFruit(&amp;#34;pear&amp;#34;);  fruit-&amp;gt;showName();  delete fruit;  return 0; } </description>
    </item>
    
    <item>
      <title>依赖倒转原则</title>
      <link>https://874656645.github.io/posts/103-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/</link>
      <pubDate>Mon, 31 Jan 2022 11:35:37 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/103-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/</guid>
      <description>传统过程式设计 传统的过程式设计倾向于使高层次的模块依赖于低层次的模块，抽象层依赖于具体实现层
// 底层实现 class BankWorker{ public:  void saveService(){  cout &amp;lt;&amp;lt; &amp;#34;办理存款业务...&amp;#34; &amp;lt;&amp;lt; endl;  }  void transferService(){  cout &amp;lt;&amp;lt; &amp;#34;办理转账业务...&amp;#34; &amp;lt;&amp;lt; endl;  }  void payService(){  cout &amp;lt;&amp;lt; &amp;#34;办理支付业务...&amp;#34; &amp;lt;&amp;lt; endl;  } }; // 中层封装 void doSaveBusiness(BankWorker* worker){  worker-&amp;gt;saveService(); } void doTransferBusiness(BankWorker* worker){  worker-&amp;gt;transferService(); } void doPayBusiness(BankWorker* worker){  worker-&amp;gt;payService(); } // 高层调用 void test1(){  BankWorker* bw = new BankWorker;  doSaveBusiness(bw);  doPayBusiness(bw);  doTransferBusiness(bw);  delete bw; } 依赖倒转 // 抽象层 class AbstractWorker{ public:  virtual void doBusiness() = 0; }; // 实现层 class SaveBankWorker:public AbstractWorker{ public:  void doBusiness()override{  cout &amp;lt;&amp;lt; &amp;#34;办理存款业务.</description>
    </item>
    
    <item>
      <title>合成复用原则</title>
      <link>https://874656645.github.io/posts/102-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 30 Jan 2022 21:45:22 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/102-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</guid>
      <description>优先使用组合的方式，而不是继承
class AbstractCar{ public:  virtual void run() = 0; }; class BMW:public AbstractCar{ public:  void run()override{  cout &amp;lt;&amp;lt; &amp;#34;BMW run&amp;#34; &amp;lt;&amp;lt; endl;  } }; class DaZhong:public AbstractCar{ public:  void run()override{  cout &amp;lt;&amp;lt; &amp;#34;DaZhong run&amp;#34; &amp;lt;&amp;lt; endl;  } }; #if 0// 错误的做法 class Person : public BMW{ public: void drive(){ run(); } }; void test1(){ Person p; p.drive(); } #endif // 正确做法 class Person{ public:  Person(){  car = nullptr;  }  Person(AbstractCar* c){  car = c;  }  void drive(){  car-&amp;gt;run();  delete car;  }  void drive(AbstractCar* car){  car-&amp;gt;run();  delete car;  } private:  AbstractCar* car; }; void test2(){  // 方式一：  Person* p = new Person(new BMW);  p-&amp;gt;drive();  delete p;  p = new Person(new DaZhong);  p-&amp;gt;drive();  delete p;   // 方式二：  Person pp;  pp.</description>
    </item>
    
    <item>
      <title>迪米特法则</title>
      <link>https://874656645.github.io/posts/101-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</link>
      <pubDate>Sun, 30 Jan 2022 20:38:36 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/101-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</guid>
      <description>又叫最少知识原则
封装一个中间层进行隔离
class AbstractBuilding{ public:  virtual string getQuality()const = 0;  virtual void sale() = 0; }; class BuildingA:public AbstractBuilding{ public:  BuildingA(){  m_quality = &amp;#34;高品质&amp;#34;;  }  string getQuality()const override{  return m_quality;  }  void sale()override{  cout &amp;lt;&amp;lt; &amp;#34;楼盘A：&amp;#34; &amp;lt;&amp;lt; m_quality &amp;lt;&amp;lt; endl;  } private:  string m_quality; }; class BuildingB:public AbstractBuilding{ public:  BuildingB(){  m_quality = &amp;#34;低品质&amp;#34;;  }  string getQuality()const override{  return m_quality;  }  void sale()override{  cout &amp;lt;&amp;lt; &amp;#34;楼盘B：&amp;#34; &amp;lt;&amp;lt; m_quality &amp;lt;&amp;lt; endl;  } private:  string m_quality; }; // 错误的做法 // 客户端 void test1(){  string myRequest = &amp;#34;低品质&amp;#34;;  BuildingA* bA = new BuildingA;  if(bA-&amp;gt;getQuality() == myRequest){  bA-&amp;gt;sale();  delete bA;  }  BuildingB* bB = new BuildingB;  if(bB-&amp;gt;getQuality() == myRequest){  bB-&amp;gt;sale();  delete bB;  } } // 正确做法 // 封装一个中间类 class Mediator{ public:  Mediator(){  AbstractBuilding* b = new BuildingA;  vb.</description>
    </item>
    
    <item>
      <title>开闭原则</title>
      <link>https://874656645.github.io/posts/100-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 30 Jan 2022 20:05:30 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/100-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</guid>
      <description>对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码
如下所示，如果想要扩展乘法、除法、取模等算法，就不用修改原码，只需增加新类
class AbstractCalculator{ public:  virtual void setOperatorNum(int a, int b) = 0;  virtual int getResult() = 0; }; class PlusCalculator:public AbstractCalculator{ public:  void setOperatorNum(int a, int b)override{  m_a = a;  m_b = b;  }  int getResult()override{  return m_a + m_b;  } private:  int m_a{0};  int m_b{0}; }; class MinusCalculator:public AbstractCalculator{ public:  void setOperatorNum(int a, int b)override{  m_a = a;  m_b = b;  }  int getResult()override{  return m_a - m_b;  } private:  int m_a{0};  int m_b{0}; }; int main() {  AbstractCalculator* calculator = new PlusCalculator;  calculator-&amp;gt;setOperatorNum(10, 20);  cout &amp;lt;&amp;lt; calculator-&amp;gt;getResult() &amp;lt;&amp;lt; endl;  delete calculator;  calculator = nullptr;  calculator = new MinusCalculator;  calculator-&amp;gt;setOperatorNum(10, 20);  cout &amp;lt;&amp;lt; calculator-&amp;gt;getResult() &amp;lt;&amp;lt; endl;  delete calculator;  calculator = nullptr;   return 0; } </description>
    </item>
    
    <item>
      <title>面向对象设计原则</title>
      <link>https://874656645.github.io/posts/99-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 30 Jan 2022 19:17:09 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/99-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
      <description>原则目的：高内聚，低耦合
 单一职责原则 Single Responsibility Principal（SRP）：类的职责单一，对外只提供一种功能 开闭原则 Open-Closed Principal（OCP）：对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码 里氏代换原则 Liskov Substitution Principal（LSP）：任何抽象类出现的地方都可以用他的实现类进行替换（多态） 依赖倒转原则 Dependence Inversion Principal（DIP）：依赖于抽象（接口），不要依赖具体的实现（类），针对接口编程 接口隔离原则 Interface Segregation Principal（ISP）：一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去 合成复用原则 Composite Reuse Principal（CRP）：对于继承和组合，优先使用组合 迪米特法则 Law of Demeter（LoD）：一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节（黑盒原理）  </description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://874656645.github.io/posts/98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 30 Jan 2022 11:57:37 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式
一、概念  设计模式是在特定环境下人们解决某类重复出现的问题的一套成功或有效的解决方案。 软件模式并非仅限于设计模式，还包括架构模式、分析模式、过程模式等。 在一定环境下，用固定套路解决问题。 设计模式的基础是多态。  二、目的  学习设计模式有助于更加深入的理解面向对象思想 如何将代码分散在几个不同的类中 为什么要有接口 何谓针对抽象编程 何时不应该使用继承 如何不修改源代码增加新功能 更好地阅读和理解现有类库与其它系统中的源代码  三、软件设计模式种类 GoF 提出的设计模式有 23 种，加简单工厂模式，一共 24 种
1、创建型模式 Creational 6种 如何创建对象
 单例模式 简单工厂模式 工厂方法模式 抽象工厂模式 原型模式 建造者模式  2、结构型模式 Structural 7种 如何实现类或对象的组合
让类和类进行组合，获得更大的结构
 适配器模式 桥接模式 组合模式 装饰模式 外观模式 享元模式 代理模式  3、行为型模式 Behavioral 11种 类或对象怎样交互以及怎样分配职责
 职责链模式 命令模式 解释器模式 迭代器模式 中介模式 备忘录模式 观察者模式 状态模式 策略模式 模板方法模式 访问者模式  </description>
    </item>
    
    <item>
      <title>UML 统一建模语言</title>
      <link>https://874656645.github.io/posts/97-uml-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Sat, 29 Jan 2022 19:55:47 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/97-uml-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</guid>
      <description>一、用例图  用例代表系统的某项完整功能 从客户角度来描述系统功能 包括参与者、用例、关系  1. 泛化关系 Generalization  父类和子类的关系  2. 包含关系 Include  一个功能肯定会使用另一个功能  3. 扩展关系 Extend  完成某个功能的时候偶尔会执行另一个功能  二、类图 用来显示系统中的类，接口以及它们之间的关系
1. 泛化关系 Generalization（is a） 一种类与类之间的继承关系
2. 实现关系 Realization（is a） 类与抽象类之间的实现关系
3. 依赖关系 Dependence（use a） 两个相对独立的系统，一个系统负责构造另一个系统的实例，或者依赖另一个系统的服务
类 A 做为类 B 方法的形参，而不是类 B 的成员属性
4. 关联关系 Directed Association 两个相对独立的系统，一个系统的实例与另一个系统的一些实例存在固定的对应关系
  聚合 Aggregation
 聚合关系是关联关系的一种，是更强的关联关系 聚合是整体和部分之间的关系，例如汽车由引擎、轮胎以及其它零件组成 聚合关系也是通过成员变量来实现的，但是，关联关系所涉及的两个类处在同一个层次上，而聚合关系中，两个类处于不同层次上，一个代表整体，一个代表部分 整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享    组合 Composition
  三、对象图 四、时序图 五、活动图 </description>
    </item>
    
  </channel>
</rss>
