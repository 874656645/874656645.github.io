<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>数据结构与算法 on Slow is Smooth and Smooth is Fast</title>
    <link>https://874656645.github.io/series/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 数据结构与算法 on Slow is Smooth and Smooth is Fast</description>
    <image>
      <url>https://874656645.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://874656645.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 06 Apr 2022 08:56:06 +0800</lastBuildDate><atom:link href="https://874656645.github.io/series/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据结构与算法——队列的应用</title>
      <link>https://874656645.github.io/posts/165-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Wed, 06 Apr 2022 08:56:06 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/165-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>一、队列的应用   只要满足先来先服务特性的应用均可采用队列作为其数据组织方式或中间数据结构
 调度或缓冲  消息缓冲器 邮件缓冲器 计算机硬设备之间的通信也需要队列作为数据缓冲 操作系统的资源管理   宽度优先搜索    广度优先搜索：搜索该步的所有可能状态，再进一步考虑后面的各种情况；（队列应用）
 树的层次遍历    深度优先搜索：沿某一状态走下去，不行再回头。（栈应用）
 树的先序、中序、后续遍历    二、农夫过河问题   问题抽象：
 “人狼羊菜”乘船过河 只有人能撑船，船只有两个位置（包括人） 狼羊、羊菜不能在没有人时共处    数据抽象：
 对每个角色的位置进行描述，农夫、狼、羊和菜，四个目标依次各用一位，目标在起始岸位置：0，目标岸：1。如 0110 表示农夫、白菜在起始岸，而狼、羊在目标岸（此状态为不安全状态） 用整数 status 表示上述四位二进制描述的状态，如整数 0x08 表示的状态 1000，整数 0x0F 表示的状态 1111 如何从上述状态中得到每个角色所在位置？  bool farmer(int status){  return ((status &amp;amp; 0x08) != 0); } bool wolf(int status){  return ((status &amp;amp; 0x04) !</description>
    </item>
    
    <item>
      <title>数据结构与算法——队列的实现方式</title>
      <link>https://874656645.github.io/posts/164-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 05 Apr 2022 12:22:44 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/164-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid>
      <description>栈的物理实现有 顺序队列 和 链式队列
一、顺序队列 用向量存储队列元素，用两个变量分别指向队列的前端(front)和尾端(rear)
 关键是如何防止假溢出    队列溢出
 上溢 下溢 假溢出：当 rear = mSize-1 时，再作插入运算就会产生溢出，如果这时队列的前端还有许多空位置，这种现象称为假溢出    循环队列
 为了解决假溢出的问题，需要采用循环队列的方式： % mSize 另外一个问题就是如何区分空队列还是满队列？空一个队列空间，空队列状态时，令 front = rear，若 (rear + 1) % mSize == front，我们认为此时队列已满，但实际上 rear 指向的空间并没有被利用    循环队列类定义
  template &amp;lt;class T&amp;gt; class arrQueue: public Queue&amp;lt;T&amp;gt; { private:  int mSize; // 存放队列的数组的大小  int front; // 表示队头所在位置的下标  int rear; // 表示待入队元素所在位置的下标  T *qu; // 存放类型为T的队列元素的数组 public: // 队列的运算集  arrQueue(int size) { // 创建队列的实例  mSize = size + 1; // 浪费一个存储空间，以区别队列空和队列满  qu = new T[mSize];  front = rear = 0;  }  ~arrQueue() { // 消除该实例，并释放其空间  delete[] qu;  } }  // 入队操作 template&amp;lt;class T&amp;gt; bool arrQueue&amp;lt;T&amp;gt; :: enQueue(const T item) {  // item入队，插入队尾  if (((rear + 1 ) % mSize) == front) {  cout &amp;lt;&amp;lt; &amp;#34;队列已满，溢出&amp;#34; &amp;lt;&amp;lt; endl;  return false;  }  qu[rear] = item;  rear = (rear + 1) % mSize; // 循环后继  return true; }  // 出队操作 bool arrQueue&amp;lt;T&amp;gt; :: deQueue(T&amp;amp; item) {  // 返回队头元素并从队列中删除  if ( front == rear) {  cout &amp;lt;&amp;lt; &amp;#34;队列为空&amp;#34; &amp;lt;&amp;lt; endl;  return false;  }  item = qu[front];  front = (front + 1) % mSize; // 这里并没有真的删除队列空间的元素，而是把头指针循环后移  return true; } 二、链式队列   用单链表方式存储，队列中每个元素对于链表中的一个结点</description>
    </item>
    
    <item>
      <title>数据结构与算法——队列</title>
      <link>https://874656645.github.io/posts/163-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/</link>
      <pubDate>Tue, 05 Apr 2022 09:03:06 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/163-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/</guid>
      <description>一、队列   队列特点
 访问受限的线性表 先进先出 插入在一端进行，删除在另一端进行    主要元素
 队头 队尾    主要操作
 入队列 出队列 取队首元素 判断队列是否为空    二、队列的抽象数据类型 template &amp;lt;class T&amp;gt; class Queue {  // 队列的运算集 public:  // 变为空队列  void clear();  // 将item插入队尾，成功则返回真，否则返回假  bool enQueue(const T item);  // 返回队头元素并将其从队列中删除，成功则返回真  bool deQueue(T &amp;amp; item);  // 返回队头元素，但不删除，成功则返回真  bool getFront(T &amp;amp; item);  // 返回真，若队列已空  bool isEmpty();  // 返回真，若队列已满  bool isFull(); }; 三、队列的实现方式 队列的物理实现又分为顺序队列和链式队列</description>
    </item>
    
    <item>
      <title>数据结构与算法——栈的应用</title>
      <link>https://874656645.github.io/posts/162-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Mon, 04 Apr 2022 14:12:42 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/162-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>栈的特点是后进先出，所以常用来处理具有递归结构的数据
 深度优先搜索 表达式求值 子程序 / 函数调用的管理 消除递归    表达式的递归定义
 基本符号集：${0，1，…，9，+，-，*，/，（，）}$ 语法成分集：{&amp;lt;表达式&amp;gt; , &amp;lt;项&amp;gt; , &amp;lt;因子&amp;gt; , &amp;lt;常数&amp;gt;, &amp;lt;数字&amp;gt; } 中缀表达式：$23\ +\ (34\ *\ 45)\ /\ (5\ +\ 6\ +\ 7)$  后缀表达式：$23\ 34\ 45\ *\ 5\ 6\ +\ 7\ +\ /\ +$
    中缀表达式
 运算符在中间 需要括号改变优先级  例如：$4\ *\ x\ *\ (2\ *\ x\ +\ a)\ –\ c$
  后缀表达式</description>
    </item>
    
    <item>
      <title>数据结构与算法——栈的实现方式</title>
      <link>https://874656645.github.io/posts/161-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sun, 03 Apr 2022 20:03:03 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/161-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid>
      <description>栈的物理实现有 顺序栈 和 链式栈
一、顺序栈（Array-based Stack）  使用向量实现，本质上是顺序表的简化版  栈有固定大小   关键是确定哪一端作为栈顶 注意上溢、下溢问题  类定义：
template &amp;lt;class T&amp;gt; class arrStack : public Stack &amp;lt;T&amp;gt; { private: // 栈的顺序存储  int mSize; // 栈中最多可存放的元素个数  int top; // 栈顶位置，应小于mSize  T *st; // 存放栈元素的数组 public: // 栈的运算的顺序实现  arrStack(int size) { // 创建一个给定长度的顺序栈实例  mSize = size;  top = -1;  st = new T[mSize];  }  arrStack() { // 创建一个顺序栈的实例  top = -1;  }  ~arrStack() {  delete [] st;  }  void clear() {  top = -1;  } // 清空栈 };  bool arrStack&amp;lt;T&amp;gt;::push(const T item) { // 入栈  if (top == mSize-1) { // 栈已满  cout &amp;lt;&amp;lt; &amp;#34;栈满溢出&amp;#34; &amp;lt;&amp;lt; endl;  return false;  } else { // 新元素入栈并修改栈顶指针  st[++top] = item;  return true;  } }  bool arrStack&amp;lt;T&amp;gt;::pop(T&amp;amp; item) { // 出栈  if (top == -1) { // 栈为空  cout &amp;lt;&amp;lt; &amp;#34;栈为空，不能执行出栈操作&amp;#34;&amp;lt;&amp;lt; endl;  return false;  } else {  item = st[top--]; // 返回栈顶，并缩减1  return true;  } } 二、链式栈（Linked Stack）  用单链表方式存储，其中指针的方向是从栈顶向下链接 理论上没有大小限制  类定义：</description>
    </item>
    
    <item>
      <title>数据结构与算法——栈</title>
      <link>https://874656645.github.io/posts/160-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88/</link>
      <pubDate>Thu, 31 Mar 2022 22:04:28 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/160-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88/</guid>
      <description>一、栈  后进先出  是一种限制访问端口的线性表   主要操作  进栈（push） 出栈（pop）   应用  表达式求值（中缀表达式、后缀表达式） 消除递归 深度优先搜索（树、图）    二、栈的抽象数据类型 template &amp;lt;class T&amp;gt; class Stack { public: // 栈的运算集  void clear(); // 变为空栈  bool push(const T item); // item入栈，成功返回真，否则假  bool pop(T&amp;amp; item); // 返回栈顶内容并弹出，成功返回真，否则假  bool top(T&amp;amp; item); // 返回栈顶但不弹出，成功返回真，否则假  bool isEmpty(); // 若栈已空返回真  bool isFull(); // 若栈已满返回真 }; 三、思考题   若入栈顺序为 1,2,3,4 的话，则出栈的顺序可以有哪些?</description>
    </item>
    
    <item>
      <title>数据结构与算法——连续子数组最大和</title>
      <link>https://874656645.github.io/posts/152-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/</link>
      <pubDate>Sat, 19 Mar 2022 15:35:35 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/152-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/</guid>
      <description>一、暴力算法 $\mathcal{O}(n^3)$ 遍历数组的所有子数组集合，并对其求和，筛选出和的最大值
int maxSumOfSub1(int* array, int length){  int maxSum = 0;  int startIndex = 0, endIndex = 0;  for(int i = 0; i &amp;lt; length; i++){  for(int j = i; j &amp;lt; length; j++){  int sum = 0;  for(int k = i; k &amp;lt;= j; k++)  sum += array[k];  if(maxSum &amp;lt; sum){  maxSum = sum;  startIndex = i;  endIndex = j;  }  }  }   cout &amp;lt;&amp;lt; &amp;#34;Begin:&amp;#34; &amp;lt;&amp;lt; startIndex &amp;lt;&amp;lt; &amp;#34; End:&amp;#34; &amp;lt;&amp;lt; endIndex &amp;lt;&amp;lt; &amp;#34; Num:&amp;#34; &amp;lt;&amp;lt; maxSum &amp;lt;&amp;lt; endl;  return maxSum; } 二、前缀和 $\mathcal{O}(n^2)$ 先把数组的前 i 项和求出来并将其保存到数组中，然后计算所有子数组集合的和，筛选其中最大的</description>
    </item>
    
    <item>
      <title>数据结构与算法——线性表</title>
      <link>https://874656645.github.io/posts/151-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E8%A1%A8/</link>
      <pubDate>Mon, 14 Mar 2022 21:30:45 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/151-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E8%A1%A8/</guid>
      <description>线性结构  二元组 B = (K, R) , K = {a0, a1, …, an-1 }, R = {r}，其中 r 为前驱后继关系，具有反对称性和传递性 唯一的开始结点（表头）：没有前驱，只有一个唯一的后继 唯一的终止结点（表尾）：没有后继，只有一个唯一的前驱 内部结点：一个唯一的前驱和一个唯一的后继  线性表 线性表简称表，是零个或多个元素的有穷序列
 表目：线性表中的元素 文件：含有大量记录的线性表又称为文件 索引（下标） 表的长度 空表：长度为零的线性表(n=0)  线性表分类   按访问方式划分：
 直接访问型 顺序访问型 目录索引型    按存储方式：
 顺序表（数组） 链表    按操作：
 线性表：不限操作 栈：在同一端操作，在深度优先搜索、递归等算法中有很好的应用 队列：在两端操作，在宽度优先搜索、层次化处理中有很好的应用    顺序表  顺序表俗称向量，是用数组实现的（固定长度的一维数组） 按索引值从小到大存放在一片相邻的连续区域 结构紧凑，存储密度为1（存储密度 = 数据本身所占存储 / 整个数据结构所占存储） 物理存储关系就能表示逻辑关联关系  链表  链表需要指针表示逻辑关联关系，存储效率不如顺序表 有头链表和无头链表 在一些边界处理的时候，要注意头结点（head）和尾结点（tail）的特殊处理  讨论   线性表的分类方法有哪些？各种线性表名称中，哪些跟存储结构相关？哪些跟运算相关？</description>
    </item>
    
    <item>
      <title>数据结构与算法——算法效率与度量</title>
      <link>https://874656645.github.io/posts/150-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E4%B8%8E%E5%BA%A6%E9%87%8F/</link>
      <pubDate>Sun, 13 Mar 2022 16:29:26 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/150-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E4%B8%8E%E5%BA%A6%E9%87%8F/</guid>
      <description>算法的时间和空间性能非常重要
一、算法的渐近分析 当 n 增大到一定值后，其他的常数项和低幂次项都可以忽略，只需确定是在什么量级（线性、n 方、指数级等）
1. 大 $\mathcal{O}$ 表式法 函数增长率上限
2. 大 $\Omega$ 表式法 函数增值率的下限
3. 大 $\Theta$ 表示法 当上、下限相同时则可用 $\Theta$ 表示法
二、增长率曲线 三、数据结构和算法的选择  仔细分析所要解决的问题  特别是求解问题所涉及的数据类型和数据间逻辑关系（问题抽象、数据抽象） 数据结构的初步设计往往先于算法设计   注意数据结构的可扩展性  考虑当输入数据的规模发生改变时，数据结构是否能够适应求解问题的演变和扩展    三、思考题   数据结构的三个要素任何一个发生改变，都是不同的数据结构，请举例讨论
 双向链表和二叉树的存储结构其实是一样的，他们的不同在于逻辑结构。 数组和向量都是线性表，其存储形式不同，成为不同的数据结构。    算法设计目标是什么？
 时间和空间的权衡 易读 易编码 易调试 易维护 易扩展    算法选择的过程？
  要求在时间复杂度 $\mathcal{O}(n)$、空间复杂度 $\mathcal{O}(1)$，使数组元素循环向右移动 K 位
  </description>
    </item>
    
    <item>
      <title>数据结构与算法——算法特性及分类</title>
      <link>https://874656645.github.io/posts/149-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7%E5%8F%8A%E5%88%86%E7%B1%BB/</link>
      <pubDate>Fri, 11 Mar 2022 22:26:22 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/149-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7%E5%8F%8A%E5%88%86%E7%B1%BB/</guid>
      <description>一、问题——算法——程序  问题：一个函数，从输入到输出在一种映射 算法：对特定问题求解过程的描述，是指令的有限序列 程序：算法在计算机程序设计语言中的具体实现  二、算法的特性  通用性：参数化的，能对一类问题进行参数化输入并问题求解 有效性：有限条有效指令组成的指令序列，保证计算结果的正确性 确定性：算法的下一步执行步骤必须明确 有穷性：执行必须在有限步内结束，不能有死循环  三、基本算法分类  穷举法：
遍历每一个元素，比较低效，但是是一种万能的算法；对于一个问题，如果一时想不出好的算法的话，可对小规模数据采用穷举法剖析问题的特性和数据的特性，进而寻求更高效的算法 回溯、搜索：
能进则进，不能进则换，不能换则退，如树和图的遍历 递归分治：
二分查找，以及快速排序、归并排序，都是经典的分治算法思想 贪心法：
其数据具有贪心性质，每次求解的时候都采用当前的最佳解，最终得到最优解，如 Huffman 编码树、最短路径 Dijkstra 算法、最小生成树 Prim 算法 动态规划：
得到小规模问题的最优解，然后在更大规模的时候去组合这些最优解，最后得到全局的最优解，如图的两两结点之间最短路 Floyd 算法。要求具有最优子结构性质以及无后效性，动态规划的子结构有重叠，而递归分治子结构不重叠。  四、“监视哨”顺序检索 设置“监视哨”后，在查找过程中不用判断 i 是否越界，少一次判断，算法的运行效率会更高</description>
    </item>
    
    <item>
      <title>数据结构与算法——数据结构定义</title>
      <link>https://874656645.github.io/posts/148-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Thu, 10 Mar 2022 21:10:53 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/148-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89/</guid>
      <description>一、什么是数据结构   结构：实体 + 关系，比如分子结构，关系图等
  数据结构：按照逻辑关系组织起来的一批数据，按一定的存储方法所把它存储在计算机中，并在这些数据上定义了一个运算的集合
  二、数据的逻辑结构  线性结构
线性表（表、栈、队列、串等） 非线性结构
树（二叉树、Huffman树、二叉检索树等）
图（有向图、无向图等） 图 ⊇ 树 ⊇ 二叉树 ⊇ 线性表  三、数据的存储结构   将逻辑结构的结点映射到内存中，每一个结点都对应一个唯一的连续存储区域
  内存可以看作从低地址到高地址的一个编码的线性结构，可以根据地址立即访问想要访问的内存单元，不需要搜索
  存储结构主要有顺序、链接、索引和散列四种形式
 顺序存储对应于数组 链接存储对应于链表 索引是对数据建立一个索引表，通过这个表有效的找到相应数据的存储地址 散列是一种特殊的索引结构，本身也是一种存储结构，通过关键码的映射关系，在整个散列表中用单位时间快速地找到其存储地址    四、抽象数据类型 ADT（Abstract Data Type）  定义了一组运算的数学模型 与物理存储结构无关 使软件系统建立在数据之上(面向对象)  五、定义抽象数据类型 抽象数据类型就是在逻辑结构上的运算，可以理解为抽象数据结构二元组 &amp;lt;数据对象D, 数据操作P&amp;gt;
先定义逻辑结构，再定义运算
 逻辑结构：数据对象及其关系 运算：数据操作  就像面向对象语言中所定义的类（特别是抽象类），封装了数据成员和函数成员</description>
    </item>
    
    <item>
      <title>数据结构与算法——简介</title>
      <link>https://874656645.github.io/posts/147-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 08 Mar 2022 20:33:08 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/147-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%80%E4%BB%8B/</guid>
      <description>算法 + 数据结构 = 程序   数据结构与算法是程序的灵魂，以问题求解为导向，进行问题抽象、数据抽象、算法抽象，通过有效地组织数据、设计高效的算法、完成高质量的程序，从而解决实际应用的问题。
  流程：问题 =&amp;gt; 数据 =&amp;gt; 算法
  理论（离散数学、概率统计、图论等） =&amp;gt; 抽象（问题抽象、数据抽象、算法抽象等面向对象思想） =&amp;gt; 设计（实现的某种具体编程语言）
  逻辑抽象 + 运算抽象 =&amp;gt; ADT
  运算 + 存储 =&amp;gt; 算法分析（时间和空间复杂度）
  问题抽象：分析和抽象任务需求，建立问题模型
  数据抽象：确定恰当的数据结构表示数学模型
  算法抽象：在数据模型的基础上设计合适的算法
  </description>
    </item>
    
    <item>
      <title>哈希法与冲突处理</title>
      <link>https://874656645.github.io/posts/134-%E5%93%88%E5%B8%8C%E6%B3%95%E4%B8%8E%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 25 Feb 2022 17:23:49 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/134-%E5%93%88%E5%B8%8C%E6%B3%95%E4%B8%8E%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/</guid>
      <description>哈希表及处理冲突的方法
一、哈希法与哈希表  哈希法又称散列法、杂凑法以及关键字地址计算法等，相应的表称为哈希表。 这种方法的基本思想是：首先在元素的关键字 k 和元素的存储位置 p 之间建立一个对应关系 f，使得 p = f(k)，f 称为哈希函数。 创建哈希表时，把关键字为 k 的元素直接存入地址为 f(k) 的单元；以后当查找关键字为 k 的元素时，再利用哈希函数计算出该元素的存储位置 p=f(k)，从而达到按关键字直接存取元素的目的。  二、冲突 当关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，即 k1 ≠ k2，但 f(k1) = f(k2)，这种现象称为冲突，此时称 k1 和 k2 为同义词。
三、哈希函数构造方法 构造哈希函数的原则是：
 函数本身便于计算； 计算出来的地址分布均匀，即对任一关键字 k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突  常用的构造方法：
 数字分析法 平方取中法 分段叠加法 除留余数法：假设哈希表长为 m，p 为小于等于 m 的最大素数，则哈希函数为 f(k)=k % p 伪随机数法  四、冲突处理方法 1. 开放地址法（Open addressing） 这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi
 线性探测 二次探测 伪随机探测  线性探测再散列的优点是：只要哈希表不满，就一定能找到一个不冲突的哈希地址，而二次探测再散列和伪随机探测再散列则不一定；缺点是线性探测再散列容易产生二次聚集
2. 再哈希法 这种方法是同时构造多个不同的哈希函数，当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间</description>
    </item>
    
  </channel>
</rss>
