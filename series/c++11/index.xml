<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43;11 on Slow is Smooth and Smooth is Fast</title>
    <link>https://874656645.github.io/series/c&#43;&#43;11/</link>
    <description>Recent content in C&#43;&#43;11 on Slow is Smooth and Smooth is Fast</description>
    <image>
      <url>https://874656645.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://874656645.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 09 Apr 2022 10:28:47 +0800</lastBuildDate><atom:link href="https://874656645.github.io/series/c++11/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;11 constexpr</title>
      <link>https://874656645.github.io/posts/170-c&#43;&#43;11-constexpr/</link>
      <pubDate>Sat, 09 Apr 2022 10:28:47 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/170-c&#43;&#43;11-constexpr/</guid>
      <description>在编译过程中就已经把值计算出来，会做类型检查； define 是在预编译过程中进行简单的文本替换，不会做类型检查； 在对象声明时或非静态成员函数中使用 constexpr 关键字(C++ 14)暗示这个对象或非静态成员函数是 const 的； 在函数或静态数据成员(C++ 17)声明中使用的 constexpr 关键字意味着内联； C++11 中 constexpr 函数可以使用递归，?: 三目运算符，从 C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句；    constexpr 修饰变量必须满足以下要求：
 它的类型必须是一个LiteralType 它必须立即初始化 其初始化的完整表达式，包括所有隐式转换、构造函数调用等，必须是 constexpr 它必须有 constexpr 析构    constexpr 修饰函数必须满足以下要求：
 它不能是 virtual 修饰的(直到 C++20) 它不能是 coroutine 协程(直到 C++20) 它的返回类型（如果有的话）必须是 LiteralType 所有参数必须是 LiteralType    class Test{ public: int x = 10; }; int main() { constexpr Test t; // const  cout &amp;lt;&amp;lt; typeid(t.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 std::function</title>
      <link>https://874656645.github.io/posts/169-c&#43;&#43;11-function/</link>
      <pubDate>Fri, 08 Apr 2022 16:06:06 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/169-c&#43;&#43;11-function/</guid>
      <description>替代以前的函数指针 类模板 std::function 是一个通用的多态函数包装器。 function 的实例可以存储、复制和调用任何 CopyConstructible Callable 目标：  函数 lambda 表达式 std::bind 表达式 函数对象 指向成员函数的指针 指向成员属性的指针    参考：
std::function</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 std::mem_fn</title>
      <link>https://874656645.github.io/posts/168-c&#43;&#43;11-mem_fn/</link>
      <pubDate>Fri, 08 Apr 2022 10:20:07 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/168-c&#43;&#43;11-mem_fn/</guid>
      <description></description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 std::reference_wrapper</title>
      <link>https://874656645.github.io/posts/167-c&#43;&#43;11-reference_wrapper/</link>
      <pubDate>Thu, 07 Apr 2022 13:43:10 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/167-c&#43;&#43;11-reference_wrapper/</guid>
      <description>创建一个对象或函数的引用，对象必须是 可复制(CopyConstructible)、可赋值(CopyAssignable) 的。
  它经常被用作在标准容器(如 std::vector )中存储引用的机制，而标准容器通常不能保存引用。
  辅助函数 std::ref 与 std::cref 常用于生成 std::reference_wrapper 对象。
  std::reference_wrapper 也用于按引用传递参数给 std::bind 或 std::thread 的构造函数。
  能隐式转换成 T&amp;amp;。
    在 vector 中存储引用类型：
#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;random&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;algorithm&amp;gt; int main() { std::list&amp;lt;int&amp;gt; l(10); std::iota(l.begin(), l.end(), -4); // 从 -4 开始，逐个 +1  std::vector&amp;lt;std::reference_wrapper&amp;lt;int&amp;gt;&amp;gt; v(l.begin(), l.end()); // 不能在 list 上用 shuffle （要求随机访问），但能在 vector 上使用它  std::shuffle(v.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 std::ref, std::cref 与 std::bind</title>
      <link>https://874656645.github.io/posts/166-c&#43;&#43;11-refcref-%E4%B8%8E-bind/</link>
      <pubDate>Thu, 07 Apr 2022 10:40:34 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/166-c&#43;&#43;11-refcref-%E4%B8%8E-bind/</guid>
      <description>函数模板 ref 与 cref 是生成 std::reference_wrapper 类型对象的帮助函数，主要是与 std::bind 一起使用，默认情况下，std::bind 无法使用变量引用传递，即使原来的函数形参是引用类型的
void f(int&amp;amp; n1, int&amp;amp; n2, const int&amp;amp; n3) { std::cout &amp;lt;&amp;lt; &amp;#34;In function: &amp;#34; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; ++n1; // 增加存储于函数对象的 n1 副本  ++n2; // 增加 main() 的 n2  // ++n3; // 编译错误 error: increment of read-only reference ‘n3’ } int main() { int n1 = 1, n2 = 2, n3 = 3; // 函数对象 bound_f  // 默认会将此时变量值的副本做为函数对象的参数（函数参数特例化）  std::function&amp;lt;void()&amp;gt; bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3)); n1 = 10; n2 = 11; n3 = 12; std::cout &amp;lt;&amp;lt; &amp;#34;Before function: &amp;#34; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; bound_f(); std::cout &amp;lt;&amp;lt; &amp;#34;After function: &amp;#34; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } 输出：</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 左值、右值和移动语义</title>
      <link>https://874656645.github.io/posts/133-c&#43;&#43;11-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</link>
      <pubDate>Wed, 23 Feb 2022 22:19:35 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/133-c&#43;&#43;11-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</guid>
      <description>一、结论  C 中将数据类型分为左值和右值，在 C++11 中又将右值概念更为细致的分为将亡值（xvalue）和纯右值（prvalue）。 将亡值是 C++11 新增的跟右值引用相关的表达式，通常是将要被移动的对象（移为他用），比如返回右值引用 T&amp;amp;&amp;amp; 的函数返回值、std::move 的返回值。 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。 右值引用可以直接指向右值，也可以通过 std::move 指向左值；而左值引用只能指向左值（const左值引用也能指向右值）。 作为函数形参时，右值引用更灵活。虽然 const 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。 可移动对象在需要拷贝且被拷贝者之后不再被需要的场景，建议使用 std::move 触发移动语义，提升性能。 我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和 std::move 的语言特性。 std::move 本身只做类型转换，对性能无影响。 std::forward 同样也是做类型转换且更强大，move 只能转出来右值，forward 既可以转成右值，又可以转成左值。 函数最好不要返回函数体内局部变量的左值引用或右值引用。  二、注意事项  左值引用是具名变量值的别名 右值引用是不具名（匿名）变量的别名    引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值，但是，const左值引用是可以指向右值的
const int &amp;amp;ref_a = 5; int a = 5; int &amp;amp;ref_a = a; // 左值引用指向左值，编译通过 int &amp;amp;ref_a = 5; // 左值引用指向了右值，会编译失败   右值引用的标志是 &amp;amp;&amp;amp;，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值
int&amp;amp;&amp;amp; ref_a_right = 5; // ok int a = 5; int&amp;amp;&amp;amp; ref_a_left = a; // 编译不过，右值引用不可以指向左值  ref_a_right = 6; // 右值引用的用途：可以修改右值   事实上 std::move 移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(lvalue)。 所以，单纯的 std::move(xxx) 不会有性能提升，从这个角度来讲，右值引用和左值引用的功能相似，都是原始变量的别名，至于移动后原始变量是否可用，取决于被移动的数据类型对于移动语义的具体实现。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 auto_ptr 被废弃与 unique_ptr</title>
      <link>https://874656645.github.io/posts/131-c&#43;&#43;11-auto_ptr-%E8%A2%AB%E5%BA%9F%E5%BC%83%E4%B8%8E-unique_ptr/</link>
      <pubDate>Tue, 22 Feb 2022 22:18:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/131-c&#43;&#43;11-auto_ptr-%E8%A2%AB%E5%BA%9F%E5%BC%83%E4%B8%8E-unique_ptr/</guid>
      <description>一、auto_ptr 特点  支持拷贝构造 支持赋值拷贝 支持 operator-&amp;gt;/operator* 解引用 支持指针变量重置 保证指针持有者唯一（涉及所有权转移）  二、问题一：使用数组存储 auto_ptr std::vector&amp;lt;std::auto_ptr&amp;lt;People&amp;gt;&amp;gt; peoples; // 这里实例化多个people并保存到数组中 ... std::auto_ptr&amp;lt;People&amp;gt; one = peoples[5]; ... std::cout &amp;lt;&amp;lt; peoples[5]-&amp;gt;get_name() &amp;lt;&amp;lt; std::endl; 原因在于 std::auto_ptr 支持 operator=，为了确保指针所有者唯一，这里转移了所有权，people[5] 变成了 null
三、问题二、函数传参 auto_ptr 类型 void do_somthing(std::auto_ptr&amp;lt;People&amp;gt; people){ // 该函数内不对people变量执行各种隐式/显示的所有权转移和释放  ... } std::auto_ptr&amp;lt;People&amp;gt; people(new People(&amp;#34;jony&amp;#34;)); do_something(people); ... std::cout &amp;lt;&amp;lt; people-&amp;gt;get_name() &amp;lt;&amp;lt; std::endl; 原因在于 std::auto_ptr支持拷贝构造，为了确保指针所有者唯一，这里转移了所有权
四、unique_ptr 在11中，可以支持右值以及移动语义了，此时可以完全匹配auto_ptr的所有权管理，新增了 std::unique_ptr。std::unique_ptr 不仅加入了移动语义的支持，同时也关闭了左值拷贝构造和左值赋值功能！杜绝了上述场景的出现！但是，此时，需要使用其他的方案了。比如场景一中，std::unique_ptr类型变量不能使用vector保存了！
所以 std::auto_ptr 废弃了，由 std::unique_ptr 代替！
class Person{ public: int getAge()const{ return m_age; } void setAge(int age){ m_age = age; } private: int m_age{20}; }; unique_ptr&amp;lt;Person&amp;gt; Change(unique_ptr&amp;lt;Person&amp;gt; p){ p-&amp;gt;setAge(30); return p; } int main() { unique_ptr&amp;lt;Person&amp;gt; pP(new Person); cout &amp;lt;&amp;lt; pP-&amp;gt;getAge() &amp;lt;&amp;lt; endl; // unique_ptr&amp;lt;Person&amp;gt; pP2 = Change(pP); // error： unique_ptr 删除了拷贝构造，所以需要使用 move 关键字转移所有权  unique_ptr&amp;lt;Person&amp;gt; pP2 = Change(move(pP)); // pP = pP2; // error：unique_ptr 删除了 = 赋值构造  cout &amp;lt;&amp;lt; &amp;#34;-------------&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; pP2-&amp;gt;getAge() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;-------------&amp;#34; &amp;lt;&amp;lt; endl; if(pP == nullptr){ cout &amp;lt;&amp;lt; &amp;#34;pP 变量已失效&amp;#34; &amp;lt;&amp;lt; endl; } return 0; } 输出：</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 mutable 关键字</title>
      <link>https://874656645.github.io/posts/132-c&#43;&#43;11-mutable-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Tue, 22 Feb 2022 22:18:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/132-c&#43;&#43;11-mutable-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>一、修饰类成员变量 此关键字只能应用于类的非静态和非常量数据成员，mutable 是为了让 const 对象的某些数据成员可以被修改。static 是类的成员，不属于对象，常对象和常函数只会限制类的成员变量修改，所以类的 static 数据成员不需要 mutable 修饰，在常对象和常函数中也能被修改。
class Person{ public: int getAge() const{ m_count++; s_count++; return m_age; } int getCount()const{ return m_count; } private: int m_age{20}; mutable int m_count{0}; public: static int s_count; }; int Person::s_count = 0; int main() { Person p; p.getAge(); p.getAge(); p.getAge(); cout &amp;lt;&amp;lt; p.getCount() &amp;lt;&amp;lt; endl; // 3  cout &amp;lt;&amp;lt; p.s_count &amp;lt;&amp;lt; endl; // 3  return 0; } 二、修饰匿名函数 表示可以修改按值传入的变量的副本（不是值本身），类似于不带 const 关键字的形参。使用 mutable 关键字后对按值传入的变量进行的修改，不会将改变传递到 Lambda 表达式之外。如果不加 mutable 关键字，按值传入的变量是只读的，即使在 Lambda 表达式内部也不可修改</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 auto 与 decltype 关键字</title>
      <link>https://874656645.github.io/posts/130-c&#43;&#43;11-auto-%E4%B8%8E-decltype-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Tue, 22 Feb 2022 20:30:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/posts/130-c&#43;&#43;11-auto-%E4%B8%8E-decltype-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>一、进行自动类型推导  auto 的自动类型推断发生在编译期，所以使用 auto 并不会造成程序运行时效率的降低。 而是否会造成编译期的时间消耗，我认为是不会的，在未使用 auto 时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换。  int main() { int a = 10; auto val = a; cout &amp;lt;&amp;lt; typeid(val).name() &amp;lt;&amp;lt; endl; // i  return 0; } 二、在定义模板函数时，用于声明依赖模板参数的变量类型 不到编译的时候，x * y 的真正类型很难确定
template &amp;lt;class _Tx,class _Ty&amp;gt; void Multiply(_Tx x, _Ty y) { auto v = x * y; std::cout &amp;lt;&amp;lt; v; } int main() { int a = 10; double b = 1.53; Multiply(a, b); // 15.</description>
    </item>
    
  </channel>
</rss>
