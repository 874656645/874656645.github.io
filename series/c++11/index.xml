<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43;11 on Slow is Smooth and Smooth is Fast</title>
    <link>https://874656645.github.io/rick/series/c&#43;&#43;11/</link>
    <description>Recent content in C&#43;&#43;11 on Slow is Smooth and Smooth is Fast</description>
    <image>
      <url>https://874656645.github.io/rick/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://874656645.github.io/rick/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 22 Feb 2022 22:18:33 +0800</lastBuildDate><atom:link href="https://874656645.github.io/rick/series/c++11/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;11 auto_ptr 被废弃与 unique_ptr</title>
      <link>https://874656645.github.io/rick/posts/131-c&#43;&#43;11-auto_ptr-%E8%A2%AB%E5%BA%9F%E5%BC%83%E4%B8%8E-unique_ptr/</link>
      <pubDate>Tue, 22 Feb 2022 22:18:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/131-c&#43;&#43;11-auto_ptr-%E8%A2%AB%E5%BA%9F%E5%BC%83%E4%B8%8E-unique_ptr/</guid>
      <description>支持拷贝构造 支持赋值拷贝 支持 operator-&amp;gt;/operator* 解引用 支持指针变量重置 保证指针持有者唯一（涉及所有权转移）  一、问题一：使用数组存储 auto_ptr std::vector&amp;lt;std::auto_ptr&amp;lt;People&amp;gt;&amp;gt; peoples; // 这里实例化多个people并保存到数组中 ... std::auto_ptr&amp;lt;People&amp;gt; one = peoples[5]; ... std::cout &amp;lt;&amp;lt; peoples[5]-&amp;gt;get_name() &amp;lt;&amp;lt; std::endl; 原因在于 std::auto_ptr 支持 operator=，为了确保指针所有者唯一，这里转移了所有权，people[5] 变成了 null
二、问题二、函数传参 auto_ptr 类型 void do_somthing(std::auto_ptr&amp;lt;People&amp;gt; people){ // 该函数内不对people变量执行各种隐式/显示的所有权转移和释放  ... } std::auto_ptr&amp;lt;People&amp;gt; people(new People(&amp;#34;jony&amp;#34;)); do_something(people); ... std::cout &amp;lt;&amp;lt; people-&amp;gt;get_name() &amp;lt;&amp;lt; std::endl; 原因在于 std::auto_ptr支持拷贝构造，为了确保指针所有者唯一，这里转移了所有权
三、unique_ptr 在11中，可以支持右值以及移动语义了，此时可以完全匹配auto_ptr的所有权管理，新增了 std::unique_ptr。std::unique_ptr 不仅加入了移动语义的支持，同时也关闭了左值拷贝构造和左值赋值功能！杜绝了上述场景的出现！但是，此时，需要使用其他的方案了。比如场景一中，std::unique_ptr类型变量不能使用vector保存了！
所以 std::auto_ptr 废弃了，由 std::unique_ptr 代替！
class Person{ public: int getAge()const{ return m_age; } void setAge(int age){ m_age = age; } private: int m_age{20}; }; unique_ptr&amp;lt;Person&amp;gt; Change(unique_ptr&amp;lt;Person&amp;gt; p){ p-&amp;gt;setAge(30); return p; } int main() { unique_ptr&amp;lt;Person&amp;gt; pP(new Person); cout &amp;lt;&amp;lt; pP-&amp;gt;getAge() &amp;lt;&amp;lt; endl; // unique_ptr&amp;lt;Person&amp;gt; pP2 = Change(pP); // error： unique_ptr 删除了拷贝构造，所以需要使用 move 关键字转移所有权  unique_ptr&amp;lt;Person&amp;gt; pP2 = Change(move(pP)); // pP = pP2; // error：unique_ptr 删除了 = 赋值构造  cout &amp;lt;&amp;lt; &amp;#34;-------------&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; pP2-&amp;gt;getAge() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;-------------&amp;#34; &amp;lt;&amp;lt; endl; if(pP == nullptr){ cout &amp;lt;&amp;lt; &amp;#34;pP 变量已失效&amp;#34; &amp;lt;&amp;lt; endl; } return 0; } 输出：</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 mutable 关键字</title>
      <link>https://874656645.github.io/rick/posts/132-c&#43;&#43;11-mutable-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Tue, 22 Feb 2022 22:18:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/132-c&#43;&#43;11-mutable-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>一、修饰类成员变量 此关键字只能应用于类的非静态和非常量数据成员，mutable 是为了让 const 对象的某些数据成员可以被修改。static 是类的成员，不属于对象，常对象和常函数只会限制类的成员变量修改，所以类的 static 数据成员不需要 mutable 修饰，在常对象和常函数中也能被修改。
class Person{ public: int getAge() const{ m_count++; s_count++; return m_age; } int getCount()const{ return m_count; } private: int m_age{20}; mutable int m_count{0}; public: static int s_count; }; int Person::s_count = 0; int main() { Person p; p.getAge(); p.getAge(); p.getAge(); cout &amp;lt;&amp;lt; p.getCount() &amp;lt;&amp;lt; endl; // 3  cout &amp;lt;&amp;lt; p.s_count &amp;lt;&amp;lt; endl; // 3  return 0; } 二、修饰匿名函数 表示可以修改按值传入的变量的副本（不是值本身），类似于不带 const 关键字的形参。使用 mutable 关键字后对按值传入的变量进行的修改，不会将改变传递到 Lambda 表达式之外。如果不加 mutable 关键字，按值传入的变量是只读的，即使在 Lambda 表达式内部也不可修改</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 auto 与 decltype 关键字</title>
      <link>https://874656645.github.io/rick/posts/130-c&#43;&#43;11-auto-%E4%B8%8E-decltype-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Tue, 22 Feb 2022 20:30:33 +0800</pubDate>
      
      <guid>https://874656645.github.io/rick/posts/130-c&#43;&#43;11-auto-%E4%B8%8E-decltype-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>一、进行自动类型推导  auto 的自动类型推断发生在编译期，所以使用 auto 并不会造成程序运行时效率的降低。 而是否会造成编译期的时间消耗，我认为是不会的，在未使用 auto 时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换。  int main() { int a = 10; auto val = a; cout &amp;lt;&amp;lt; typeid(val).name() &amp;lt;&amp;lt; endl; // i  return 0; } 二、在定义模板函数时，用于声明依赖模板参数的变量类型 不到编译的时候，x * y 的真正类型很难确定
template &amp;lt;class _Tx,class _Ty&amp;gt; void Multiply(_Tx x, _Ty y) { auto v = x * y; std::cout &amp;lt;&amp;lt; v; } int main() { int a = 10; double b = 1.53; Multiply(a, b); // 15.</description>
    </item>
    
  </channel>
</rss>
