[{"content":"三层架构：业务逻辑层、抽象层、实现层\n原则：依赖倒转\n","permalink":"https://874656645.github.io/rick/posts/67-%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%BC%96%E7%A8%8B/","summary":"三层架构：业务逻辑层、抽象层、实现层\n原则：依赖倒转","title":"面向抽象类编程"},{"content":"MyString.h\n#ifndef __MYSTRING_H_ #define __MYSTRING_H_  #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; class MyString { // 重载 \u0026lt;\u0026lt;  // 最好是 const 的，可以输出匿名变量（匿名变量不能被非 const 的左值引用接收）  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const MyString \u0026amp;s); // 重载 \u0026gt;\u0026gt;  friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, MyString \u0026amp;s); private: // 字符串的有效长度  int m_len; // 字符串指针  char* m_pStr; public: MyString(); MyString(const char *); MyString(const MyString \u0026amp;); ~MyString(); // 重载 =  MyString\u0026amp; operator=(const MyString \u0026amp;); // 重载 []  char\u0026amp; operator[](int index); // 重载 +  MyString operator+(const MyString \u0026amp;); // 重载 +=  MyString\u0026amp; operator+=(const MyString \u0026amp;); // 重载 ==  bool operator==(const MyString \u0026amp;); // 重载 !=  bool operator!=(const MyString \u0026amp;); }; #endif MyString.cpp\n#include \u0026#34;MyString.h\u0026#34; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const MyString \u0026amp;s){ os \u0026lt;\u0026lt; s.m_pStr; return os; } istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, MyString \u0026amp;s){ char temp[4096] = {0}; is \u0026gt;\u0026gt; temp; if (s.m_pStr != NULL) { s.m_len = 0; free(s.m_pStr); s.m_pStr = NULL; } s.m_len = strlen(temp); s.m_pStr = (char*)malloc(s.m_len); strcpy(s.m_pStr, temp); return is; } MyString::MyString() { m_len = 0; m_pStr = NULL; // 注意 \u0026#39;\\0\u0026#39; NULL \u0026#34;\u0026#34;的区别 } MyString::MyString(const char *c) { if (c != NULL) { m_len = strlen(c); m_pStr = (char*)malloc(m_len + 1); strcpy(m_pStr, c); } cout \u0026lt;\u0026lt; \u0026#34;MyString(const char *c)...\u0026#34; \u0026lt;\u0026lt; endl; } MyString::MyString(const MyString \u0026amp;s) { if (s.m_pStr != NULL) { m_len = s.m_len; m_pStr = (char*)malloc(m_len + 1); strcpy(m_pStr, s.m_pStr); } cout \u0026lt;\u0026lt; \u0026#34;MyString(const MyString \u0026amp;s)...\u0026#34; \u0026lt;\u0026lt; endl; } MyString::~MyString() { m_len = 0; if (m_pStr != NULL) { free(m_pStr); m_pStr = NULL; } cout \u0026lt;\u0026lt; \u0026#34;~MyString()...\u0026#34; \u0026lt;\u0026lt; endl; } MyString\u0026amp; MyString::operator=(const MyString \u0026amp;s) { cout \u0026lt;\u0026lt; \u0026#34;operator=(const MyString \u0026amp;s)...\u0026#34; \u0026lt;\u0026lt; endl; // 1. 是否是给自身赋值  if (this == \u0026amp;s) { return *this; } // 2. 处理自身垃圾  if (m_pStr != NULL) { free(m_pStr); m_pStr = NULL; } // 3. 深拷贝  if (s.m_pStr != NULL) { m_len = s.m_len; m_pStr = (char*)malloc(m_len + 1); strcpy(m_pStr, s.m_pStr); } // 4. 返回自身  return *this; } char\u0026amp; MyString::operator[](int index) { if (m_len == 0) { throw \u0026#34;bad memory\u0026#34;; } if (index \u0026lt; 0 || index \u0026gt;= m_len) { throw \u0026#34;out of range\u0026#34;; } return m_pStr[index]; } MyString MyString::operator+(const MyString \u0026amp;s) { // 方式一：  /* MyString temp; temp.m_len = m_len + s.m_len; temp.m_pStr = (char*)malloc(temp.m_len + 1); // memset(temp.m_pStr, 0, temp.m_len + 1); strcpy(temp.m_pStr, m_pStr); // 注意 strcpy 和 strcat 的使用 strcat(temp.m_pStr, s.m_pStr); // 注意 strcat 的使用 return temp; */ // 方式二：  MyString temp = *this; return temp += s; } MyString\u0026amp; MyString::operator+=(const MyString \u0026amp;s) { if (s.m_len \u0026gt; 0) { // 处理自身垃圾  if (m_pStr != NULL) { char* pTemp = m_pStr; m_len += s.m_len; m_pStr = (char*)malloc(m_len + 1); strcpy(m_pStr, pTemp); strcat(m_pStr, s.m_pStr); free(pTemp); pTemp = NULL; } } return *this; } bool MyString::operator==(const MyString \u0026amp;s) { if (m_len == 0 || s.m_len == 0) { return false; } if(m_len != s.m_len) { return false; } for (int i = 0; i \u0026lt; m_len; i++) { if (m_pStr[i] != s.m_pStr[i]) { return false; } } return true; } bool MyString::operator!=(const MyString \u0026amp;s) { return !(*this == s); } test.cpp\n#include \u0026lt;iostream\u0026gt;#include \u0026#34;MyString.h\u0026#34; using namespace std; int main(){ // 隐式转换  MyString s0 = \u0026#34;123\u0026#34;; cout \u0026lt;\u0026lt; s0 \u0026lt;\u0026lt; endl; // 构造函数  MyString s1(\u0026#34;abc\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // 拷贝构造  MyString s2 = s1; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; // 拷贝构造  MyString s3(s2); cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; // = 操作符  s3 = s1; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; // [] 操作符  cout \u0026lt;\u0026lt; s3[1] \u0026lt;\u0026lt; endl; s3[1] = \u0026#39;1\u0026#39;; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; // + 操作符  cout \u0026lt;\u0026lt; s1 + s2 +s3 \u0026lt;\u0026lt; endl; // += 操作符  s3 += s1; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; // == 操作符  cout \u0026lt;\u0026lt; (s3 == s1) \u0026lt;\u0026lt; endl; // != 操作符  cout \u0026lt;\u0026lt; (s3 != s1) \u0026lt;\u0026lt; endl; return 0; } 输出：\nMyString(const char *c)... abc MyString(const MyString \u0026amp;s)... abc MyString(const MyString \u0026amp;s)... abc operator=(const MyString \u0026amp;s)... abc b a1c abcabca1c ~MyString()... ~MyString()... a1cabc 0 1 ~MyString()... ~MyString()... ~MyString()... ","permalink":"https://874656645.github.io/rick/posts/66-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/","summary":"MyString.h\n#ifndef __MYSTRING_H_ #define __MYSTRING_H_  #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; class MyString { // 重载 \u0026lt;\u0026lt;  // 最好是 const 的，可以输出匿名变量（匿名变量不能被非 const 的左值引用接收）  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const MyString \u0026amp;s); // 重载 \u0026gt;\u0026gt;  friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, MyString \u0026amp;s); private: // 字符串的有效长度  int m_len; // 字符串指针  char* m_pStr; public: MyString(); MyString(const char *); MyString(const MyString \u0026amp;); ~MyString(); // 重载 =  MyString\u0026amp; operator=(const MyString \u0026amp;); // 重载 []  char\u0026amp; operator[](int index); // 重载 +  MyString operator+(const MyString \u0026amp;); // 重载 +=  MyString\u0026amp; operator+=(const MyString \u0026amp;); // 重载 ==  bool operator==(const MyString \u0026amp;); // 重载 !","title":"实现一个简单的字符串类"},{"content":"1. 声明静态数组后一定要进行初始化，否则里面的值都是未知的 int main() { int ia[3] = {0}; // 这虽然只是给第一个元素赋了值，但剩余未赋值的元素都会初始化为0  char ca[3] = {0}; double da[3]; bool ba[3]; short sa[3]; float fa[3]; for(auto \u0026amp; i : da){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } return 0; } 输出：\n6.95128e-310 4.63759e-310 0 2. C++ 数组指针和数组类型  数组类型和数组指针（数组名）不是一种类型，只是恰好指向的地址相同而已 数组名是指针常量（int * const），代表数组中第一个元素的地址 数组类型代表整个数组  int main() { int arr[10]; cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; arr + 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;arr + 1 \u0026lt;\u0026lt; endl; return 0; } 输出：\n0x7fff7fd65c20 0x7fff7fd65c24 ---------- 0x7fff7fd65c20 0x7fff7fd65c48 定义数组类型： // 方法一：定义一个数组类型 typedef int(ARRAY_INT_10)[10]; // 方法二：定义一个数组指针（不推荐这种写法） typedef int(*ARRAY_INT_10_P)[10]; int main() { int arr[10]; // 方法一：  ARRAY_INT_10 *arr1 = \u0026amp;arr; for(int i = 0; i \u0026lt; 10; i++){ //arr2[i] = i; // 错误 cannot convert ‘int*’ to ‘int (*)[10]’  // arr 是数组指针，arr1 是数组名  (*arr1)[i] = i; // 正确，要对 arr1 降级  } for(int i = 0; i \u0026lt; 10; i++){ cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;-----\u0026#34; \u0026lt;\u0026lt; endl; // 方法二：  ARRAY_INT_10_P arr2 = \u0026amp;arr; for(int i = 0; i \u0026lt; 10; i++){ cout \u0026lt;\u0026lt; (*arr2)[i] \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;+++++\u0026#34; \u0026lt;\u0026lt; endl; // 方法三：  int(*arr3)[10] = \u0026amp;arr; for(int i = 0; i \u0026lt; 10; i++){ cout \u0026lt;\u0026lt; (*arr3)[i] \u0026lt;\u0026lt; endl; } return 0; } 错误输出：\nmain.cpp:50:26: error: cannot convert ‘int*’ to ‘int (*)[10]’ in initialization 50 | ARRAY_INT_10 *arr2 = arr; | ^~~ | | | int* 输出：\n0 1 2 3 4 5 6 7 8 9 ----- 0 1 2 3 4 5 6 7 8 9 +++++ 0 1 2 3 4 5 6 7 8 9 ","permalink":"https://874656645.github.io/rick/posts/65-%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/","summary":"1. 声明静态数组后一定要进行初始化，否则里面的值都是未知的 int main() { int ia[3] = {0}; // 这虽然只是给第一个元素赋了值，但剩余未赋值的元素都会初始化为0  char ca[3] = {0}; double da[3]; bool ba[3]; short sa[3]; float fa[3]; for(auto \u0026amp; i : da){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } return 0; } 输出：\n6.95128e-310 4.63759e-310 0 2. C++ 数组指针和数组类型  数组类型和数组指针（数组名）不是一种类型，只是恰好指向的地址相同而已 数组名是指针常量（int * const），代表数组中第一个元素的地址 数组类型代表整个数组  int main() { int arr[10]; cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; arr + 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;arr + 1 \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"静态数组初始化"},{"content":"一、安装 C++ 开发环境 Using GCC with MinGW\n 安装 MSYS2 更新 MSYS2 pacman -Syu 在开始菜单中运行 MSYS2 MSYS，更新其余的基本包 pacman -Su 安装 C++ 开发环境：  clang++ x64 gdb: pacman -S --needed base-devel mingw-w64-ucrt-x86_64-clang mingw-w64-ucrt-x86_64-gdb g++ gdb: pacman -S --needed base-devel mingw-w64-x86_64-toolchain clang++ lldb: pacman -S --needed base-devel mingw-w64-clang-x86_64-lldb\n这个库会把 clang clang++ 等库安装到 msys64/clang64/bin 目录，但是 lldb 在 Windows 上的调试效果不如 gdb clang++ x86：pacman -S --needed base-devel mingw-w64-i686-clang   添加环境变量 D:\\msys64\\ucrt64\\bin 检查是否安装成功  clang++ --version g++ --version gdb --version    pacman -Syu // 更新整个系统 pacman -Su // 更新已安装的包 pacman -Ss 关键字 // 搜索含关键字的包 pacman -S 包名 // 安装包，也可以同时安装多个包，只需以空格分隔包名即可 pacman -Rs 包名 // 删除包及其依赖 pacman -R 包名 // 删除包 二、配置 VS Code 主要是修改 task.json 和 launch.json 两个配置文件；\n新版本的 VS Code 按 F5 会自动创建这两个配置文件，稍做修改就可以了；\ntask.json 示例：\n{ \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Build\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;clang++.exe\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-fdiagnostics-color=always\u0026#34;, \u0026#34;-g\u0026#34;, // \u0026#34;${file}\u0026#34;, // 单文件  \u0026#34;${fileDirname}\\\\*.cpp\u0026#34;, // 多文件  \u0026#34;-o\u0026#34;, \u0026#34;${workspaceRoot}\\\\bin64\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;-ggdb3\u0026#34;, // 生成和调试有关的信息  \u0026#34;-Wall\u0026#34;, // 开启额外警告  \u0026#34;-static-libgcc\u0026#34;, // 静态链接  \u0026#34;-std=c++17\u0026#34;, // 使用c++17标准  \u0026#34;-finput-charset=UTF-8\u0026#34;, // 输入编译器文本编码 默认为UTF-8  \u0026#34;-D _USE_MATH_DEFINES\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;detail\u0026#34;: \u0026#34;调试器生成的任务。\u0026#34; } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } launch.json 示例：\n{ // 使用 IntelliSense 了解相关属性。  // 悬停以查看现有属性的描述。  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387  \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Debug\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}\\\\bin64\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;gdb.exe\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;为 gdb 启用整齐打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;Build\u0026#34; } ] } ","permalink":"https://874656645.github.io/rick/posts/64-vs-code-%E6%90%AD%E5%BB%BA-c++-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","summary":"一、安装 C++ 开发环境 Using GCC with MinGW\n 安装 MSYS2 更新 MSYS2 pacman -Syu 在开始菜单中运行 MSYS2 MSYS，更新其余的基本包 pacman -Su 安装 C++ 开发环境：  clang++ x64 gdb: pacman -S --needed base-devel mingw-w64-ucrt-x86_64-clang mingw-w64-ucrt-x86_64-gdb g++ gdb: pacman -S --needed base-devel mingw-w64-x86_64-toolchain clang++ lldb: pacman -S --needed base-devel mingw-w64-clang-x86_64-lldb\n这个库会把 clang clang++ 等库安装到 msys64/clang64/bin 目录，但是 lldb 在 Windows 上的调试效果不如 gdb clang++ x86：pacman -S --needed base-devel mingw-w64-i686-clang   添加环境变量 D:\\msys64\\ucrt64\\bin 检查是否安装成功  clang++ --version g++ --version gdb --version    pacman -Syu // 更新整个系统 pacman -Su // 更新已安装的包 pacman -Ss 关键字 // 搜索含关键字的包 pacman -S 包名 // 安装包，也可以同时安装多个包，只需以空格分隔包名即可 pacman -Rs 包名 // 删除包及其依赖 pacman -R 包名 // 删除包 二、配置 VS Code 主要是修改 task.","title":"VS Code 搭建 c++ gdb 开发环境"},{"content":"C/C++内存对齐详解\n内存对齐规则  对齐系数（也叫对齐模数）：gcc中默认 #pragma pack(4)，可以通过预编译命令 #pragma pack(n)，n = 1,2,4,8,16 来改变这一系数 有效对齐值：是给定值 #pragma pack(n) 和结构体中 最长数据类型长度中较小的那个。有效对齐值也叫 对齐单位    规则一：结构体第一个成员的偏移量 offset 为 0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节\n  规则二：结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节\n注意：上面两条规则都需要得到满足\n注意：成员变量首地址偏移和对齐都是与【有效对齐值】进行比较，而有效对齐值是对齐系数与结构体中最长数据类型中的较小者\n  // 64 位程序 struct { int i; char c1; char c2; }x1; struct{ char c1; int i; char c2; }x2; struct{ char c1; char c2; int i; }x3; struct { short i; char c1; char c2; }y1; struct{ char c1; short i; char c2; }y2; struct{ char c1; char c2; short i; }y3; int main() { printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x1)); // 输出8  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x2)); // 输出12  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x3)); // 输出8  cout \u0026lt;\u0026lt; \u0026#34;----------------\u0026#34; \u0026lt;\u0026lt; endl; printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y1)); // 输出4  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y2)); // 输出6  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y3)); // 输出4  return 0; } 既要考虑首地址偏移，又要是有效对齐值（对齐单位）的整数倍 y1 y2 y3结构体：\n以上测试都是在 Linux 环境下进行的，linux 下默认 #pragma pack(4)，且结构体中最长的数据类型为 2 个字节，所以有效对齐单位为 2 字节，下面根据上面所说的规则以 y2 来分析其内存布局：\n首先使用规则 1，对成员变量进行对齐：\nsizeof(c1) = 1 \u0026lt;= 2 (有效对齐位)，按照 1 字节对齐，占用第 0 单元；\nsizeof(i) = 2 \u0026lt;= 2 (有效对齐位)，相对于结构体首地址的偏移要为 2 的倍数，占用第 2，3 单元；\nsizeof(c2) = 1 \u0026lt;= 2 (有效对齐位)，相对于结构体首地址的偏移要为 1 的倍数，占用第 4 单元；\n然后使用规则 2，对结构体整体进行对齐：\ny2 中变量 i 占用内存最大占 2 字节，而有对齐系数为 4 字节，两者较小值就是 2 字节。因此整体也是按照 2 字节对齐。由规则 1 得到 y2 占 5 个字节，此处再按照规则 2 进行整体的 2 字节对齐，所以整个结构体占用 6 个字节。\n","permalink":"https://874656645.github.io/rick/posts/63-c++-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/","summary":"C/C++内存对齐详解\n内存对齐规则  对齐系数（也叫对齐模数）：gcc中默认 #pragma pack(4)，可以通过预编译命令 #pragma pack(n)，n = 1,2,4,8,16 来改变这一系数 有效对齐值：是给定值 #pragma pack(n) 和结构体中 最长数据类型长度中较小的那个。有效对齐值也叫 对齐单位    规则一：结构体第一个成员的偏移量 offset 为 0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节\n  规则二：结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节\n注意：上面两条规则都需要得到满足\n注意：成员变量首地址偏移和对齐都是与【有效对齐值】进行比较，而有效对齐值是对齐系数与结构体中最长数据类型中的较小者\n  // 64 位程序 struct { int i; char c1; char c2; }x1; struct{ char c1; int i; char c2; }x2; struct{ char c1; char c2; int i; }x3; struct { short i; char c1; char c2; }y1; struct{ char c1; short i; char c2; }y2; struct{ char c1; char c2; short i; }y3; int main() { printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x1)); // 输出8  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x2)); // 输出12  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x3)); // 输出8  cout \u0026lt;\u0026lt; \u0026#34;----------------\u0026#34; \u0026lt;\u0026lt; endl; printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y1)); // 输出4  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y2)); // 输出6  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y3)); // 输出4  return 0; } 既要考虑首地址偏移，又要是有效对齐值（对齐单位）的整数倍 y1 y2 y3结构体：","title":"C++ 内存对齐"},{"content":" 使用模板类 重载 -\u0026gt; 操作符 重载 * 操作符  template\u0026lt;typename T\u0026gt; class MyAutoPtr{ public: MyAutoPtr(T * t){ ptr = t; } ~MyAutoPtr(){ if(ptr != NULL){ delete ptr; ptr = NULL; } } T* operator-\u0026gt;(){ // 相当于 ptr-\u0026gt; , 所以返回 ptr 指针即可  return ptr; } T\u0026amp; operator*(){ // 相当于 (*ptr). ，所以返回 ptr 指向的对象引用即可  return *ptr; } private: T* ptr; }; class A{ public: A(int a){ cout \u0026lt;\u0026lt; \u0026#34;A(int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; } ~A(){ cout \u0026lt;\u0026lt; \u0026#34;~A()...\u0026#34; \u0026lt;\u0026lt; endl; } void printA(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } private: int a; }; int main( ) { MyAutoPtr\u0026lt;A\u0026gt; p(new A(10)); p-\u0026gt;printA(); // ptr-\u0026gt;printA()  (*p).printA(); // (*ptr).printA()  MyAutoPtr\u0026lt;int\u0026gt; ip(new int(100)); cout \u0026lt;\u0026lt; *ip \u0026lt;\u0026lt; endl; return 0; } 输出：\nA(int)... a = 10 a = 10 100 ~A()... ","permalink":"https://874656645.github.io/rick/posts/62-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","summary":"使用模板类 重载 -\u0026gt; 操作符 重载 * 操作符  template\u0026lt;typename T\u0026gt; class MyAutoPtr{ public: MyAutoPtr(T * t){ ptr = t; } ~MyAutoPtr(){ if(ptr != NULL){ delete ptr; ptr = NULL; } } T* operator-\u0026gt;(){ // 相当于 ptr-\u0026gt; , 所以返回 ptr 指针即可  return ptr; } T\u0026amp; operator*(){ // 相当于 (*ptr). ，所以返回 ptr 指向的对象引用即可  return *ptr; } private: T* ptr; }; class A{ public: A(int a){ cout \u0026lt;\u0026lt; \u0026#34;A(int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; } ~A(){ cout \u0026lt;\u0026lt; \u0026#34;~A().","title":"自定义智能指针"},{"content":"一、进程与线程  进程是资源分配和调度的一个独立单位；而线程是进程的一个实体，是 CPU 调度和分配的基本单位 同一个进程中的多个线程的内存资源是共享的，各线程都可以改变进程中的变量。因此在执行多线程运算的时候要注意执行顺序  二、并行与并发  并行（parallellism）指的是多个任务在同一时刻同时在执行 并发（concurrency）是指在一个时间段内，多个任务交替进行。虽然看起来像在同时执行，但其实是交替的  三、多任务处理 多线程是多任务处理的一种特殊形式，一般情况下，有基于进程和基于线程的两种类型的多任务处理方式。\n 基于进程的多任务处理是程序的并发执行 基于线程的多任务处理是同一程序的片段的并发执行  四、C++11 线程管理 thread 库  C++11 提供了多线程库，使用时需要 #include \u0026lt;thread\u0026gt; 头文件，该头文件主要包含了对线程的管理类 std::thread 以及其他管理线程相关的类 每个应用程序至少有一个进程，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个子线程。每个线程都需要一个入口函数，入口函数返回退出，该线程也会退出，主线程就是以 main 函数作为入口函数的线程 主线程退出后，运行中的子线程也会被销毁 std::thread 的构造函数需要的是可调用（callable）类型，除了函数外，还可以调用 lambda 表达式、重载了 () 运算符的类的实例 把函数对象传入 std::thread 时，应传入函数名称（不带括号） 当启动一个线程后，一定要在该线程 thread 销毁前，调用 join() 或者 detach()，确定以何种方式等待线程执行结束  detach 方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束 join 方式，等待关联的线程完成，才会继续执行 join() 后的代码 在以 detach 的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用按值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束    1、调用全局函数启动线程 #include \u0026lt;thread\u0026gt; using namespace std; void func(int i){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } int main() { for(int i = 0; i \u0026lt; 4; ++i){ // 创建一个线程t，第一个参数为调用的函数，第二个参数为传递的参数  thread t(func, i); // 表示允许该线程在后台运行  t.detach(); } return 0; } 输出：\nStart 10 2 3 0 Finish 2、调用类成员函数启动线程 class Test{ public: explicit Test(int a){ this-\u0026gt;a = a; } void fuc1(int n){ cout \u0026lt;\u0026lt; \u0026#34;fuc1() n = \u0026#34; \u0026lt;\u0026lt; n * a \u0026lt;\u0026lt; endl; } static void fuc2(int n){ cout \u0026lt;\u0026lt; \u0026#34;static fuc2() n = \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } private: int a; }; int main() { Test t(5); thread t1(\u0026amp;Test::fuc1, \u0026amp;t, 10); t1.join(); thread t2(\u0026amp;Test::fuc2, 100); t2.join(); return 0; } 输出：\nStart fuc1() n = 50 static fuc2() n = 100 0 Finish 3、转移线程的所有权 thread 是可移动的 (movable) 的，但不可复制的 (copyable)。可以通过 move 来改变线程的所有权，灵活的决定线程在什么时候 join 或者 detach\nthread t1(f1); thread t3(move(t1)); 将线程从 t1 转移给 t3，这时候 t1 就不再拥有线程的所有权，调用 t1.join 或 t1.detach 会出现异常，要使用 t3 来管理线程。这也就意味着 thread 可以作为函数的返回类型，或者作为参数传递给函数，能够更为方便的管理线程\n4、线程标识的获取 线程的标识类型为 std:🧵:id，有两种方式获得到线程的 id：\n 通过 thread 的实例调用 get_id() 直接获取 在当前线程上调用 this_thread::get_id() 获取  5、线程暂停 如果让线程从外部暂停会引发很多并发问题，这也是为什么std::thread没有直接提供pause函数的原因。如果线程在运行过程中，确实需要停顿，就可以用 this_thread::sleep_for\nclass Test{ public: explicit Test(int a){ this-\u0026gt;a = a; } void fuc1(int n){ this_thread::sleep_for(chrono::seconds(3)); cout \u0026lt;\u0026lt; \u0026#34;fuc1() n = \u0026#34; \u0026lt;\u0026lt; n * a \u0026lt;\u0026lt; endl; } static void fuc2(int n){ cout \u0026lt;\u0026lt; \u0026#34;static fuc2() n = \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } private: int a; }; int main() { Test t(5); thread t1(\u0026amp;Test::fuc1, \u0026amp;t, 10); cout \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; endl; t1.join(); //t1.detach(); // 主线程销后，t1 这个等待线程也会被销毁（没有执行fuc1函数的输出）  thread t2(\u0026amp;Test::fuc2, 100); cout \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; endl; t2.join(); cout \u0026lt;\u0026lt; \u0026#34;main thread id: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 140270821496576 140270813103872 static fuc2() n = 100 main thread id: 140270844794624 0 Finish 6、异常情况下等待线程完成 为了避免主线程出现异常时将子线程终结，就要保证子线程在函数退出前完成，即在函数退出前调用 join()\n 方法一：异常捕获  void func() { thread t([]{ cout \u0026lt;\u0026lt; \u0026#34;hello C++ 11\u0026#34; \u0026lt;\u0026lt; endl; }); try { do_something_else(); } catch (...) { t.join(); throw; } t.join(); }  方法二：资源获取即初始化（RAII）  无论是何种情况，当函数退出时，对象 guard 调用其析构函数销毁，从而能够保证 join 一定会被调用\nclass thread_guard { private: thread \u0026amp;t; public: /*加入explicit防止隐式转换*/ explicit thread_guard(thread\u0026amp; _t) { t = _t; } thread_guard(const thread_guard\u0026amp;) = delete; //删除默认拷贝构造函数  thread_guard\u0026amp; operator=(const thread_guard\u0026amp;) = delete; //删除默认赋值运算符  ~thread_guard() { if (t.joinable()) t.join(); } }; void func(){ thread t([]{ cout \u0026lt;\u0026lt; \u0026#34;Hello thread\u0026#34; \u0026lt;\u0026lt;endl ; }); thread_guard guard(t); } ","permalink":"https://874656645.github.io/rick/posts/61-c++-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","summary":"一、进程与线程  进程是资源分配和调度的一个独立单位；而线程是进程的一个实体，是 CPU 调度和分配的基本单位 同一个进程中的多个线程的内存资源是共享的，各线程都可以改变进程中的变量。因此在执行多线程运算的时候要注意执行顺序  二、并行与并发  并行（parallellism）指的是多个任务在同一时刻同时在执行 并发（concurrency）是指在一个时间段内，多个任务交替进行。虽然看起来像在同时执行，但其实是交替的  三、多任务处理 多线程是多任务处理的一种特殊形式，一般情况下，有基于进程和基于线程的两种类型的多任务处理方式。\n 基于进程的多任务处理是程序的并发执行 基于线程的多任务处理是同一程序的片段的并发执行  四、C++11 线程管理 thread 库  C++11 提供了多线程库，使用时需要 #include \u0026lt;thread\u0026gt; 头文件，该头文件主要包含了对线程的管理类 std::thread 以及其他管理线程相关的类 每个应用程序至少有一个进程，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个子线程。每个线程都需要一个入口函数，入口函数返回退出，该线程也会退出，主线程就是以 main 函数作为入口函数的线程 主线程退出后，运行中的子线程也会被销毁 std::thread 的构造函数需要的是可调用（callable）类型，除了函数外，还可以调用 lambda 表达式、重载了 () 运算符的类的实例 把函数对象传入 std::thread 时，应传入函数名称（不带括号） 当启动一个线程后，一定要在该线程 thread 销毁前，调用 join() 或者 detach()，确定以何种方式等待线程执行结束  detach 方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束 join 方式，等待关联的线程完成，才会继续执行 join() 后的代码 在以 detach 的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用按值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束    1、调用全局函数启动线程 #include \u0026lt;thread\u0026gt; using namespace std; void func(int i){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } int main() { for(int i = 0; i \u0026lt; 4; ++i){ // 创建一个线程t，第一个参数为调用的函数，第二个参数为传递的参数  thread t(func, i); // 表示允许该线程在后台运行  t.","title":"C++ 多线程"},{"content":"error: cannot bind non-const lvalue reference of type ‘T\u0026amp;’ to an rvalue of type ‘T’\n如果一个参数是以非 const 引用传入，c++ 编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。\n但如果你 把一个临时变量当作非 const 引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉。\n所以，修改一个临时变量是毫无意义的。据此，c++ 编译器加入了临时变量不能作为非 const 引用的这个语义限制。\nc++ 中临时变量是右值类型，不能作为非 const 的引用参数\nstd::move() 返回的也是一个右值\n一般来说，右值的地址不能通过解引用来获得，因为它们是字面量，或者因为它们本质上是临时的(例如由函数或显式构造函数调用返回的值)。通过将一个对象传递给这个函数，可以获得一个引用它的右值。\nclass T{ public: T(int v){ a = v; } T operator+(T \u0026amp;t){ T temp = this-\u0026gt;a + t.a; return temp; } void printT(T \u0026amp;t){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; t.a \u0026lt;\u0026lt; endl; } private: int a; }; int main() { T t0(0), t1(1), t2(2); t0.printT(t1 + t2); // t1 + t2 返回临时变量 右值  return 0; } 输出：\nmain.cpp:29:18: error: cannot bind non-const lvalue reference of type ‘T\u0026amp;’ to an rvalue of type ‘T’ 29 | t0.printT(t1 + t2); | ~~~^~~~ main.cpp:20:20: note: initializing argument 1 of ‘void T::printT(T\u0026amp;)’ 20 | void printT(T \u0026amp;t){ | ~~~^ ","permalink":"https://874656645.github.io/rick/posts/60-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BAno-const%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0/","summary":"error: cannot bind non-const lvalue reference of type ‘T\u0026amp;’ to an rvalue of type ‘T’\n如果一个参数是以非 const 引用传入，c++ 编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。\n但如果你 把一个临时变量当作非 const 引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉。\n所以，修改一个临时变量是毫无意义的。据此，c++ 编译器加入了临时变量不能作为非 const 引用的这个语义限制。\nc++ 中临时变量是右值类型，不能作为非 const 的引用参数\nstd::move() 返回的也是一个右值\n一般来说，右值的地址不能通过解引用来获得，因为它们是字面量，或者因为它们本质上是临时的(例如由函数或显式构造函数调用返回的值)。通过将一个对象传递给这个函数，可以获得一个引用它的右值。\nclass T{ public: T(int v){ a = v; } T operator+(T \u0026amp;t){ T temp = this-\u0026gt;a + t.a; return temp; } void printT(T \u0026amp;t){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; t.a \u0026lt;\u0026lt; endl; } private: int a; }; int main() { T t0(0), t1(1), t2(2); t0.","title":"临时变量不能绑定 no-const 左值引用类型"},{"content":"#include \u0026lt;iostream\u0026gt; using namespace std; class Complex{ // friend Complex complexAdd(Complex \u0026amp;c1, Complex \u0026amp;c2);  // friend Complex operator+(Complex \u0026amp;c1, Complex \u0026amp;c2);  // friend Complex\u0026amp; operator+= (Complex \u0026amp;c1, Complex \u0026amp;c2);  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Complex \u0026amp;c); friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, Complex \u0026amp;c); public: Complex(){ cout \u0026lt;\u0026lt; \u0026#34;Complex()...\u0026#34; \u0026lt;\u0026lt; endl; a = 0; b = 0; } Complex(int a, int b){ cout \u0026lt;\u0026lt; \u0026#34;Complex(int, int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; this-\u0026gt;b = b; } ~Complex(){ cout \u0026lt;\u0026lt; \u0026#34;~Complex()...\u0026#34; \u0026lt;\u0026lt; endl; } void printComplex(){ cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;b \u0026lt;\u0026lt; \u0026#34;i)\u0026#34; \u0026lt;\u0026lt; endl; } // 方式二：在类内部实现（方式一和二是一样的，所以只能保留一种）  // c1 + c2 的写法会同时匹配这两种实现方式，如果都有实现就会产生二义性  // 不能返回引用类型  // + 操作符重载  Complex operator+(Complex \u0026amp;c2){ Complex temp(this-\u0026gt;a + c2.a, this-\u0026gt;b + c2.b); return temp; } // += 操作符重载  Complex\u0026amp; operator+=(Complex \u0026amp;c2){ cout \u0026lt;\u0026lt; \u0026#34;operator+=()...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a += c2.a; this-\u0026gt;b += c2.b; return *this; } // 单目运算符 前++，因为可以进行连续前++操作，所以返回引用类型  Complex\u0026amp; operator++(){ this-\u0026gt;a++; this-\u0026gt;b++; return *this; } // 单目运算符 后++，不能进行连续 后++ 操作，返回类型加const  // 为了与 前++ 进行区分，使用亚元形参  const Complex operator++(int){ Complex temp(this-\u0026gt;a, this-\u0026gt;b); this-\u0026gt;a++; this-\u0026gt;b++; return temp; } // = 操作符重载  Complex\u0026amp; operator=(Complex \u0026amp;c){ // 1、是否与自身相同  if(this == \u0026amp;c) return *this; // 2、如果自身有开辟内存，就清理自己的垃圾  // 3、深拷贝  this-\u0026gt;a = c.a; this-\u0026gt;b = c.b; return *this; } // [] 操作符重载  int\u0026amp; operator[](int index){ if(index == 1){ return this-\u0026gt;a; } if(index == 2){ return this-\u0026gt;b; } throw \u0026#34;error index\u0026#34;; } // == 操作符重载  bool operator==(Complex \u0026amp;c){ return (this-\u0026gt;a == c.a \u0026amp;\u0026amp; this-\u0026gt;b == c.b); } // != 操作符重载  bool operator!=(Complex \u0026amp;c){ return !(*this == c); } // () 操作符重载，仿函数  bool operator()(){ return (this-\u0026gt;a != 0 \u0026amp;\u0026amp; this-\u0026gt;b != 0); } // new 操作符重载，会传入所创对象的大小（sizeof(Complex)）  // 返回的是 void* 的指针  // p-\u0026gt;operator new(sizeof(Complex))  void* operator new(size_t n){ void* p = malloc(n); cout \u0026lt;\u0026lt; \u0026#34;重载了 new... 空间大小是：\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\t指针地址是：\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return p; } // new[] 操作符重载，这个 n 多了一个指针的大小，不知道为什么？  void* operator new[](size_t n){ void* p = malloc(n); cout \u0026lt;\u0026lt; \u0026#34;重载了 new[]... 空间大小是：\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\t指针地址是：\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return p; } // delete 操作符重载，会传入所要删除的指针，类型是 void*  void operator delete(void *p){ cout \u0026lt;\u0026lt; \u0026#34;重载了 delete... 指针地址是：\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; if(p != NULL){ free(p); p = NULL; } } // delete[] 操作符重载，会传入所要删除的指针，类型是 void*  void operator delete(void *p){ cout \u0026lt;\u0026lt; \u0026#34;重载了 delete[]... 指针地址是：\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; if(p != NULL){ free(p); p = NULL; } } // \u0026amp;\u0026amp; 操作符重载（不建议重载，因为不会发生短路现象）  bool operator\u0026amp;\u0026amp;(Complex \u0026amp;c){ return ((*this)()) \u0026amp;\u0026amp; c(); } // || 操作符重载（不建议重载，因为不会发生短路现象）  bool operator||(Complex \u0026amp;c){ return (*this)() || c(); } private: int a; // 实部  int b; // 虚部 }; #if 0Complex complexAdd(Complex \u0026amp;c1, Complex \u0026amp;c2){ Complex temp(c1.a + c2.a, c1.b + c2.b); return temp; } // 方式一：用全局函数重载(友元重载) Complex operator+(Complex \u0026amp;c1, Complex \u0026amp;c2){ Complex temp(c1.a + c2.a, c1.b + c2.b); return temp; } Complex\u0026amp; operator+= (Complex \u0026amp;c1, Complex \u0026amp;c2){ c1.a += c2.a; c1.b += c2.b; return c1; } #endif // 左移 // 只能用全局函数实现重载，如果在类内部实现，调用形式就成了 c.operator\u0026lt;\u0026lt;(cout) // 因为可以连续调用，所以返回 ostream 对象引用 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Complex \u0026amp;c){ os \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; c.a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; c.b \u0026lt;\u0026lt; \u0026#34;i)\u0026#34; \u0026lt;\u0026lt; endl; return os; } // 右移同理 istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, Complex \u0026amp;c){ cout \u0026lt;\u0026lt; \u0026#34;a: \u0026#34;; is \u0026gt;\u0026gt; c.a; cout \u0026lt;\u0026lt; \u0026#34;b: \u0026#34;; is \u0026gt;\u0026gt; c.b; return is; } int main( ) { Complex c1(1, 2), c2(3, 4); c1.printComplex(); c2.printComplex(); // Complex c3 = complexAdd(c1, c2);  Complex c3 = c1 + c2 + c1; // 方式一等同于 operator+(c1, c2);  // 方式二等同于 c1.operator+(c2);  c3.printComplex(); cin \u0026gt;\u0026gt; c1; // operator\u0026gt;\u0026gt;(cin, c1)  cout \u0026lt;\u0026lt; c1 \u0026lt;\u0026lt; endl; // operator\u0026lt;\u0026lt;(cout, c1)  cout \u0026lt;\u0026lt; c1[1] \u0026lt;\u0026lt; endl; c1[1] = 5; cout \u0026lt;\u0026lt; c1; try{ c1[0] = 0; } catch(char const *e){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; } if(c1()){ cout \u0026lt;\u0026lt; \u0026#34;c1 is valid\u0026#34; \u0026lt;\u0026lt; endl; } else{ cout \u0026lt;\u0026lt; \u0026#34;c1 is not valid\u0026#34; \u0026lt;\u0026lt; endl; } // 测试数组  cout \u0026lt;\u0026lt; \u0026#34;静态数组大小是：\u0026#34; \u0026lt;\u0026lt; sizeof(Complex[2]) \u0026lt;\u0026lt; endl; Complex *cArray = new Complex[2]; // 这里的地址比 delete[] 的地址高了一个字节，不知道为什么？  cout \u0026lt;\u0026lt; \u0026#34;首地址是：\u0026#34; \u0026lt;\u0026lt; (cArray - sizeof(char)) \u0026lt;\u0026lt; endl; delete[] cArray; // 测试 \u0026amp;\u0026amp; || 是否发生短路  c1[1] = c1[2] = 0; if(c1 \u0026amp;\u0026amp; (c1 += c2)){ // c1.operator\u0026amp;\u0026amp;(c1 += c2)  cout \u0026lt;\u0026lt; \u0026#34;真\u0026#34; \u0026lt;\u0026lt; endl; } else{ cout \u0026lt;\u0026lt; \u0026#34;假\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;============\u0026#34; \u0026lt;\u0026lt; endl; c1[1] = -3; c2[2] = -4; if(c1 || (c1 += c2)){ // c1.operator||(c1 += c2)  cout \u0026lt;\u0026lt; \u0026#34;真\u0026#34; \u0026lt;\u0026lt; endl; } else{ cout \u0026lt;\u0026lt; \u0026#34;假\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输出：\n(1, 2i) (3, 4i) (5, 8i) a: 10 b: 20 (10, 20i) 1 (5, 2i) error index c1 is valid 重载了 new... 空间大小是：8 Complex(int, int)... 对象 c1 的地址是：0x5641c235a2c0 ~Complex()... 重载了 delete... 指针地址是：0x5641c235a2c0 静态数组大小是：16 重载了 new[]... 空间大小是：24 指针地址是：0x5640c52efeb0 Complex()... Complex()... 首地址是：0x5640c52efeb8 ~Complex()... ~Complex()... 重载了 delete[]... 指针地址是：0x5640c52efeb0 operator+=()... 真 ============ operator+=()... 假 ","permalink":"https://874656645.github.io/rick/posts/59-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/","summary":"#include \u0026lt;iostream\u0026gt; using namespace std; class Complex{ // friend Complex complexAdd(Complex \u0026amp;c1, Complex \u0026amp;c2);  // friend Complex operator+(Complex \u0026amp;c1, Complex \u0026amp;c2);  // friend Complex\u0026amp; operator+= (Complex \u0026amp;c1, Complex \u0026amp;c2);  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Complex \u0026amp;c); friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, Complex \u0026amp;c); public: Complex(){ cout \u0026lt;\u0026lt; \u0026#34;Complex()...\u0026#34; \u0026lt;\u0026lt; endl; a = 0; b = 0; } Complex(int a, int b){ cout \u0026lt;\u0026lt; \u0026#34;Complex(int, int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; this-\u0026gt;b = b; } ~Complex(){ cout \u0026lt;\u0026lt; \u0026#34;~Complex().","title":"操作符重载"},{"content":"买卖货物问题：\n#include \u0026lt;iostream\u0026gt; using namespace std; class Goods{ public: Goods(){ m_pNext = nullptr; m_weight = 0; cout \u0026lt;\u0026lt; \u0026#34;买入了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } Goods(int weight){ m_pNext = nullptr; m_weight = weight; total_weight += m_weight; cout \u0026lt;\u0026lt; \u0026#34;买入了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } ~Goods(){ total_weight -= m_weight; // m_pNext 不是在本类中 new 的，所以也不用 delete  this-\u0026gt;m_pNext = nullptr; cout \u0026lt;\u0026lt; \u0026#34;卖出了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } static int getTotalWeight(){ return total_weight; } Goods *m_pNext; private: int m_weight; static int total_weight; }; int Goods::total_weight = 0; void buy(Goods *\u0026amp;head, int weight){ Goods *pNewGoods = new Goods(weight); if(head == nullptr){ head = pNewGoods; } else{ pNewGoods-\u0026gt;m_pNext = head; head = pNewGoods; } } void sale(Goods *\u0026amp;head){ if(head == nullptr){ cout \u0026lt;\u0026lt; \u0026#34;没有货物了\u0026#34; \u0026lt;\u0026lt; endl; return; } Goods *temp = head; head = head-\u0026gt;m_pNext; delete temp; temp = nullptr; } int main( ) { Goods *head = nullptr; int choice; do{ // 提供菜单  cout \u0026lt;\u0026lt; \u0026#34;输入 1 进货\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 2 出货\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 0 退出\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; choice; switch(choice){ case 0: // 退出  return 0; case 1: { // 进货  int w = 0; cout \u0026lt;\u0026lt; \u0026#34;输入货物重量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; w; buy(head, w); break; } case 2: // 出货  sale(head); break; } cout \u0026lt;\u0026lt; \u0026#34;目前货物的总重量是：\u0026#34; \u0026lt;\u0026lt; Goods::getTotalWeight() \u0026lt;\u0026lt; endl; }while(1); return 0; } 输出：\n输入 1 进货 输入 2 出货 输入 0 退出 1 输入货物重量： 10 买入了货物，重量是：10 目前货物的总重量是：10 输入 1 进货 输入 2 出货 输入 0 退出 1 输入货物重量： 20 买入了货物，重量是：20 目前货物的总重量是：30 输入 1 进货 输入 2 出货 输入 0 退出 1 输入货物重量： 30 买入了货物，重量是：30 目前货物的总重量是：60 输入 1 进货 输入 2 出货 输入 0 退出 2 卖出了货物，重量是：30 目前货物的总重量是：30 输入 1 进货 输入 2 出货 输入 0 退出 2 卖出了货物，重量是：20 目前货物的总重量是：10 输入 1 进货 输入 2 出货 输入 0 退出 2 卖出了货物，重量是：10 目前货物的总重量是：0 输入 1 进货 输入 2 出货 输入 0 退出 2 没有货物了 目前货物的总重量是：0 输入 1 进货 输入 2 出货 输入 0 退出 0 ","permalink":"https://874656645.github.io/rick/posts/58-%E5%85%B7%E6%9C%89%E9%93%BE%E8%A1%A8%E7%89%B9%E6%80%A7%E7%9A%84%E7%B1%BB/","summary":"买卖货物问题：\n#include \u0026lt;iostream\u0026gt; using namespace std; class Goods{ public: Goods(){ m_pNext = nullptr; m_weight = 0; cout \u0026lt;\u0026lt; \u0026#34;买入了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } Goods(int weight){ m_pNext = nullptr; m_weight = weight; total_weight += m_weight; cout \u0026lt;\u0026lt; \u0026#34;买入了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } ~Goods(){ total_weight -= m_weight; // m_pNext 不是在本类中 new 的，所以也不用 delete  this-\u0026gt;m_pNext = nullptr; cout \u0026lt;\u0026lt; \u0026#34;卖出了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } static int getTotalWeight(){ return total_weight; } Goods *m_pNext; private: int m_weight; static int total_weight; }; int Goods::total_weight = 0; void buy(Goods *\u0026amp;head, int weight){ Goods *pNewGoods = new Goods(weight); if(head == nullptr){ head = pNewGoods; } else{ pNewGoods-\u0026gt;m_pNext = head; head = pNewGoods; } } void sale(Goods *\u0026amp;head){ if(head == nullptr){ cout \u0026lt;\u0026lt; \u0026#34;没有货物了\u0026#34; \u0026lt;\u0026lt; endl; return; } Goods *temp = head; head = head-\u0026gt;m_pNext; delete temp; temp = nullptr; } int main( ) { Goods *head = nullptr; int choice; do{ // 提供菜单  cout \u0026lt;\u0026lt; \u0026#34;输入 1 进货\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 2 出货\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 0 退出\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; choice; switch(choice){ case 0: // 退出  return 0; case 1: { // 进货  int w = 0; cout \u0026lt;\u0026lt; \u0026#34;输入货物重量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; w; buy(head, w); break; } case 2: // 出货  sale(head); break; } cout \u0026lt;\u0026lt; \u0026#34;目前货物的总重量是：\u0026#34; \u0026lt;\u0026lt; Goods::getTotalWeight() \u0026lt;\u0026lt; endl; }while(1); return 0; } 输出：","title":"具有链表特性的类"},{"content":"一、try、catch、throw 可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型\nint main( ) { try{ throw \u0026#34;exception\u0026#34;; }catch(const char * e){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; }catch(...){ // 捕获所有异常  cout \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; } { cout \u0026lt;\u0026lt; \u0026#34;finally\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输出：\nStart exception finally 0 Finish 二、std::exception class exception { public: exception() throw(); exception(const exception\u0026amp; rhs) throw(); exception\u0026amp; operator=(const exception\u0026amp; rhs) throw(); virtual ~exception() throw(); virtual const char *what() const throw(); }; 派生了两个异常类：\n   类名 描述     logic_erro 报告程序的逻辑错误，可在程序执行前被检测到   runtime_erro 报告程序运行时的错误，只有在运行的时候才能检测到    由logic_erro派生的异常类：\n   类名 描述     domain_error 报告违反了前置条件   invalid_argument 指出函数的一个无效参数   length_error 指出有一个产生超过NPOS长度的对象的企图（NPOS为size_t的最大可表现值   out_of_range 报告参数越界   bad_cast 在运行时类型识别中有一个无效的dynamic_cast表达式   bad_typeid 报告在表达式typeid(*p)中有一个空指针P    由runtime_error派生的异常：\n   类名 描述     range_error 报告违反了后置条件   overflow_error 报告一个算术溢出   bad_alloc 报告一个存储分配错误    三、自定义异常 可以通过继承和重载 exception 类来定义新的异常\nstruct MyException : public exception { const char * what () const throw () // 表明没有任何异常抛出  { return \u0026#34;C++ Exception\u0026#34;; } }; int main() { try { throw MyException(); } catch(MyException\u0026amp; e) { cout \u0026lt;\u0026lt; \u0026#34;MyException caught\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } catch(std::exception\u0026amp; e) { //其他的错误  } catch(...) { cout \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; } { cout \u0026lt;\u0026lt; \u0026#34;finally\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } Start MyException caught C++ Exception finally 0 Finish ","permalink":"https://874656645.github.io/rick/posts/57-%E5%BC%82%E5%B8%B8/","summary":"一、try、catch、throw 可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型\nint main( ) { try{ throw \u0026#34;exception\u0026#34;; }catch(const char * e){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; }catch(...){ // 捕获所有异常  cout \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; } { cout \u0026lt;\u0026lt; \u0026#34;finally\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输出：\nStart exception finally 0 Finish 二、std::exception class exception { public: exception() throw(); exception(const exception\u0026amp; rhs) throw(); exception\u0026amp; operator=(const exception\u0026amp; rhs) throw(); virtual ~exception() throw(); virtual const char *what() const throw(); }; 派生了两个异常类：","title":"异常"},{"content":"1、六大组件介绍  容器：数据结构，用来存放数据 算法：常用算法 迭代器：容器和算法之间的胶合剂，“范型指针” 仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数 配置器：为容器分配并管理内存 适配器：修改其他组件接口  2、STL 常用的容器有哪些以及各自的特点是什么?    名称 特点     vector 底层数据结构为数组，支持快速随机访问   list 底层数据结构为双向链表，支持快速增删   deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问   stack 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   queue 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   priority_queue 底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现   set 底层数据结构为红黑树，有序，不重复   multiset 底层数据结构为红黑树，有序，可重复   map 底层数据结构为红黑树，有序，不重复   multimap 底层数据结构为红黑树，有序，可重复   unordered_set 底层数据结构为hash表，无序，不重复   unordered_multiset 底层数据结构为hash表，无序，可重复   unordered_map 底层数据结构为hash表，无序，不重复   unordered_multimap 底层数据结构为hash表，无序，可重复    3、vector 和 list 的区别  vector底层实现是数组，所以在内存中是连续存放的，随机读取效率高，但插入、删除效率低；list底层实现是双向链表，所以在内存中是任意存放的，插入、删除效率高，但访问元素效率低 vector在中间节点进行插入、删除会导致内存拷贝，而list不会 vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请  4、vector 扩容原理 以原内存空间大小的两倍配置一份新的内存空间，并将原空间数据拷贝过来进行初始化\n5、map 和 set 有什么区别  map中的元素是键值对；Set仅是关键字的简单集合 set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key map支持用关键字作下标操作，set不支持下标操作  6、map 和 unordered_map 的区别  map内部实现了一个红黑树，红黑树的每一个节点都代表着map的一个元素，因此所有元素都是有序的，对其进行查找、插入、删除得效率都是O(log n)；但是，因为每个结点都需要额外保存数据，所以空间占用率比较高 unordered_map内部实现了一个哈希表，因此内部元素是无序的，对其进行查找、插入、删除得效率都是O(1)；但是建立哈希表比较费时  7、STL 中迭代器的作用，有指针为何还要迭代器  Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-\u0026gt;、*、++、\u0026ndash;等，相当于一种智能指针 迭代器产生原因：Iterator采用的是面向对象的思想，把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果  ","permalink":"https://874656645.github.io/rick/posts/56-stl-%E6%80%BB%E7%BB%93/","summary":"1、六大组件介绍  容器：数据结构，用来存放数据 算法：常用算法 迭代器：容器和算法之间的胶合剂，“范型指针” 仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数 配置器：为容器分配并管理内存 适配器：修改其他组件接口  2、STL 常用的容器有哪些以及各自的特点是什么?    名称 特点     vector 底层数据结构为数组，支持快速随机访问   list 底层数据结构为双向链表，支持快速增删   deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问   stack 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   queue 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   priority_queue 底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现   set 底层数据结构为红黑树，有序，不重复   multiset 底层数据结构为红黑树，有序，可重复   map 底层数据结构为红黑树，有序，不重复   multimap 底层数据结构为红黑树，有序，可重复   unordered_set 底层数据结构为hash表，无序，不重复   unordered_multiset 底层数据结构为hash表，无序，可重复   unordered_map 底层数据结构为hash表，无序，不重复   unordered_multimap 底层数据结构为hash表，无序，可重复    3、vector 和 list 的区别  vector底层实现是数组，所以在内存中是连续存放的，随机读取效率高，但插入、删除效率低；list底层实现是双向链表，所以在内存中是任意存放的，插入、删除效率高，但访问元素效率低 vector在中间节点进行插入、删除会导致内存拷贝，而list不会 vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请  4、vector 扩容原理 以原内存空间大小的两倍配置一份新的内存空间，并将原空间数据拷贝过来进行初始化","title":"STL 总结"},{"content":"vector 常用操作 #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; int main() { //1.定义和初始化  vector\u0026lt;int\u0026gt; vec1; //默认初始化，vec1为空  vector\u0026lt;int\u0026gt; vec2(vec1); //使用vec1初始化vec2  vector\u0026lt;int\u0026gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2  vector\u0026lt;int\u0026gt; vec4(10); //10个值为0的元素  vector\u0026lt;int\u0026gt; vec5(10,4); //10个值为4的元素  //2.常用操作方法  //2.1 添加函数  vec1.push_back(100); //尾部添加元素  vec1.insert(vec1.end(),5,3); //从vec1.back位置插入5个值为3的元素  //2.2 删除函数  vec1.pop_back(); //删除末尾元素  vec1.erase(vec1.begin(),vec1.begin()+2); //删除vec1[0]-vec1[2]之间的元素，不包括vec1[2]其他元素前移  vec1.clear(); //清空元素，元素在内存中并未消失，通常使用swap()来清空  vector\u0026lt;int\u0026gt;().swap(V); //利用swap函数和临时对象交换内存，交换以后，临时对象消失，释放内存。  // 必须是同类型的 vector  //2.3 遍历函数  vec1[0]; //取得第一个元素  vec1.at(int pos); //返回pos位置元素的引用  vec1.front(); //返回首元素的引用  vec1.back(); //返回尾元素的引用  vector\u0026lt;int\u0026gt;::iterator begin= vec1.begin(); //返回向量头指针，指向第一个元素  vector\u0026lt;int\u0026gt;::iterator end= vec1.end(); //返回向量尾指针，指向向量最后一个元素的下一个位置  vector\u0026lt;int\u0026gt;::iterator rbegin= vec1.rbegin(); //反向迭代器，指向最后一个元素  vector\u0026lt;int\u0026gt;::iterator rend= vec1.rend(); //反向迭代器，指向第一个元素之前的位置  //2.4 判断函数  bool isEmpty = vec1.empty(); //判断是否为空  //2.5 大小函数  int size = vec1.size(); //元素个数  vec1.capacity(); //返回容器当前能够容纳的元素个数  vec1.max_size(); //返回容器最大的可能存储的元素个数  //2.6 改动函数  vec1.assign(int n,const T\u0026amp; x); //赋n个值为x的元素到vec1中，这会清除掉vec1中以前的内容。  vec1.assign(const_iterator first,const_iterator last); //当前向量中[first,last)中元素设置成迭代器所指向量的元素，这会清除掉vec1中以前的内容。 } ","permalink":"https://874656645.github.io/rick/posts/55-vector/","summary":"vector 常用操作 #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; int main() { //1.定义和初始化  vector\u0026lt;int\u0026gt; vec1; //默认初始化，vec1为空  vector\u0026lt;int\u0026gt; vec2(vec1); //使用vec1初始化vec2  vector\u0026lt;int\u0026gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2  vector\u0026lt;int\u0026gt; vec4(10); //10个值为0的元素  vector\u0026lt;int\u0026gt; vec5(10,4); //10个值为4的元素  //2.常用操作方法  //2.1 添加函数  vec1.push_back(100); //尾部添加元素  vec1.insert(vec1.end(),5,3); //从vec1.back位置插入5个值为3的元素  //2.2 删除函数  vec1.pop_back(); //删除末尾元素  vec1.erase(vec1.begin(),vec1.begin()+2); //删除vec1[0]-vec1[2]之间的元素，不包括vec1[2]其他元素前移  vec1.clear(); //清空元素，元素在内存中并未消失，通常使用swap()来清空  vector\u0026lt;int\u0026gt;().swap(V); //利用swap函数和临时对象交换内存，交换以后，临时对象消失，释放内存。  // 必须是同类型的 vector  //2.3 遍历函数  vec1[0]; //取得第一个元素  vec1.at(int pos); //返回pos位置元素的引用  vec1.front(); //返回首元素的引用  vec1.","title":"vector"},{"content":"STL六大组件\nSTL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。STL中包括六大组件：容器、算法、迭代器、适配器、仿函数、空间配置器\n适配器：适配器是一种设计模式(设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结)，该中模式是将一个类的接口转换成客户希望的另外一个接口。\n一、容器 序列式容器（vector、deque、list）、关联式容器（map、set）、容器适配器（stack、queue、priority_queue）\n1. vector 是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。由于具有连续的存储空间，所以在插入和删除操作方面，效率比较慢\n2. deque deque是 double ended queue 的缩写，双向队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。与 vector 不同，deque 不能保证将所有元素存储在连续的存储空间上\n3. list list是STL实现的双向链表，与vector相比, 它允许快速的插入和删除，但是随机访问却比较慢\n4. map、multimap、unordered_map、unordered_multimap  map 是STL的一个关联容器，它是一种键值对容器，里面的数据都是成对出现的，且键值是唯一的，可在我们处理一对一数据的时候，在编程上提供快速通道。map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。 multimap 中的元素也是有序的，但允许存在相同键值的 unordered_map 中的元素是唯一的，但无序（也不是插入顺序），而是根据它们的散列值（hash values）组织成桶（buckets），从而允许通过键值直接快速访问单个元素（速度一般比 map 更快） unordered_multimap 无序且不唯一  5. set、multiset、unordered_set、unordered_multiset  set 的含义是集合，它是一个有序的容器，里面的元素都是唯一且排序好的，支持插入、删除、查找等操作，就像一个集合一样，所有的操作都是严格在 logn时间内完成，效率非常高，使用方法类似list multiset 也是排序好的，但是可以存有相同的元素 unordered_set 无序但元素是不可重复的 unordered_multiset 无序，元素也不唯一  二、容器适配器 虽然stack、queue、priority_queue中也可以存放元素，但在STL中并没有将其划分在容器的行列，而是将其称为容器适配器，这是因为每个容器在底层都有自己的实现方式，而stack、queue、priority_queue只是在底层将其他容器进行了封装\nstd::stack template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class stack; std::queue template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class queue; std::priority_queue template\u0026lt;class T, class Container = vector\u0026lt;T\u0026gt;, class Compare = less\u0026lt;typename Container::value_type\u0026gt;\u0026gt; class priority_queue; 为什么选择deque作为stack和queue的底层默认容器？\nstack是后进先出的特殊线性数据结构，只要具有push_back()和pop_back()操作的线性结构，都可以作为stack的底层容器，比如vector和list都可以；\nqueue是先进先出的特殊线性数据结构，只要具有push_back()和pop_front()操作的线性结构，都可以作为queue的底层容器，比如list。\n但是STL中对stack和queue默认选择deque作为其底层容器，主要是因为：\n stack和queue不需要遍历(因此stack和queue没有迭代器)，只需要在固定的一端或者两端进行操作。 在stack中元素增长时，deque比vector的效率高。 在queue中的元素增长时，deque不仅效率高，而且内存使用率高  ","permalink":"https://874656645.github.io/rick/posts/54-c++-stl/","summary":"STL六大组件\nSTL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。STL中包括六大组件：容器、算法、迭代器、适配器、仿函数、空间配置器\n适配器：适配器是一种设计模式(设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结)，该中模式是将一个类的接口转换成客户希望的另外一个接口。\n一、容器 序列式容器（vector、deque、list）、关联式容器（map、set）、容器适配器（stack、queue、priority_queue）\n1. vector 是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。由于具有连续的存储空间，所以在插入和删除操作方面，效率比较慢\n2. deque deque是 double ended queue 的缩写，双向队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。与 vector 不同，deque 不能保证将所有元素存储在连续的存储空间上\n3. list list是STL实现的双向链表，与vector相比, 它允许快速的插入和删除，但是随机访问却比较慢\n4. map、multimap、unordered_map、unordered_multimap  map 是STL的一个关联容器，它是一种键值对容器，里面的数据都是成对出现的，且键值是唯一的，可在我们处理一对一数据的时候，在编程上提供快速通道。map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。 multimap 中的元素也是有序的，但允许存在相同键值的 unordered_map 中的元素是唯一的，但无序（也不是插入顺序），而是根据它们的散列值（hash values）组织成桶（buckets），从而允许通过键值直接快速访问单个元素（速度一般比 map 更快） unordered_multimap 无序且不唯一  5. set、multiset、unordered_set、unordered_multiset  set 的含义是集合，它是一个有序的容器，里面的元素都是唯一且排序好的，支持插入、删除、查找等操作，就像一个集合一样，所有的操作都是严格在 logn时间内完成，效率非常高，使用方法类似list multiset 也是排序好的，但是可以存有相同的元素 unordered_set 无序但元素是不可重复的 unordered_multiset 无序，元素也不唯一  二、容器适配器 虽然stack、queue、priority_queue中也可以存放元素，但在STL中并没有将其划分在容器的行列，而是将其称为容器适配器，这是因为每个容器在底层都有自己的实现方式，而stack、queue、priority_queue只是在底层将其他容器进行了封装\nstd::stack template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class stack; std::queue template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class queue; std::priority_queue template\u0026lt;class T, class Container = vector\u0026lt;T\u0026gt;, class Compare = less\u0026lt;typename Container::value_type\u0026gt;\u0026gt; class priority_queue; 为什么选择deque作为stack和queue的底层默认容器？","title":"C++ STL"},{"content":"1、new / delete 具体步骤 new\n 第一步：调用 operator new 函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值 第三部：对象构造完成后，返回一个指向该对象的指针  delete\n 第一步：调用对象的析构函数 第二步：编译器调用 operator delete 函数释放内存空间  2、new/delete 与 malloc/free 的区别是什么？  malloc/free 是 C 语言的标准库函数， new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存 malloc/free 不会去自动调用构造和析构函数，对于基本数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求 malloc/free 需要指定分配内存的大小，而 new/delete 会自动计算所需内存大小 new 返回的是指定对象的指针，而 malloc 返回的是 void*，因此 malloc 的返回值一般都需要进行强制类型转换  3、C++内存管理 在 C++ 中，虚拟内存分为代码段、数据段、BSS段、堆区、栈区以及文件映射区六部分\n 代码段：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码 数据段：存储程序中已初始化的全局变量和静态变量 BSS段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量（这个段的数据全都是0） 堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存 映射区：存储动态链接库以及调用mmap函数进行的文件映射 栈区：使用栈空间存储函数的返回地址、参数、局部变量、返回值（最靠近CPU的区）  4、内存的分配方式（三种）   静态存储区分配：是在程序编译时就已经分配好的，在整个运行期间都存在，如全局变量、常量、静态变量\n  栈上分配：函数内的局部变量就是从这分配的，但分配的内存容易有限\n  堆上分配：也称动态分配，如我们用 new,malloc 分配内存，用 delete,free 来释放的内存。堆内存空间可由用户手动分配和释放，所以其生存周期由用户指定，较为灵活。但频繁的分配、释放大小不同的堆空间会产生内存碎片\n  5、内存池 内存池是一种内存分配方式。通常我们习惯直接使用new、malloc申请内存，这样做的缺点在于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，预先申请分配一定数量、大小相等（一般情况下）的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是，使得内存分配效率得到提升\n6、内存泄漏 内存泄漏一般是指堆内存的泄漏，也就是程序在运行过程中动态申请的内存空间不再使用后没有及时释放，导致那块内存不能被再次使用\n7、C++中的不安全是什么概念？ C++中的不安全包括两种：一是程序得不到正确的结果，二是发生不可预知的错误（占用了不该用的内存空间）。可能会发生如下问题：\n 最严重的：内存泄漏，程序崩溃； 一般严重的：发生一些逻辑错误，且不便于调试； 较轻的：丢失部分数据，就像强制转换一样  8、内存中的堆与栈有什么区别？  申请方式：栈由系统自动分配和管理，堆由程序员手动分配和管理 效率：栈由系统分配，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行，因此，其速度快，不会有内存碎片；堆由程序员分配，堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低，可能由于操作不当产生内存碎片 扩展方向：栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展 程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间；同时，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间  ","permalink":"https://874656645.github.io/rick/posts/53-new-delete-%E4%B8%8E%E5%86%85%E5%AD%98/","summary":"1、new / delete 具体步骤 new\n 第一步：调用 operator new 函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值 第三部：对象构造完成后，返回一个指向该对象的指针  delete\n 第一步：调用对象的析构函数 第二步：编译器调用 operator delete 函数释放内存空间  2、new/delete 与 malloc/free 的区别是什么？  malloc/free 是 C 语言的标准库函数， new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存 malloc/free 不会去自动调用构造和析构函数，对于基本数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求 malloc/free 需要指定分配内存的大小，而 new/delete 会自动计算所需内存大小 new 返回的是指定对象的指针，而 malloc 返回的是 void*，因此 malloc 的返回值一般都需要进行强制类型转换  3、C++内存管理 在 C++ 中，虚拟内存分为代码段、数据段、BSS段、堆区、栈区以及文件映射区六部分\n 代码段：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码 数据段：存储程序中已初始化的全局变量和静态变量 BSS段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量（这个段的数据全都是0） 堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存 映射区：存储动态链接库以及调用mmap函数进行的文件映射 栈区：使用栈空间存储函数的返回地址、参数、局部变量、返回值（最靠近CPU的区）  4、内存的分配方式（三种）   静态存储区分配：是在程序编译时就已经分配好的，在整个运行期间都存在，如全局变量、常量、静态变量\n  栈上分配：函数内的局部变量就是从这分配的，但分配的内存容易有限\n  堆上分配：也称动态分配，如我们用 new,malloc 分配内存，用 delete,free 来释放的内存。堆内存空间可由用户手动分配和释放，所以其生存周期由用户指定，较为灵活。但频繁的分配、释放大小不同的堆空间会产生内存碎片","title":"new delete 与内存"},{"content":"在堆上声明一个数组 int main( ) { int ** pArr = NULL; pArr = new int*[4]; for(int i = 0; i \u0026lt; 4; i++){ pArr[i] = new int[8]; } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ if(j == 0) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pArr[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; } } // 删除  for(int i = 0; i \u0026lt; 4; ++i){ delete [] pArr[i]; } delete [] pArr; return 0; } 输出：\nStart 0\t0\t0\t0\t0\t0\t0\t0\t0\t1\t2\t3\t4\t5\t6\t7\t0\t2\t4\t6\t8\t10\t12\t14\t0\t3\t6\t9\t12\t15\t18\t21\t0 Finish 在栈上声明一个数组 int main( ) { int a[3]; // 全部初始化为 0  int b[3]{4}; // 第一个值是 4，其余初始化为 0  int c[3] = {4}; // 同上  // 与 vector 不同  vector\u0026lt;int\u0026gt; v(3, 4);// 3 个值都是 4  return 0; } ","permalink":"https://874656645.github.io/rick/posts/52-new-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/","summary":"在堆上声明一个数组 int main( ) { int ** pArr = NULL; pArr = new int*[4]; for(int i = 0; i \u0026lt; 4; i++){ pArr[i] = new int[8]; } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ if(j == 0) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pArr[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; } } // 删除  for(int i = 0; i \u0026lt; 4; ++i){ delete [] pArr[i]; } delete [] pArr; return 0; } 输出：","title":"new 二维数组"},{"content":"1. this指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用该成员函数的对象的首地址\n 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值 this 是个右值，所以不能取 this 的地址  2. delete this  类的成员函数中可以调用 delete this，但是在释放后，对象后续调用的方法不能再用到 this 指针 delete this 释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，此时其中的值是不确定的 delete 的本质是为将被释放的内存调用一个或多个析构函数，如果在类的析构函数中调用 delete this，会陷入无限递归，造成栈溢出  3. 一个空类class中有什么？ 构造函数、拷贝构造函数、析构函数、赋值运算符重载、取地址操作符重载、被 const 修饰的取地址操作符重载\n4. C++ 计算一个类的 sizeof  一个空的类 sizeof 返回 1，因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址 类内的普通成员函数不参与 sizeof 的统计，因为 sizeof 是针对实例的，而普通成员函数，是针对类体的 一个类如果含有虚函数，则这个类中有一个指向虚函数表的指针（虚函数指针），32位程序占4个字节，64位程序占8个字节 静态成员不影响类的大小，被编译器放在程序的数据段中 普通继承的类sizeof，会得到基类的大小加上派生类自身成员的大小 当存在虚拟继承时，派生类中会有一个指向虚基类表的指针。所以其大小应为普通继承的大小，再加上虚基类表的指针大小  5. 构造函数和析构函数能被继承吗? 不能。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么\n6. 构造函数能不能是虚函数？ 不能。虚函数对应一个虚函数表，可是这个虚函数表存储在对象的内存空间的。问题就在于，如果构造函数是虚的，就需要通过 虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，就不会有虚函数表\n7. 构造函数和析构函数能不能被重载？ 构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数。\n8. 构造函数调用顺序，析构函数调用顺序？ 基类的构造函数——\u0026gt;成员类对象的构造函数——\u0026gt;派生类的构造函数；\n析构函数相反：派生类析构——\u0026gt;成员类对象析构——\u0026gt;基类析构\n9. 构造函数和析构函数调用时机  全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数 局部自动对象：建立对象时调用构造函数，函数结束时调用析构函数 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数 静态局部变量对象：建立对象时调用构造函数，在主函数结束时调用析构函数  10. 拷贝构造函数中深拷贝和浅拷贝区别  深拷贝会先申请一块和拷贝数据一样大的内存空间，然后将数据逐字节拷贝过去，拷贝后两个指针指向不同的两个内存空间 浅拷贝仅是拷贝指针地址，拷贝后两个指针指向同一个内存空间\n当浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针，因为所指向的内存空间已经被释放了  11. 什么时候必须重写拷贝构造函数？ 当构造函数涉及到动态内存分配时，要自己写拷贝构造函数，并且要深拷贝\n12. 面向过程编程和面向对象编程的区别  面向过程：就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现（函数驱动） 面向对象：面向对象是一种对现实世界理解和抽象的方法，强调的是通过将需求要素转化为对象进行问题处理的一种思想（对象驱动）  13. 为什么内联函数，构造函数，静态成员函数不能为virtual函数？  内联函数：内联函数是在编译时期展开，而虚函数的特性是运行时才动态联编，所以两者矛盾，不能定义内联函数为虚函数 构造函数：构造函数用来创建一个新的对象，而虚函数的运行是建立在对象的基础上，在构造函数执行时，对象尚未形成，所以不能将构造函数定义为虚函数 静态成员函数：静态成员函数属于一个类而非某一对象，没有this指针，它无法进行对象的判别 友元函数：C++不支持友元函数的继承，对于没有继承性的函数没有虚函数  ","permalink":"https://874656645.github.io/rick/posts/51-%E7%B1%BB%E5%85%B6%E5%AE%83%E6%80%BB%E7%BB%93/","summary":"1. this指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用该成员函数的对象的首地址\n 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值 this 是个右值，所以不能取 this 的地址  2. delete this  类的成员函数中可以调用 delete this，但是在释放后，对象后续调用的方法不能再用到 this 指针 delete this 释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，此时其中的值是不确定的 delete 的本质是为将被释放的内存调用一个或多个析构函数，如果在类的析构函数中调用 delete this，会陷入无限递归，造成栈溢出  3. 一个空类class中有什么？ 构造函数、拷贝构造函数、析构函数、赋值运算符重载、取地址操作符重载、被 const 修饰的取地址操作符重载\n4. C++ 计算一个类的 sizeof  一个空的类 sizeof 返回 1，因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址 类内的普通成员函数不参与 sizeof 的统计，因为 sizeof 是针对实例的，而普通成员函数，是针对类体的 一个类如果含有虚函数，则这个类中有一个指向虚函数表的指针（虚函数指针），32位程序占4个字节，64位程序占8个字节 静态成员不影响类的大小，被编译器放在程序的数据段中 普通继承的类sizeof，会得到基类的大小加上派生类自身成员的大小 当存在虚拟继承时，派生类中会有一个指向虚基类表的指针。所以其大小应为普通继承的大小，再加上虚基类表的指针大小  5. 构造函数和析构函数能被继承吗? 不能。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么\n6. 构造函数能不能是虚函数？ 不能。虚函数对应一个虚函数表，可是这个虚函数表存储在对象的内存空间的。问题就在于，如果构造函数是虚的，就需要通过 虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，就不会有虚函数表","title":"类其它总结"},{"content":" 构造函数可以互调，但不能在函数体内，只能通过初始化列表的形式 构造函数中不要写业务逻辑 析构函数中不要 delete this ，这会导致析构递归，最终导致栈溢出  class Test{ public: Test(int a, int b, int c){ _a = a; _b = b; _c = c; } // 正确  Test(int a, int b):Test(a, b, 100){ } /* // 错误 Test(int a, int b){ _a = a; _b = b; Test(a, b, 100); // 此处只是产生一个临时对象，马上又被释放掉了，没有任何意义 } */ int getA(){ return _a; } int getB(){ return _b; } int getC(){ return _c; } private: int _a; int _b; int _c; }; int main( ) { Test t1(10, 20); cout \u0026lt;\u0026lt; t1.getA() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; t1.getB() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; t1.getC() \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 10 20 100 0 Finish ","permalink":"https://874656645.github.io/rick/posts/50-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BA%92%E8%B0%83/","summary":"构造函数可以互调，但不能在函数体内，只能通过初始化列表的形式 构造函数中不要写业务逻辑 析构函数中不要 delete this ，这会导致析构递归，最终导致栈溢出  class Test{ public: Test(int a, int b, int c){ _a = a; _b = b; _c = c; } // 正确  Test(int a, int b):Test(a, b, 100){ } /* // 错误 Test(int a, int b){ _a = a; _b = b; Test(a, b, 100); // 此处只是产生一个临时对象，马上又被释放掉了，没有任何意义 } */ int getA(){ return _a; } int getB(){ return _b; } int getC(){ return _c; } private: int _a; int _b; int _c; }; int main( ) { Test t1(10, 20); cout \u0026lt;\u0026lt; t1.","title":"构造函数重载与互调"},{"content":"思路是借助类的静态成员函数\n方式一：\nclass A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void setCur(){ s_curA = this; } static void callback(){ s_curA-\u0026gt;print(); } private: static A* s_curA; int m_a; }; A* A::s_curA = nullptr; typedef void (*FUN_S)(); void Handle(FUN_S call){ call(); } int main( ) { A a(10), b(20); a.setCur(); Handle(A::callback); b.setCur(); Handle(A::callback); return 0; } 方式二：\nclass A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } static void callback(void *a){ ((A*)a)-\u0026gt;print(); } private: int m_a; }; typedef void (*FUN)(void *); void Handle(void *a, FUN call){ call(a); } int main( ) { A a(10), b(20); Handle(\u0026amp;a, A::callback); Handle(\u0026amp;b, A::callback); return 0; } 输出：\nStart m_a = 10 m_a = 20 0 Finish 还可以进一步封装：\ntypedef void (*FUN_S)(); void Handle(FUN_S call){ cout \u0026lt;\u0026lt; \u0026#34;Handle(FUN_S) begin...\u0026#34; \u0026lt;\u0026lt; endl; call(); cout \u0026lt;\u0026lt; \u0026#34;Handle(FUN_S) end...\u0026#34; \u0026lt;\u0026lt; endl; } typedef void (*FUN)(void *); void Handle(void *a, FUN call){ cout \u0026lt;\u0026lt; \u0026#34;Handle(void *, FUN) begin...\u0026#34; \u0026lt;\u0026lt; endl; call(a); cout \u0026lt;\u0026lt; \u0026#34;Handle(void *, FUN) end...\u0026#34; \u0026lt;\u0026lt; endl; } class A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void setCur(){ s_curA = this; } void startup(){ setCur(); Handle(A::callback); } void startup(int){ Handle(this, A::callback); } static void callback(){ s_curA-\u0026gt;print(); } static void callback(void *a){ ((A*)a)-\u0026gt;print(); } private: static A* s_curA; int m_a; }; A* A::s_curA = nullptr; int main( ) { A a(10), b(20); a.startup(); b.startup(); cout \u0026lt;\u0026lt; \u0026#34;======================================\u0026#34; \u0026lt;\u0026lt; endl; a.startup(1); b.startup(1); return 0; } 输出：\nStart Handle(FUN_S) begin... m_a = 10 Handle(FUN_S) end... Handle(FUN_S) begin... m_a = 20 Handle(FUN_S) end... ====================================== Handle(void *, FUN) begin... m_a = 10 Handle(void *, FUN) end... Handle(void *, FUN) begin... m_a = 20 Handle(void *, FUN) end... 0 Finish ","permalink":"https://874656645.github.io/rick/posts/49-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","summary":"思路是借助类的静态成员函数\n方式一：\nclass A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void setCur(){ s_curA = this; } static void callback(){ s_curA-\u0026gt;print(); } private: static A* s_curA; int m_a; }; A* A::s_curA = nullptr; typedef void (*FUN_S)(); void Handle(FUN_S call){ call(); } int main( ) { A a(10), b(20); a.setCur(); Handle(A::callback); b.setCur(); Handle(A::callback); return 0; } 方式二：\nclass A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } static void callback(void *a){ ((A*)a)-\u0026gt;print(); } private: int m_a; }; typedef void (*FUN)(void *); void Handle(void *a, FUN call){ call(a); } int main( ) { A a(10), b(20); Handle(\u0026amp;a, A::callback); Handle(\u0026amp;b, A::callback); return 0; } 输出：","title":"类的成员函数作为回调函数"},{"content":" 父类指针可以new子类对象，子类指针不可以new父类对象，但是可以接收强转的已经存在的父类指针 父类指针指向本类对象，调用的虚函数和普通函数都是自己的 将子类指针指向父类对象，虚函数执行的是父类的，也可以调用子类函数（这种操作是错误的，编译会报错，虽然可通过指针强转，但是不建议这样做，可能会导致未知错误） 父类指针指向子类对象，虚函数执行的是子类的，并且不能调用子类的函数 父类指针与子类指针之间赋值可以理解为指针所指内容的一种浅拷贝\nFather *f = (Father*)Child * 子类的虚函数指针覆盖父类的，并且子类特有的函数指针不会拷贝过去\nChild *c = (Child*)new Father父类的虚函数指针覆盖子类的，同时也有子类特有的函数指针  class A{ public: void printA(){ cout \u0026lt;\u0026lt; \u0026#34;printA()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void print(){ cout \u0026lt;\u0026lt; \u0026#34;A::print()\u0026#34; \u0026lt;\u0026lt; endl; } }; class B:public A{ public: void printB(){ cout \u0026lt;\u0026lt; \u0026#34;printB()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void print() override{ cout \u0026lt;\u0026lt; \u0026#34;B::print() b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } private: int b; }; int main( ) { // 1、指向自己的类对象（将父类对象赋值给父类指针）  A *a = new A; // 1.1 调用自己的函数  a-\u0026gt;printA(); // printA()  // 1.2 调用虚函数  a-\u0026gt;print(); // A::print()  // 2、将指向父类的父类指针强转为子类指针（将父类对象赋值给子类指针）  // b = new A; // error: incompatible pointer types assigning to \u0026#39;B *\u0026#39; from \u0026#39;A *\u0026#39;  B *b = (B*)new A; // 2.1 调用父类函数  b-\u0026gt;printA(); // printA()  // 2.2 调用虚函数（执行父类的）  b-\u0026gt;print(); // A::print() 调用父类的  // 2.3 可以调用子类函数  b-\u0026gt;printB(); // printB() b = 0  // 3、将子类对象赋值给父类指针  a = new B; // 3.1 调用父类函数  a-\u0026gt;printA(); // printA()  // 3.2 调用子类的函数  // a-\u0026gt;printB(); // error: no member named \u0026#39;printB\u0026#39; in \u0026#39;A\u0026#39;; did you mean \u0026#39;printA\u0026#39;?  // 3.3 调用虚函数（执行子类的）  a-\u0026gt;print(); // B::print() b = 0  // 4、指向子类对象的子类指针强转为父类指针（效果等同情况3）  b = new B; a = (A*)b; a-\u0026gt;printA(); // printA()  //a-\u0026gt;printB(); // error: no member named \u0026#39;printB\u0026#39; in \u0026#39;A\u0026#39;  a-\u0026gt;print(); // B::print() b = 0  return 0; } ","permalink":"https://874656645.github.io/rick/posts/48-%E7%B1%BB%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8E%9F%E5%88%99/","summary":"父类指针可以new子类对象，子类指针不可以new父类对象，但是可以接收强转的已经存在的父类指针 父类指针指向本类对象，调用的虚函数和普通函数都是自己的 将子类指针指向父类对象，虚函数执行的是父类的，也可以调用子类函数（这种操作是错误的，编译会报错，虽然可通过指针强转，但是不建议这样做，可能会导致未知错误） 父类指针指向子类对象，虚函数执行的是子类的，并且不能调用子类的函数 父类指针与子类指针之间赋值可以理解为指针所指内容的一种浅拷贝\nFather *f = (Father*)Child * 子类的虚函数指针覆盖父类的，并且子类特有的函数指针不会拷贝过去\nChild *c = (Child*)new Father父类的虚函数指针覆盖子类的，同时也有子类特有的函数指针  class A{ public: void printA(){ cout \u0026lt;\u0026lt; \u0026#34;printA()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void print(){ cout \u0026lt;\u0026lt; \u0026#34;A::print()\u0026#34; \u0026lt;\u0026lt; endl; } }; class B:public A{ public: void printB(){ cout \u0026lt;\u0026lt; \u0026#34;printB()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void print() override{ cout \u0026lt;\u0026lt; \u0026#34;B::print() b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } private: int b; }; int main( ) { // 1、指向自己的类对象（将父类对象赋值给父类指针）  A *a = new A; // 1.","title":"类的兼容性原则"},{"content":" 如果类的内部没有专门创建实例的代码，则是无法创建任何实例的 如果父类构造函数设置成了私有的，则子类无法编译，因为在初始化子类时会先执行父类的构造  class A{ public: private: A(int ){ } }; class B:public A{ public: int x; }; int main( ) { B b; b.x = 0; return 0; } 输出：\nStart prog.cc:19:7: error: call to implicitly-deleted default constructor of \u0026#39;B\u0026#39; B b; ^ prog.cc:13:9: note: default constructor of \u0026#39;B\u0026#39; is implicitly deleted because base class \u0026#39;A\u0026#39; has an inaccessible default constructor class B:public A{ ^ 1 error generated. 1 Finish ","permalink":"https://874656645.github.io/rick/posts/47-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%A7%81%E6%9C%89/","summary":" 如果类的内部没有专门创建实例的代码，则是无法创建任何实例的 如果父类构造函数设置成了私有的，则子类无法编译，因为在初始化子类时会先执行父类的构造  class A{ public: private: A(int ){ } }; class B:public A{ public: int x; }; int main( ) { B b; b.x = 0; return 0; } 输出：\nStart prog.cc:19:7: error: call to implicitly-deleted default constructor of \u0026#39;B\u0026#39; B b; ^ prog.cc:13:9: note: default constructor of \u0026#39;B\u0026#39; is implicitly deleted because base class \u0026#39;A\u0026#39; has an inaccessible default constructor class B:public A{ ^ 1 error generated. 1 Finish ","title":"构造函数私有"},{"content":"一、只能在堆上 方法：将析构函数设置为私有\n原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象\nclass Test { public: void printT(){ cout \u0026lt;\u0026lt; \u0026#34;printT\u0026#34; \u0026lt;\u0026lt; endl; } void freeT(){ delete this; } private: ~Test(){ cout \u0026lt;\u0026lt; \u0026#34;~Test()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main( ) { // 不能在栈上创建对象  //Test t; // prog.cc:25:10: error: variable of type \u0026#39;Test\u0026#39; has private destructor  // 只能在堆上创建对象  Test *t = new Test; t-\u0026gt;printT(); // 销毁对象  t-\u0026gt;freeT(); return 0; } 输出：\nStart printT ~Test() 0 Finish 二、只能在栈上 方法：将 new 和 delete 重载为私有\n原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象\n","permalink":"https://874656645.github.io/rick/posts/46-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/","summary":"一、只能在堆上 方法：将析构函数设置为私有\n原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象\nclass Test { public: void printT(){ cout \u0026lt;\u0026lt; \u0026#34;printT\u0026#34; \u0026lt;\u0026lt; endl; } void freeT(){ delete this; } private: ~Test(){ cout \u0026lt;\u0026lt; \u0026#34;~Test()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main( ) { // 不能在栈上创建对象  //Test t; // prog.cc:25:10: error: variable of type \u0026#39;Test\u0026#39; has private destructor  // 只能在堆上创建对象  Test *t = new Test; t-\u0026gt;printT(); // 销毁对象  t-\u0026gt;freeT(); return 0; } 输出：\nStart printT ~Test() 0 Finish 二、只能在栈上 方法：将 new 和 delete 重载为私有","title":"定义一个只能在堆上（栈上）生成对象的类"},{"content":" 抽象类：含有纯虚函数的类，不能实例化对象 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：\n1）所有成员都是 public，没有私有和受保护的非静态成员；\n2）没有定义任何构造函数；\n3）没有类内初始化；\n4）没有基类，也没有 virtual 函数  // 接口类 class A { virtual void printA() = 0; // 纯虚函数 }; // 抽象类 class AA:public A { public: // 覆写接口类的纯虚函数  void printA() override { cout \u0026lt;\u0026lt; \u0026#34;class AA printA()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void printAA() = 0; }; // 可实例化的类 class B:public AA { public: // 覆写父类（抽象类）的纯虚函数  void printAA() override { cout \u0026lt;\u0026lt; \u0026#34;class B printAA()\u0026#34; \u0026lt;\u0026lt; endl; } void printB() { cout \u0026lt;\u0026lt; \u0026#34;printB()\u0026#34; \u0026lt;\u0026lt; endl; } }; // 聚合类 class C { public: int x; int y; void print(){ cc(); } private: void cc(){ cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;, z = \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; } static int z; }; int C::z = 0; class D { public: int a; int b; C c; void print(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; c.print(); } }; int main( ) { B b; b.printA(); b.printB(); // 初始化聚合类  D d = {1, 2, {3, 4}}; d.print(); return 0; } 输出：\nStart class AA printA() class B printAA() printB() a = 1, b = 2 x = 3, y = 4, z = 0 0 Finish ","permalink":"https://874656645.github.io/rick/posts/45-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E7%B1%BB%E8%81%9A%E5%90%88%E7%B1%BB/","summary":"抽象类：含有纯虚函数的类，不能实例化对象 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：\n1）所有成员都是 public，没有私有和受保护的非静态成员；\n2）没有定义任何构造函数；\n3）没有类内初始化；\n4）没有基类，也没有 virtual 函数  // 接口类 class A { virtual void printA() = 0; // 纯虚函数 }; // 抽象类 class AA:public A { public: // 覆写接口类的纯虚函数  void printA() override { cout \u0026lt;\u0026lt; \u0026#34;class AA printA()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void printAA() = 0; }; // 可实例化的类 class B:public AA { public: // 覆写父类（抽象类）的纯虚函数  void printAA() override { cout \u0026lt;\u0026lt; \u0026#34;class B printAA()\u0026#34; \u0026lt;\u0026lt; endl; } void printB() { cout \u0026lt;\u0026lt; \u0026#34;printB()\u0026#34; \u0026lt;\u0026lt; endl; } }; // 聚合类 class C { public: int x; int y; void print(){ cc(); } private: void cc(){ cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;, z = \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; } static int z; }; int C::z = 0; class D { public: int a; int b; C c; void print(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; c.","title":"抽象类、接口类、聚合类"},{"content":"虚继承和虚基类 参考\n 在C++中，在定义公共基类A的派生类B、C\u0026hellip;的时候，如果在继承方式前使用关键字virtual对继承方式限定，这样的继承方式就是虚拟继承，公共基类A成为虚基类。这样，在具有公共基类的、使用了虚拟继承方式的多个派生类B、C\u0026hellip;的公共派生类D中，该基类A的成员就只有一份拷贝 一个类有多个基类，这样的继承关系称为多继承。在多继承的情况下，如果不同基类的成员名称相同，匹配度相同, 则会造成二义性。为了避免多继承产生的二义性，在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 会在虚继承的类中生成一个指向虚基类的指针 {vbptr} 会在内存中生成一个虚基类表 D::$vbtable@B@  微软的Visual Studio提供给用户显示C++对象在内存中的布局的选项\ncl [filename].cpp /d1 reportSingleClassLayout[className]\n一般继承：\nclass A { public: int dataA; }; class B:public A { public: int dataB; }; class C:public A { public: int dataC; }; class D : public B, public C { public: int dataD; }; 输出：\nclass D size(20): +--- 0 | +--- (base class B) 0 | | +--- (base class A) 0 | | | dataA | | +--- 4 | | dataB | +--- 8 | +--- (base class C) 8 | | +--- (base class A) 8 | | | dataA | | +--- 12 | | dataC | +--- 16 | dataD +--- 调用：\nint main( ) { D d; cout \u0026lt;\u0026lt; d.dataA \u0026lt;\u0026lt; endl; return 0; } 调用输出：\nStart prog.cc:29:15: error: non-static member \u0026#39;dataA\u0026#39; found in multiple base-class subobjects of type \u0026#39;A\u0026#39;: class D -\u0026gt; class B -\u0026gt; class A class D -\u0026gt; class C -\u0026gt; class A cout \u0026lt;\u0026lt; d.dataA \u0026lt;\u0026lt; endl; ^ prog.cc:9:9: note: member found by ambiguous name lookup int dataA; ^ 1 error generated. 1 Finish 虚继承：\nclass A { public: int dataA; }; class B:virtual public A { public: int dataB; }; class C:virtual public A { public: int dataC; }; class D : public B, public C { public: int dataD; }; B 类输出：\nclass B size(12): +--- 0 | {vbptr} 4 | dataB +--- +--- (virtual base A) 8 | dataA +--- B::$vbtable@: 0 | 0 1 | 8 (Bd(B+0)A) vbi: class offset o.vbptr o.vbte fVtorDisp A 8 0 4 0 C 类输出：\nclass C size(12): +--- 0 | {vbptr} 4 | dataC +--- +--- (virtual base A) 8 | dataA +--- C::$vbtable@: 0 | 0 1 | 8 (Cd(C+0)A) vbi: class offset o.vbptr o.vbte fVtorDisp A 8 0 4 0 D 类输出：\nclass D size(24): +--- 0 | +--- (base class B) 0 | | {vbptr} 4 | | dataB | +--- 8 | +--- (base class C) 8 | | {vbptr} 12 | | dataC | +--- 16 | dataD +--- +--- (virtual base A) 20 | dataA +--- D::$vbtable@B@: 0 | 0 1 | 20 (Dd(B+0)A) D::$vbtable@C@: 0 | 0 1 | 12 (Dd(C+0)A) vbi: class offset o.vbptr o.vbte fVtorDisp A 20 0 4 0 ","permalink":"https://874656645.github.io/rick/posts/44-%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB/","summary":"虚继承和虚基类 参考\n 在C++中，在定义公共基类A的派生类B、C\u0026hellip;的时候，如果在继承方式前使用关键字virtual对继承方式限定，这样的继承方式就是虚拟继承，公共基类A成为虚基类。这样，在具有公共基类的、使用了虚拟继承方式的多个派生类B、C\u0026hellip;的公共派生类D中，该基类A的成员就只有一份拷贝 一个类有多个基类，这样的继承关系称为多继承。在多继承的情况下，如果不同基类的成员名称相同，匹配度相同, 则会造成二义性。为了避免多继承产生的二义性，在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 会在虚继承的类中生成一个指向虚基类的指针 {vbptr} 会在内存中生成一个虚基类表 D::$vbtable@B@  微软的Visual Studio提供给用户显示C++对象在内存中的布局的选项\ncl [filename].cpp /d1 reportSingleClassLayout[className]\n一般继承：\nclass A { public: int dataA; }; class B:public A { public: int dataB; }; class C:public A { public: int dataC; }; class D : public B, public C { public: int dataD; }; 输出：\nclass D size(20): +--- 0 | +--- (base class B) 0 | | +--- (base class A) 0 | | | dataA | | +--- 4 | | dataB | +--- 8 | +--- (base class C) 8 | | +--- (base class A) 8 | | | dataA | | +--- 12 | | dataC | +--- 16 | dataD +--- 调用：","title":"虚继承和虚基类"},{"content":"1. C++ 多态分类及实现  重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载（静态多态、静态编译） 子类多态（Subtype Polymorphism，运行期）：虚函数（动态多态、动态编译） 参数多态（Parametric Polymorphism，编译期）：类模板（泛型）、函数模板（函数指针） 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换  2. 虚表指针、虚函数指针、虚函数表  虚表指针：在含有虚函数的类的对象中，指向虚函数表的指针，在运行时确定 虚函数指针：指向虚函数的地址的指针 {vfptr} 虚函数表：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚函数表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建 Shape::$vftable@  class Shape { public: virtual ~Shape(){ cout \u0026lt;\u0026lt; \u0026#34;~Shape()\u0026#34; \u0026lt;\u0026lt; endl; } }; class Point { public: ~Point(){ cout \u0026lt;\u0026lt; \u0026#34;~Point()\u0026#34; \u0026lt;\u0026lt; endl; } private: int m_x{0}; int m_y{0}; char m_c; }; class Circle : public Shape { public: ~Circle(){ cout \u0026lt;\u0026lt; \u0026#34;~Circle()\u0026#34; \u0026lt;\u0026lt; endl; } private: Point m_p; }; int main( ) { // 8 类中存有指向虚函数表的指针  cout \u0026lt;\u0026lt; sizeof(Shape) \u0026lt;\u0026lt; endl; // 16 类中存有指向虚函数表的指针  // 以及Point对象的大小（此时Point类中不包含任何变量），虽然真实大小是 8 + 1  // 但是额外多的1个字节导致内存大小扩增了 8(每次扩增的最小数值是8 \u0026lt;alignment member\u0026gt; (size=7))  cout \u0026lt;\u0026lt; sizeof(Circle) \u0026lt;\u0026lt; endl; // 8 类中的int占4个字节，char占1个字节  // 但每次扩增的最小数值是4(\u0026lt;alignment member\u0026gt; (size=3))  cout \u0026lt;\u0026lt; sizeof(Point) \u0026lt;\u0026lt; endl; Circle c; return 0; } Start 8 24 12 ~Circle() ~Point() ~Shape() 0 Finish Shape 类\n// 没有虚函数 class Shape size(1): +--- +--- // 有虚析构函数 class Shape size(8): +--- 0 | {vfptr} +--- Shape::$vftable@: | \u0026amp;Shape_meta | 0 0 | \u0026amp;Shape::{dtor} Shape::{dtor} this adjustor: 0 Shape::__delDtor this adjustor: 0 Shape::__vecDelDtor this adjustor: 0 Point 类\nclass Point size(8): +--- 0 | m_x 4 | m_y 8 | m_c | \u0026lt;alignment member\u0026gt; (size=3) +--- Circle 类\nclass Circle size(24): +--- 0 | +--- (base class Shape) 0 | | {vfptr} | +--- 8 | Point m_p | \u0026lt;alignment member\u0026gt; (size=4) +--- Circle::$vftable@: | \u0026amp;Circle_meta | 0 0 | \u0026amp;Circle::{dtor} Circle::{dtor} this adjustor: 0 Circle::__delDtor this adjustor: 0 Circle::__vecDelDtor this adjustor: 0 ","permalink":"https://874656645.github.io/rick/posts/43-%E5%A4%9A%E6%80%81%E6%80%BB%E7%BB%93/","summary":"1. C++ 多态分类及实现  重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载（静态多态、静态编译） 子类多态（Subtype Polymorphism，运行期）：虚函数（动态多态、动态编译） 参数多态（Parametric Polymorphism，编译期）：类模板（泛型）、函数模板（函数指针） 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换  2. 虚表指针、虚函数指针、虚函数表  虚表指针：在含有虚函数的类的对象中，指向虚函数表的指针，在运行时确定 虚函数指针：指向虚函数的地址的指针 {vfptr} 虚函数表：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚函数表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建 Shape::$vftable@  class Shape { public: virtual ~Shape(){ cout \u0026lt;\u0026lt; \u0026#34;~Shape()\u0026#34; \u0026lt;\u0026lt; endl; } }; class Point { public: ~Point(){ cout \u0026lt;\u0026lt; \u0026#34;~Point()\u0026#34; \u0026lt;\u0026lt; endl; } private: int m_x{0}; int m_y{0}; char m_c; }; class Circle : public Shape { public: ~Circle(){ cout \u0026lt;\u0026lt; \u0026#34;~Circle()\u0026#34; \u0026lt;\u0026lt; endl; } private: Point m_p; }; int main( ) { // 8 类中存有指向虚函数表的指针  cout \u0026lt;\u0026lt; sizeof(Shape) \u0026lt;\u0026lt; endl; // 16 类中存有指向虚函数表的指针  // 以及Point对象的大小（此时Point类中不包含任何变量），虽然真实大小是 8 + 1  // 但是额外多的1个字节导致内存大小扩增了 8(每次扩增的最小数值是8 \u0026lt;alignment member\u0026gt; (size=7))  cout \u0026lt;\u0026lt; sizeof(Circle) \u0026lt;\u0026lt; endl; // 8 类中的int占4个字节，char占1个字节  // 但每次扩增的最小数值是4(\u0026lt;alignment member\u0026gt; (size=3))  cout \u0026lt;\u0026lt; sizeof(Point) \u0026lt;\u0026lt; endl; Circle c; return 0; } Start 8 24 12 ~Circle() ~Point() ~Shape() 0 Finish Shape 类","title":"多态总结"},{"content":"1. 函数默认参数和占位参数（亚元） 形参中的占位参数又叫亚元，并没有什么实际意义，只在函数重载中起到作用\n// 亚元，设置了默认值所以调用时可以不传参数 // 否则就必须传入两个参数 void foo(int a, int = 0){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } int main() { foo(20); return 0; } 2. 函数重载  函数名相同，形参列表不同（形参个数、类型、顺序） 函数返回值不起作用 函数重载和默认参数不要同时使用（函数调用时容易产生二义性） 倾轧技术（name mangling），底层会将函数名进行编译  用 v c i f l d 表示 void char int float long double 及其引用 int fun(int) =\u0026gt; fun_i\nint fun(int, char, double) =\u0026gt; fun_icd   重载函数匹配顺序  如果能够严格匹配，则调用完全匹配的 如果没有完全匹配的，则调用隐式转换的 都匹配不上，编译失败    3. 函数指针 int test(int a, int b){ cout \u0026lt;\u0026lt; \u0026#34;test(\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; return 0; } // 方式一： typedef int(FUN)(int, int); // 方式二： typedef int(*FUN_P)(int, int); int main() { // 方式一：  FUN *f1 = NULL; f1 = test; f1(10, 20); (*f1)(10, 20); // 方式二：  FUN_P f2 = NULL; f2 = test; f2(10, 20); // 方式三：  int (*f3)(int, int) = NULL; f3 = test; f3(10, 20); return 0; } 输出：\nStart test(10, 20) test(10, 20) test(10, 20) test(10, 20) 0 Finish ","permalink":"https://874656645.github.io/rick/posts/42-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%92%8C%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0/","summary":"1. 函数默认参数和占位参数（亚元） 形参中的占位参数又叫亚元，并没有什么实际意义，只在函数重载中起到作用\n// 亚元，设置了默认值所以调用时可以不传参数 // 否则就必须传入两个参数 void foo(int a, int = 0){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } int main() { foo(20); return 0; } 2. 函数重载  函数名相同，形参列表不同（形参个数、类型、顺序） 函数返回值不起作用 函数重载和默认参数不要同时使用（函数调用时容易产生二义性） 倾轧技术（name mangling），底层会将函数名进行编译  用 v c i f l d 表示 void char int float long double 及其引用 int fun(int) =\u0026gt; fun_i\nint fun(int, char, double) =\u0026gt; fun_icd   重载函数匹配顺序  如果能够严格匹配，则调用完全匹配的 如果没有完全匹配的，则调用隐式转换的 都匹配不上，编译失败    3.","title":"函数默认参数和占位参数"},{"content":"","permalink":"https://874656645.github.io/rick/posts/41-%E5%86%85%E5%AD%98%E5%8C%BA%E9%97%B4%E5%88%92%E5%88%86/","summary":"","title":"内存区间划分"},{"content":" 指针也是一种变量，作为函数形参和返回值的时候也是值拷贝（拷贝的是一个地址） 使用指针引用的方式，代码更加简洁，逻辑更加清晰 释放掉指针指向的空间后，一定记得把指针置空 声明指针时就进行初始化或将其指向 NULL 是个好习惯  指针值拷贝：\nvoid test(int * a){ a = new int(20); //*a = 20;  cout \u0026lt;\u0026lt; \u0026#34;test point a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;test:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; } int main() { int *a = new int(10); cout \u0026lt;\u0026lt; \u0026#34;main point a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;main:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; test(a); cout \u0026lt;\u0026lt; \u0026#34;main:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart main point a = 0x7ffea2597be0 main:0x195d010\ta = 10 test point a = 0x7ffea2597ba8 test:0x195e040\ta = 20 main:0x195d010\ta = 10 0 Finish struct teacher{ char name[64]; int id; }; // 方式一： // 如果想要在函数内部实现指针内存分配 // 就只能用二级指针的形参 int getTT(struct teacher ** tpp){ struct teacher *tp = (struct teacher *)malloc(sizeof(struct teacher)); if(tp == NULL){ return -1; } tp-\u0026gt;id = 100; strcpy(tp-\u0026gt;name, \u0026#34;zhang3\u0026#34;); *tpp = tp; return 0; } // 如果是想释放指针，也可以用一级指针 void freeTT(struct teacher **tpp){ if(tpp == NULL){ return; } if(*tpp != NULL){ free(*tpp); *tpp = NULL; } } void freeTT(struct teacher *tpp){ if(tpp == NULL){ return; } if(tpp != NULL){ free(tpp); // 此处的tpp是一个指针复本，置空没有效果  // 所以只能在外部将指针置空  tpp = NULL; } } // 方式二： // 指针引用的方式，更加简洁 int getT(struct teacher *\u0026amp; tp){ tp = (struct teacher *)malloc(sizeof(struct teacher)); if(tp == NULL){ return -1; } tp-\u0026gt;id = 100; strcpy(tp-\u0026gt;name, \u0026#34;zhang3\u0026#34;); return 0; } void freeT(struct teacher *\u0026amp; tp){ if(tp == NULL){ return; } free(tp); tp = NULL; } int main() { struct teacher *tp = NULL; // 1、利用二级指针  //getTT(\u0026amp;tp);  // 2、利用指针引用  getT(tp); cout \u0026lt;\u0026lt; tp-\u0026gt;id \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tp-\u0026gt;name \u0026lt;\u0026lt; endl; //freeTT(\u0026amp;tp);  freeT(tp); cout \u0026lt;\u0026lt; \u0026#34;==========================\u0026#34; \u0026lt;\u0026lt; endl; if(tp == NULL){ cout \u0026lt;\u0026lt; \u0026#34;free ok\u0026#34; \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; tp-\u0026gt;id \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tp-\u0026gt;name \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 100 zhang3 ========================== free ok 0 Finish ","permalink":"https://874656645.github.io/rick/posts/40-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/","summary":"指针也是一种变量，作为函数形参和返回值的时候也是值拷贝（拷贝的是一个地址） 使用指针引用的方式，代码更加简洁，逻辑更加清晰 释放掉指针指向的空间后，一定记得把指针置空 声明指针时就进行初始化或将其指向 NULL 是个好习惯  指针值拷贝：\nvoid test(int * a){ a = new int(20); //*a = 20;  cout \u0026lt;\u0026lt; \u0026#34;test point a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;test:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; } int main() { int *a = new int(10); cout \u0026lt;\u0026lt; \u0026#34;main point a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;main:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; test(a); cout \u0026lt;\u0026lt; \u0026#34;main:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"指针引用"},{"content":"一、抽象、封装 数据抽象：是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制，是一种依赖于接口实现分离的设计技术\n数据封装：是一种把数据和操作数据的函数捆绑在一起的机制\n1. 好处  类的内部受到保护，不会因无意的用户级错误导致对象状态受损 类实现可能随着时间的推移而发生变化，数据抽象可以更好的应对不断变化的需求  2. 策略  通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。 抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可  3. 接口 接口描述了类的行为和功能，而不需要完成类的特定实现。如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类\n设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n可用于实例化对象的类被称为具体类\n接口的好处实现了解耦合的作用。 可以将软件架构分为业务逻辑层、抽象层和实现层\n二、继承 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。类派生列表以一个或多个基类命名\n派生类可以访问基类中所有的非私有成员，同时，一个派生类继承了所有的基类方法，但下列情况除外：\n 基类的构造函数、析构函数和拷贝构造函数 基类的重载运算符 基类的友元函数  三、多态 虚函数：虚函数是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链编到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链编，或后期绑定。\n 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数 一般要将父类的析构函数设置为虚函数，如果不把父类的析构函数设置为虚函数，在 delete 父类指针时就不会调用子类的析构了 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数 若在基类中不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数，在函数参数后直接加 = 0 告诉编译器，函数没有主体，这种虚函数即是纯虚函数  测试类：\n// 基类 Shape class Shape { protected: int width, height; public: Shape(int a = 0, int b = 0) { width = a; height = b; } virtual ~Shape() { cout \u0026lt;\u0026lt; \u0026#34;Shape destructor\u0026#34; \u0026lt;\u0026lt; endl; } // pure virtual function  virtual int area() = 0; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { auto res = area * 70; cout \u0026lt;\u0026lt; \u0026#34;PaintCost: \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return res; } }; class Rectangle: public Shape, public PaintCost { public: Rectangle(int a = 0, int b = 0):Shape(a, b) { } ~Rectangle() { cout \u0026lt;\u0026lt; \u0026#34;Rectangle destructor\u0026#34; \u0026lt;\u0026lt; endl; } void printPro() { // 访问父类的成员变量（不能访问父类的私有成员）  cout \u0026lt;\u0026lt; \u0026#34;width: \u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34;\\theight: \u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; endl; } int area () { auto area = width * height; cout \u0026lt;\u0026lt; \u0026#34;Rectangle class area: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt;endl; return area; } }; class Triangle: public Shape { public: Triangle(int a = 0, int b = 0):Shape(a, b) { } ~Triangle() { cout \u0026lt;\u0026lt; \u0026#34;Triangle destructor\u0026#34; \u0026lt;\u0026lt; endl; } int area () { auto area = width * height / 2; cout \u0026lt;\u0026lt; \u0026#34;Triangle class area: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt;endl; return area; } }; 多继承：\nint main() { Rectangle rec(10, 20); rec.printPro(); // 调用父类函数  rec.getCost(10); return 0; } 输出：\nStart width: 10\theight: 20 PaintCost: 700 Rectangle destructor Shape destructor 0 Finish 多态：\nint main() { Shape *shape = new Rectangle(10, 7); Triangle tri(10,5); shape-\u0026gt;area(); //Rectangle class area  delete shape; shape = \u0026amp;tri; shape-\u0026gt;area(); //Triangle class area  // delete shape; // 这种指针不能 delete  return 0; } 输出：\nStart Rectangle class area: 70 Rectangle destructor Shape destructor Triangle class area: 25 Triangle destructor Shape destructor 0 Finish 实现多态的原因： 如果父类有 virtual 方法，编译器会创建一个虚函数表（在只读区），同时会在类中存储一个指向虚函数表的指针 VPTR，这个表也会被子类继承，如果子类中重写了父类的虚函数，就会在子类中覆盖所继承的虚函数表中的函数\n虚函数表指针是分步初始化的，在构建父类时指向的还是父类的虚函数表\nclass A{ public: A(){ cout \u0026lt;\u0026lt; \u0026#34;A()...\u0026#34; \u0026lt;\u0026lt; endl; print(); } virtual ~A(){ cout \u0026lt;\u0026lt; \u0026#34;~A()...\u0026#34; \u0026lt;\u0026lt; endl; print(); } virtual void print(){ cout \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; } }; class B : public A{ public: B(){ cout \u0026lt;\u0026lt; \u0026#34;B()...\u0026#34; \u0026lt;\u0026lt; endl; print(); } ~B(){ cout \u0026lt;\u0026lt; \u0026#34;~B()...\u0026#34; \u0026lt;\u0026lt; endl; print(); } virtual void print(){ cout \u0026lt;\u0026lt; \u0026#34;B\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { A *a = new B; delete a; return 0; } 输出：\nA()... A B()... B ~B()... B ~A()... A ","permalink":"https://874656645.github.io/rick/posts/39-%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/","summary":"一、抽象、封装 数据抽象：是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制，是一种依赖于接口实现分离的设计技术\n数据封装：是一种把数据和操作数据的函数捆绑在一起的机制\n1. 好处  类的内部受到保护，不会因无意的用户级错误导致对象状态受损 类实现可能随着时间的推移而发生变化，数据抽象可以更好的应对不断变化的需求  2. 策略  通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。 抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可  3. 接口 接口描述了类的行为和功能，而不需要完成类的特定实现。如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类\n设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n可用于实例化对象的类被称为具体类\n接口的好处实现了解耦合的作用。 可以将软件架构分为业务逻辑层、抽象层和实现层\n二、继承 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。类派生列表以一个或多个基类命名\n派生类可以访问基类中所有的非私有成员，同时，一个派生类继承了所有的基类方法，但下列情况除外：\n 基类的构造函数、析构函数和拷贝构造函数 基类的重载运算符 基类的友元函数  三、多态 虚函数：虚函数是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链编到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链编，或后期绑定。\n 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数 一般要将父类的析构函数设置为虚函数，如果不把父类的析构函数设置为虚函数，在 delete 父类指针时就不会调用子类的析构了 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数 若在基类中不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数，在函数参数后直接加 = 0 告诉编译器，函数没有主体，这种虚函数即是纯虚函数  测试类：\n// 基类 Shape class Shape { protected: int width, height; public: Shape(int a = 0, int b = 0) { width = a; height = b; } virtual ~Shape() { cout \u0026lt;\u0026lt; \u0026#34;Shape destructor\u0026#34; \u0026lt;\u0026lt; endl; } // pure virtual function  virtual int area() = 0; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { auto res = area * 70; cout \u0026lt;\u0026lt; \u0026#34;PaintCost: \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return res; } }; class Rectangle: public Shape, public PaintCost { public: Rectangle(int a = 0, int b = 0):Shape(a, b) { } ~Rectangle() { cout \u0026lt;\u0026lt; \u0026#34;Rectangle destructor\u0026#34; \u0026lt;\u0026lt; endl; } void printPro() { // 访问父类的成员变量（不能访问父类的私有成员）  cout \u0026lt;\u0026lt; \u0026#34;width: \u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34;\\theight: \u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; endl; } int area () { auto area = width * height; cout \u0026lt;\u0026lt; \u0026#34;Rectangle class area: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt;endl; return area; } }; class Triangle: public Shape { public: Triangle(int a = 0, int b = 0):Shape(a, b) { } ~Triangle() { cout \u0026lt;\u0026lt; \u0026#34;Triangle destructor\u0026#34; \u0026lt;\u0026lt; endl; } int area () { auto area = width * height / 2; cout \u0026lt;\u0026lt; \u0026#34;Triangle class area: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt;endl; return area; } }; 多继承：","title":"抽象、封装、继承、多态"},{"content":" 使用 static 关键字来把类成员定义为静态的。静态成员在类的所有对象中是共享的，当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本 如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零 不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数） 普通成员函数有 this 指针，可以访问类中的任意成员；  class A { string name {\u0026#34;C++\u0026#34;}; int id {1024}; static int objCount; public: A(); friend void printA(const A \u0026amp;a); void printA(); static void printC(); }; // 静态成员类外初始化 int A::objCount = 0; A::A(){ objCount++; } void A::printA(){ cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;objCount \u0026lt;\u0026lt; \u0026#34;\\tname = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;id \u0026lt;\u0026lt; endl; } void A::printC(){ // 静态函数内没有this指针  cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; objCount \u0026lt;\u0026lt; endl; // error: \u0026#39;this\u0026#39; is unavailable for static member functions  // cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;objCount \u0026lt;\u0026lt; endl; } void printA(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; a.objCount \u0026lt;\u0026lt; \u0026#34;\\tname = \u0026#34; \u0026lt;\u0026lt; a.name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; a.id \u0026lt;\u0026lt; endl; } int main() { // 类静态成员函数  A::printC(); // 友员函数  A a; printA(a); // 成员函数  A b; b.printA(); return 0; } 输出：\nStart objCount = 0 objCount = 1\tname = C++\tid = 1024 objCount = 2\tname = C++\tid = 1024 0 Finish ","permalink":"https://874656645.github.io/rick/posts/38-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/","summary":"使用 static 关键字来把类成员定义为静态的。静态成员在类的所有对象中是共享的，当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本 如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零 不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数） 普通成员函数有 this 指针，可以访问类中的任意成员；  class A { string name {\u0026#34;C++\u0026#34;}; int id {1024}; static int objCount; public: A(); friend void printA(const A \u0026amp;a); void printA(); static void printC(); }; // 静态成员类外初始化 int A::objCount = 0; A::A(){ objCount++; } void A::printA(){ cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;objCount \u0026lt;\u0026lt; \u0026#34;\\tname = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;id \u0026lt;\u0026lt; endl; } void A::printC(){ // 静态函数内没有this指针  cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; objCount \u0026lt;\u0026lt; endl; // error: \u0026#39;this\u0026#39; is unavailable for static member functions  // cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;objCount \u0026lt;\u0026lt; endl; } void printA(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; a.","title":"类的静态成员"},{"content":"  友元利弊：\n友元不是类的成员但能访问类中的私有成员。友元的作用在于提高程序的运行效率，但也破坏了类的封装。\n  注意事项：\n（1）友元关系不能被继承；\n（2）友元关系是单向的，不具有交换性；\n（3）友元关系不具有传递性；\n  一、友元函数  类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员 尽管友元函数的原型有在类的定义中出现过，但是 友元函数并不是成员函数 this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针  1. 友元函数是全局函数\nclass A { friend void printA(const A \u0026amp;a); public: void printA(); private: string name {\u0026#34;C++\u0026#34;}; int id {1024}; }; void A::printA(){ cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;id \u0026lt;\u0026lt; endl; } // 请注意：printA() 不是任何类的成员函数 void printA(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; a.name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; a.id \u0026lt;\u0026lt; endl; } int main() { A a; printA(a); a.printA(); return 0; } 输出：\nStart name = C++\tid = 1024 name = C++\tid = 1024 0 Finish 2. 友元函数是类的成员方法\n小技巧：为了防止相互嵌套，可以将其中一个类的声明和实现拆开\nclass Point; class PointManager{ public: double getDistance(Point \u0026amp;p1, Point \u0026amp;p2); private: }; class Point{ friend double PointManager::getDistance(Point \u0026amp;p1, Point \u0026amp;p2); public: Point(int x, int y){ this-\u0026gt;x = x; this-\u0026gt;y = y; } private: int x; int y; }; double PointManager::getDistance(Point \u0026amp;p1, Point \u0026amp;p2){ int dx = p1.x - p2.x; int dy = p1.y - p2.y; return sqrt(dx * dx + dy * dy); } int main( ) { Point p1(1, 1), p2(3, 1); PointManager pm; cout \u0026lt;\u0026lt; pm.getDistance(p1, p2) \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 2 0 Finish 二、友元类 class A{ friend class B; // 将 B 声明为友元类后，在 B 中 A 就是透明的 public: A(int a){ this-\u0026gt;a = a; } void printA(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;a \u0026lt;\u0026lt; endl; } private: int a; }; class B{ public: B(int b){ this-\u0026gt;b = b; } void printB(){ A a(10); cout \u0026lt;\u0026lt; \u0026#34;print a in b: \u0026#34; \u0026lt;\u0026lt; a.a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;b \u0026lt;\u0026lt; endl; } private: int b; }; int main( ) { B b(-10); b.printB(); return 0; } Start print a in b: 10 b = -10 0 Finish ","permalink":"https://874656645.github.io/rick/posts/37-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8B%E5%85%83%E7%B1%BB/","summary":"友元利弊：\n友元不是类的成员但能访问类中的私有成员。友元的作用在于提高程序的运行效率，但也破坏了类的封装。\n  注意事项：\n（1）友元关系不能被继承；\n（2）友元关系是单向的，不具有交换性；\n（3）友元关系不具有传递性；\n  一、友元函数  类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员 尽管友元函数的原型有在类的定义中出现过，但是 友元函数并不是成员函数 this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针  1. 友元函数是全局函数\nclass A { friend void printA(const A \u0026amp;a); public: void printA(); private: string name {\u0026#34;C++\u0026#34;}; int id {1024}; }; void A::printA(){ cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;id \u0026lt;\u0026lt; endl; } // 请注意：printA() 不是任何类的成员函数 void printA(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; a.","title":"友元函数与友元类"},{"content":"结论：\n 拷贝构造函数是函数，赋值运算符是运算符的重载； 拷贝构造函数会生成新的类对象，赋值运算符不会； 拷贝构造函数是用一个已存在的对象去构造一个不存在的对象；而赋值运算符重载函数是用一个存在的对象去给另一个已存在并初始化过的对象进行赋值; 若接受返回值的对象已经初始化过，则会调用赋值构造函数，且该对象还会调用析构函数，当对象中包含指针时，会使该指针失效，因此需要重载赋值构造函数，使用类似深拷贝或移动构造函数的方法赋值，才能避免指针失效。 当没有显式的构造函数和拷贝构造时，系统才会提供默认的无参构造  成员初始化列表  使用初始化列表，少了一次调用默认构造函数的过程，提高效率 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 成员变量初始化的顺序跟在初始化列表的顺序无关，与变量声明的顺序有关  测试类 class A { public: A(){ cout \u0026lt;\u0026lt; \u0026#34;default constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } A(int t){ x = new int(0); y = t; cout \u0026lt;\u0026lt; \u0026#34;second constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } A(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;const copy constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; this-\u0026gt;x = a.x; this-\u0026gt;y = a.y; } A\u0026amp; operator = (const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;const assignment constructor\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;x = a.x; this-\u0026gt;y = a.y; return *this; } ~A(){ cout \u0026lt;\u0026lt; \u0026#34;destructor delete \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; delete x; } public: int * x {nullptr}; int y{0}; }; A f(){ A ret(3); cout \u0026lt;\u0026lt; \u0026#34;stack f adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;ret \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; ret.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; ret.y \u0026lt;\u0026lt; endl; return ret; } // 匿名对象 = ret (此处会调用拷贝构造) 一、拷贝构造 1. 对象需要通过另外一个对象进行初始化 int main() { A a(1); A c = a; cout \u0026lt;\u0026lt; \u0026#34;global adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;c \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart second constructor adrres: 0x7ffdf2cf5cc0\tpoint x: 0x1e9db20\ty: 1 const copy constructor adrres: 0x7ffdf2cf5cb0\tpoint x: 0\ty: 0 global adrres: 0x7ffdf2cf5cb0\tpoint x: 0x1e9db20\ty: 1 destructor delete 0x7ffdf2cf5cb0 destructor delete 0x7ffdf2cf5cc0 0 Finish 2. 对象通过值传递方式进入函数 void g(A a){ cout \u0026lt;\u0026lt; \u0026#34;stack g adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; a.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; a.y \u0026lt;\u0026lt; endl; } int main() { A a(1); g(a); return 0; } 输出：\nStart second constructor adrres: 0x7ffddc160510\tpoint x: 0x2448b20\ty: 1 const copy constructor adrres: 0x7ffddc160520\tpoint x: 0\ty: 0 stack g adrres: 0x7ffddc160520\tpoint x: 0x2448b20\ty: 1 destructor delete 0x7ffddc160520 destructor delete 0x7ffddc160510 0 Finish 3. 当对象以值传递的方式从函数返回  函数返回匿名对象时会调用拷贝构造 变量在接收匿名对象时就不会调用拷贝构造了  class A { //注意把拷贝构造设为禁止使用，否则看不到效果  A(const A \u0026amp;a) = delete; } int main() { f(); // 如果没有变量接收匿名对象，编译器就直接回收了，立即执行对象析构  A c = f(); // 匿名对象直接转正，就不会调用拷贝构造了  A d; d = f(); // 此处会调用 = 号操作符重载（d = 匿名对象）  // 然后匿名对象会执行析构，立即销毁  cout \u0026lt;\u0026lt; \u0026#34;global adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;c \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart prog.cc: In function \u0026#39;A f()\u0026#39;: prog.cc:40:12: error: use of deleted function \u0026#39;A::A(const A\u0026amp;)\u0026#39; 40 | return ret; | ^~~ prog.cc:20:5: note: declared here 20 | A(const A \u0026amp;a) = delete; | ^ 1 Finish 正常输出：虽然没有输出调用拷贝构造的信息，但确实有关系\nStart second constructor adrres: 0x7fff0f7062d0\tpoint x: 0x127eb20\ty: 3 stack f adrres: 0x7fff0f7062d0\tpoint x: 0x127eb20\ty: 3 global adrres: 0x7fff0f7062d0\tpoint x: 0x127eb20\ty: 3 destructor delete 0x7fff0f7062d0 0 Finish 二、赋值构造  注意：拷贝构造不能是 delete 的  1. 对象直接赋值给另一个对象，且接受值的对象已经初始化过 int main() { A a(1); A c; c = a; cout \u0026lt;\u0026lt; \u0026#34;global adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;c \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart second constructor adrres: 0x7ffee27a6fa0\tpoint x: 0xcdeb20\ty: 1 default constructor adrres: 0x7ffee27a6f90\tpoint x: 0\ty: 0 const assignment constructor global adrres: 0x7ffee27a6f90\tpoint x: 0xcdeb20\ty: 1 destructor delete 0x7ffee27a6f90 destructor delete 0x7ffee27a6fa0 0 Finish 2. 对象以值传递方式从函数返回，且接受返回值的对象已经初始化过  注意：返回函数调用后，会调用析构，如果对象中包含指针时，会使该指针失效  int main() { A c; c = f(); // 此时调用指针会出错，f()结束，调用对象析构，对象中的指针被 delete 掉了  // cout \u0026lt;\u0026lt; *c.x \u0026lt;\u0026lt; endl;  cout \u0026lt;\u0026lt; \u0026#34;global adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;c \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart default constructor adrres: 0x7ffd3aed2be0\tpoint x: 0\ty: 0 second constructor adrres: 0x7ffd3aed2bf0\tpoint x: 0x1475b20\ty: 3 stack f adrres: 0x7ffd3aed2bf0\tpoint x: 0x1475b20\ty: 3 const assignment constructor destructor delete 0x7ffd3aed2bf0 global adrres: 0x7ffd3aed2be0\tpoint x: 0x1475b20\ty: 3 destructor delete 0x7ffd3aed2be0 0 Finish ","permalink":"https://874656645.github.io/rick/posts/36-%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0/","summary":"结论：\n 拷贝构造函数是函数，赋值运算符是运算符的重载； 拷贝构造函数会生成新的类对象，赋值运算符不会； 拷贝构造函数是用一个已存在的对象去构造一个不存在的对象；而赋值运算符重载函数是用一个存在的对象去给另一个已存在并初始化过的对象进行赋值; 若接受返回值的对象已经初始化过，则会调用赋值构造函数，且该对象还会调用析构函数，当对象中包含指针时，会使该指针失效，因此需要重载赋值构造函数，使用类似深拷贝或移动构造函数的方法赋值，才能避免指针失效。 当没有显式的构造函数和拷贝构造时，系统才会提供默认的无参构造  成员初始化列表  使用初始化列表，少了一次调用默认构造函数的过程，提高效率 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 成员变量初始化的顺序跟在初始化列表的顺序无关，与变量声明的顺序有关  测试类 class A { public: A(){ cout \u0026lt;\u0026lt; \u0026#34;default constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } A(int t){ x = new int(0); y = t; cout \u0026lt;\u0026lt; \u0026#34;second constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } A(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;const copy constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; this-\u0026gt;x = a.","title":"构造、拷贝构造、赋值构造"},{"content":" 重载： 在同一作用域中，两个函数名相同，但是参数列表不同（个数、类型、顺序），返回值类型没有要求； 重写： 子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写； 重定义： 派生类中函数与基类中的函数同名，但是这个函数在基类中并没有被定义为虚函数 隐藏： 派生类中重定义了父类的函数，此时基类的函数会被隐藏； 模板： 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表，只适用于 参数个数相同而类型不同 的函数。 构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数  1、重载  类的静态函数也可以重载； 形参中一级指针和二级指针被认为是不同类型的参数；  class A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;print()\u0026#34; \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void freeP(A ** p){ if(p == NULL){ return; } if(*p != NULL){ free(*p); *p = NULL; } } void freeP(A * p){ if(p != NULL){ free(p); p = NULL; } } static void printS(){ cout \u0026lt;\u0026lt; \u0026#34;printS() s_a = \u0026#34; \u0026lt;\u0026lt; s_a \u0026lt;\u0026lt; endl; } static void printS(int s){ cout \u0026lt;\u0026lt; \u0026#34;printS(int s) \u0026#34; \u0026lt;\u0026lt; s_a * s \u0026lt;\u0026lt; endl; } static void printS(void *p, int s){ cout \u0026lt;\u0026lt; \u0026#34;printS(void *p, int s) \u0026#34; \u0026lt;\u0026lt; ((A*)p)-\u0026gt;m_a * s \u0026lt;\u0026lt; endl; } static int s_a; private: int m_a; }; int A::s_a = 0; int main( ) { A *a = new A(1); a-\u0026gt;printS(a, 20); a-\u0026gt;print(); A::s_a = 10; a-\u0026gt;printS(); a-\u0026gt;printS(10); a-\u0026gt;freeP(a); if(a == NULL){ cout \u0026lt;\u0026lt; \u0026#34;*a is not valid\u0026#34; \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; \u0026#34;*a is valid\u0026#34; \u0026lt;\u0026lt; endl; a-\u0026gt;print(); return 0; } 输出：\nStart printS(void *p, int s) 20 print()m_a = 1 printS() s_a = 10 printS(int s) 100 *a is valid print()m_a = 0 0 Finish ","permalink":"https://874656645.github.io/rick/posts/35-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F%E6%A8%A1%E6%9D%BF/","summary":"重载： 在同一作用域中，两个函数名相同，但是参数列表不同（个数、类型、顺序），返回值类型没有要求； 重写： 子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写； 重定义： 派生类中函数与基类中的函数同名，但是这个函数在基类中并没有被定义为虚函数 隐藏： 派生类中重定义了父类的函数，此时基类的函数会被隐藏； 模板： 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表，只适用于 参数个数相同而类型不同 的函数。 构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数  1、重载  类的静态函数也可以重载； 形参中一级指针和二级指针被认为是不同类型的参数；  class A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;print()\u0026#34; \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void freeP(A ** p){ if(p == NULL){ return; } if(*p != NULL){ free(*p); *p = NULL; } } void freeP(A * p){ if(p != NULL){ free(p); p = NULL; } } static void printS(){ cout \u0026lt;\u0026lt; \u0026#34;printS() s_a = \u0026#34; \u0026lt;\u0026lt; s_a \u0026lt;\u0026lt; endl; } static void printS(int s){ cout \u0026lt;\u0026lt; \u0026#34;printS(int s) \u0026#34; \u0026lt;\u0026lt; s_a * s \u0026lt;\u0026lt; endl; } static void printS(void *p, int s){ cout \u0026lt;\u0026lt; \u0026#34;printS(void *p, int s) \u0026#34; \u0026lt;\u0026lt; ((A*)p)-\u0026gt;m_a * s \u0026lt;\u0026lt; endl; } static int s_a; private: int m_a; }; int A::s_a = 0; int main( ) { A *a = new A(1); a-\u0026gt;printS(a, 20); a-\u0026gt;print(); A::s_a = 10; a-\u0026gt;printS(); a-\u0026gt;printS(10); a-\u0026gt;freeP(a); if(a == NULL){ cout \u0026lt;\u0026lt; \u0026#34;*a is not valid\u0026#34; \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; \u0026#34;*a is valid\u0026#34; \u0026lt;\u0026lt; endl; a-\u0026gt;print(); return 0; } 输出：","title":"函数重载、重写、隐藏、模板"},{"content":"当一个函数被声明为内联函数之后，在编译阶段，编译器会用内联函数的函数体取替换程序中出现的内联函数调用表达式，而其他的函数都是在运行时才被替换，这其实就是用空间换时间，提高了函数调用的效率。同时，内联函数具有几个特点：\n 适用于函数体积很小并频繁使用的函数 内联函数中不可以出现循环、递归或开关操作 内联函数的声明必须在函数定义之前 内联函数的定义必须出现在内联函数的第一次调用前 在类中声明同时定义的成员函数（除了虚函数）会自动隐式的当成内联函数 虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联  优点：\n 内联函数在被调用处进行代码展开，省去了参数压栈、跳转返回、栈帧开辟与回收，结果返回等操作，从而提高程序运行速度； 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换，而宏定义则不会； 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能； 内联函数在运行时可调试，而宏定义不可以。  缺点：\n 代码膨胀，消耗了更多的内存空间； inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接； 内联函数其实是不可控的，它只是对编译器的建议，是否对函数内联，决定权在于编译器; 不能对函数进行取址操作  ","permalink":"https://874656645.github.io/rick/posts/34-inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/","summary":"当一个函数被声明为内联函数之后，在编译阶段，编译器会用内联函数的函数体取替换程序中出现的内联函数调用表达式，而其他的函数都是在运行时才被替换，这其实就是用空间换时间，提高了函数调用的效率。同时，内联函数具有几个特点：\n 适用于函数体积很小并频繁使用的函数 内联函数中不可以出现循环、递归或开关操作 内联函数的声明必须在函数定义之前 内联函数的定义必须出现在内联函数的第一次调用前 在类中声明同时定义的成员函数（除了虚函数）会自动隐式的当成内联函数 虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联  优点：\n 内联函数在被调用处进行代码展开，省去了参数压栈、跳转返回、栈帧开辟与回收，结果返回等操作，从而提高程序运行速度； 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换，而宏定义则不会； 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能； 内联函数在运行时可调试，而宏定义不可以。  缺点：\n 代码膨胀，消耗了更多的内存空间； inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接； 内联函数其实是不可控的，它只是对编译器的建议，是否对函数内联，决定权在于编译器; 不能对函数进行取址操作  ","title":"inline 内联函数"},{"content":"Unix 的 fork 函数 fork函数可以创建一个和当前映像一样的子进程，这个函数会返回两个值：从子进程返回0，从父进程返回子进程的PID；\n 1）在父进程中，fork返回新创建子进程的进程ID； 2）在子进程中，fork返回0； 3）如果出现错误，fork返回一个负值；  #include \u0026lt;iostream\u0026gt;#include \u0026lt;unistd.h\u0026gt; using namespace std; int main() { pid_t fpid; //fpid表示fork函数返回的值  int count = 0; cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; fpid = fork(); if (fpid \u0026lt; 0) printf(\u0026#34;error in fork!\\n\u0026#34;); else if (fpid == 0) { printf(\u0026#34;i am the child process, my process id is %d\\n\u0026#34;,getpid()); cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; count++; } else { printf(\u0026#34;i am the parent process, my process id is %d\\n\u0026#34;,getpid()); cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; count++; } printf(\u0026#34;统计结果是: %d\\n\u0026#34;,count); return 0; } 输出：\nStart 0x7ffd3ed42530 i am the parent process, my process id is 22 0x7ffd3ed42530 统计结果是: 1 i am the child process, my process id is 23 0x7ffd3ed42530 统计结果是: 1 0 Finish ","permalink":"https://874656645.github.io/rick/posts/33-fork-unix/","summary":"Unix 的 fork 函数 fork函数可以创建一个和当前映像一样的子进程，这个函数会返回两个值：从子进程返回0，从父进程返回子进程的PID；\n 1）在父进程中，fork返回新创建子进程的进程ID； 2）在子进程中，fork返回0； 3）如果出现错误，fork返回一个负值；  #include \u0026lt;iostream\u0026gt;#include \u0026lt;unistd.h\u0026gt; using namespace std; int main() { pid_t fpid; //fpid表示fork函数返回的值  int count = 0; cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; fpid = fork(); if (fpid \u0026lt; 0) printf(\u0026#34;error in fork!\\n\u0026#34;); else if (fpid == 0) { printf(\u0026#34;i am the child process, my process id is %d\\n\u0026#34;,getpid()); cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; count++; } else { printf(\u0026#34;i am the parent process, my process id is %d\\n\u0026#34;,getpid()); cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; count++; } printf(\u0026#34;统计结果是: %d\\n\u0026#34;,count); return 0; } 输出：","title":"fork Unix"},{"content":"C++ 是 C 的超集和增强，校验更加严格\nC 主要是面向过程，C++ 是面向对象，面向过程是函数驱动，面向对象是对象驱动\n1 新增命名空间  给{}作用域起了个名称，后面不用加分号; 命名空间可以嵌套  namespace X { namespace Y { } } 2 新增引用类型  引用在一定程度上可以替代指针，作用与常指针类似 int * const a 引用没有定义，是一种关系声明，声明它和原有某一变量（实体）的关系，\n故而类型与原类型保持一致，且不分配内存，与被引用的变量有相同的地址 声明时必须初始化，一经声明，不可变更 可对引用再次引用，多次引用的结果是某一变量具有多个别名 \u0026amp; 符号在 = 号左边是引用，在 = 号右边为取地址  3 枚举检测增强  不能将整型隐式转化为枚举  4 变量定义增强  C++ 变量不必都声明在函数顶部，可以随使用随定义  5 全局变量定义检测严格  C 全局变量重复定义，C++ 不可以，全局变量检测增强  // C 语言 int g_val; // bss段 int g_val = 10; // data段 6 函数形参个数和函数返回值检测增强 // C 语言 f() // 默认返回值 int { return 10; } int g(int a) { return 10; } // 调用 g(10, 20, 30, 40); // 可编译通过，但是有警告 7 struct 结构体增强  功能与类基本等同，只不过 class 默认是 private 权限，struct 默认是 public 权限  // C 语言声明结构体变量 struct Student s; // C++ 语言声明结构体变量 Student s; 8 新增 bool 关键字，1 个字节  C 用 0 表示 false，非 0 表示 true C++ 中 bool 为 1 个字节，但是只有 true 和 false 两个值  9 三目运算符增强（语法糖）  C 中三目运算符不可以当左值  // C 语言 int a = 10, b = 20; ((a \u0026lt; b) ? a : b) = 50; // 错误 *((a \u0026lt; b) ? \u0026amp;a : \u0026amp;b) = 50; // 正确，a 此时是50 // C++ 三目运算左值 int a = 10, b = 20; ((a \u0026lt; b) ? a : b) = 50; // 正确，a 此时是50（返回的是引用） 10 const 增强  C中的 const 变量可以通过指针的方式进行修改，是假常量  // C 语言 const int a = 10; int *p = \u0026amp;a; *p = 20; printf(\u0026#34;a = %d\u0026#34;, a);  C++ 中的 const 变量放在了全局空间的符号表中，是不可更改的  // C++ 语言 const int a = 10; // 常量区符号表中（key value 键值对），编译过程中进行替换  // #define 是在预处理阶段展开，不受作用域限制 int *p = \u0026amp;a; // 在栈中开辟了一个临时变量空间 *p = 20; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // a = 10 cout \u0026lt;\u0026lt; \u0026#34;*p = \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; // *p = 20 ","permalink":"https://874656645.github.io/rick/posts/32-c-%E4%B8%8E-c++-%E7%9A%84%E5%B7%AE%E5%BC%82/","summary":"C++ 是 C 的超集和增强，校验更加严格\nC 主要是面向过程，C++ 是面向对象，面向过程是函数驱动，面向对象是对象驱动\n1 新增命名空间  给{}作用域起了个名称，后面不用加分号; 命名空间可以嵌套  namespace X { namespace Y { } } 2 新增引用类型  引用在一定程度上可以替代指针，作用与常指针类似 int * const a 引用没有定义，是一种关系声明，声明它和原有某一变量（实体）的关系，\n故而类型与原类型保持一致，且不分配内存，与被引用的变量有相同的地址 声明时必须初始化，一经声明，不可变更 可对引用再次引用，多次引用的结果是某一变量具有多个别名 \u0026amp; 符号在 = 号左边是引用，在 = 号右边为取地址  3 枚举检测增强  不能将整型隐式转化为枚举  4 变量定义增强  C++ 变量不必都声明在函数顶部，可以随使用随定义  5 全局变量定义检测严格  C 全局变量重复定义，C++ 不可以，全局变量检测增强  // C 语言 int g_val; // bss段 int g_val = 10; // data段 6 函数形参个数和函数返回值检测增强 // C 语言 f() // 默认返回值 int { return 10; } int g(int a) { return 10; } // 调用 g(10, 20, 30, 40); // 可编译通过，但是有警告 7 struct 结构体增强  功能与类基本等同，只不过 class 默认是 private 权限，struct 默认是 public 权限  // C 语言声明结构体变量 struct Student s; // C++ 语言声明结构体变量 Student s; 8 新增 bool 关键字，1 个字节  C 用 0 表示 false，非 0 表示 true C++ 中 bool 为 1 个字节，但是只有 true 和 false 两个值  9 三目运算符增强（语法糖）  C 中三目运算符不可以当左值  // C 语言 int a = 10, b = 20; ((a \u0026lt; b) ?","title":"C 与 C++ 的差异"},{"content":"int add(int count, ...) { // 指针大小与程序位数有关（32位指针是4个字节，64位指针是8个字节）  int intSize = sizeof(int*) / sizeof(int); int sum = 0; // cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl;  int *p = \u0026amp;count + intSize; // cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;  for (int i = 0; i \u0026lt; count; ++i) { sum += *p; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; p += intSize; } return sum; } int main() { cout \u0026lt;\u0026lt; add(3, 1, 2, 3) \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 2 3 6 ","permalink":"https://874656645.github.io/rick/posts/31-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%E5%85%A5%E6%A0%88/","summary":"int add(int count, ...) { // 指针大小与程序位数有关（32位指针是4个字节，64位指针是8个字节）  int intSize = sizeof(int*) / sizeof(int); int sum = 0; // cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl;  int *p = \u0026amp;count + intSize; // cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;  for (int i = 0; i \u0026lt; count; ++i) { sum += *p; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; p += intSize; } return sum; } int main() { cout \u0026lt;\u0026lt; add(3, 1, 2, 3) \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"函数形参从右到左入栈"},{"content":"1. 32 位和 64 位程序指针是多少位 32位指针大小为4个字节，64位指针大小位8个字节\n2. 指针加 1，是对该指针增加 1 个储存单位 “存储单位”，指的是指针指向的数据类型所占的内存的字节数。不同类型的指针加1后，增加的大小不同。\nint main() { int a[] = {1, 2, 3, 4, 5}; // \u0026amp;a是数组指针，其类型为 int (*)[5]，a是长度为5的int数组指针，所以要加 5*sizeof(int)，所以ptr实际是a[5]；  // \u0026amp;a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）  // 但是prt与(\u0026amp;a+1)类型是不一样的(这点很重要，prt指向的是整形)，所以prt-1只会减去sizeof(int)  int *ptr = (int*)(\u0026amp;a + 1); cout \u0026lt;\u0026lt; *(a + 1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *(ptr - 1) \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 2 3 6 注： a，\u0026amp;a的地址是一样的，但意思不一样：\n a是数组首地址，也就是a[0]的地址，a+1是数组下一元素的地址，即a[1] \u0026amp;a是对象（整个数组作为一个对象）首地址，而\u0026amp;a+1是下一个对象的地址，即a[5].  ","permalink":"https://874656645.github.io/rick/posts/30-%E6%8C%87%E9%92%88-+1/","summary":"1. 32 位和 64 位程序指针是多少位 32位指针大小为4个字节，64位指针大小位8个字节\n2. 指针加 1，是对该指针增加 1 个储存单位 “存储单位”，指的是指针指向的数据类型所占的内存的字节数。不同类型的指针加1后，增加的大小不同。\nint main() { int a[] = {1, 2, 3, 4, 5}; // \u0026amp;a是数组指针，其类型为 int (*)[5]，a是长度为5的int数组指针，所以要加 5*sizeof(int)，所以ptr实际是a[5]；  // \u0026amp;a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）  // 但是prt与(\u0026amp;a+1)类型是不一样的(这点很重要，prt指向的是整形)，所以prt-1只会减去sizeof(int)  int *ptr = (int*)(\u0026amp;a + 1); cout \u0026lt;\u0026lt; *(a + 1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *(ptr - 1) \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 2 3 6 注： a，\u0026amp;a的地址是一样的，但意思不一样：\n a是数组首地址，也就是a[0]的地址，a+1是数组下一元素的地址，即a[1] \u0026amp;a是对象（整个数组作为一个对象）首地址，而\u0026amp;a+1是下一个对象的地址，即a[5].  ","title":"指针 + 1"},{"content":"template\u0026lt;class T\u0026gt; class Test { public: Test(T t){ m_t = t;}; // explicit Test(T t){ m_t = t;};  T getValue(){ return m_t; }; private: T m_t; }; int main() { Test\u0026lt;int\u0026gt; tInt(1); cout \u0026lt;\u0026lt; tInt.getValue() \u0026lt;\u0026lt; endl; Test\u0026lt;double\u0026gt; tD(1.15); cout \u0026lt;\u0026lt; tD.getValue() \u0026lt;\u0026lt; endl; Test\u0026lt;float\u0026gt; tF = 1.3f; // 构造函数没有explicit修饰，可以隐式转换  cout \u0026lt;\u0026lt; tF.getValue() \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 1 1.15 1.3 0 Finish ","permalink":"https://874656645.github.io/rick/posts/29-%E6%A8%A1%E6%9D%BF%E7%B1%BB/","summary":"template\u0026lt;class T\u0026gt; class Test { public: Test(T t){ m_t = t;}; // explicit Test(T t){ m_t = t;};  T getValue(){ return m_t; }; private: T m_t; }; int main() { Test\u0026lt;int\u0026gt; tInt(1); cout \u0026lt;\u0026lt; tInt.getValue() \u0026lt;\u0026lt; endl; Test\u0026lt;double\u0026gt; tD(1.15); cout \u0026lt;\u0026lt; tD.getValue() \u0026lt;\u0026lt; endl; Test\u0026lt;float\u0026gt; tF = 1.3f; // 构造函数没有explicit修饰，可以隐式转换  cout \u0026lt;\u0026lt; tF.getValue() \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 1 1.15 1.3 0 Finish ","title":"模板类"},{"content":"template \u0026lt;typename T\u0026gt; inline const T\u0026amp; Max (const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? b:a; }; int main() { int i = 39; int j = 20; cout \u0026lt;\u0026lt; \u0026#34;Max(i, j): \u0026#34; \u0026lt;\u0026lt; Max(i, j) \u0026lt;\u0026lt; endl; double f1 = 13.5; double f2 = 20.7; cout \u0026lt;\u0026lt; \u0026#34;Max(f1, f2): \u0026#34; \u0026lt;\u0026lt; Max(f1, f2) \u0026lt;\u0026lt; endl; string s1 = \u0026#34;Hello\u0026#34;; string s2 = \u0026#34;World\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Max(s1, s2): \u0026#34; \u0026lt;\u0026lt; Max(s1, s2) \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart Max(i, j): 39 Max(f1, f2): 20.7 Max(s1, s2): World 0 Finish ","permalink":"https://874656645.github.io/rick/posts/28-%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/","summary":"template \u0026lt;typename T\u0026gt; inline const T\u0026amp; Max (const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? b:a; }; int main() { int i = 39; int j = 20; cout \u0026lt;\u0026lt; \u0026#34;Max(i, j): \u0026#34; \u0026lt;\u0026lt; Max(i, j) \u0026lt;\u0026lt; endl; double f1 = 13.5; double f2 = 20.7; cout \u0026lt;\u0026lt; \u0026#34;Max(f1, f2): \u0026#34; \u0026lt;\u0026lt; Max(f1, f2) \u0026lt;\u0026lt; endl; string s1 = \u0026#34;Hello\u0026#34;; string s2 = \u0026#34;World\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Max(s1, s2): \u0026#34; \u0026lt;\u0026lt; Max(s1, s2) \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"模板函数"},{"content":" 注：软件版本为10.6，需要 服务端 token 注：天地图官网的服务（https://t0.tianditu.gov.cn/img_w/wmts）使用的 dpi 大小采用的是国家标准，并不是OGC标准，会导致 ArcMap 加载后坐标不对  影像底图：\nhttp://t0.tianditu.com/img_c/esri/wmts 天地图影像（经纬度，CGCS2000）\nhttp://t0.tianditu.com/cia_c/esri/wmts 天地图影像注记（经纬度，CGCS2000）\nhttp://t0.tianditu.com/img_w/esri/wmts 天地图影像（墨卡托，WGS1984）\nhttp://t0.tianditu.com/cia_w/esri/wmts 天地图影像注记（墨卡托，WGS1984）\n矢量底图：\nhttp://t0.tianditu.com/vec_c/esri/wmts 天地图矢量（经纬度，CGCS2000）\nhttp://t0.tianditu.com/cva_c/esri/wmts 天地图矢量注记（经纬度，CGCS2000）\nhttp://t0.tianditu.com/vec_w/esri/wmts 天地图矢量（墨卡托，WGS1984）\nhttp://t0.tianditu.com/cva_w/esri/wmts 天地图矢量注记（墨卡托，WGS1984）\nArcMap WMTS\n","permalink":"https://874656645.github.io/rick/posts/27-arcmap-%E5%8A%A0%E8%BD%BD%E5%A4%A9%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1/","summary":"注：软件版本为10.6，需要 服务端 token 注：天地图官网的服务（https://t0.tianditu.gov.cn/img_w/wmts）使用的 dpi 大小采用的是国家标准，并不是OGC标准，会导致 ArcMap 加载后坐标不对  影像底图：\nhttp://t0.tianditu.com/img_c/esri/wmts 天地图影像（经纬度，CGCS2000）\nhttp://t0.tianditu.com/cia_c/esri/wmts 天地图影像注记（经纬度，CGCS2000）\nhttp://t0.tianditu.com/img_w/esri/wmts 天地图影像（墨卡托，WGS1984）\nhttp://t0.tianditu.com/cia_w/esri/wmts 天地图影像注记（墨卡托，WGS1984）\n矢量底图：\nhttp://t0.tianditu.com/vec_c/esri/wmts 天地图矢量（经纬度，CGCS2000）\nhttp://t0.tianditu.com/cva_c/esri/wmts 天地图矢量注记（经纬度，CGCS2000）\nhttp://t0.tianditu.com/vec_w/esri/wmts 天地图矢量（墨卡托，WGS1984）\nhttp://t0.tianditu.com/cva_w/esri/wmts 天地图矢量注记（墨卡托，WGS1984）\nArcMap WMTS","title":"ArcMap 加载天地图服务"},{"content":"#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;using namespace std; // 声明函数指针 int (*fn)(int); // 定义函数指针类型 typedef int (*Fn)(int); int cal(int v){ return v; }; // 函数指针做为形参 void proc(int v, Fn f){ cout \u0026lt;\u0026lt; f(v) \u0026lt;\u0026lt; endl; }; int main() { fn = cal; cout \u0026lt;\u0026lt; (*fn)(10) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; fn(10) \u0026lt;\u0026lt; endl; Fn f1 = cal; cout \u0026lt;\u0026lt; (*f1)(20) \u0026lt;\u0026lt; endl; proc(30, cal); return 0; } Start 10 10 20 30 0 Finish ","permalink":"https://874656645.github.io/rick/posts/26-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/","summary":"#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;using namespace std; // 声明函数指针 int (*fn)(int); // 定义函数指针类型 typedef int (*Fn)(int); int cal(int v){ return v; }; // 函数指针做为形参 void proc(int v, Fn f){ cout \u0026lt;\u0026lt; f(v) \u0026lt;\u0026lt; endl; }; int main() { fn = cal; cout \u0026lt;\u0026lt; (*fn)(10) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; fn(10) \u0026lt;\u0026lt; endl; Fn f1 = cal; cout \u0026lt;\u0026lt; (*f1)(20) \u0026lt;\u0026lt; endl; proc(30, cal); return 0; } Start 10 10 20 30 0 Finish ","title":"函数指针"},{"content":"  指针函数本质是一个函数，返回值是一个指针；\n  函数指针是指向函数的一个指针变量；\n  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt; using namespace std; // 指针函数fun char * fun(const char * p) { cout \u0026lt;\u0026lt; \u0026#34;fun: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return nullptr; }; // 函数指针pf char * (*pf)(const char * p); int main() { pf = fun; // 函数指针pf指向函数fun  pf(\u0026#34;Hello\u0026#34;); return 0; } ","permalink":"https://874656645.github.io/rick/posts/25-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/","summary":"  指针函数本质是一个函数，返回值是一个指针；\n  函数指针是指向函数的一个指针变量；\n  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt; using namespace std; // 指针函数fun char * fun(const char * p) { cout \u0026lt;\u0026lt; \u0026#34;fun: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return nullptr; }; // 函数指针pf char * (*pf)(const char * p); int main() { pf = fun; // 函数指针pf指向函数fun  pf(\u0026#34;Hello\u0026#34;); return 0; } ","title":"指针函数和函数指针"},{"content":" 修饰构造函数，防止隐式转换，复制初始化，复制列表初始化 修饰转换函数，可以防止隐式转换，但按语境转换除外 explicit 可加在带多个参数的构造方法上(converting to ‘XXX’ from initializer list)  struct B { explicit B(int) {} explicit operator bool() const { return true; } }; int main() { B b1(1); // OK：直接初始化  B b2 = 1; // 错误：被 explicit 修饰构造函数的对象不可以复制初始化  B b3{ 1 }; // OK：直接列表初始化  B b4 = { 1 }; // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化  B b5 = (B)1; // OK：允许 static_cast 的显式转换  if (b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b6(b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b7 = b1; // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换  bool b8 = static_cast\u0026lt;bool\u0026gt;(b1); // OK：static_cast 进行直接初始化  return 0; } 从初始化列表隐式转换：\nclass T{ public: T(int a, int b){ cout \u0026lt;\u0026lt; \u0026#34;T(int, int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; this-\u0026gt;b = b; } ~T(){ cout \u0026lt;\u0026lt; \u0026#34;~T()...\u0026#34; \u0026lt;\u0026lt; endl; } void printT(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } private: int a; int b; }; T func(){ cout \u0026lt;\u0026lt; \u0026#34;in func()...\u0026#34; \u0026lt;\u0026lt; endl; return {3, 4}; } int main() { T t = func(); t.printT(); return 0; } 输出：\nin func()... T(int, int)... a = 3, b = 4 ~T()... ","permalink":"https://874656645.github.io/rick/posts/24-explicit-%E5%85%B3%E9%94%AE%E5%AD%97/","summary":"修饰构造函数，防止隐式转换，复制初始化，复制列表初始化 修饰转换函数，可以防止隐式转换，但按语境转换除外 explicit 可加在带多个参数的构造方法上(converting to ‘XXX’ from initializer list)  struct B { explicit B(int) {} explicit operator bool() const { return true; } }; int main() { B b1(1); // OK：直接初始化  B b2 = 1; // 错误：被 explicit 修饰构造函数的对象不可以复制初始化  B b3{ 1 }; // OK：直接列表初始化  B b4 = { 1 }; // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化  B b5 = (B)1; // OK：允许 static_cast 的显式转换  if (b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b6(b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b7 = b1; // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换  bool b8 = static_cast\u0026lt;bool\u0026gt;(b1); // OK：static_cast 进行直接初始化  return 0; } 从初始化列表隐式转换：","title":"explicit（显式）关键字"},{"content":"局部变量、静态局部变量、全局变量、全局静态变量、字符串常量以及动态申请的内存区\n 局部变量存储在栈中 全局变量、静态变量（全局和局部静态变量）存储在静态存储区 new申请的内存是在堆中 字符串常量也是存储在静态存储区   栈中的变量内存会随着定义所在区间的结束自动释放；而对于堆，需要手动free，否则它就一直存在，直到程序结束； 对于静态存储区，其中的变量常量在程序运行期间会一直存在，不会释放，且变量常量在其中只有一份拷贝，不会出现相同的变量和常量的不同拷贝。  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt; using namespace std; //返回的是局部变量的地址，该地址位于动态数据区，栈里 char *s1() { char* p1 = \u0026#34;qqq\u0026#34;;//为了测试‘char p[]=\u0026#34;Hello world!\u0026#34;’中的字符串在静态存储区是否也有一份拷贝  char p[]=\u0026#34;Hello world!\u0026#34;; char* p2 = \u0026#34;w\u0026#34;;//为了测试‘char p[]=\u0026#34;Hello world!\u0026#34;’中的字符串在静态存储区是否也有一份拷贝  printf(\u0026#34;in s1 p=%p\\n\u0026#34;, p); printf(\u0026#34;in s1 p1=%p\\n\u0026#34;, p1); printf(\u0026#34;in s1: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!\u0026#34;)); printf(\u0026#34;in s1 p2=%p\\n\u0026#34;, p2); return p1; // 这里不能返回局部变量 p } //返回的是字符串常量的地址，该地址位于静态数据区 char *s2() { char *q=\u0026#34;Hello world!\u0026#34;; printf(\u0026#34;in s2 q=%p\\n\u0026#34;, q); printf(\u0026#34;in s2: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!\u0026#34;)); return q; } //返回的是静态局部变量的地址，该地址位于静态数据区 char *s3() { static char r[]=\u0026#34;Hello world!\u0026#34;; printf(\u0026#34;in s3 r=%p\\n\u0026#34;, r); printf(\u0026#34;in s3: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!\u0026#34;)); return r; } int main() { char *t1, *t2, *t3; t1=s1(); t2=s2(); t3=s3(); printf(\u0026#34;in main:\u0026#34;); printf(\u0026#34;p=%p, q=%p, r=%p\\n\u0026#34;, t1, t2, t3); printf(\u0026#34;%s\\n\u0026#34;, t1); printf(\u0026#34;%s\\n\u0026#34;, t2); printf(\u0026#34;%s\\n\u0026#34;, t3); cout \u0026lt;\u0026lt; sizeof(\u0026#39;a\u0026#39;) \u0026lt;\u0026lt; endl; return 0; } 输出：\nin s1 p=0x7ffef76f34d3 in s1 p1=0x401010 in s1: string\u0026#39;s address: 0x40102f in s1 p2=0x401014 in s2 q=0x40102f in s2: string\u0026#39;s address: 0x40102f in s3 r=0x601798 in s3: string\u0026#39;s address: 0x40102f in main:p=0x401010, q=0x40102f, r=0x601798 qqq Hello world! Hello world! 1 这个结果正好应证了上面解释，同时，还可是得出一个结论： 字符串常量，之所以称之为常量，因为它可一看作是一个没有命名的字符串且为常量，存放在静态数据区。 这里说的静态数据区，是相对于堆、栈等动态数据区而言的。 静态数据区存放的是全局变量和静态变量，从这一点上来说，字符串常量又可以称之为一个无名的静态变量， 因为\u0026quot;Hello world!\u0026quot;这个字符串在函数 s1和s2 中都引用了，但在内存中却只有一份拷贝，这与静态变量性质相当神似。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt;int main() { const char *b = NULL, *c = NULL; char a[] = \u0026#34;hello world!\u0026#34;; b = \u0026#34;hello world!\u0026#34;; c = \u0026#34;hello world!\u0026#34;; printf(\u0026#34;%p\\n\u0026#34;, a); printf(\u0026#34;%p\\n\u0026#34;, b); printf(\u0026#34;%p\\n\u0026#34;, c); printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;(\u0026#34;hello world!\u0026#34;)); } 输出：\nStart 0x7ffca882ddf3 0x400d40 0x400d40 0x400d40 0 Finish ","permalink":"https://874656645.github.io/rick/posts/23-c++-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8/","summary":"局部变量、静态局部变量、全局变量、全局静态变量、字符串常量以及动态申请的内存区\n 局部变量存储在栈中 全局变量、静态变量（全局和局部静态变量）存储在静态存储区 new申请的内存是在堆中 字符串常量也是存储在静态存储区   栈中的变量内存会随着定义所在区间的结束自动释放；而对于堆，需要手动free，否则它就一直存在，直到程序结束； 对于静态存储区，其中的变量常量在程序运行期间会一直存在，不会释放，且变量常量在其中只有一份拷贝，不会出现相同的变量和常量的不同拷贝。  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt; using namespace std; //返回的是局部变量的地址，该地址位于动态数据区，栈里 char *s1() { char* p1 = \u0026#34;qqq\u0026#34;;//为了测试‘char p[]=\u0026#34;Hello world!\u0026#34;’中的字符串在静态存储区是否也有一份拷贝  char p[]=\u0026#34;Hello world!\u0026#34;; char* p2 = \u0026#34;w\u0026#34;;//为了测试‘char p[]=\u0026#34;Hello world!\u0026#34;’中的字符串在静态存储区是否也有一份拷贝  printf(\u0026#34;in s1 p=%p\\n\u0026#34;, p); printf(\u0026#34;in s1 p1=%p\\n\u0026#34;, p1); printf(\u0026#34;in s1: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!\u0026#34;)); printf(\u0026#34;in s1 p2=%p\\n\u0026#34;, p2); return p1; // 这里不能返回局部变量 p } //返回的是字符串常量的地址，该地址位于静态数据区 char *s2() { char *q=\u0026#34;Hello world!\u0026#34;; printf(\u0026#34;in s2 q=%p\\n\u0026#34;, q); printf(\u0026#34;in s2: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!","title":"C++ 字符串常量存储"},{"content":"1、const 修饰指针和引用 常对象：const Class A 只能调用 const 成员函数\n常量指针：const int * 所指的地址内容为 常量只读，但是可指向其它对象的地址（可以重指向）\n指针常量：int * const 指针所指的地址不能变（不可以重指向），但地址的内容可以被修改，与引用变量效果类似\n常量引用：const int \u0026amp; 相当于是对象的一个别名，对象内容为 只读，并且不能指向其它对象\nconst int \u0026amp;a = 40 与 constexpr int a = 40 效果类似，但后者只能在全局区声明\nconst int \u0026amp;a = 40 等同于 const int * const a = new int(40)（指针的指向和存放的内容都不可更改）\nClassA myA(10), myB(-10); const ClassA a; // 常对象（只能调用常成员函数） const ClassA * b = \u0026amp;myA; // 常量指针 ClassA * const b = \u0026amp;myA; // 指针常量 const ClassA \u0026amp;bb = myB; // 常量引用  b = \u0026amp;myB; // 合法（可以指向其它对象） b-\u0026gt;setA(10); // 错误（只读） bb.setA(100); // 错误（只读） bb = myA; // 错误（不可指向其它对象） char greet[] = \u0026#34;Hello\u0026#34;, w[] = \u0026#34;World\u0026#34;; const char * p = greet; char * const pp = greet; cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; *p = \u0026#39;W\u0026#39;; //error: assignment of read-only location \u0026#39;* p\u0026#39;  // *p = \u0026#39;W\u0026#39;; p = w; // 合法（常量指针可以改变指向，不能改变存储的内容） pp = w; //error: assignment of read-only variable \u0026#39;pp\u0026#39;  // pp = w; *pp = \u0026#39;W\u0026#39;; // 合法（指针常量可以改变存储的内容，不能改变指向） cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; w \u0026lt;\u0026lt; endl; return 0; 2、const变量存放位置  局部变量存放在栈区 对于全局对象，编译期一般不分配内存，放在符号表中以提高访问效率 对于字面值常量，存放在常量存储区  ","permalink":"https://874656645.github.io/rick/posts/22-const-%E4%BF%AE%E9%A5%B0%E7%AC%A6/","summary":"1、const 修饰指针和引用 常对象：const Class A 只能调用 const 成员函数\n常量指针：const int * 所指的地址内容为 常量只读，但是可指向其它对象的地址（可以重指向）\n指针常量：int * const 指针所指的地址不能变（不可以重指向），但地址的内容可以被修改，与引用变量效果类似\n常量引用：const int \u0026amp; 相当于是对象的一个别名，对象内容为 只读，并且不能指向其它对象\nconst int \u0026amp;a = 40 与 constexpr int a = 40 效果类似，但后者只能在全局区声明\nconst int \u0026amp;a = 40 等同于 const int * const a = new int(40)（指针的指向和存放的内容都不可更改）\nClassA myA(10), myB(-10); const ClassA a; // 常对象（只能调用常成员函数） const ClassA * b = \u0026amp;myA; // 常量指针 ClassA * const b = \u0026amp;myA; // 指针常量 const ClassA \u0026amp;bb = myB; // 常量引用  b = \u0026amp;myB; // 合法（可以指向其它对象） b-\u0026gt;setA(10); // 错误（只读） bb.","title":"const 修饰符"},{"content":" 路径中有空格  m_process-\u0026gt;startDetached(strAppDir + \u0026quot;/ThreeDScreen.exe\u0026quot;, QStringList())\n杀死一个进程（注：-t 参数会将创建的子进程一起杀死）  QProcess::startDetached(\u0026quot;taskkill -t -f /IM iexplore.exe\u0026quot;);\n","permalink":"https://874656645.github.io/rick/posts/21-qprocess-%E4%BD%BF%E7%94%A8/","summary":"路径中有空格  m_process-\u0026gt;startDetached(strAppDir + \u0026quot;/ThreeDScreen.exe\u0026quot;, QStringList())\n杀死一个进程（注：-t 参数会将创建的子进程一起杀死）  QProcess::startDetached(\u0026quot;taskkill -t -f /IM iexplore.exe\u0026quot;);","title":"QProcess 使用"},{"content":" QString使用的是UTF-8编码 从字符常量中获取中文  QString msg = QString::fromLocal8Bit(\u0026quot;This is a debug message at 中文\u0026quot;);\n以QString做为形参变量传递  qDebug(msg.toUtf8());\nQString与操作系统间读写，会自动将UTF-8与操作系统的编码做转换（比如日志系统）  void QtLog::WriteLine(const QString \u0026amp;logFileName, const QString \u0026amp;logMsg) { QFile file(logFileName); file.open(QIODevice::WriteOnly | QIODevice::Append); QTextStream text_stream(\u0026amp;file); text_stream \u0026lt;\u0026lt; logMsg \u0026lt;\u0026lt; \u0026#34;\\r\\n\u0026#34;; file.flush(); file.close(); } QString strAppDir = QCoreApplication::applicationDirPath(); // 不用转码  QString message, text, fileName = strAppDir + \u0026#34;/Log/\u0026#34;; QDir dir(fileName); if (!dir.exists()) { // 注：不能创建两级文件夹  bool ismkdir = dir.mkdir(fileName); } ","permalink":"https://874656645.github.io/rick/posts/20-qstring-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","summary":" QString使用的是UTF-8编码 从字符常量中获取中文  QString msg = QString::fromLocal8Bit(\u0026quot;This is a debug message at 中文\u0026quot;);\n以QString做为形参变量传递  qDebug(msg.toUtf8());\nQString与操作系统间读写，会自动将UTF-8与操作系统的编码做转换（比如日志系统）  void QtLog::WriteLine(const QString \u0026amp;logFileName, const QString \u0026amp;logMsg) { QFile file(logFileName); file.open(QIODevice::WriteOnly | QIODevice::Append); QTextStream text_stream(\u0026amp;file); text_stream \u0026lt;\u0026lt; logMsg \u0026lt;\u0026lt; \u0026#34;\\r\\n\u0026#34;; file.flush(); file.close(); } QString strAppDir = QCoreApplication::applicationDirPath(); // 不用转码  QString message, text, fileName = strAppDir + \u0026#34;/Log/\u0026#34;; QDir dir(fileName); if (!dir.exists()) { // 注：不能创建两级文件夹  bool ismkdir = dir.mkdir(fileName); } ","title":"QString 中文乱码"},{"content":"1、设置IE为单进程模式  64位操作系统的 IE 默认每个 Tab 页都是一个进程，并且 Tab 页的进程是 32 位的，主进程是 64 位的，如下图所示  值为0时是单进程模式，1是多进程\n","permalink":"https://874656645.github.io/rick/posts/19-ie64-%E4%BD%8D%E6%8F%92%E4%BB%B6/","summary":"1、设置IE为单进程模式  64位操作系统的 IE 默认每个 Tab 页都是一个进程，并且 Tab 页的进程是 32 位的，主进程是 64 位的，如下图所示  值为0时是单进程模式，1是多进程","title":"IE 64位插件"},{"content":"1、查看纹理 渲染——材质编辑器——精简材质编辑器\n2、合并Mesh——附加 3、资源跟踪器快捷键 Shift + T ","permalink":"https://874656645.github.io/rick/posts/18-3dmax-%E6%93%8D%E4%BD%9C/","summary":"1、查看纹理 渲染——材质编辑器——精简材质编辑器\n2、合并Mesh——附加 3、资源跟踪器快捷键 Shift + T ","title":"3DMax 操作"},{"content":"1、随机数 python 脚本\nimport random def randNum(): res = random.randint(1, 7) return res 2、自增 python 脚本\ntotal = 0 def accumulate(increment): global total if total: total += increment else: total = increment return total ","permalink":"https://874656645.github.io/rick/posts/17-arcgis-%E5%AD%97%E6%AE%B5%E9%9A%8F%E6%9C%BA%E6%95%B0/","summary":"1、随机数 python 脚本\nimport random def randNum(): res = random.randint(1, 7) return res 2、自增 python 脚本\ntotal = 0 def accumulate(increment): global total if total: total += increment else: total = increment return total ","title":"ArcGIS 字段计算（自增、随机数）"},{"content":"1、随机数 SQL 脚本\nupdate \u0026#34;CYBuildings2\u0026#34; set \u0026#34;imgIndex\u0026#34; = FLOOR(1 + (RANDOM()+9223372036854775808)/2.0/9223372036854775808 * 7); ","permalink":"https://874656645.github.io/rick/posts/16-sqlite-%E9%9A%8F%E6%9C%BA%E6%95%B0/","summary":"1、随机数 SQL 脚本\nupdate \u0026#34;CYBuildings2\u0026#34; set \u0026#34;imgIndex\u0026#34; = FLOOR(1 + (RANDOM()+9223372036854775808)/2.0/9223372036854775808 * 7); ","title":"Sqlite 随机数"},{"content":"查看库的版本（win32 or 64） 1、通过 vs 自带工具 dumpbin.exe dumpbin.exe /headers dll文件路径\n2、使用 notepad++ 直接用 记事本 或者 notepad++ 打开exe文件（dll文件），会有很多乱码，不要头疼，接下来只需要在第二段中找到 PE 两个字母，在其后的不远出会出现d 或者L。若是d，则证明该程序是64位；若是L，则证明是32位。\n","permalink":"https://874656645.github.io/rick/posts/15-%E6%9F%A5%E7%9C%8B-dll-%E7%89%88%E6%9C%AC/","summary":"查看库的版本（win32 or 64） 1、通过 vs 自带工具 dumpbin.exe dumpbin.exe /headers dll文件路径\n2、使用 notepad++ 直接用 记事本 或者 notepad++ 打开exe文件（dll文件），会有很多乱码，不要头疼，接下来只需要在第二段中找到 PE 两个字母，在其后的不远出会出现d 或者L。若是d，则证明该程序是64位；若是L，则证明是32位。","title":"查看 dll 版本"},{"content":"miniconda包管理器常用命令 0、指定conda的工作平台 set CONDA_FORCE_32BIT=1 // 指定 conda 的工作平台为 win-32\nset CONDA_FORCE_32BIT= // 指定 conda 的工作平台为 x64\n1、指定conda的资源镜像 # 推荐使用中科大的 conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free # 清华的镜像好像用不了了 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free # 设置搜索时显示通道地址 conda config --set show_channel_urls yes 执行此命令后会在当前的用户文件夹下生成一个 .condarc 的配置文件\n2、搜索某个库的所有版本 conda search gdal\n3、查看当前环境下已安装的包 conda list\n4、创建一个虚拟环境 conda create --name python34 python=3.4\n5、激活某个环境 activate python34 // for windows\nsource activate python34 // for Linux \u0026amp; Mac\n6、取消激活 conda deactivate // for windows\nsource conda deactivate // for Linux \u0026amp; Mac\n7、删除一个环境 conda remove --name python34 --all\n8、查看已安装的环境 conda info -e\n9、查看当前激活环境下的安装包 conda list\n10、查看某个指定环境的安装包 conda list -n python34\n11、安装到当前激活环境 conda install gdal\n12、安装到指定环境 conda install -n python34 numpy\n13、清理 conda clean -p // 删除没有用的包\nconda clean -t // 删除tar打包\n14、查看帮助 conda --help conda -h conda env -h conda update -h 15、查看当前所有环境 conda info --envs\n","permalink":"https://874656645.github.io/rick/posts/14-conda-learn/","summary":"miniconda包管理器常用命令 0、指定conda的工作平台 set CONDA_FORCE_32BIT=1 // 指定 conda 的工作平台为 win-32\nset CONDA_FORCE_32BIT= // 指定 conda 的工作平台为 x64\n1、指定conda的资源镜像 # 推荐使用中科大的 conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free # 清华的镜像好像用不了了 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free # 设置搜索时显示通道地址 conda config --set show_channel_urls yes 执行此命令后会在当前的用户文件夹下生成一个 .condarc 的配置文件\n2、搜索某个库的所有版本 conda search gdal\n3、查看当前环境下已安装的包 conda list\n4、创建一个虚拟环境 conda create --name python34 python=3.4\n5、激活某个环境 activate python34 // for windows\nsource activate python34 // for Linux \u0026amp; Mac\n6、取消激活 conda deactivate // for windows","title":"Conda Learn"},{"content":"win10 小娜开始菜单无法搜索应用 1.用管理员权限打开 powershell.exe 或者 cmd;\n2.在其中输入下列命令，重新注册激活小娜\nGet-AppXPackage -Name Microsoft.Windows.Cortana | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register \u0026quot;$($_.InstallLocation)\\AppXManifest.xml\u0026quot;}\n","permalink":"https://874656645.github.io/rick/posts/13-restart-cortana/","summary":"win10 小娜开始菜单无法搜索应用 1.用管理员权限打开 powershell.exe 或者 cmd;\n2.在其中输入下列命令，重新注册激活小娜\nGet-AppXPackage -Name Microsoft.Windows.Cortana | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register \u0026quot;$($_.InstallLocation)\\AppXManifest.xml\u0026quot;}","title":"Restart Cortana"},{"content":"cmake命令\n1、生成 VS 2015 win64 版本的解决方案 注：下面的命令要在cmd下使用，power shell不可以\ncmake -H. -B./cmk_build/Win64 -G \u0026quot;Visual Studio 15 2017 Win64\u0026quot;\n2、指定目标版本 cmake -D CMAKE_SYSTEM_VERSION=8.1 -H. -B./cmk_build/Win64 -G \u0026quot;Visual Studio 15 2017 Win64\u0026quot;\n3、使用 MinGW 编译器 cmake -H. -B./cmk_build/MinGW -G \u0026quot;MinGW Makefiles\u0026quot;\n","permalink":"https://874656645.github.io/rick/posts/12-cmake-learn/","summary":"cmake命令\n1、生成 VS 2015 win64 版本的解决方案 注：下面的命令要在cmd下使用，power shell不可以\ncmake -H. -B./cmk_build/Win64 -G \u0026quot;Visual Studio 15 2017 Win64\u0026quot;\n2、指定目标版本 cmake -D CMAKE_SYSTEM_VERSION=8.1 -H. -B./cmk_build/Win64 -G \u0026quot;Visual Studio 15 2017 Win64\u0026quot;\n3、使用 MinGW 编译器 cmake -H. -B./cmk_build/MinGW -G \u0026quot;MinGW Makefiles\u0026quot;","title":"Cmake Learn"},{"content":"vcpkg安装及使用\n注意：需要安装vs的英文语言包1、指定 vcpkg 中 msvc 的编译版本 在 vcpkg/triplets/文件夹下的所有cmake文件中添加代码 set(VCPKG_PLATFORM_TOOLSET v140)\n如果同时安装了vs2017，需要确保安装vs2017的英文语言包\n","permalink":"https://874656645.github.io/rick/posts/11-vcpkg-learn/","summary":"vcpkg安装及使用\n注意：需要安装vs的英文语言包1、指定 vcpkg 中 msvc 的编译版本 在 vcpkg/triplets/文件夹下的所有cmake文件中添加代码 set(VCPKG_PLATFORM_TOOLSET v140)\n如果同时安装了vs2017，需要确保安装vs2017的英文语言包","title":"Vcpkg Learn"},{"content":"Power shell执行策略 原文网址\n1、查看当前的安全策略 Get-ExecutionPolicy\n2、修改执行策略 ps:这种方法会将执行策略保存到注册表\nSet-ExecutionPolicy UnRestricted\nor\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned\n3、查看所有支持的执行策略 [System.Enum]::GetNames([Microsoft.PowerShell.ExecutionPolicy])\n4、获取影响当前会话的所有执行策略 Get-ExecutionPolicy -List\n6、为当前 Windows PowerShell 会话设置执行策略 PowerShell.exe -ExecutionPolicy RemoteSigned\n","permalink":"https://874656645.github.io/rick/posts/10-power-shell-executionpolicy/","summary":"Power shell执行策略 原文网址\n1、查看当前的安全策略 Get-ExecutionPolicy\n2、修改执行策略 ps:这种方法会将执行策略保存到注册表\nSet-ExecutionPolicy UnRestricted\nor\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned\n3、查看所有支持的执行策略 [System.Enum]::GetNames([Microsoft.PowerShell.ExecutionPolicy])\n4、获取影响当前会话的所有执行策略 Get-ExecutionPolicy -List\n6、为当前 Windows PowerShell 会话设置执行策略 PowerShell.exe -ExecutionPolicy RemoteSigned","title":"Power Shell ExecutionPolicy"},{"content":"1、使用requests库访问网址 2、使用xpath技术提取网页目标图片网址 3、通过os库保存图片到本地 #coding = utf-8 import requests import os from lxml import etree from urllib.parse import quote,unquote # import urllib.request class DmdSpider(object): name = \u0026#34;dmd\u0026#34; save_path = \u0026#39;E:/python/manhuadao/pics/\u0026#39; __picNo = 0 # 访问漫画岛网页 def start_request(self, url): header = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\u0026#39;} r = requests.get(url, params=header) # print(r.text) self.__get_imgs(r) # 自动跳转下一页 html = etree.HTML(r.text) next_urls = html.xpath(\u0026#39;//div[@class=\u0026#34;read-bottom\u0026#34;]//a[@class=\u0026#34;next\u0026#34;]/@href\u0026#39;) # print(next) for href in next_urls: nexturl = href.split(\u0026#39;=\u0026#39;)[-1] self.start_request(unquote(nexturl)) # 使用xpath提取网页中的图片网址 def __get_imgs(self, resbonse): html = etree.HTML(resbonse.text) # print(html) # result = etree.tostring(html) # print(result.decode(\u0026#34;utf-8\u0026#34;)) img_srcs = html.xpath(\u0026#39;//div[@class=\u0026#34;center-t\u0026#34;]//div[@class=\u0026#34;main-content\u0026#34;]//img/@src\u0026#39;) # print(img_srcs) for url in img_srcs: self.__save_img(url) # 下载图片 def __save_img(self, url): # arr = url.split(\u0026#39;-\u0026#39;) # picName = arr[-1].split(\u0026#39;.\u0026#39;)[0] header = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\u0026#39;} # request = urllib.request.Request(url, None, header)  # response = urllib.request.urlopen(request) # with open(\u0026#39;E:/python/manhuadao/pics/%s.jpg\u0026#39; %picName, \u0026#34;wb\u0026#34;) as f: # f.write(response.read()) # print(response) response = requests.get(url, params = header) # print(response.content) if not os.path.exists(self.save_path): os.makedirs(self.save_path) with open(self.save_path + \u0026#39;%s.jpg\u0026#39;%self.__picNo, \u0026#34;wb\u0026#34;) as f: f.write(response.content) self.__picNo = self.__picNo + 1 def main(): dmd = DmdSpider() dmd.start_request(\u0026#39;http://www.manhuadao.cn/Comic/ComicView?comicid=58df8c73d401da325c9cf77c\u0026amp;chapterid=9587480\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: main() ","permalink":"https://874656645.github.io/rick/posts/9-crawl-pictures-from-website/","summary":"1、使用requests库访问网址 2、使用xpath技术提取网页目标图片网址 3、通过os库保存图片到本地 #coding = utf-8 import requests import os from lxml import etree from urllib.parse import quote,unquote # import urllib.request class DmdSpider(object): name = \u0026#34;dmd\u0026#34; save_path = \u0026#39;E:/python/manhuadao/pics/\u0026#39; __picNo = 0 # 访问漫画岛网页 def start_request(self, url): header = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\u0026#39;} r = requests.get(url, params=header) # print(r.text) self.__get_imgs(r) # 自动跳转下一页 html = etree.HTML(r.text) next_urls = html.xpath(\u0026#39;//div[@class=\u0026#34;read-bottom\u0026#34;]//a[@class=\u0026#34;next\u0026#34;]/@href\u0026#39;) # print(next) for href in next_urls: nexturl = href.","title":"Crawl Pictures From Website"},{"content":"原文网址\n在python中使用virtualenv创建虚拟环境 注意：要使用cmd命令行，不能使用Power Shell1、使用pip安装 pip install virtualenv\n2、创建项目目录并用cd进入 mkdir E:\\python\\Virtualenv cd E:\\python\\Virtualenv 3、创建虚拟环境 virtualenv -p c:\\Python36\\python.exe env\n或者\nvirtualenv env\n此命令会在当前目录下创建一个env目录\n4、启动虚拟环境 env\\Scripts\\activate\n5、离开虚拟环境 deactivate\n6、删除env文件夹即可 ","permalink":"https://874656645.github.io/rick/posts/8-python-virtualenv/","summary":"原文网址\n在python中使用virtualenv创建虚拟环境 注意：要使用cmd命令行，不能使用Power Shell1、使用pip安装 pip install virtualenv\n2、创建项目目录并用cd进入 mkdir E:\\python\\Virtualenv cd E:\\python\\Virtualenv 3、创建虚拟环境 virtualenv -p c:\\Python36\\python.exe env\n或者\nvirtualenv env\n此命令会在当前目录下创建一个env目录\n4、启动虚拟环境 env\\Scripts\\activate\n5、离开虚拟环境 deactivate\n6、删除env文件夹即可 ","title":"Python Virtualenv"},{"content":"原文网址\n1. Using a virtual environment (recommended) pip install virtualenv\n详细操作\n2. Creating a new Scrapy project scrapy startproject tutorial\n3. Writing a spider to crawl a site and extract data This is the code for our first Spider. Save it in a file named quotes_spider.py under the tutorial/spiders directory in your project:\nimport scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; def start_requests(self): urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, \u0026#39;http://quotes.toscrape.com/page/2/\u0026#39;, ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self, response): page = response.url.split(\u0026#34;/\u0026#34;)[-2] filename = \u0026#39;quotes-%s.html\u0026#39; % page with open(filename, \u0026#39;wb\u0026#39;) as f: f.write(response.body) self.log(\u0026#39;Saved file %s\u0026#39; % filename) 3.1 Extracting data in our spider import scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; start_urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, \u0026#39;http://quotes.toscrape.com/page/2/\u0026#39;, ] def parse(self, response): for quote in response.css(\u0026#39;div.quote\u0026#39;): yield { \u0026#39;text\u0026#39;: quote.css(\u0026#39;span.text::text\u0026#39;).get(), \u0026#39;author\u0026#39;: quote.css(\u0026#39;small.author::text\u0026#39;).get(), \u0026#39;tags\u0026#39;: quote.css(\u0026#39;div.tags a.tag::text\u0026#39;).getall(), } 3.2 Storing the scraped data scrapy crawl quotes -o quotes.json\nor\nscrapy crawl quotes -o quotes.jl\n4. Exporting the scraped data using the command line scrapy crawl quotes\n5. Changing spider to recursively follow links import scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; start_urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, ] def parse(self, response): for quote in response.css(\u0026#39;div.quote\u0026#39;): yield { \u0026#39;text\u0026#39;: quote.css(\u0026#39;span.text::text\u0026#39;).get(), \u0026#39;author\u0026#39;: quote.css(\u0026#39;small.author::text\u0026#39;).get(), \u0026#39;tags\u0026#39;: quote.css(\u0026#39;div.tags a.tag::text\u0026#39;).getall(), } next_page = response.css(\u0026#39;li.next a::attr(href)\u0026#39;).get() if next_page is not None: next_page = response.urljoin(next_page) yield scrapy.Request(next_page, callback=self.parse) 5.1 A shortcut for creating Requests import scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; start_urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, ] def parse(self, response): for quote in response.css(\u0026#39;div.quote\u0026#39;): yield { \u0026#39;text\u0026#39;: quote.css(\u0026#39;span.text::text\u0026#39;).get(), \u0026#39;author\u0026#39;: quote.css(\u0026#39;span small::text\u0026#39;).get(), \u0026#39;tags\u0026#39;: quote.css(\u0026#39;div.tags a.tag::text\u0026#39;).getall(), } next_page = response.css(\u0026#39;li.next a::attr(href)\u0026#39;).get() if next_page is not None: yield response.follow(next_page, callback=self.parse) 6. Using spider arguments scrapy crawl quotes -o quotes-humor.json -a tag=humor\nimport scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; def start_requests(self): url = \u0026#39;http://quotes.toscrape.com/\u0026#39; tag = getattr(self, \u0026#39;tag\u0026#39;, None) if tag is not None: url = url + \u0026#39;tag/\u0026#39; + tag yield scrapy.Request(url, self.parse) def parse(self, response): for quote in response.css(\u0026#39;div.quote\u0026#39;): yield { \u0026#39;text\u0026#39;: quote.css(\u0026#39;span.text::text\u0026#39;).get(), \u0026#39;author\u0026#39;: quote.css(\u0026#39;small.author::text\u0026#39;).get(), } next_page = response.css(\u0026#39;li.next a::attr(href)\u0026#39;).get() if next_page is not None: yield response.follow(next_page, self.parse) ","permalink":"https://874656645.github.io/rick/posts/7-scrapy-learn/","summary":"原文网址\n1. Using a virtual environment (recommended) pip install virtualenv\n详细操作\n2. Creating a new Scrapy project scrapy startproject tutorial\n3. Writing a spider to crawl a site and extract data This is the code for our first Spider. Save it in a file named quotes_spider.py under the tutorial/spiders directory in your project:\nimport scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; def start_requests(self): urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, \u0026#39;http://quotes.toscrape.com/page/2/\u0026#39;, ] for url in urls: yield scrapy.","title":"Scrapy Learn"},{"content":"1. 配置npm镜像源 1.1 临时使用 npm --registry https://registry.npm.taobao.org install --save-dev electron\n1.2 持久使用 npm config set registry https://registry.npm.taobao.org\n1.3 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info electron 1.4 通过cnpm使用 npm install -g cnpm --registry=https://registry.npm.taobao.org\n1.5 使用 cnpm install express\n","permalink":"https://874656645.github.io/rick/posts/6-npm-commond-learning/","summary":"1. 配置npm镜像源 1.1 临时使用 npm --registry https://registry.npm.taobao.org install --save-dev electron\n1.2 持久使用 npm config set registry https://registry.npm.taobao.org\n1.3 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info electron 1.4 通过cnpm使用 npm install -g cnpm --registry=https://registry.npm.taobao.org\n1.5 使用 cnpm install express","title":"Npm Commond Learning"},{"content":"1. Use npm run example 1.1 Clone repository git clone https://github.com/electron/electron-quick-start\n1.2 Go into the repository cd electron-quick-start\n1.3 Install dependencies PS:为了加快下载依赖模块的速度，通过修改镜像源ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ npm install\n或者是\nnpm install --registry=https://registry.npm.taobao.org\n1.4 Run the app npm start\n2. Use yarn create a electron program 2.1 Create a program folder md electron-yarn-cz\n进入项目文件夹\ncd electron-yarn-cz\n2.2 Create a program config file yarn init\n2.3 Instal electron environment yarn add electron --dev --registry=https://registry.npm.taobao.org\n2.4 Add main.js and index.html 2.5 Edit package.json file \u0026#34;main\u0026#34;: \u0026#34;main.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;electron .\u0026#34; } 3. 打包项目 _推荐devtron 和 electron-builder 2个开发工具，配置简单，功能强大\n3.1 添加打包模块 yarn add electron-builder --dev\n3.2 在package.js中添加命令 \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;electron .\u0026#34;, \u0026#34;pack\u0026#34;: \u0026#34;electron-builder --dir\u0026#34;, \u0026#34;dist\u0026#34;: \u0026#34;electron-builder\u0026#34; } 3.3 运行 yarn dist ","permalink":"https://874656645.github.io/rick/posts/5-learn-electron/","summary":"1. Use npm run example 1.1 Clone repository git clone https://github.com/electron/electron-quick-start\n1.2 Go into the repository cd electron-quick-start\n1.3 Install dependencies PS:为了加快下载依赖模块的速度，通过修改镜像源ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ npm install\n或者是\nnpm install --registry=https://registry.npm.taobao.org\n1.4 Run the app npm start\n2. Use yarn create a electron program 2.1 Create a program folder md electron-yarn-cz\n进入项目文件夹\ncd electron-yarn-cz\n2.2 Create a program config file yarn init\n2.3 Instal electron environment yarn add electron --dev --registry=https://registry.npm.taobao.org\n2.4 Add main.","title":"Learn Electron"},{"content":"win10查看端口使用情况 1. 察看所有已使用的端口 netstat -ano\n2. 查看特定端口的使用 netstat -ano|findstr \u0026quot;443\u0026quot;\n3. 查看占用端口的进程PID tasklist|findstr \u0026quot;7648\u0026quot;\n","permalink":"https://874656645.github.io/rick/posts/4-netstat/","summary":"win10查看端口使用情况 1. 察看所有已使用的端口 netstat -ano\n2. 查看特定端口的使用 netstat -ano|findstr \u0026quot;443\u0026quot;\n3. 查看占用端口的进程PID tasklist|findstr \u0026quot;7648\u0026quot;","title":"Netstat"},{"content":"1、初始化本地仓库  适合远程仓库是空仓库  cd public git init git remote add blog https://github.com/874656645/rick  如果新建的仓库有东西，最好先克隆到本地，再向里面添加文件  git clone https://github.com/adityatelange/hugo-PaperMod.git\n 克隆含有子仓库的代码  git clone -b exampleSite --recursive https://github.com/adityatelange/hugo-PaperMod.git\n 克隆某一个分支  git clone -b exampleSite https://github.com/adityatelange/hugo-PaperMod.git\n2、更新远程仓库代码到本地 git pull blog master\n3、将变化提交到本地仓库 git commit -m \u0026quot;delete all files\u0026quot;\ngit commit -am \u0026quot;update\u0026quot;\n4、push推送到远程仓库 git push blog master\n5、添加远程仓库别名和网址 git remote add blog https://github.com/874656645/rick\n6、删除配置的远程仓库别名 git remote remove blog\n7、添加文件 git add -A\n8、删除文件 git rm *\n9、删除远程仓库中的文件、文件夹 git rm -r --cached \u0026quot;*.*\u0026quot;\n*.*表示全部文件和文件夹，如果想删除具体的文件或文件夹，使用具体的名称就可以了\n10、查看所有分支并切换 git branch -a\ngit branch -r\ngit checkout dev5\n11、删除远程分支 git push blog --delete name\n12、解决failed to push some refs to git git pull --rebase blog master\n13、不需验证用户名和密码 执行如下命令\ngit config --global credential.helper store\n此命令会在 .gitconfig 文件中添加如下文本\n[credential] helper = store 14、重新输入用户名和密码 git config --system --unset credential.helper\n或者把上面文件中的 store 删掉\n15、添加子仓库 git submodule add \u0026lt;仓库地址\u0026gt; \u0026lt;本地路径\u0026gt;\n添加成功后，在父仓库根目录增加了 .gitmodule 文件，并且在父仓库的 git 配置文件中加入了 submodule 段\n16、checkout 子仓库 git submodule update --init --recursive\ngit submodule init\ngit submodule update\n17、删除子模块 git submodule deinit {MOD_NAME}\n逆初始化模块，其中 {MOD_NAME} 为模块目录，执行后可发现模块目录被清空\ngit rm --cached {MOD_NAME}\n删除 .gitmodules 中记录的模块信息（\u0026ndash;cached 选项清除 .git/modules 中的缓存）\n但是测试有问题， git 配置文件中的 submodule 段和*.git/modules* 中仍有缓存\n18、常用命令 ","permalink":"https://874656645.github.io/rick/posts/3-git-commond/","summary":"1、初始化本地仓库  适合远程仓库是空仓库  cd public git init git remote add blog https://github.com/874656645/rick  如果新建的仓库有东西，最好先克隆到本地，再向里面添加文件  git clone https://github.com/adityatelange/hugo-PaperMod.git\n 克隆含有子仓库的代码  git clone -b exampleSite --recursive https://github.com/adityatelange/hugo-PaperMod.git\n 克隆某一个分支  git clone -b exampleSite https://github.com/adityatelange/hugo-PaperMod.git\n2、更新远程仓库代码到本地 git pull blog master\n3、将变化提交到本地仓库 git commit -m \u0026quot;delete all files\u0026quot;\ngit commit -am \u0026quot;update\u0026quot;\n4、push推送到远程仓库 git push blog master\n5、添加远程仓库别名和网址 git remote add blog https://github.com/874656645/rick\n6、删除配置的远程仓库别名 git remote remove blog\n7、添加文件 git add -A","title":"Git Commond"},{"content":"使用 Hugo 创建静态网站 Hugo 官网 Hugo 中文网 网站皮肤\nStep1：创建站点 进入到 E:/Hugo/Sites文件夹\nhugo new site HugoLearning.com\ncd HugoLearning.com\ngit init\nStep2：添加样式主题 在皮肤列表挑选一个心仪的皮肤，找到相关的 GitHub 地址，创建目录 themes，在 themes 目录里把皮肤 git clone 下来\ngit submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke\n编辑 config.toml 配置文件\n最后一行添加 theme = \u0026quot;ananke\u0026quot;\n或者在命令行执行 echo 'theme = \u0026quot;ananke\u0026quot;' \u0026gt;\u0026gt; config.toml\nStep3：添加markdown文件内容 hugo new posts/Hello-Hugo.md\nhugo new --kind post posts/1-Papermod-Theme-中文.md\nNote: post is a kind of archetypes( post.md )\nStep4: 启动网站 hugo server -D\n然后输入控制台提示的网址，比如： http://localhost:1313/\nStep5：生成网站 命令行执行 hugo，在网站目录生成public文件夹，发布的网站文件都在这个文件中\n 注意：如果看不到内容，将md文件中的draft设置为false  Step5：将网站发布到 git 使用git工具将文件上传到远程仓库就可以了，仓库还需要做一些设置；\n","permalink":"https://874656645.github.io/rick/posts/2-hugo-create-a-new-site/","summary":"使用 Hugo 创建静态网站 Hugo 官网 Hugo 中文网 网站皮肤\nStep1：创建站点 进入到 E:/Hugo/Sites文件夹\nhugo new site HugoLearning.com\ncd HugoLearning.com\ngit init\nStep2：添加样式主题 在皮肤列表挑选一个心仪的皮肤，找到相关的 GitHub 地址，创建目录 themes，在 themes 目录里把皮肤 git clone 下来\ngit submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke\n编辑 config.toml 配置文件\n最后一行添加 theme = \u0026quot;ananke\u0026quot;\n或者在命令行执行 echo 'theme = \u0026quot;ananke\u0026quot;' \u0026gt;\u0026gt; config.toml\nStep3：添加markdown文件内容 hugo new posts/Hello-Hugo.md\nhugo new --kind post posts/1-Papermod-Theme-中文.md\nNote: post is a kind of archetypes( post.md )\nStep4: 启动网站 hugo server -D","title":"Hugo Create a New Site by Hugo"}]