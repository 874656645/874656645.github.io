[{"content":"算法 + 数据结构 = 程序   数据结构与算法是程序的灵魂，以问题求解为导向，进行问题抽象、数据抽象、算法抽象，通过有效地组织数据、设计高效的算法、完成高质量的程序，从而解决实际应用的问题。\n  流程：问题 =\u0026gt; 数据 =\u0026gt; 算法\n  理论（离散数学、概率统计、图论等） =\u0026gt; 抽象（问题抽象、数据抽象、算法抽象等面向对象思想） =\u0026gt; 设计（实现的某种具体编程语言）\n  逻辑抽象 + 运算抽象 =\u0026gt; ADT\n  运算 + 存储 =\u0026gt; 算法分析（时间和空间复杂度）\n  ","permalink":"https://874656645.github.io/rick/posts/147-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%80%E4%BB%8B/","summary":"算法 + 数据结构 = 程序   数据结构与算法是程序的灵魂，以问题求解为导向，进行问题抽象、数据抽象、算法抽象，通过有效地组织数据、设计高效的算法、完成高质量的程序，从而解决实际应用的问题。\n  流程：问题 =\u0026gt; 数据 =\u0026gt; 算法\n  理论（离散数学、概率统计、图论等） =\u0026gt; 抽象（问题抽象、数据抽象、算法抽象等面向对象思想） =\u0026gt; 设计（实现的某种具体编程语言）\n  逻辑抽象 + 运算抽象 =\u0026gt; ADT\n  运算 + 存储 =\u0026gt; 算法分析（时间和空间复杂度）\n  ","title":"数据结构与算法-简介"},{"content":"注意：这个对于单配置生成器是有效的，对于多配置生成器(例如Visual Studio)是无效的。因此在 Windows 平台，通过 MSYS 环境进行演示。\n默认情况下（Linux平台），CMake 的一个构建目录(build dir)只包含一个配置，可以是 Debug、Release、MinSizeRel 或 RelWithDebInfo。但是，可以通过设置 CPack 来绑定多个构建目录，并构造一个包含同一项目的多个配置的发行包。\n首先，我们希望确保 Debug 和 Release 构建对将要安装的可执行文件和库使用不同的名称。让我们使用 d 作为 Debug 可执行文件和库的后缀。在顶层 CMakeLists.txt 的开始部分添加 CMAKE_DEBUG_POSTFIX\n# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 设置 CMAKE_DEBUG_POSTFIX，指定后缀为 d set(CMAKE_DEBUG_POSTFIX d)然后在 Tutorial 可执行文件上添加属性 DEBUG_POSTFIX：\n# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# And the DEBUG_POSTFIX property on the tutorial executable set_target_properties(Tutorial PROPERTIES DEBUG_POSTFIX ${CMAKE_DEBUG_POSTFIX})为 MathFunctions 库添加版本号信息，在 Mathfunctions/CMakelists.txt 中，设置 VERSION 和 SOVERSION 属性：\n# add the library that runs add_library(MathFunctions MathFunctions.cxx)# 添加 版本信息 set_property(TARGET MathFunctions PROPERTY VERSION \u0026#34;1.0.0\u0026#34;)set_property(TARGET MathFunctions PROPERTY SOVERSION \u0026#34;1\u0026#34;)接下来分别对 Debug 和 Release 分别进行构建，在 build 时使用 CMAKE_BUILD_TYPE 参数设置配置类型：\nmkdir debug mkdir release cd debug cmake -G \u0026#34;MinGW Makefiles\u0026#34; -DCMAKE_BUILD_TYPE=Debug .. cmake --build . cd ../release cmake -G \u0026#34;MinGW Makefiles\u0026#34; -DCMAKE_BUILD_TYPE=Release .. cmake --build . 现在我们可以使用一个自定义的配置文件将两个构建包打包到一个单独的发行包中。在顶层目录创建 MultiCPackConfig.cmake 文件，首先包含由 cmake 创建的默认配置文件，接下来，使用 CPACK_INSTALL_CMAKE_PROJECTS 变量来指定要安装的项目。在本例中，我们希望同时安装 debug 和 release。\ninclude(\u0026#34;release/CPackConfig.cmake\u0026#34;)set(CPACK_INSTALL_CMAKE_PROJECTS \u0026#34;debug;Tutorial;ALL;/\u0026#34; \u0026#34;release;Tutorial;ALL;/\u0026#34; )最后在顶层目录中，运行 cpack，使用 config 选项指定我们的自定义配置文件：\ncpack --config MultiCPackConfig.cmake 注：可能会需要安装 nsis 包\npacman -S mingw-w64-ucrt-x86_64-nsis 在顶层目录会生成一个可安装发行包：\n安装后的目录结构：\n","permalink":"https://874656645.github.io/rick/posts/146-cmake-%E6%89%93%E5%8C%85-debug-%E5%92%8C-release/","summary":"注意：这个对于单配置生成器是有效的，对于多配置生成器(例如Visual Studio)是无效的。因此在 Windows 平台，通过 MSYS 环境进行演示。\n默认情况下（Linux平台），CMake 的一个构建目录(build dir)只包含一个配置，可以是 Debug、Release、MinSizeRel 或 RelWithDebInfo。但是，可以通过设置 CPack 来绑定多个构建目录，并构造一个包含同一项目的多个配置的发行包。\n首先，我们希望确保 Debug 和 Release 构建对将要安装的可执行文件和库使用不同的名称。让我们使用 d 作为 Debug 可执行文件和库的后缀。在顶层 CMakeLists.txt 的开始部分添加 CMAKE_DEBUG_POSTFIX\n# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 设置 CMAKE_DEBUG_POSTFIX，指定后缀为 d set(CMAKE_DEBUG_POSTFIX d)然后在 Tutorial 可执行文件上添加属性 DEBUG_POSTFIX：\n# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# And the DEBUG_POSTFIX property on the tutorial executable set_target_properties(Tutorial PROPERTIES DEBUG_POSTFIX ${CMAKE_DEBUG_POSTFIX})为 MathFunctions 库添加版本号信息，在 Mathfunctions/CMakelists.txt 中，设置 VERSION 和 SOVERSION 属性：\n# add the library that runs add_library(MathFunctions MathFunctions.","title":"CMake 打包 Debug 和 Release"},{"content":"在安装和测试过程中，我们增加了 CMake 安装库文件和项目依赖的头文件(bin、lib、include)的能力。在打包可安装程序的过程中，我们增加了打包这些信息的能力，这样它就可以分发给其他人使用\n接下来是如何添加必要的信息，以便其他 CMake 项目可以使用我们的项目，无论是在构建目录、本地安装还是打包的时候\n第一步是更新我们的 install(TARGETS) 命令，不仅指定 DESTINATION，还指定 EXPORT。EXPORT 关键字生成一个 CMake 文件，其中包含从安装树导入安装命令中列出的所有目标的代码。\n修改 MathFunctions/CMakeLists.txt 文件代码：\n# install rules set(installable_libs MathFunctions tutorial_compiler_flags)if(TARGET SqrtLibrary) list(APPEND installable_libs SqrtLibrary)endif()install(TARGETS ${installable_libs} EXPORT MathFunctionsTargets DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)第二步我们还需要显式地安装生成的 MathFunctionsTargets.cmake 文件。在顶层的 CMakeLists.txt 文件底部添加如下代码：\ninstall(EXPORT MathFunctionsTargets FILE MathFunctionsTargets.cmake DESTINATION lib/cmake/MathFunctions )此时构建会有下面的错误：\n这是因为在生成导出信息期间，它将导出内在绑定到当前计算机项目的路径，在其他计算机上路径无效。\n第三步更新 MathFunctions/CMakeLists.txt 中的 target_include_directories() 用来设置在 build 时和在 install/package 时需要使用不同的 INTERFACE locations。\n# 将当前二进制目录添加到包含目录列表中 target_include_directories(MathFunctions # INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}  INTERFACE $\u0026lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}\u0026gt; $\u0026lt;INSTALL_INTERFACE:include\u0026gt; )第四步我们还需要生成一个 MathFunctionsConfig.cmake，这样 CMake 的 find_package() 命令就可以找到我们的项目。在顶层的项目目录添加 Config.cmake.in 配置文件，内容如下：\n@PACKAGE_INIT@ include ( \u0026#34;${CMAKE_CURRENT_LIST_DIR}/MathFunctionsTargets.cmake\u0026#34; )为了正确地配置和安装该文件，将以下内容添加到顶层 CMakeLists.txt 文件的底部\ninclude(CMakePackageConfigHelpers)然后，执行 configure_package_config_file() 命令，此命令会将 Config.cmake.in 配置文件中的 @PACKAGE_INIT@ 变量替换为一个代码块，该代码块将设置的值转换为相对路径\ninclude(CMakePackageConfigHelpers)# generate the config file that is includes the exports configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake\u0026#34; INSTALL_DESTINATION \u0026#34;lib/cmake/example\u0026#34; NO_SET_AND_CHECK_MACRO NO_CHECK_REQUIRED_COMPONENTS_MACRO )MathFunctionsConfig.cmake 文件内容：\n####### Expanded from @PACKAGE_INIT@ by configure_package_config_file() ####### ####### Any changes to this file will be overwritten by the next CMake run #### ####### The input file was Config.cmake.in ######## get_filename_component(PACKAGE_PREFIX_DIR \u0026#34;${CMAKE_CURRENT_LIST_DIR}/../../../\u0026#34; ABSOLUTE)#################################################################################### include ( \u0026#34;${CMAKE_CURRENT_LIST_DIR}/MathFunctionsTargets.cmake\u0026#34; )第五步生成 MathFunctionsConfigVersion.cmake 文件，该文件被 find_package 所使用，用于记录所需库安装包的版本和兼容性。通过添加 write_basic_package_version_file() 命令生成此文件\nwrite_basic_package_version_file( \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake\u0026#34; # 版本  VERSION \u0026#34;${Tutorial_VERSION_MAJOR}.${Tutorial_VERSION_MINOR}\u0026#34; # 指示此版本或任何更高版本与请求的版本兼容  COMPATIBILITY AnyNewerVersion )最后安装生成的配置文件：\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake ${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake DESTINATION lib/cmake/MathFunctions )如果我们希望我们的项目也从构建目录中使用，我们只需要在顶层 CMakeLists.txt 的底部添加以下内容\nexport(EXPORT MathFunctionsTargets FILE \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsTargets.cmake\u0026#34; )顶层 CMakeLists.txt 完整代码如下：\n# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.15)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 # set(CMAKE_CXX_STANDARD 11) # set(CMAKE_CXX_STANDARD_REQUIRED True) add_library(tutorial_compiler_flags INTERFACE)target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)# add compiler warning flags just when building this project via # the BUILD_INTERFACE genex set(gcc_like_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC\u0026gt;\u0026#34;)set(msvc_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,MSVC\u0026gt;\u0026#34;)target_compile_options(tutorial_compiler_flags INTERFACE \u0026#34;$\u0026lt;${gcc_like_cxx}:$\u0026lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused\u0026gt;\u0026gt;\u0026#34; \u0026#34;$\u0026lt;${msvc_cxx}:$\u0026lt;BUILD_INTERFACE:-W3\u0026gt;\u0026gt;\u0026#34; )# control where the static and shared libraries are built so that on windows # we don\u0026#39;t need to tinker with the path to run the executable # 指定静态库和动态库的生成路径 set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)# 生成共享库选项 option(BUILD_SHARED_LIBS \u0026#34;Build using shared libraries\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加编译子模块 MathFunctions library add_subdirectory(MathFunctions)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# 依赖共享库 MathFunctions target_link_libraries(Tutorial PUBLIC MathFunctions)# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )# enable dashboard scripting include(CTest)# does the application run add_test(NAME Runs COMMAND Tutorial 25)# does the usage message work? add_test(NAME Usage COMMAND Tutorial)set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION \u0026#34;Usage:.*number\u0026#34; )# define a function to simplify adding tests function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction()# do a bunch of result based tests do_test(Tutorial 4 \u0026#34;4 is 2\u0026#34;)do_test(Tutorial 9 \u0026#34;9 is 3\u0026#34;)do_test(Tutorial 5 \u0026#34;5 is 2.236\u0026#34;)do_test(Tutorial 7 \u0026#34;7 is 2.645\u0026#34;)do_test(Tutorial 25 \u0026#34;25 is 5\u0026#34;)do_test(Tutorial -25 \u0026#34;-25 is (-nan|nan|0)\u0026#34;)do_test(Tutorial 0.0001 \u0026#34;0.0001 is 0.01\u0026#34;)## Packaging an Installer # 此模块将打包项目当前平台所需的任何运行时库 include(InstallRequiredSystemLibraries)set(CPACK_RESOURCE_FILE_LICENSE \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/License.txt\u0026#34;)set(CPACK_PACKAGE_VERSION_MAJOR \u0026#34;${Tutorial_VERSION_MAJOR}\u0026#34;)set(CPACK_PACKAGE_VERSION_MINOR \u0026#34;${Tutorial_VERSION_MINOR}\u0026#34;)set(CPACK_SOURCE_GENERATOR \u0026#34;TGZ\u0026#34;)include(CPack)## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026#34; DESTINATION include )install(EXPORT MathFunctionsTargets FILE MathFunctionsTargets.cmake DESTINATION lib/cmake/MathFunctions )include(CMakePackageConfigHelpers)# generate the config file that is includes the exports # 生成 cmake 配置文件 configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake\u0026#34; INSTALL_DESTINATION \u0026#34;lib/cmake/example\u0026#34; NO_SET_AND_CHECK_MACRO NO_CHECK_REQUIRED_COMPONENTS_MACRO )write_basic_package_version_file( \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake\u0026#34; # 版本  VERSION \u0026#34;${Tutorial_VERSION_MAJOR}.${Tutorial_VERSION_MINOR}\u0026#34; # 指示此版本或任何更高版本与请求的版本兼容  COMPATIBILITY AnyNewerVersion )install(FILES ${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake ${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake DESTINATION lib/cmake/MathFunctions )# If we want our project to also be used from a build directory export(EXPORT MathFunctionsTargets FILE \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsTargets.cmake\u0026#34; )MathFunctions/CMakeLists.txt 完整代码：\n# add the library that runs add_library(MathFunctions MathFunctions.cxx)# 生成导出库的宏定义文件 # include(GenerateExportHeader) # generate_export_header(MathFunctions) # 将当前二进制目录添加到包含目录列表中 target_include_directories(MathFunctions # INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}  INTERFACE $\u0026lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}\u0026gt; $\u0026lt;INSTALL_INTERFACE:include\u0026gt; )# 通过 tutorial_compiler_flags 指定 MathFunctions 动态库的编译参数设置 target_link_libraries(MathFunctions PUBLIC tutorial_compiler_flags)# should we use our own math functions # 是否使用 USE_MYMATH 选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)if(USE_MYMATH) # 设置程序中使用到的宏定义  target_compile_definitions(MathFunctions PRIVATE \u0026#34;USE_MYMATH\u0026#34;) # first we add the executable that generates the table  add_executable(MakeTable MakeTable.cxx) # 通过 tutorial_compiler_flags 指定 MakeTable 可执行程序的编译参数设置  target_link_libraries(MakeTable PRIVATE tutorial_compiler_flags) # add the command to generate the source code  add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable ) # 添加静态库  # library that just does sqrt  add_library(SqrtLibrary STATIC mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h ) # state that we depend on our binary dir to find Table.h  target_include_directories(SqrtLibrary PRIVATE ${CMAKE_CURRENT_BINARY_DIR} )  # state that SqrtLibrary need PIC(position independent code) when the default is shared libraries  # 如果将一个没有位置独立代码(position independent code)的静态库与一个有位置独立代码的库组合在一起使用，  # 就要显示设置目标的属性，否则会有链接错误  set_target_properties(SqrtLibrary PROPERTIES POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS} )  # 通过 tutorial_compiler_flags 指定 SqrtLibrary 静态库的编译参数设置  target_link_libraries(SqrtLibrary PRIVATE tutorial_compiler_flags) target_link_libraries(MathFunctions PRIVATE SqrtLibrary)endif()# define the symbol stating we are using the declspec(dllexport) when # building on windows # 声明dll导出宏定义 target_compile_definitions(MathFunctions PRIVATE \u0026#34;EXPORTING_MYMATH\u0026#34;)# install rules set(installable_libs MathFunctions tutorial_compiler_flags)if(TARGET SqrtLibrary) list(APPEND installable_libs SqrtLibrary)endif()install(TARGETS ${installable_libs} # generates a CMake file containing code to import all targets listed in the install command from the installation tree  EXPORT MathFunctionsTargets DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)","permalink":"https://874656645.github.io/rick/posts/145-cmake-%E6%B7%BB%E5%8A%A0%E5%AF%BC%E5%87%BA%E9%85%8D%E7%BD%AE/","summary":"在安装和测试过程中，我们增加了 CMake 安装库文件和项目依赖的头文件(bin、lib、include)的能力。在打包可安装程序的过程中，我们增加了打包这些信息的能力，这样它就可以分发给其他人使用\n接下来是如何添加必要的信息，以便其他 CMake 项目可以使用我们的项目，无论是在构建目录、本地安装还是打包的时候\n第一步是更新我们的 install(TARGETS) 命令，不仅指定 DESTINATION，还指定 EXPORT。EXPORT 关键字生成一个 CMake 文件，其中包含从安装树导入安装命令中列出的所有目标的代码。\n修改 MathFunctions/CMakeLists.txt 文件代码：\n# install rules set(installable_libs MathFunctions tutorial_compiler_flags)if(TARGET SqrtLibrary) list(APPEND installable_libs SqrtLibrary)endif()install(TARGETS ${installable_libs} EXPORT MathFunctionsTargets DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)第二步我们还需要显式地安装生成的 MathFunctionsTargets.cmake 文件。在顶层的 CMakeLists.txt 文件底部添加如下代码：\ninstall(EXPORT MathFunctionsTargets FILE MathFunctionsTargets.cmake DESTINATION lib/cmake/MathFunctions )此时构建会有下面的错误：\n这是因为在生成导出信息期间，它将导出内在绑定到当前计算机项目的路径，在其他计算机上路径无效。\n第三步更新 MathFunctions/CMakeLists.txt 中的 target_include_directories() 用来设置在 build 时和在 install/package 时需要使用不同的 INTERFACE locations。\n# 将当前二进制目录添加到包含目录列表中 target_include_directories(MathFunctions # INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}  INTERFACE $\u0026lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}\u0026gt; $\u0026lt;INSTALL_INTERFACE:include\u0026gt; )第四步我们还需要生成一个 MathFunctionsConfig.cmake，这样 CMake 的 find_package() 命令就可以找到我们的项目。在顶层的项目目录添加 Config.","title":"CMake 添加导出配置"},{"content":" target_compile_features target_compile_options COMPILE_LANG_AND_ID BUILD_INTERFACE  生成器表达式(Generator expressions)允许在许多目标属性的上下文中使用，比如 LINK LIBRARIES、INCLUDE DIRECTORIES、COMPILE DEFINITIONS 等。当使用命令来填充这些属性时，它们也可以被使用，例如 target_link_libraries()、target_include_directories()、target_compile_definitions() 等。\n生成器表达式可以用于启用条件链接、编译时使用的条件定义、条件包含目录等。这些条件可能基于构建配置、目标属性、平台信息或任何其他可查询的信息。\n有不同类型的生成器表达式，包括逻辑表达式、信息表达式和输出表达式。\n逻辑表达式用于创建条件输出。基本的表达式是 0 和 1 表达式。\n生成器表达式的一个常见用法是有条件地添加编译器标志，比如那些用于语言级别或警告的标志。一个很好的模式是将该信息关联到一个 INTERFACE 目标，从而允许该信息传播。让我们先构造一个接口目标，并指定所需的 c++ 标准 11，而不是使用 CMAKE CXX 标准。\n# 指定 C++ 标准 # set(CMAKE_CXX_STANDARD 11) # set(CMAKE_CXX_STANDARD_REQUIRED True) # 将上面的代码替换为 add_library(tutorial_compiler_flags INTERFACE)target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)接下来，我们为项目添加所需的编译器警告标志。由于警告标志因编译器的不同而不同，我们使用 COMPILE_LANG_AND_ID 生成器表达式来控制给定语言和一组编译器 ID 要应用哪些标志（注：将要使用的生成器表达式是在 3.15 中引入的，所以要更新 cmake_minimum_required 的版本为 3.15），如下所示：\nset(gcc_like_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC\u0026gt;\u0026#34;)set(msvc_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,MSVC\u0026gt;\u0026#34;)target_compile_options(tutorial_compiler_flags INTERFACE \u0026#34;$\u0026lt;${gcc_like_cxx}:$\u0026lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused\u0026gt;\u0026gt;\u0026#34; \u0026#34;$\u0026lt;${msvc_cxx}:$\u0026lt;BUILD_INTERFACE:-W3\u0026gt;\u0026gt;\u0026#34; )我们看到警告标志被封装在一个 BUILD_INTERFACE 条件中。这样做是为了让我们已安装项目的使用者不会继承我们的警告标志。\n修改 Mathfunctions/cmakelists.txt，以便所有编译目标都有一个 target_link_libraries() 调用我们设置的编译条件标识 tutorial_compiler_flags。\n# add the library that runs add_library(MathFunctions MathFunctions.cxx)# include(GenerateExportHeader) # generate_export_header(MathFunctions) # 将当前二进制目录添加到包含目录列表中 target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} )# 通过 tutorial_compiler_flags 指定 MathFunctions 动态库的编译参数设置 target_link_libraries(MathFunctions PUBLIC tutorial_compiler_flags)# should we use our own math functions # 是否使用 USE_MYMATH 选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)if(USE_MYMATH) # 设置程序中使用到的宏定义  target_compile_definitions(MathFunctions PRIVATE \u0026#34;USE_MYMATH\u0026#34;) # first we add the executable that generates the table  add_executable(MakeTable MakeTable.cxx) # 通过 tutorial_compiler_flags 指定 MakeTable 可执行程序的编译参数设置  target_link_libraries(MakeTable PRIVATE tutorial_compiler_flags) # add the command to generate the source code  add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable ) # 添加静态库  # library that just does sqrt  add_library(SqrtLibrary STATIC mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h ) # state that we depend on our binary dir to find Table.h  target_include_directories(SqrtLibrary PRIVATE ${CMAKE_CURRENT_BINARY_DIR} )  # state that SqrtLibrary need PIC(position independent code) when the default is shared libraries  # 如果将一个没有位置独立代码(position independent code)的静态库与一个有位置独立代码的库组合在一起使用，  # 就要显示设置目标的属性，否则会有链接错误  set_target_properties(SqrtLibrary PROPERTIES POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS} )  # 通过 tutorial_compiler_flags 指定 SqrtLibrary 静态库的编译参数设置  target_link_libraries(SqrtLibrary PRIVATE tutorial_compiler_flags) target_link_libraries(MathFunctions PRIVATE SqrtLibrary)endif()# define the symbol stating we are using the declspec(dllexport) when # building on windows # 声明dll导出宏定义 target_compile_definitions(MathFunctions PRIVATE \u0026#34;EXPORTING_MYMATH\u0026#34;)# install rules set(installable_libs MathFunctions)if(TARGET SqrtLibrary) list(APPEND installable_libs SqrtLibrary)endif()install(TARGETS ${installable_libs} DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)","permalink":"https://874656645.github.io/rick/posts/144-cmake-%E6%B7%BB%E5%8A%A0%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"target_compile_features target_compile_options COMPILE_LANG_AND_ID BUILD_INTERFACE  生成器表达式(Generator expressions)允许在许多目标属性的上下文中使用，比如 LINK LIBRARIES、INCLUDE DIRECTORIES、COMPILE DEFINITIONS 等。当使用命令来填充这些属性时，它们也可以被使用，例如 target_link_libraries()、target_include_directories()、target_compile_definitions() 等。\n生成器表达式可以用于启用条件链接、编译时使用的条件定义、条件包含目录等。这些条件可能基于构建配置、目标属性、平台信息或任何其他可查询的信息。\n有不同类型的生成器表达式，包括逻辑表达式、信息表达式和输出表达式。\n逻辑表达式用于创建条件输出。基本的表达式是 0 和 1 表达式。\n生成器表达式的一个常见用法是有条件地添加编译器标志，比如那些用于语言级别或警告的标志。一个很好的模式是将该信息关联到一个 INTERFACE 目标，从而允许该信息传播。让我们先构造一个接口目标，并指定所需的 c++ 标准 11，而不是使用 CMAKE CXX 标准。\n# 指定 C++ 标准 # set(CMAKE_CXX_STANDARD 11) # set(CMAKE_CXX_STANDARD_REQUIRED True) # 将上面的代码替换为 add_library(tutorial_compiler_flags INTERFACE)target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)接下来，我们为项目添加所需的编译器警告标志。由于警告标志因编译器的不同而不同，我们使用 COMPILE_LANG_AND_ID 生成器表达式来控制给定语言和一组编译器 ID 要应用哪些标志（注：将要使用的生成器表达式是在 3.15 中引入的，所以要更新 cmake_minimum_required 的版本为 3.15），如下所示：\nset(gcc_like_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC\u0026gt;\u0026#34;)set(msvc_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,MSVC\u0026gt;\u0026#34;)target_compile_options(tutorial_compiler_flags INTERFACE \u0026#34;$\u0026lt;${gcc_like_cxx}:$\u0026lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused\u0026gt;\u0026gt;\u0026#34; \u0026#34;$\u0026lt;${msvc_cxx}:$\u0026lt;BUILD_INTERFACE:-W3\u0026gt;\u0026gt;\u0026#34; )我们看到警告标志被封装在一个 BUILD_INTERFACE 条件中。这样做是为了让我们已安装项目的使用者不会继承我们的警告标志。\n修改 Mathfunctions/cmakelists.txt，以便所有编译目标都有一个 target_link_libraries() 调用我们设置的编译条件标识 tutorial_compiler_flags。","title":"CMake 添加生成器表达式"},{"content":" 将原来的 静态库 MathFunctions拆分为动态库 MathFunctions.dll 和静态库 SqrtLibrary.lib 两个库。MathFunctions.dll 动态库会使用 SqrtLibrary.lib 静态库。 BUILD_SHARED_LIBS  在顶层的 CMakeLists.txt 文件中添加 BUILD_SHARED_LIBS，如果这个标记存在且为真，则将导致所有库都被构建为共享库，除非该库被显式地设置为静态库。这个变量通常作为 option() 添加到项目中，以便项目的每个用户可以决定他们是要使用共享库还是静态库构建项目。\n顶层的 CMakeLists.txt 文件修改如下：\n# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.2)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# control where the static and shared libraries are built so that on windows # we don\u0026#39;t need to tinker with the path to run the executable # 指定静态库和动态库的生成路径 set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)# 生成共享库选项 option(BUILD_SHARED_LIBS \u0026#34;Build using shared libraries\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加编译子模块 MathFunctions library add_subdirectory(MathFunctions)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# 依赖共享库 MathFunctions target_link_libraries(Tutorial PUBLIC MathFunctions)# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026#34; DESTINATION include )# enable dashboard scripting include(CTest)# does the application run add_test(NAME Runs COMMAND Tutorial 25)# does the usage message work? add_test(NAME Usage COMMAND Tutorial)set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION \u0026#34;Usage:.*number\u0026#34; )# define a function to simplify adding tests function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction()# do a bunch of result based tests do_test(Tutorial 4 \u0026#34;4 is 2\u0026#34;)do_test(Tutorial 9 \u0026#34;9 is 3\u0026#34;)do_test(Tutorial 5 \u0026#34;5 is 2.236\u0026#34;)do_test(Tutorial 7 \u0026#34;7 is 2.645\u0026#34;)do_test(Tutorial 25 \u0026#34;25 is 5\u0026#34;)do_test(Tutorial -25 \u0026#34;-25 is (-nan|nan|0)\u0026#34;)do_test(Tutorial 0.0001 \u0026#34;0.0001 is 0.01\u0026#34;)## Packaging an Installer # 此模块将打包项目当前平台所需的任何运行时库 include(InstallRequiredSystemLibraries)set(CPACK_RESOURCE_FILE_LICENSE \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/License.txt\u0026#34;)set(CPACK_PACKAGE_VERSION_MAJOR \u0026#34;${Tutorial_VERSION_MAJOR}\u0026#34;)set(CPACK_PACKAGE_VERSION_MINOR \u0026#34;${Tutorial_VERSION_MINOR}\u0026#34;)set(CPACK_SOURCE_GENERATOR \u0026#34;TGZ\u0026#34;)include(CPack)在 Mathfunctions/Cmakelists.txt 中，我们需要创建一个 Sqrtlibrary，当启用 USE_MYMATH 时，将有条件地构建和安装。\n# add the library that runs add_library(MathFunctions MathFunctions.cxx)# 将当前二进制目录添加到包含目录列表中 target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} )# should we use our own math functions # 是否使用 USE_MYMATH 选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)if(USE_MYMATH) # 设置程序中使用到的宏定义  target_compile_definitions(MathFunctions PRIVATE \u0026#34;USE_MYMATH\u0026#34;) # first we add the executable that generates the table  add_executable(MakeTable MakeTable.cxx) # add the command to generate the source code  add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable ) # 添加静态库  # library that just does sqrt  add_library(SqrtLibrary STATIC mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h ) # state that we depend on our binary dir to find Table.h  target_include_directories(SqrtLibrary PRIVATE ${CMAKE_CURRENT_BINARY_DIR} )  # state that SqrtLibrary need PIC(position independent code) when the default is shared libraries  # 如果将一个没有位置独立代码(position independent code)的静态库与一个有位置独立代码的库组合在一起使用，  # 就要显示设置目标的属性，否则会有链接错误  set_target_properties(SqrtLibrary PROPERTIES POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS} ) target_link_libraries(MathFunctions PRIVATE SqrtLibrary)endif()# define the symbol stating we are using the declspec(dllexport) when # building on windows # 声明dll导出宏定义 target_compile_definitions(MathFunctions PRIVATE \u0026#34;EXPORTING_MYMATH\u0026#34;)# install rules # 安装规则 set(installable_libs MathFunctions)if(TARGET SqrtLibrary) list(APPEND installable_libs SqrtLibrary)endif()install(TARGETS ${installable_libs} DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)","permalink":"https://874656645.github.io/rick/posts/143-cmake-%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/","summary":"将原来的 静态库 MathFunctions拆分为动态库 MathFunctions.dll 和静态库 SqrtLibrary.lib 两个库。MathFunctions.dll 动态库会使用 SqrtLibrary.lib 静态库。 BUILD_SHARED_LIBS  在顶层的 CMakeLists.txt 文件中添加 BUILD_SHARED_LIBS，如果这个标记存在且为真，则将导致所有库都被构建为共享库，除非该库被显式地设置为静态库。这个变量通常作为 option() 添加到项目中，以便项目的每个用户可以决定他们是要使用共享库还是静态库构建项目。\n顶层的 CMakeLists.txt 文件修改如下：\n# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.2)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# control where the static and shared libraries are built so that on windows # we don\u0026#39;t need to tinker with the path to run the executable # 指定静态库和动态库的生成路径 set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)# 生成共享库选项 option(BUILD_SHARED_LIBS \u0026#34;Build using shared libraries\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.","title":"CMake 静态库和动态库混合使用"},{"content":"向仪表板提交测试结果 1. 修改最上层的 CMakeLists.txt 文件 将 enable_testing() 替换为 include(CTest)，CTest 模块会自动调用 enable_testing()\n# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026#34; DESTINATION include )# enable dashboard scripting include(CTest)# does the application run add_test(NAME Runs COMMAND Tutorial 25)# does the usage message work? add_test(NAME Usage COMMAND Tutorial)set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION \u0026#34;Usage:.*number\u0026#34; )# define a function to simplify adding tests function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction()# do a bunch of result based tests do_test(Tutorial 4 \u0026#34;4 is 2\u0026#34;)do_test(Tutorial 9 \u0026#34;9 is 3\u0026#34;)do_test(Tutorial 5 \u0026#34;5 is 2.236\u0026#34;)do_test(Tutorial 7 \u0026#34;7 is 2.645\u0026#34;)do_test(Tutorial 25 \u0026#34;25 is 5\u0026#34;)do_test(Tutorial -25 \u0026#34;-25 is (-nan|nan|0)\u0026#34;)do_test(Tutorial 0.0001 \u0026#34;0.0001 is 0.01\u0026#34;)## Packaging an Installer # 此模块将打包项目当前平台所需的任何运行时库 include(InstallRequiredSystemLibraries)set(CPACK_RESOURCE_FILE_LICENSE \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/License.txt\u0026#34;)set(CPACK_PACKAGE_VERSION_MAJOR \u0026#34;${Tutorial_VERSION_MAJOR}\u0026#34;)set(CPACK_PACKAGE_VERSION_MINOR \u0026#34;${Tutorial_VERSION_MINOR}\u0026#34;)set(CPACK_SOURCE_GENERATOR \u0026#34;TGZ\u0026#34;)include(CPack)2. 添加 CTestConfig.cmake 文件 在顶级目录中添加 CTestConfig.cmake 文件，在这个文件里为 CTest 指定关于项目的信息，CTest 可执行文件在运行时将读取这个文件\n# 项目名称 set(CTEST_PROJECT_NAME \u0026#34;CMakeTutorial\u0026#34;)# 24 小时制 set(CTEST_NIGHTLY_START_TIME \u0026#34;00:00:00 EST\u0026#34;)# 发送提交生成的文档的CDash实例的URL set(CTEST_DROP_METHOD \u0026#34;http\u0026#34;)set(CTEST_DROP_SITE \u0026#34;my.cdash.org\u0026#34;)set(CTEST_DROP_LOCATION \u0026#34;/submit.php?project=CMakeTutorial\u0026#34;)set(CTEST_DROP_SITE_CDASH TRUE)3. 执行 ctest 命令 在 build 目录下运行命令：\n ctest [-VV] -D Experimental ctest [-VV] -C Debug -D Experimental  4. 查看数据 CTest 可执行文件将构建和测试项目并将结果提交给 Kitware 的公共仪表板：https://my.cdash.org/index.php?project=cmaketutorial\n","permalink":"https://874656645.github.io/rick/posts/142-cmake-%E6%B7%BB%E5%8A%A0%E5%AF%B9%E6%B5%8B%E8%AF%95%E4%BB%AA%E8%A1%A8%E6%9D%BF%E7%9A%84%E6%94%AF%E6%8C%81/","summary":"向仪表板提交测试结果 1. 修改最上层的 CMakeLists.txt 文件 将 enable_testing() 替换为 include(CTest)，CTest 模块会自动调用 enable_testing()\n# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.","title":"CMake 添加对测试仪表板的支持"},{"content":" 可以在各种平台上提供二进制和源代码发行版。 InstallRequiredSystemLibraries CPack  一、需要在顶层 CMakeLists.txt 文件的底部添加几行代码 # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026#34; DESTINATION include )## 测试 enable_testing()# does the application run add_test(NAME Runs COMMAND Tutorial 25)# does the usage message work? add_test(NAME Usage COMMAND Tutorial)set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION \u0026#34;Usage:.*number\u0026#34; )# define a function to simplify adding tests function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction()# do a bunch of result based tests do_test(Tutorial 4 \u0026#34;4 is 2\u0026#34;)do_test(Tutorial 9 \u0026#34;9 is 3\u0026#34;)do_test(Tutorial 5 \u0026#34;5 is 2.236\u0026#34;)do_test(Tutorial 7 \u0026#34;7 is 2.645\u0026#34;)do_test(Tutorial 25 \u0026#34;25 is 5\u0026#34;)do_test(Tutorial -25 \u0026#34;-25 is (-nan|nan|0)\u0026#34;)do_test(Tutorial 0.0001 \u0026#34;0.0001 is 0.01\u0026#34;)## Packaging an Installer # 此模块将打包项目当前平台所需的任何运行时库 include(InstallRequiredSystemLibraries)# 设置一些 CPack 变量来存储这个项目的许可证和版本信息 set(CPACK_RESOURCE_FILE_LICENSE \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/License.txt\u0026#34;)set(CPACK_PACKAGE_VERSION_MAJOR \u0026#34;${Tutorial_VERSION_MAJOR}\u0026#34;)set(CPACK_PACKAGE_VERSION_MINOR \u0026#34;${Tutorial_VERSION_MINOR}\u0026#34;)# 为源包选择一种文件格式 # ZIP (.zip) # TGZ (.tar.gz) # TBZ2 (.tar.bz2) # 等格式 set(CPACK_SOURCE_GENERATOR \u0026#34;TGZ\u0026#34;)include(CPack)二、像往常一样 build 工程 cmake --build . --config Release\n三、执行打包命令  cpack：构建二进制发行版 cpack -G ZIP -C Debug：指定发行包的文件格式和配置类型 cpack --config CPackSourceConfig.cmake：打包带有源码的可发行包  ","permalink":"https://874656645.github.io/rick/posts/141-cmake-%E6%89%93%E5%8C%85%E5%8F%AF%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F/","summary":"可以在各种平台上提供二进制和源代码发行版。 InstallRequiredSystemLibraries CPack  一、需要在顶层 CMakeLists.txt 文件的底部添加几行代码 # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.","title":"CMake 打包可安装程序"},{"content":" add_custom_command  MathFunctions 工程的 CMakeLists.txt # 添加可执行程序 MakeTable add_executable(MakeTable MakeTable.cxx)# 添加一个自定义命令，指定如何通过运行 MakeTable 生成 Table.h add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable )# 将生成的 Table.h 添加到库 MathFunctions 的源代码列表 add_library(MathFunctions mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h )# 将当前二进制目录添加到包含目录列表中，这样 Table.h 才能被 mysqrt.cxx 找到并包含 target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} PRIVATE ${CMAKE_CURRENT_BINARY_DIR} )install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)install(FILES ${CMAKE_CURRENT_BINARY_DIR}/Table.h DESTINATION include)生成的 Table.h 文件 double sqrtTable[] = { 0, 1, 1.41421, 1.73205, 2, 2.23607, 2.44949, 2.64575, 2.82843, 3, 0}; Tutorial.exe 运行结果 .\\Release\\Tutorial.exe 4.8 Use the table to help find an initial value Computing sqrt of 4.8 to be 2.2 Computing sqrt of 4.8 to be 2.19091 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 The square root of 4.8 is 2.19089 ","permalink":"https://874656645.github.io/rick/posts/140-cmake-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E5%92%8C%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/","summary":"add_custom_command  MathFunctions 工程的 CMakeLists.txt # 添加可执行程序 MakeTable add_executable(MakeTable MakeTable.cxx)# 添加一个自定义命令，指定如何通过运行 MakeTable 生成 Table.h add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable )# 将生成的 Table.h 添加到库 MathFunctions 的源代码列表 add_library(MathFunctions mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h )# 将当前二进制目录添加到包含目录列表中，这样 Table.h 才能被 mysqrt.cxx 找到并包含 target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} PRIVATE ${CMAKE_CURRENT_BINARY_DIR} )install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)install(FILES ${CMAKE_CURRENT_BINARY_DIR}/Table.h DESTINATION include)生成的 Table.h 文件 double sqrtTable[] = { 0, 1, 1.41421, 1.73205, 2, 2.23607, 2.44949, 2.64575, 2.82843, 3, 0}; Tutorial.","title":"CMake 添加自定义命令和生成文件"},{"content":" CheckSymbolExists: 考虑在项目中添加一些代码，这些代码依赖于目标平台可能没有的特性 target_compile_definitions  add_library(MathFunctions mysqrt.cxx)target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})# does this system provide the log and exp functions? include(CheckSymbolExists)check_symbol_exists(log \u0026#34;math.h\u0026#34; HAVE_LOG)check_symbol_exists(exp \u0026#34;math.h\u0026#34; HAVE_EXP)# 如果平台中没有找到 log 和 exp，我们需要链接到 m 库 if(NOT (HAVE_LOG AND HAVE_EXP)) unset(HAVE_LOG CACHE) unset(HAVE_EXP CACHE) # 设置 m 库并再次尝试  set(CMAKE_REQUIRED_LIBRARIES \u0026#34;m\u0026#34;) check_symbol_exists(log \u0026#34;math.h\u0026#34; HAVE_LOG) check_symbol_exists(exp \u0026#34;math.h\u0026#34; HAVE_EXP) if(HAVE_LOG AND HAVE_EXP) target_link_libraries(MathFunctions PRIVATE m) endif()endif()# 如果可用，使用 target_compile_definitions() 指定 HAVE LOG 和 HAVE EXP 作为私有编译定义 # 在项目配置 预处理器定义中添加 HAVE LOG 和 HAVE EXP 两个宏定义 if(HAVE_LOG AND HAVE_EXP) target_compile_definitions(MathFunctions PRIVATE \u0026#34;HAVE_LOG\u0026#34; \u0026#34;HAVE_EXP\u0026#34;)endif()# install install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)修改 mysqrt 函数：\ndouble mysqrt(double x) { if (x \u0026lt;= 0) { return 0; } #if defined(HAVE_LOG) \u0026amp;\u0026amp; defined(HAVE_EXP)  double result = exp(log(x) * 0.5); std::cout \u0026lt;\u0026lt; \u0026#34;Computing sqrt of \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; to be \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; \u0026#34; using log and exp\u0026#34; \u0026lt;\u0026lt; std::endl; #else  double result = x; // do ten iterations  for (int i = 0; i \u0026lt; 10; ++i) { if (result \u0026lt;= 0) { result = 0.1; } double delta = x - (result * result); result = result + 0.5 * delta / result; std::cout \u0026lt;\u0026lt; \u0026#34;Computing sqrt of \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; to be \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } #endif  return result; } ","permalink":"https://874656645.github.io/rick/posts/139-cmake-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%87%AA%E6%A3%80/","summary":"CheckSymbolExists: 考虑在项目中添加一些代码，这些代码依赖于目标平台可能没有的特性 target_compile_definitions  add_library(MathFunctions mysqrt.cxx)target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})# does this system provide the log and exp functions? include(CheckSymbolExists)check_symbol_exists(log \u0026#34;math.h\u0026#34; HAVE_LOG)check_symbol_exists(exp \u0026#34;math.h\u0026#34; HAVE_EXP)# 如果平台中没有找到 log 和 exp，我们需要链接到 m 库 if(NOT (HAVE_LOG AND HAVE_EXP)) unset(HAVE_LOG CACHE) unset(HAVE_EXP CACHE) # 设置 m 库并再次尝试  set(CMAKE_REQUIRED_LIBRARIES \u0026#34;m\u0026#34;) check_symbol_exists(log \u0026#34;math.h\u0026#34; HAVE_LOG) check_symbol_exists(exp \u0026#34;math.h\u0026#34; HAVE_EXP) if(HAVE_LOG AND HAVE_EXP) target_link_libraries(MathFunctions PRIVATE m) endif()endif()# 如果可用，使用 target_compile_definitions() 指定 HAVE LOG 和 HAVE EXP 作为私有编译定义 # 在项目配置 预处理器定义中添加 HAVE LOG 和 HAVE EXP 两个宏定义 if(HAVE_LOG AND HAVE_EXP) target_compile_definitions(MathFunctions PRIVATE \u0026#34;HAVE_LOG\u0026#34; \u0026#34;HAVE_EXP\u0026#34;)endif()# install install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.","title":"CMake 添加系统自检"},{"content":"Install Rules 在库的 CMakeLists.txt 文件末尾添加 install\nadd_library(MathFunctions mysqrt.cxx)target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)在顶层 CMakeLists.txt 的末尾添加\n... ... ## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026#34; DESTINATION include )Testing Support 在顶层 CMakeLists.txt 的末尾添加\n... ... ## 测试 enable_testing()# does the application run add_test(NAME Runs COMMAND Tutorial 25)# does the usage message work? add_test(NAME Usage COMMAND Tutorial)# 设置校验信息 set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION \u0026#34;Usage:.*number\u0026#34; )# define a function to simplify adding tests function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction()# do a bunch of result based tests do_test(Tutorial 4 \u0026#34;4 is 2\u0026#34;)do_test(Tutorial 9 \u0026#34;9 is 3\u0026#34;)do_test(Tutorial 5 \u0026#34;5 is 2.236\u0026#34;)do_test(Tutorial 7 \u0026#34;7 is 2.645\u0026#34;)do_test(Tutorial 25 \u0026#34;25 is 5\u0026#34;)do_test(Tutorial -25 \u0026#34;-25 is (-nan|nan|0)\u0026#34;)do_test(Tutorial 0.0001 \u0026#34;0.0001 is 0.01\u0026#34;)","permalink":"https://874656645.github.io/rick/posts/138-cmake-%E5%AE%89%E8%A3%85%E5%92%8C%E6%B5%8B%E8%AF%95/","summary":"Install Rules 在库的 CMakeLists.txt 文件末尾添加 install\nadd_library(MathFunctions mysqrt.cxx)target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)在顶层 CMakeLists.txt 的末尾添加\n... ... ## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026#34; DESTINATION include )Testing Support 在顶层 CMakeLists.txt 的末尾添加\n... ... ## 测试 enable_testing()# does the application run add_test(NAME Runs COMMAND Tutorial 25)# does the usage message work? add_test(NAME Usage COMMAND Tutorial)# 设置校验信息 set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION \u0026#34;Usage:.*number\u0026#34; )# define a function to simplify adding tests function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction()# do a bunch of result based tests do_test(Tutorial 4 \u0026#34;4 is 2\u0026#34;)do_test(Tutorial 9 \u0026#34;9 is 3\u0026#34;)do_test(Tutorial 5 \u0026#34;5 is 2.","title":"CMake 安装和测试"},{"content":"添加依赖库和使用条件 CMakeLists.txt  注意编译选项、生成配置文件和条件编译三部分的顺序  # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions) list(APPEND EXTRA_INCLUDES \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34;)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; ${EXTRA_INCLUDES} )子模块（库）的 CMakeLists.txt 文件 add_library(MathFunctions mysqrt.cxx)TutorialConfig.h.in // 版本号配置信息 #define TUTORIAL_VERSION_MAJOR @Tutorial_VERSION_MAJOR@ #define TUTORIAL_VERSION_MINOR @Tutorial_VERSION_MINOR@ // 程序中使用到的宏定义 #cmakedefine USE_MYMATH 程序中的宏定义使用 #ifdef USE_MYMATH #include \u0026#34;MathFunctions.h\u0026#34;#endif  ... ... #ifdef USE_MYMATH  const double outputValue = mysqrt(inputValue); #else  const double outputValue = sqrt(inputValue); #endif 添加库的使用需求   在子模块（库）的 CMakeLists.txt 文件末尾添加\nadd_library(MathFunctions mysqrt.cxx)target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} ) INTERFACE means things that consumers require but the producer doesn\u0026rsquo;t    在上层 CMakeLists.txt 文件中就可以不添加 EXTRA_INCLUDES 了\n... ... if(USE_MYMATH)add_subdirectory(MathFunctions)list(APPEND EXTRA_LIBS MathFunctions)# list(APPEND EXTRA_INCLUDES \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34;) endif()... ... target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )  ","permalink":"https://874656645.github.io/rick/posts/137-cmake-%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%BA%93%E5%92%8C%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6/","summary":"添加依赖库和使用条件 CMakeLists.txt  注意编译选项、生成配置文件和条件编译三部分的顺序  # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions) list(APPEND EXTRA_INCLUDES \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34;)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; ${EXTRA_INCLUDES} )子模块（库）的 CMakeLists.txt 文件 add_library(MathFunctions mysqrt.","title":"CMake 添加依赖库和使用条件"},{"content":"CMakeList # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 2.0)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 生成一个头文件，传递 CMake 的一些设置到源代码 configue_file(TutorialConfig.h.in TutorialConfig.h)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# 添加头文件查找路径 target_include_directories(Tutorial PUBLIC \u0026#34;$(PROJECT_BINARY_DIR)\u0026#34;)TutorialConfig.h.in // #define TUTORIAL_VERSION_MAJOR @Tutorial_VERSION_MAJOR@ #define TUTORIAL_VERSION_MINOR @Tutorial_VERSION_MINOR@ ","permalink":"https://874656645.github.io/rick/posts/136-cmake-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92%E8%AE%BE%E7%BD%AE%E4%BF%A1%E6%81%AF/","summary":"CMakeList # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 2.0)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 生成一个头文件，传递 CMake 的一些设置到源代码 configue_file(TutorialConfig.h.in TutorialConfig.h)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# 添加头文件查找路径 target_include_directories(Tutorial PUBLIC \u0026#34;$(PROJECT_BINARY_DIR)\u0026#34;)TutorialConfig.h.in // #define TUTORIAL_VERSION_MAJOR @Tutorial_VERSION_MAJOR@ #define TUTORIAL_VERSION_MINOR @Tutorial_VERSION_MINOR@ ","title":"CMake 配置文件传递设置信息"},{"content":"一、CMakeLists.txt 文件示例 # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 1.0)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)二、CMake 相关命令   cmake .. 含有 CMakeLists.txt 文件的路径，根据 CMakeLists.txt 文件构建对应的工程；\n  cmake .. -DUSE_MYMATH=OFF 将 CMake 编译选项 USE_MYMATH 设置为关闭状态，并构建工程\n  cmake .. -DCMAKE_BUILD_TYPE=Release 在Linux中设定 Release 版本\n  指定编译工具为 MSVC（不同的 CMake 版本，命令写法不同）：\ncmake -G \u0026#34;Visual Studio 14 2015 Win64\u0026#34; cmake -G \u0026#34;Visual Studio 16 2019\u0026#34; -A x64 cmake -G \u0026#34;Visual Studio 16 2019\u0026#34; -A Win32   在 Windows 中使用 MinGW\ncmake -G \u0026#34;MinGW Makefiles\u0026#34; -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ -DCMAKE_SYSROOT=D:/msys64/ucrt64/bin .. cmake -G \u0026#34;MinGW Makefiles\u0026#34; -DCMAKE_BUILD_TYPE=Debug -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ .. cmake -G \u0026#34;MinGW Makefiles\u0026#34; -DCMAKE_BUILD_TYPE=Debug ..   cmake --install . --prefix \u0026quot;E:/VSCode-Projects/CMake/Install\u0026quot; 指定安装路径，在 Windows 中，如果不指定 --prefix 参数，64位默认会安装到 C:\\Program Files\n  cpack --config CPackSourceConfig.cmake：创建完整源代码树和 build 的压缩包\n  Windows  cmake --build . 在当前目录编译成二进制文件，默认是 Debug cmake --build . --config Release 编译 Release ctest -C Release -VV 参数 -VV 输出详细信息，可不加。对于多配置生成器(例如Visual Studio)，配置类型必须用 -C \u0026lt;mode\u0026gt; 标志来指定 cpack -G ZIP -C Debug：要指定生成器，请使用 -G 选项。对于多配置构建，使用 -C 来指定配置 ctest [-VV] -C Debug -D Experimental：向仪表板提交测试结果  Linux  make 进行编译 ctest -N 和 ctest -VV 测试 cpack ctest [-VV] -D Experimental：向仪表板提交测试结果  ","permalink":"https://874656645.github.io/rick/posts/135-cmake-%E4%BD%BF%E7%94%A8/","summary":"一、CMakeLists.txt 文件示例 # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 1.0)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)二、CMake 相关命令   cmake .. 含有 CMakeLists.txt 文件的路径，根据 CMakeLists.txt 文件构建对应的工程；\n  cmake .. -DUSE_MYMATH=OFF 将 CMake 编译选项 USE_MYMATH 设置为关闭状态，并构建工程\n  cmake .. -DCMAKE_BUILD_TYPE=Release 在Linux中设定 Release 版本\n  指定编译工具为 MSVC（不同的 CMake 版本，命令写法不同）：\ncmake -G \u0026#34;Visual Studio 14 2015 Win64\u0026#34; cmake -G \u0026#34;Visual Studio 16 2019\u0026#34; -A x64 cmake -G \u0026#34;Visual Studio 16 2019\u0026#34; -A Win32   在 Windows 中使用 MinGW","title":"CMake 使用"},{"content":"哈希表及处理冲突的方法\n一、哈希法与哈希表  哈希法又称散列法、杂凑法以及关键字地址计算法等，相应的表称为哈希表。 这种方法的基本思想是：首先在元素的关键字 k 和元素的存储位置 p 之间建立一个对应关系 f，使得 p = f(k)，f 称为哈希函数。 创建哈希表时，把关键字为 k 的元素直接存入地址为 f(k) 的单元；以后当查找关键字为 k 的元素时，再利用哈希函数计算出该元素的存储位置 p=f(k)，从而达到按关键字直接存取元素的目的。  二、冲突 当关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，即 k1 ≠ k2，但 f(k1) = f(k2)，这种现象称为冲突，此时称 k1 和 k2 为同义词。\n三、哈希函数构造方法 构造哈希函数的原则是：\n 函数本身便于计算； 计算出来的地址分布均匀，即对任一关键字 k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突  常用的构造方法：\n 数字分析法 平方取中法 分段叠加法 除留余数法：假设哈希表长为 m，p 为小于等于 m 的最大素数，则哈希函数为 f(k)=k % p 伪随机数法  四、冲突处理方法 1. 开放地址法（Open addressing） 这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi\n 线性探测 二次探测 伪随机探测  线性探测再散列的优点是：只要哈希表不满，就一定能找到一个不冲突的哈希地址，而二次探测再散列和伪随机探测再散列则不一定；缺点是线性探测再散列容易产生二次聚集\n2. 再哈希法 这种方法是同时构造多个不同的哈希函数，当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间\n3. 开链法（Separate chaining） 这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i 个单元中，因而查找、插入和删除主要在同义词链中进行。同义词较多时可以考虑使用红黑树替代链表。链地址法适用于经常进行插入和删除的情况\n4. 建立公共溢出区 将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表\n","permalink":"https://874656645.github.io/rick/posts/134-%E5%93%88%E5%B8%8C%E6%B3%95%E4%B8%8E%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/","summary":"哈希表及处理冲突的方法\n一、哈希法与哈希表  哈希法又称散列法、杂凑法以及关键字地址计算法等，相应的表称为哈希表。 这种方法的基本思想是：首先在元素的关键字 k 和元素的存储位置 p 之间建立一个对应关系 f，使得 p = f(k)，f 称为哈希函数。 创建哈希表时，把关键字为 k 的元素直接存入地址为 f(k) 的单元；以后当查找关键字为 k 的元素时，再利用哈希函数计算出该元素的存储位置 p=f(k)，从而达到按关键字直接存取元素的目的。  二、冲突 当关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，即 k1 ≠ k2，但 f(k1) = f(k2)，这种现象称为冲突，此时称 k1 和 k2 为同义词。\n三、哈希函数构造方法 构造哈希函数的原则是：\n 函数本身便于计算； 计算出来的地址分布均匀，即对任一关键字 k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突  常用的构造方法：\n 数字分析法 平方取中法 分段叠加法 除留余数法：假设哈希表长为 m，p 为小于等于 m 的最大素数，则哈希函数为 f(k)=k % p 伪随机数法  四、冲突处理方法 1. 开放地址法（Open addressing） 这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi\n 线性探测 二次探测 伪随机探测  线性探测再散列的优点是：只要哈希表不满，就一定能找到一个不冲突的哈希地址，而二次探测再散列和伪随机探测再散列则不一定；缺点是线性探测再散列容易产生二次聚集\n2. 再哈希法 这种方法是同时构造多个不同的哈希函数，当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间","title":"哈希法与冲突处理"},{"content":"认识C++移动语义与右值引用\n一文读懂C++右值引用和std::move\n一、结论  C 中将数据类型分为左值和右值，在 C++11 中又将右值概念更为细致的分为将亡值（xvalue）和纯右值（prvalue）。 将亡值是 C++11 新增的跟右值引用相关的表达式，通常是将要被移动的对象（移为他用），比如返回右值引用 T\u0026amp;\u0026amp; 的函数返回值、std::move 的返回值。 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。 右值引用可以直接指向右值，也可以通过 std::move 指向左值；而左值引用只能指向左值（const左值引用也能指向右值）。 作为函数形参时，右值引用更灵活。虽然 const 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。 可移动对象在需要拷贝且被拷贝者之后不再被需要的场景，建议使用 std::move 触发移动语义，提升性能。 我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和 std::move 的语言特性。 std::move 本身只做类型转换，对性能无影响。 std::forward 同样也是做类型转换且更强大，move 只能转出来右值，forward 既可以转成右值，又可以转成左值。 函数最好不要返回函数体内局部变量的左值引用或右值引用。  二、注意事项  左值引用是具名变量值的别名 右值引用是不具名（匿名）变量的别名    引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值，但是，const左值引用是可以指向右值的\nconst int \u0026amp;ref_a = 5; int a = 5; int \u0026amp;ref_a = a; // 左值引用指向左值，编译通过 int \u0026amp;ref_a = 5; // 左值引用指向了右值，会编译失败   右值引用的标志是 \u0026amp;\u0026amp;，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值\nint\u0026amp;\u0026amp; ref_a_right = 5; // ok int a = 5; int\u0026amp;\u0026amp; ref_a_left = a; // 编译不过，右值引用不可以指向左值  ref_a_right = 6; // 右值引用的用途：可以修改右值   事实上 std::move 移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(lvalue)。 所以，单纯的 std::move(xxx) 不会有性能提升，从这个角度来讲，右值引用和左值引用的功能相似，都是原始变量的别名，至于移动后原始变量是否可用，取决于被移动的数据类型对于移动语义的具体实现。\n案例一：\nint a = 5; // a是个左值 int \u0026amp;ref_a_left = a; // 左值引用指向左值 int \u0026amp;\u0026amp;ref_a_right = std::move(a); // 通过std::move将左值转化为右值，可以被右值引用指向 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 打印结果：5 ref_a_right = 10; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 打印结果：10 ref_a_left = 20; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 打印结果：20 // 这三个变量的地址都相同 案例二：\nclass Person{ public: int m_age{20}; }; void test(Person\u0026amp;\u0026amp; p){ cout \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; \u0026amp;p \u0026lt;\u0026lt; endl; } void test1(Person\u0026amp; p){ cout \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; \u0026amp;p \u0026lt;\u0026lt; endl; } int main() { Person pp; cout \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; \u0026amp;pp \u0026lt;\u0026lt; endl; test(move(pp)); cout \u0026lt;\u0026lt; pp.m_age \u0026lt;\u0026lt; endl; test1(pp); return 0; } 输出： main 0x7ffc06f34444 test 0x7ffc06f34444 20 test1 0x7ffc06f34444   被声明出来的左、右值引用都是左值。因为被声明出的左右值引用是有地址的，也位于等号左边。\n// 形参是个右值引用 void change(int\u0026amp;\u0026amp; right_value) { right_value = 8; } int main() { int a = 5; // a是个左值  int \u0026amp;ref_a_left = a; // ref_a_left是个左值引用  int \u0026amp;\u0026amp;ref_a_right = std::move(a); // ref_a_right是个右值引用  cout \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026amp;ref_a_left \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026amp;ref_a_right; // 打印这三个左值的地址，都是一样的  // error: cannot bind rvalue reference of type ‘int\u0026amp;\u0026amp;’ to lvalue of type ‘int’  // change(a); // 编译不过，a是左值，change参数要求右值  // change(ref_a_left); // 编译不过，左值引用ref_a_left本身也是个左值  // change(ref_a_right); // 编译不过，右值引用ref_a_right本身也是个左值  change(std::move(a)); // 编译通过  change(std::move(ref_a_right)); // 编译通过  change(std::move(ref_a_left)); // 编译通过  change(5); // 当然可以直接接右值，编译通过 }   右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值。\n  三、std::forward std::forward\u0026lt;T\u0026gt;(u) 有两个参数：T 与 u\n a. 当 T 显示为左值引用类型时，u 将被转换为 T 类型的左值； b. 否则 u 将被转换为 T 类型右值  void change2(int\u0026amp;\u0026amp; ref_r) { ref_r = 1; } void change3(int\u0026amp; ref_l) { ref_l = 1; } // change的入参是右值引用 // 有名字的右值引用是 左值，因此ref_r是左值 void change(int\u0026amp;\u0026amp; ref_r) { // error: cannot bind rvalue reference of type ‘int\u0026amp;\u0026amp;’ to lvalue of type ‘int’  // change2(ref_r); // 错误，change2的入参是右值引用，需要接右值，ref_r是左值，编译失败  change2(std::move(ref_r)); // ok，std::move把左值转为右值，编译通过  change2(std::forward\u0026lt;int\u0026amp;\u0026amp;\u0026gt;(ref_r)); // ok，std::forward的T是右值引用类型(int \u0026amp;\u0026amp;)，符合条件b，因此u(ref_r)会被转换为右值，编译通过  change2(std::forward\u0026lt;int\u0026gt;(ref_r)); // ok，std::forward的T是int类型，属于条件b，因此会把ref_r转为右值  change3(ref_r); // ok，change3的入参是左值引用，需要接左值，ref_r是左值，编译通过  change3(std::forward\u0026lt;int\u0026amp;\u0026gt;(ref_r)); // ok，std::forward的T是左值引用类型(int \u0026amp;)，符合条件a，因此u(ref_r)会被转换为左值，编译通过  // 可见，forward可以把值转换为左值或者右值 } int main() { int a = 5; change(std::move(a)); } 四、自定义类支持移动语义 编译器会默认在用户自定义的 class 和 struct 中生成移动语义函数，但前提是符合用户类默认的移动构造/移动赋值的启用条件，系统默认的移动语义函数更像是一种引用（原始变量的别名）。\nif (定义了 拷贝构造函数 、 拷贝赋值运算符 或 析构函数) { 不会合成移动构造函数和移动赋值运算符。此时会使用对应 拷贝 操作来代替 移动 } else if (类的所有成员都可以移动) { 则会为类合成移动构造函数或移动赋值运算符。 } else { 合成拷贝构造函数和拷贝复制运算符。 } class Person{ public: Person():m_age(new int(20)){ cout \u0026lt;\u0026lt; \u0026#34;Construct: \u0026#34; \u0026lt;\u0026lt; ++n_cstr \u0026lt;\u0026lt; endl; } ~Person(){ delete m_age; cout \u0026lt;\u0026lt; \u0026#34;Destruct: \u0026#34; \u0026lt;\u0026lt; ++n_dstr \u0026lt;\u0026lt; endl; } Person(const Person\u0026amp; p):m_age(new int(*p.m_age)){ cout \u0026lt;\u0026lt; \u0026#34;Copy construct: \u0026#34; \u0026lt;\u0026lt; ++n_cptr \u0026lt;\u0026lt; endl; } Person(Person\u0026amp;\u0026amp; p){ m_age = std::exchange(p.m_age, nullptr); cout \u0026lt;\u0026lt; \u0026#34;Move construct: \u0026#34; \u0026lt;\u0026lt; ++n_mvtr \u0026lt;\u0026lt; endl; } Person\u0026amp; operator=(const Person\u0026amp; p){ *m_age = *p.m_age; cout \u0026lt;\u0026lt; \u0026#34;operator=(const Person\u0026amp; p)...\u0026#34; \u0026lt;\u0026lt; endl; return *this; } Person\u0026amp; operator=(Person\u0026amp;\u0026amp; p){ if(m_age) delete m_age; m_age = std::exchange(p.m_age, nullptr); cout \u0026lt;\u0026lt; \u0026#34;operator=(Person\u0026amp;\u0026amp; p)...\u0026#34; \u0026lt;\u0026lt; endl; return *this; } int* m_age{nullptr}; static int n_cstr; static int n_dstr; static int n_cptr; static int n_mvtr; }; int Person::n_cstr = 0; int Person::n_dstr = 0; int Person::n_cptr = 0; int Person::n_mvtr = 0; Person GetPerson(){ Person p; cout \u0026lt;\u0026lt; *p.m_age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Resource from \u0026#34; \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; return p; } int main(int argc, const char* argv[]){ Person p = GetPerson(); cout \u0026lt;\u0026lt; *p.m_age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Resource from \u0026#34; \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; return 0; } 输出：\nConstruct: 1 20 Resource from GetPerson: 000001D5C8D85990 Move construct: 1 Destruct: 1 20 Resource from main: 000001D5C8D85990 Destruct: 2 ","permalink":"https://874656645.github.io/rick/posts/133-c++11-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/","summary":"认识C++移动语义与右值引用\n一文读懂C++右值引用和std::move\n一、结论  C 中将数据类型分为左值和右值，在 C++11 中又将右值概念更为细致的分为将亡值（xvalue）和纯右值（prvalue）。 将亡值是 C++11 新增的跟右值引用相关的表达式，通常是将要被移动的对象（移为他用），比如返回右值引用 T\u0026amp;\u0026amp; 的函数返回值、std::move 的返回值。 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。 右值引用可以直接指向右值，也可以通过 std::move 指向左值；而左值引用只能指向左值（const左值引用也能指向右值）。 作为函数形参时，右值引用更灵活。虽然 const 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。 可移动对象在需要拷贝且被拷贝者之后不再被需要的场景，建议使用 std::move 触发移动语义，提升性能。 我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和 std::move 的语言特性。 std::move 本身只做类型转换，对性能无影响。 std::forward 同样也是做类型转换且更强大，move 只能转出来右值，forward 既可以转成右值，又可以转成左值。 函数最好不要返回函数体内局部变量的左值引用或右值引用。  二、注意事项  左值引用是具名变量值的别名 右值引用是不具名（匿名）变量的别名    引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值，但是，const左值引用是可以指向右值的\nconst int \u0026amp;ref_a = 5; int a = 5; int \u0026amp;ref_a = a; // 左值引用指向左值，编译通过 int \u0026amp;ref_a = 5; // 左值引用指向了右值，会编译失败   右值引用的标志是 \u0026amp;\u0026amp;，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值\nint\u0026amp;\u0026amp; ref_a_right = 5; // ok int a = 5; int\u0026amp;\u0026amp; ref_a_left = a; // 编译不过，右值引用不可以指向左值  ref_a_right = 6; // 右值引用的用途：可以修改右值   事实上 std::move 移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(lvalue)。 所以，单纯的 std::move(xxx) 不会有性能提升，从这个角度来讲，右值引用和左值引用的功能相似，都是原始变量的别名，至于移动后原始变量是否可用，取决于被移动的数据类型对于移动语义的具体实现。","title":"C++11 左值、右值和移动语义"},{"content":"一、auto_ptr 特点  支持拷贝构造 支持赋值拷贝 支持 operator-\u0026gt;/operator* 解引用 支持指针变量重置 保证指针持有者唯一（涉及所有权转移）  二、问题一：使用数组存储 auto_ptr std::vector\u0026lt;std::auto_ptr\u0026lt;People\u0026gt;\u0026gt; peoples; // 这里实例化多个people并保存到数组中 ... std::auto_ptr\u0026lt;People\u0026gt; one = peoples[5]; ... std::cout \u0026lt;\u0026lt; peoples[5]-\u0026gt;get_name() \u0026lt;\u0026lt; std::endl; 原因在于 std::auto_ptr 支持 operator=，为了确保指针所有者唯一，这里转移了所有权，people[5] 变成了 null\n三、问题二、函数传参 auto_ptr 类型 void do_somthing(std::auto_ptr\u0026lt;People\u0026gt; people){ // 该函数内不对people变量执行各种隐式/显示的所有权转移和释放  ... } std::auto_ptr\u0026lt;People\u0026gt; people(new People(\u0026#34;jony\u0026#34;)); do_something(people); ... std::cout \u0026lt;\u0026lt; people-\u0026gt;get_name() \u0026lt;\u0026lt; std::endl; 原因在于 std::auto_ptr支持拷贝构造，为了确保指针所有者唯一，这里转移了所有权\n四、unique_ptr 在11中，可以支持右值以及移动语义了，此时可以完全匹配auto_ptr的所有权管理，新增了 std::unique_ptr。std::unique_ptr 不仅加入了移动语义的支持，同时也关闭了左值拷贝构造和左值赋值功能！杜绝了上述场景的出现！但是，此时，需要使用其他的方案了。比如场景一中，std::unique_ptr类型变量不能使用vector保存了！\n所以 std::auto_ptr 废弃了，由 std::unique_ptr 代替！\nclass Person{ public: int getAge()const{ return m_age; } void setAge(int age){ m_age = age; } private: int m_age{20}; }; unique_ptr\u0026lt;Person\u0026gt; Change(unique_ptr\u0026lt;Person\u0026gt; p){ p-\u0026gt;setAge(30); return p; } int main() { unique_ptr\u0026lt;Person\u0026gt; pP(new Person); cout \u0026lt;\u0026lt; pP-\u0026gt;getAge() \u0026lt;\u0026lt; endl; // unique_ptr\u0026lt;Person\u0026gt; pP2 = Change(pP); // error： unique_ptr 删除了拷贝构造，所以需要使用 move 关键字转移所有权  unique_ptr\u0026lt;Person\u0026gt; pP2 = Change(move(pP)); // pP = pP2; // error：unique_ptr 删除了 = 赋值构造  cout \u0026lt;\u0026lt; \u0026#34;-------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pP2-\u0026gt;getAge() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-------------\u0026#34; \u0026lt;\u0026lt; endl; if(pP == nullptr){ cout \u0026lt;\u0026lt; \u0026#34;pP 变量已失效\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输出：\n20 ------------- 30 ------------- pP 变量已失效 ","permalink":"https://874656645.github.io/rick/posts/131-c++11-auto_ptr-%E8%A2%AB%E5%BA%9F%E5%BC%83%E4%B8%8E-unique_ptr/","summary":"一、auto_ptr 特点  支持拷贝构造 支持赋值拷贝 支持 operator-\u0026gt;/operator* 解引用 支持指针变量重置 保证指针持有者唯一（涉及所有权转移）  二、问题一：使用数组存储 auto_ptr std::vector\u0026lt;std::auto_ptr\u0026lt;People\u0026gt;\u0026gt; peoples; // 这里实例化多个people并保存到数组中 ... std::auto_ptr\u0026lt;People\u0026gt; one = peoples[5]; ... std::cout \u0026lt;\u0026lt; peoples[5]-\u0026gt;get_name() \u0026lt;\u0026lt; std::endl; 原因在于 std::auto_ptr 支持 operator=，为了确保指针所有者唯一，这里转移了所有权，people[5] 变成了 null\n三、问题二、函数传参 auto_ptr 类型 void do_somthing(std::auto_ptr\u0026lt;People\u0026gt; people){ // 该函数内不对people变量执行各种隐式/显示的所有权转移和释放  ... } std::auto_ptr\u0026lt;People\u0026gt; people(new People(\u0026#34;jony\u0026#34;)); do_something(people); ... std::cout \u0026lt;\u0026lt; people-\u0026gt;get_name() \u0026lt;\u0026lt; std::endl; 原因在于 std::auto_ptr支持拷贝构造，为了确保指针所有者唯一，这里转移了所有权\n四、unique_ptr 在11中，可以支持右值以及移动语义了，此时可以完全匹配auto_ptr的所有权管理，新增了 std::unique_ptr。std::unique_ptr 不仅加入了移动语义的支持，同时也关闭了左值拷贝构造和左值赋值功能！杜绝了上述场景的出现！但是，此时，需要使用其他的方案了。比如场景一中，std::unique_ptr类型变量不能使用vector保存了！\n所以 std::auto_ptr 废弃了，由 std::unique_ptr 代替！\nclass Person{ public: int getAge()const{ return m_age; } void setAge(int age){ m_age = age; } private: int m_age{20}; }; unique_ptr\u0026lt;Person\u0026gt; Change(unique_ptr\u0026lt;Person\u0026gt; p){ p-\u0026gt;setAge(30); return p; } int main() { unique_ptr\u0026lt;Person\u0026gt; pP(new Person); cout \u0026lt;\u0026lt; pP-\u0026gt;getAge() \u0026lt;\u0026lt; endl; // unique_ptr\u0026lt;Person\u0026gt; pP2 = Change(pP); // error： unique_ptr 删除了拷贝构造，所以需要使用 move 关键字转移所有权  unique_ptr\u0026lt;Person\u0026gt; pP2 = Change(move(pP)); // pP = pP2; // error：unique_ptr 删除了 = 赋值构造  cout \u0026lt;\u0026lt; \u0026#34;-------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pP2-\u0026gt;getAge() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-------------\u0026#34; \u0026lt;\u0026lt; endl; if(pP == nullptr){ cout \u0026lt;\u0026lt; \u0026#34;pP 变量已失效\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输出：","title":"C++11 auto_ptr 被废弃与 unique_ptr"},{"content":"一、修饰类成员变量 此关键字只能应用于类的非静态和非常量数据成员，mutable 是为了让 const 对象的某些数据成员可以被修改。static 是类的成员，不属于对象，常对象和常函数只会限制类的成员变量修改，所以类的 static 数据成员不需要 mutable 修饰，在常对象和常函数中也能被修改。\nclass Person{ public: int getAge() const{ m_count++; s_count++; return m_age; } int getCount()const{ return m_count; } private: int m_age{20}; mutable int m_count{0}; public: static int s_count; }; int Person::s_count = 0; int main() { Person p; p.getAge(); p.getAge(); p.getAge(); cout \u0026lt;\u0026lt; p.getCount() \u0026lt;\u0026lt; endl; // 3  cout \u0026lt;\u0026lt; p.s_count \u0026lt;\u0026lt; endl; // 3  return 0; } 二、修饰匿名函数 表示可以修改按值传入的变量的副本（不是值本身），类似于不带 const 关键字的形参。使用 mutable 关键字后对按值传入的变量进行的修改，不会将改变传递到 Lambda 表达式之外。如果不加 mutable 关键字，按值传入的变量是只读的，即使在 Lambda 表达式内部也不可修改\nint main () { int x = 1; int y = 1; int z; cout \u0026lt;\u0026lt; \u0026#34;x1: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty1: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; z = [=]() mutable -\u0026gt; int { ++x; ++y; cout \u0026lt;\u0026lt; \u0026#34;x2: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty2: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; return x + y; }(); cout \u0026lt;\u0026lt; \u0026#34;x3: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty3: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;z: \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; return 0; } 输出：\nx1: 1\ty1: 1 x2: 2\ty2: 2 x3: 1\ty3: 1 z: 4 ","permalink":"https://874656645.github.io/rick/posts/132-c++11-mutable-%E5%85%B3%E9%94%AE%E5%AD%97/","summary":"一、修饰类成员变量 此关键字只能应用于类的非静态和非常量数据成员，mutable 是为了让 const 对象的某些数据成员可以被修改。static 是类的成员，不属于对象，常对象和常函数只会限制类的成员变量修改，所以类的 static 数据成员不需要 mutable 修饰，在常对象和常函数中也能被修改。\nclass Person{ public: int getAge() const{ m_count++; s_count++; return m_age; } int getCount()const{ return m_count; } private: int m_age{20}; mutable int m_count{0}; public: static int s_count; }; int Person::s_count = 0; int main() { Person p; p.getAge(); p.getAge(); p.getAge(); cout \u0026lt;\u0026lt; p.getCount() \u0026lt;\u0026lt; endl; // 3  cout \u0026lt;\u0026lt; p.s_count \u0026lt;\u0026lt; endl; // 3  return 0; } 二、修饰匿名函数 表示可以修改按值传入的变量的副本（不是值本身），类似于不带 const 关键字的形参。使用 mutable 关键字后对按值传入的变量进行的修改，不会将改变传递到 Lambda 表达式之外。如果不加 mutable 关键字，按值传入的变量是只读的，即使在 Lambda 表达式内部也不可修改","title":"C++11 mutable 关键字"},{"content":"一、进行自动类型推导  auto 的自动类型推断发生在编译期，所以使用 auto 并不会造成程序运行时效率的降低。 而是否会造成编译期的时间消耗，我认为是不会的，在未使用 auto 时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换。  int main() { int a = 10; auto val = a; cout \u0026lt;\u0026lt; typeid(val).name() \u0026lt;\u0026lt; endl; // i  return 0; } 二、在定义模板函数时，用于声明依赖模板参数的变量类型 不到编译的时候，x * y 的真正类型很难确定\ntemplate \u0026lt;class _Tx,class _Ty\u0026gt; void Multiply(_Tx x, _Ty y) { auto v = x * y; std::cout \u0026lt;\u0026lt; v; } int main() { int a = 10; double b = 1.53; Multiply(a, b); // 15.3  return 0; } 三、函数模板返回值依赖于模板参数 auto 在这里的作用也称为返回值占位，真正的返回值是后面的 decltype(x * y)。为何要将返回值后置呢？如果没有后置，则函数声明时为：decltype(x * y) multiply(_Tx x, _Ty y)，而此时 x, y 还没声明呢，编译无法通过。\ntemplate \u0026lt;class _Tx,class _Ty\u0026gt; auto Multiply(_Tx x, _Ty y) -\u0026gt; decltype(x * y) { return x * y; } int main() { int a = 10; double b = 1.53; cout \u0026lt;\u0026lt; Multiply(a, b) \u0026lt;\u0026lt; endl; return 0; } 四、与匿名函数结合使用 int main() { auto f = [](int a, int b) -\u0026gt; int { return a * b; }; decltype(f) g = f; // lambda 的类型是独有且无名的  // 也不用定义函数指针了  cout \u0026lt;\u0026lt; typeid(f).name() \u0026lt;\u0026lt; endl; auto i = f(2, 2); decltype(g(3, 3)) j = g(3, 3); cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; \u0026#34;j = \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 输出：\nZ4mainEUliiE_ i = 4, j = 9 五、auto 注意事项   auto 变量必须在声明时初始化，这类似于 const 关键字。\n  定义在一个 auto 序列的变量必须始终推导成同一类型。\nauto a4 = 10, a5 = 20, a6 = 30; //正确 auto b4 = 10, b5 = 20.0, b6 = \u0026#39;a\u0026#39;; //错误   如果初始化表达式是引用，则去除引用语义。\nint main() { int a = 10; int \u0026amp;b = a; auto c = b; // c的类型为int而非int\u0026amp;（去除引用）  auto \u0026amp;d = b; // 此时c的类型才为int\u0026amp;  c = 100; //a = 10;  cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; d = 100; //a = 100;  cout \u0026lt;\u0026lt; \u0026#34;d = \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34; a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 输出：\nc = 100 a = 10 d = 100 a = 100   如果初始化表达式为 const 或 volatile（或者两者兼有），则除去 const/volatile 语义\n  如果 auto 关键字带上 \u0026amp; 号，则不去除 const 语义\nint main() { const int a1 = 10; auto b1= a1; // b1的类型为int而非const int（去除const）  // 与指针类似，只是为新变量开辟了新的空间  int* pB1 = (int*)\u0026amp;a1; b1 = 100; // 合法  *pB1 = 1000; // 合法  cout \u0026lt;\u0026lt; \u0026#34;b1 = \u0026#34; \u0026lt;\u0026lt; b1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a1 = \u0026#34; \u0026lt;\u0026lt; a1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;*pB1 = \u0026#34; \u0026lt;\u0026lt; *pB1 \u0026lt;\u0026lt; endl; const auto c1 = a1; // 此时c1的类型为const int  // c1 = 100; // 非法  auto\u0026amp; b2 = a1; // 因为auto带上\u0026amp;，故不去除const，b2类型为const int  // b2 = 100; // 非法  return 0; } 输出：\nb1 = 100 a1 = 10 *pB1 = 1000   初始化表达式为数组时，auto 关键字推导类型为指针。\n  若表达式为数组且 auto 带上 \u0026amp;，则推导类型为数组类型。\nint main() { int a3[3] = { 1, 2, 3 }; auto b3 = a3; cout \u0026lt;\u0026lt; typeid(b3).name() \u0026lt;\u0026lt; endl; auto\u0026amp; c3 = a3; cout \u0026lt;\u0026lt; typeid(c3).name() \u0026lt;\u0026lt; endl; return 0; } 输出：\nPi A3_i   函数形参或者模板参数不能被声明为 auto。\n  六、decltype 声明引用类型 struct A { double x; }; const A* a; decltype(a-\u0026gt;x) y; // y 的类型是 double（其声明类型） decltype((a-\u0026gt;x)) z = y; // z 的类型是 const double\u0026amp;（左值表达式） ","permalink":"https://874656645.github.io/rick/posts/130-c++11-auto-%E4%B8%8E-decltype-%E5%85%B3%E9%94%AE%E5%AD%97/","summary":"一、进行自动类型推导  auto 的自动类型推断发生在编译期，所以使用 auto 并不会造成程序运行时效率的降低。 而是否会造成编译期的时间消耗，我认为是不会的，在未使用 auto 时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换。  int main() { int a = 10; auto val = a; cout \u0026lt;\u0026lt; typeid(val).name() \u0026lt;\u0026lt; endl; // i  return 0; } 二、在定义模板函数时，用于声明依赖模板参数的变量类型 不到编译的时候，x * y 的真正类型很难确定\ntemplate \u0026lt;class _Tx,class _Ty\u0026gt; void Multiply(_Tx x, _Ty y) { auto v = x * y; std::cout \u0026lt;\u0026lt; v; } int main() { int a = 10; double b = 1.53; Multiply(a, b); // 15.","title":"C++11 auto 与 decltype 关键字"},{"content":"一、生成带有调试信息的程序 gcc main.c -o app -g\n二、启动调试  启动调试：gdb app 设置参数： set args\nset args 123 abc 456 ddd 查看代码： list 或 l  查看代码显示行数：show listsize 设置代码显示行数：set listsize 20 查看当前文件：  l l 行号 l 函数名   查看非当前文件：  l 文件名:行号 l 文件名:函数名      三、断点相关  设置断点：  break 行号 b 行号 b 函数名 b 文件名:行号 b 文件名:函数名   查看断点：info break 或 i b 删除断点：  del 断点Num d Num d Num1 Num2 d Num1-Num10   设置断点无效：dis Num 断点生效：ena Num 设置条件断点：b 行号 if i == 10  四、调试相关  启动运行：  start - s run - r   退出 gdb 调试：quit - q 打印变量的值：p 变量名 打印变量的类型：ptype 变量名 向下单步调试：  next - n step - s   跳出函数体：finish 从循环中跳出（循环体中不能有断点）：until 设置变量的值：set var 变量名 = value 继续运行到下一个断点：continue - c 监视变量：display 变量名 查看所有的监视变量的信息：info(i) display 取消变量监视：undisplay Num  ","permalink":"https://874656645.github.io/rick/posts/127-gdb-%E8%B0%83%E8%AF%95%E4%BD%BF%E7%94%A8/","summary":"一、生成带有调试信息的程序 gcc main.c -o app -g\n二、启动调试  启动调试：gdb app 设置参数： set args\nset args 123 abc 456 ddd 查看代码： list 或 l  查看代码显示行数：show listsize 设置代码显示行数：set listsize 20 查看当前文件：  l l 行号 l 函数名   查看非当前文件：  l 文件名:行号 l 文件名:函数名      三、断点相关  设置断点：  break 行号 b 行号 b 函数名 b 文件名:行号 b 文件名:函数名   查看断点：info break 或 i b 删除断点：  del 断点Num d Num d Num1 Num2 d Num1-Num10   设置断点无效：dis Num 断点生效：ena Num 设置条件断点：b 行号 if i == 10  四、调试相关  启动运行：  start - s run - r   退出 gdb 调试：quit - q 打印变量的值：p 变量名 打印变量的类型：ptype 变量名 向下单步调试：  next - n step - s   跳出函数体：finish 从循环中跳出（循环体中不能有断点）：until 设置变量的值：set var 变量名 = value 继续运行到下一个断点：continue - c 监视变量：display 变量名 查看所有的监视变量的信息：info(i) display 取消变量监视：undisplay Num  ","title":"gdb 调试使用"},{"content":"一、make  gcc 编译器 make 是 Linux 自带的构建器  二、文件命名  makefile Makefile  三、makefile 中的规则 例如：gcc a.c b.c c.c -o app\n  规则由三部分组成：目标、依赖、命令\napp:a.c b.c c.c gcc a.c b.c c.c -o app   makefile 中可以有多条规则\n  四、makefile 优化   版本一：\napp:main.c add.c sub.c gcc main.c add.c sub.c -I ./ -o app 存在的问题： 效率低，其中一个文件修改了，剩余的其它文件都要重新编译\n  版本二：\napp:main.o add.o sub.o gcc main.o add.o sub.o -I ./ -o app main.o:main.c gcc main.c -c -I ./ add.o:add.c gcc add.c -c -I ./ sub.o:sub.c gcc sub.c -c -I ./ 存在的问题： 冗余\n  版本三：\n 自定义变量：obj=a.o b.o c.o 自定义变量取值：tmp=$(obj) makefile 自带的变量，一般都是大写的 自动变量：只能在规则的命令中使用  $@：规则中的目标 $\u0026lt;：规则中的第一个依赖 $^：规则中的所有依赖    obj = main.o add.o sub.o target = app $(target):$(obj) gcc $(obj) -o $(target) -I ./ %.o:%.c gcc -c $\u0026lt; -o $@ -I ./ obj = main.o add.o sub.o target = app $(target):$(obj) gcc $^ -o $@ -I ./ %.o:%.c gcc -c $\u0026lt; -o $@ -I ./ 存在的问题： 可移植性比较差\n  版本四：（makefile 中的函数）\n wildcard：查找指定目录下指定类型的文件 patsubst：匹配替换  src = $(wildcard ./*.c) obj = $(patsubst %.c,%.o,$(src)) target = app $(target):$(obj) gcc $^ -o $@ -I ./ %.o:%.c gcc $\u0026lt; -c -I ./ 存在的问题： 不能自动清除\n  版本五：\n make 目标名：让 make 执行非终极目标 clean:：编写一个清理项目的规则（只有目标，没有依赖项） -f：强制执行 .PHONY:clean：声明伪目标，避免同名文件干扰 -命令：忽略执行失败的命令，继续向下执行  src = $(wildcard ./*.c) obj = $(patsubst %.c,%.o,$(src)) target = app $(target):$(obj) gcc $^ -o $@ -I ./ %.o:%.c gcc $\u0026lt; -c -I ./ .PHONY:clean clean: -mkdir /abc -rm *.o $(target) -f   ","permalink":"https://874656645.github.io/rick/posts/126-makefile-%E4%BD%BF%E7%94%A8/","summary":"一、make  gcc 编译器 make 是 Linux 自带的构建器  二、文件命名  makefile Makefile  三、makefile 中的规则 例如：gcc a.c b.c c.c -o app\n  规则由三部分组成：目标、依赖、命令\napp:a.c b.c c.c gcc a.c b.c c.c -o app   makefile 中可以有多条规则\n  四、makefile 优化   版本一：\napp:main.c add.c sub.c gcc main.c add.c sub.c -I ./ -o app 存在的问题： 效率低，其中一个文件修改了，剩余的其它文件都要重新编译\n  版本二：\napp:main.o add.o sub.o gcc main.o add.o sub.o -I ./ -o app main.","title":"Makefile 使用"},{"content":"一、库是什么 库是二进制格式的源代码（二进制加密）\n二、库的使用  头文件 制作的库文件  三、静态库的制作和使用  命名规则 libxxx.a 制作步骤  准备源代码文件 将源代码文件生成 .o 文件 gcc -c *.c 将 .o 文件打包（archive） ar rcs libxxx.a *.o 查看 lib 文件 nm libxxx.a   库的使用 gcc main.c -I./include -L ./lib -lmyCalc -o app  -L: 库的路径 -l: 库的名称（去掉 lib 前缀和 .a 后缀）    四、动态库的制作和使用  命名规则 libxxx.so 制作步骤  准备源代码文件 将源代码文件生成 .o 文件 gcc -c -fpic *.c 或者 gcc -c -fPIC *.c 将 .o 文件打包 gcc -shared -o libxxx.so *.o   库的使用  gcc main.c -I ./include -L ./lib -l mycalc -o app2   动态库无法加载（4 种方式）  使用临时环境变量设置：export LD_LIBRARY_PATH=./lib:$LD_LIBRARY_PATH 修改用户级别的配置文件：打开 ~/.bashrc文件，将 export LD_LIBRARY_PATH=~/lib （注：等号两边不要有空格）添加到文件最后，重启 bash 终端或 source ~/.bashrc 修改系统级别的配置文件：/etc/profile，重复上面的步骤 更新 /etc/ld_so_cache 文件列表  将库的绝对路径（注：必需是绝对路径，不能使用类似 ~ 代替）添加到配置文件中 etc/ld.so.conf 执行 sudo ldconfig -v 命令   拓展，使用函数调用：dlopen、dlclose、dlsym Linux动态库路径查找顺序：\n    五、其它命令  file app2\n ldd app2\n  ","permalink":"https://874656645.github.io/rick/posts/125-linux-%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/","summary":"一、库是什么 库是二进制格式的源代码（二进制加密）\n二、库的使用  头文件 制作的库文件  三、静态库的制作和使用  命名规则 libxxx.a 制作步骤  准备源代码文件 将源代码文件生成 .o 文件 gcc -c *.c 将 .o 文件打包（archive） ar rcs libxxx.a *.o 查看 lib 文件 nm libxxx.a   库的使用 gcc main.c -I./include -L ./lib -lmyCalc -o app  -L: 库的路径 -l: 库的名称（去掉 lib 前缀和 .a 后缀）    四、动态库的制作和使用  命名规则 libxxx.so 制作步骤  准备源代码文件 将源代码文件生成 .o 文件 gcc -c -fpic *.c 或者 gcc -c -fPIC *.","title":"Linux 静态库与动态库"},{"content":"一、gcc 工作流程  预处理 —— -E  宏替换 头文件展开 去掉注释 生成 .i 文件   编译 —— -S  生成 .s 文件 汇编文件   汇编 —— -c  生成 .o 文件 二进制文件   链接   二、gcc 常用参数  -v / --version -I : 编译时指定头文件路径 -c : 生成二进制文件 .o -o : 指定生成的文件名 -g : gdb 调试，生成带有调试信息的二进制文件（Debug模式） -D : 编译时指定一个宏 -Wall : 显示警告信息 -On : 优化代码，n 是优化级别（1，2，3）  ","permalink":"https://874656645.github.io/rick/posts/124-gcc-%E7%9B%B8%E5%85%B3/","summary":"一、gcc 工作流程  预处理 —— -E  宏替换 头文件展开 去掉注释 生成 .i 文件   编译 —— -S  生成 .s 文件 汇编文件   汇编 —— -c  生成 .o 文件 二进制文件   链接   二、gcc 常用参数  -v / --version -I : 编译时指定头文件路径 -c : 生成二进制文件 .o -o : 指定生成的文件名 -g : gdb 调试，生成带有调试信息的二进制文件（Debug模式） -D : 编译时指定一个宏 -Wall : 显示警告信息 -On : 优化代码，n 是优化级别（1，2，3）  ","title":"gcc 相关"},{"content":"  NULL，0，'\\0'，\u0026lsquo;0\u0026rsquo;\nint main() { char arr[] = {0, \u0026#39;\\0\u0026#39;, \u0026#39;0\u0026#39;, 48}; printf(\u0026#34;%c\\n\u0026#34;, arr[0]); printf(\u0026#34;%c\\n\u0026#34;, arr[1]); printf(\u0026#34;%c\\n\u0026#34;, arr[2]); printf(\u0026#34;%c\\n\u0026#34;, arr[3]); printf(\u0026#34;---------------\\n\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;, arr[0]); printf(\u0026#34;%d\\n\u0026#34;, arr[1]); printf(\u0026#34;%d\\n\u0026#34;, arr[2]); printf(\u0026#34;%d\\n\u0026#34;, arr[3]); return 0; } 输出：\n0 0 --------------- 0 0 48 48   UTF-8 向下兼容 ASCII 编码，UTF-8 编码中，一个英文字为一个字节，一个中文一般为三个字节（ASCII、Unicode、UTF-8）\n 0xxxxxxx：单字节编码形式，这和 ASCII 编码完全一样，因此 UTF-8 是兼容 ASCII 的； 110xxxxx 10xxxxxx：双字节编码形式； 1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式； 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式； UTF-8：每字 1 ~ 6 字节 Unicode（UCS-2）：每字都是 2 bytes UTF-16：每字 2 ~ 4 字节 UTF-32（UCS-4）：每字都是 4 bytes    float 单精度，浮点数在内存中是按科学计数法来存储的，小数点后6位能确定表示，float 是由 1 bit 符号位，8 bit 指数位和 23 bit 尾数位组成，精度是由尾数位决定的（2^23 = 8388608）\nbool test(float a, float b){ float t = (a + b) - a - b; cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; return t == 0; } int main() { // 第五位及以后的数字，大于等于 8 的数字就不稳定了  cout \u0026lt;\u0026lt; test(1.12348, 2.12348) \u0026lt;\u0026lt; endl; return 0; } 输出：\n-2.38419e-07 0   double 双精度是由 1 bit 符号位，11 bit 指数位和 52 bit 尾数位组成\n  IPv4 地址由 4 部分组成，每部分 8 bit，一共 32 bit，每部分用 10 进制表示，中间用 . 隔开\n  IPv6 地址由 8 部分组成，每部分 16 bit，一共 128 bit，每部分用 16 进制表示，中间用 : 隔开\n  ","permalink":"https://874656645.github.io/rick/posts/123-2022-02-14%E6%9D%82%E8%AE%B0/","summary":"NULL，0，'\\0'，\u0026lsquo;0\u0026rsquo;\nint main() { char arr[] = {0, \u0026#39;\\0\u0026#39;, \u0026#39;0\u0026#39;, 48}; printf(\u0026#34;%c\\n\u0026#34;, arr[0]); printf(\u0026#34;%c\\n\u0026#34;, arr[1]); printf(\u0026#34;%c\\n\u0026#34;, arr[2]); printf(\u0026#34;%c\\n\u0026#34;, arr[3]); printf(\u0026#34;---------------\\n\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;, arr[0]); printf(\u0026#34;%d\\n\u0026#34;, arr[1]); printf(\u0026#34;%d\\n\u0026#34;, arr[2]); printf(\u0026#34;%d\\n\u0026#34;, arr[3]); return 0; } 输出：\n0 0 --------------- 0 0 48 48   UTF-8 向下兼容 ASCII 编码，UTF-8 编码中，一个英文字为一个字节，一个中文一般为三个字节（ASCII、Unicode、UTF-8）\n 0xxxxxxx：单字节编码形式，这和 ASCII 编码完全一样，因此 UTF-8 是兼容 ASCII 的； 110xxxxx 10xxxxxx：双字节编码形式； 1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式； 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式； UTF-8：每字 1 ~ 6 字节 Unicode（UCS-2）：每字都是 2 bytes UTF-16：每字 2 ~ 4 字节 UTF-32（UCS-4）：每字都是 4 bytes    float 单精度，浮点数在内存中是按科学计数法来存储的，小数点后6位能确定表示，float 是由 1 bit 符号位，8 bit 指数位和 23 bit 尾数位组成，精度是由尾数位决定的（2^23 = 8388608）","title":"2022-02-14 杂记"},{"content":"一、使用教程   vimtutor\n  显示行号:\nvim ~/.vimrc 在文件的最后一行输入 set number 并保存退出   二、vim 三种工作模式  命令模式 编辑模式 末行模式\n  三、命令模式下的相关操作  保存退出\nZZ 代码格式化\ngg=G 光标移动：  左下上右：H J K L 移动到行首：0 移动到行尾：$ 移动到文件首部：gg 移动到文件尾部：G 跳转到第20行：20 + G 从当前位置向下移动 n 行：n + enter   删除命令：  删除光标后的一个字符：x（小写） 删除光标前的一个字符：X（大写） 删除一个单词：dw 删除光标前的所有字符：d0 删除光标后的所有字符：d$ 或者 D 删除光标所在行：dd 删除多行：ndd 删除光标所在行以及下面 n 行 删除光标所在行到文件首部的字符：dgg 删除光标所在行到文件尾部的字符：dG   撤销与反撤销：  撤销：u 反撤销：ctrl + r   复制粘贴：  复制一行：yy 复制多行：nyy 粘贴到光标下一行：p 粘贴到光标上一行：P(大写)   字符可视模式：v  移动光标 复制：y 删除：d 粘贴：p(小写 光标之后) P(大写 光标之前)   行可视模式：V  增加缩进：\u0026gt; 减少缩进：\u0026lt;   块可视模式：ctrl + V  o：将光标在块的左上角和右下角切换 O：将光标移动到所在行的对角 nl：将光标向右移动 n 个字符 nj：将光标向下移动 n 行 I：插入，按两次 ESC 退出（例如：多行注释操作）   替换操作：  r：替换光标后的字符 R：替换光标后的多个字符   查找操作：  /xxx ?xxx # 查找光标所在的单词 n 或 N 切换到下一个   想看 man 文档  光标移动到要查的内容上，然后 章节号 + K shell 命令：man 3 printf man man    四、命令模式切换到文本编辑模式  a：在光标所覆盖的字符后面插入 A：行尾部插入 i：在光标所覆盖的字符前面插入 I：行首部插入 o：在光标所在行的下一行开始插入 O：在光标所在行的上一行开始插入 s：删除掉光标覆盖的字符并开始插入 S：删除光标所在的整行并开始插入  五、末行模式  从命令模式进入末行模式：: 保存退出：:wq 或 :x 保存：:w 退出：:q 退出不保存：:q! 跳转到第 n 行：:n 删除从 m 行到 n 行：:m,nd 末行模式下执行 shell 命令：:!ls  六、替换  替换光标所在行的字符串：:s/old/new 替换光标所在行所有的字符串：:s/old/new/g 替换光标所在行所有的字符串并提示确认：:s/old/new/gc 替换某些行范围内的字符串：:10,20s/old/new 替换某些行范围内的所有字符串：:10,20s/old/new/g 替换当前文档所有的：:%s/old/new/g  七、分屏操作  当前文件分屏：:sp 或 :vsp 两个屏幕显示不同的文件：:sp 文件名 或 :vsp 文件名 分屏关闭：:qall :wqall :q 屏幕切换：ctrl + w + w 打开的时候分屏：vi -o 多个文件名 或 vi -O 多个文件名  ","permalink":"https://874656645.github.io/rick/posts/122-vim-%E4%BD%BF%E7%94%A8/","summary":"一、使用教程   vimtutor\n  显示行号:\nvim ~/.vimrc 在文件的最后一行输入 set number 并保存退出   二、vim 三种工作模式  命令模式 编辑模式 末行模式\n  三、命令模式下的相关操作  保存退出\nZZ 代码格式化\ngg=G 光标移动：  左下上右：H J K L 移动到行首：0 移动到行尾：$ 移动到文件首部：gg 移动到文件尾部：G 跳转到第20行：20 + G 从当前位置向下移动 n 行：n + enter   删除命令：  删除光标后的一个字符：x（小写） 删除光标前的一个字符：X（大写） 删除一个单词：dw 删除光标前的所有字符：d0 删除光标后的所有字符：d$ 或者 D 删除光标所在行：dd 删除多行：ndd 删除光标所在行以及下面 n 行 删除光标所在行到文件首部的字符：dgg 删除光标所在行到文件尾部的字符：dG   撤销与反撤销：  撤销：u 反撤销：ctrl + r   复制粘贴：  复制一行：yy 复制多行：nyy 粘贴到光标下一行：p 粘贴到光标上一行：P(大写)   字符可视模式：v  移动光标 复制：y 删除：d 粘贴：p(小写 光标之后) P(大写 光标之前)   行可视模式：V  增加缩进：\u0026gt; 减少缩进：\u0026lt;   块可视模式：ctrl + V  o：将光标在块的左上角和右下角切换 O：将光标移动到所在行的对角 nl：将光标向右移动 n 个字符 nj：将光标向下移动 n 行 I：插入，按两次 ESC 退出（例如：多行注释操作）   替换操作：  r：替换光标后的字符 R：替换光标后的多个字符   查找操作：  /xxx ?","title":"vim 使用"},{"content":"WSL 的基本命令\n  安装 WSL\nwsl --install\n  查看可用的 Linux 发行版\nwsl -l -o\n  查看已安装的 Linux 分发版\nwsl -l -v\n  注销 Linux 发行版\nwsl --unregister Ubuntu\n  可以直接从官网下载 Linux 发行版的安装包，然后将 appx 扩展名改为 zip，解压到想要放置的目录，双击 ubuntu.exe\n  ","permalink":"https://874656645.github.io/rick/posts/121-windows-10-%E4%B8%AD%E7%9A%84-linux-%E5%AD%90%E7%B3%BB%E7%BB%9F/","summary":"WSL 的基本命令\n  安装 WSL\nwsl --install\n  查看可用的 Linux 发行版\nwsl -l -o\n  查看已安装的 Linux 分发版\nwsl -l -v\n  注销 Linux 发行版\nwsl --unregister Ubuntu\n  可以直接从官网下载 Linux 发行版的安装包，然后将 appx 扩展名改为 zip，解压到想要放置的目录，双击 ubuntu.exe\n  ","title":"Windows 10 中的 Linux 子系统"},{"content":"         bin 二进制文件，可执行文件   boot 系统开机启动项   dev device 设备（硬盘、显卡、显示器 一切皆文件）   lib 动态库   mnt 手动挂载目录   media 外设自动挂载目录   root 超级用户的家目录   usr unix system resource 头文件include、源文件src、用户安装程序/usr/local   etc 配置文件   opt 安装第三方应用程序   home Linux 所有用户的家目录（操作系统的家目录）   tmp 临时文件目录，系统重启后会被清空    ","permalink":"https://874656645.github.io/rick/posts/120-linux-%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/","summary":"         bin 二进制文件，可执行文件   boot 系统开机启动项   dev device 设备（硬盘、显卡、显示器 一切皆文件）   lib 动态库   mnt 手动挂载目录   media 外设自动挂载目录   root 超级用户的家目录   usr unix system resource 头文件include、源文件src、用户安装程序/usr/local   etc 配置文件   opt 安装第三方应用程序   home Linux 所有用户的家目录（操作系统的家目录）   tmp 临时文件目录，系统重启后会被清空    ","title":"Linux 目录介绍"},{"content":"  逆序打印字符串\nvoid printReverseString(const char* str){ if(*str == \u0026#39;\\0\u0026#39;){ return; } printReverseString(str + 1); printf(\u0026#34;%c\u0026#34;, *str); } int main() { const char* str = \u0026#34;Hello World\u0026#34;; printReverseString(str); // dlroW olleH  return 0; }   逆序输出链表\nstruct LinkNode{ int data; struct LinkNode* next; }; void printReverseLinkNode(struct LinkNode* header){ if(header == NULL){ return; } printReverseLinkNode(header-\u0026gt;next); printf(\u0026#34;%d\\n\u0026#34;, header-\u0026gt;data); } int main() { struct LinkNode* header = malloc(sizeof(struct LinkNode)); struct LinkNode* node1 = malloc(sizeof(struct LinkNode)); node1-\u0026gt;data = 10; node1-\u0026gt;next = NULL; struct LinkNode* node2 = malloc(sizeof(struct LinkNode)); node2-\u0026gt;data = 20; node2-\u0026gt;next = NULL; struct LinkNode* node3 = malloc(sizeof(struct LinkNode)); node3-\u0026gt;data = 30; node3-\u0026gt;next = NULL; header-\u0026gt;next = node1; node1-\u0026gt;next = node2; node2-\u0026gt;next = node3; printReverseLinkNode(header-\u0026gt;next); return 0; }   递归实现给出一个数 8793，依次打印千位数 8、百位数 7、十位数 9、个位数 3\nvoid printNum(int num){ if(num == 0){ return; } int val = num / 10; printNum(val); printf(\u0026#34;%d \u0026#34;, num % 10); } int main() { int num = 8973; printNum(num); // 8 9 7 3  return 0; }   ","permalink":"https://874656645.github.io/rick/posts/119-%E9%80%92%E5%BD%92/","summary":"逆序打印字符串\nvoid printReverseString(const char* str){ if(*str == \u0026#39;\\0\u0026#39;){ return; } printReverseString(str + 1); printf(\u0026#34;%c\u0026#34;, *str); } int main() { const char* str = \u0026#34;Hello World\u0026#34;; printReverseString(str); // dlroW olleH  return 0; }   逆序输出链表\nstruct LinkNode{ int data; struct LinkNode* next; }; void printReverseLinkNode(struct LinkNode* header){ if(header == NULL){ return; } printReverseLinkNode(header-\u0026gt;next); printf(\u0026#34;%d\\n\u0026#34;, header-\u0026gt;data); } int main() { struct LinkNode* header = malloc(sizeof(struct LinkNode)); struct LinkNode* node1 = malloc(sizeof(struct LinkNode)); node1-\u0026gt;data = 10; node1-\u0026gt;next = NULL; struct LinkNode* node2 = malloc(sizeof(struct LinkNode)); node2-\u0026gt;data = 20; node2-\u0026gt;next = NULL; struct LinkNode* node3 = malloc(sizeof(struct LinkNode)); node3-\u0026gt;data = 30; node3-\u0026gt;next = NULL; header-\u0026gt;next = node1; node1-\u0026gt;next = node2; node2-\u0026gt;next = node3; printReverseLinkNode(header-\u0026gt;next); return 0; }   递归实现给出一个数 8793，依次打印千位数 8、百位数 7、十位数 9、个位数 3","title":"递归"},{"content":"int main() { printf(\u0026#34;%s\\n\u0026#34;, __FILE__); // main.c  printf(\u0026#34;%d\\n\u0026#34;, __LINE__); // 14  printf(\u0026#34;%s\\n\u0026#34;, __DATE__); // Feb 7 2022  printf(\u0026#34;%s\\n\u0026#34;, __TIME__); // 01:59:37  return 0; } // func1.h #ifdef __cplusplus extern \u0026#34;C\u0026#34;{ #endif  void func1(); #ifdef __cplusplus } #endif  // main.h extern \u0026#34;C\u0026#34;{ include \u0026#34;func1.h\u0026#34; } extern \u0026#34;C\u0026#34;{ extern void func1(); } int main() { func1(); return 0; } ","permalink":"https://874656645.github.io/rick/posts/118-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/","summary":"int main() { printf(\u0026#34;%s\\n\u0026#34;, __FILE__); // main.c  printf(\u0026#34;%d\\n\u0026#34;, __LINE__); // 14  printf(\u0026#34;%s\\n\u0026#34;, __DATE__); // Feb 7 2022  printf(\u0026#34;%s\\n\u0026#34;, __TIME__); // 01:59:37  return 0; } // func1.h #ifdef __cplusplus extern \u0026#34;C\u0026#34;{ #endif  void func1(); #ifdef __cplusplus } #endif  // main.h extern \u0026#34;C\u0026#34;{ include \u0026#34;func1.h\u0026#34; } extern \u0026#34;C\u0026#34;{ extern void func1(); } int main() { func1(); return 0; } ","title":"常用的宏定义"},{"content":"Linux 命令大全\n一、更新和升级包 1. 更新和升级包 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade 2. 安装软件 sudo apt-get install tree 二、shell 操作和常用命令 1、查看输入的命令历史 history 2、删除光标前面的字符串 ctrl + u 3、删除光标后面的字符串 ctrl + k 4、光标定位到头部 ctrl + a 5、光标定位到尾部 ctrl + e 6、命令、路径补全 Tab 7、缩写别名 alias 8、查看说明 man 5 passwd 9、宿主目录 ~ 10、查看目录内容 tree ~ 11、打印工作目录 pwd 12、表示当前用户是普通用户 $ 13、表示当前用户是超级用户 # 14、切换超级用户 sudo su 15、 查看文件和目录 ls ls -a ls -l // -rwxrw-r-- 1 rick rick 0 Feb 12 18:37 test ls -lh ls -alF // drwxr-xr-x 1 rick rick 4096 Feb 12 18:37 rick/ ll 16、 cd cd /home/rick cd ~ cd cd - // 切换到上一个的历史目录 17、 mkdir 目录名 mkdir aa mkdir aa/bb rm aa -r mkdir aa/bb/cc -p 18、 touch 文件名  如果文件不存在，则创建文件 如果文件存在，更新文件时间  19、 rmdir 删除空目录  只能删除空目录  20、 rm 删除目录和文件  删除后很难恢复  rm -r // 用递归的方式删除目录 rm -ri // 提示 rm aa/* -r // 删除 aa 目录下的所有文件和目录 21、 cp 拷贝 cp file file1 // file1 不存在，则创建 file1 并把 file 中的内容拷贝进去 cp file file1 // file1 存在，则会用 file 中的内容覆盖 file1 中的内容 cp file dir // 将 file 拷贝到 dir 目录下 cp dir dir1 // dir1 目录不存在，则把 dir 的所有子目录拷贝到 dir1 目录下 rm dir1/* -r cp dir dir1 // dir1 目录存在，则把 dir 整个目录拷贝到 dir1 目录下 22、 mv mv file file1 // file1 不存在，则是将 file 文件改名为 file1 mv file file1 // file1 存在，则用 file 中的内容覆盖 file1 中的内容，并删除 file mv file dir // dir 存在，将 file 移动到 dir 目录下 mv dir dir1 // dir1 不存在，就是将 dir 改名为 dir1 mv dir dir1 // dir1 存在，则将 dir 目录移动到 dir1下 23、 cat 将文件内容打印到终端  适用文件内容较小的情况  23、 more 将文件内容打印到终端  不能向上翻页 Enter 向下滚动一行 空格：向下翻页 退出：q  23、 less 将文件内容打印到终端  Enter 或 ctrl + n : 向下滚动一行 ctrl + p : 向上滚动一行 pgdn : 向下翻页 空格 : 向下翻页 pgup : 向上翻页 q : 退出  23、 head 打印文件内容的前 10 行到终端 24、 tail 打印文件内容的后 10 行到终端 25、 ln 创建软硬链接  创建软链接 ln -s 全文件名 链接名称 创建硬链接（在其他多个目录中管理文件，并且能时时同步修改） ln 文件名 链接名  26、 chmod 修改权限 chmod uo-rw program chmod u+r,g-x program chmod -440 program chmod 777 program 27、 chown 修改所有者或所属组 sudo chown sys program sudo chown rick:sys program 28、 chgrp 所属组 sudo chgrp rick program\n29、 find 查找 find ./ -name \u0026#34;program\u0026#34; // 按文件名查找 find ./ -type f // 按文件类型查找（7种） find ./ -size -4k find ./ -size +2k -size -10k // 按文件大小查找 find ./ -ctime -1 // 按日期查找（-ctime、-mtime、-atime） find ./ -type d -exec ls -l {} \\; // 查找指定目录，并列出该目录中文件详细信息 find ./ -type d | xargs ls -l // 利用管道，效率较高 30、 grep 所属组 grep -r \u0026#34;hello\u0026#34; ./ -n 31、 写入文件 ls -l \u0026gt; fileinfo\n三、Linux 文件类型          - 普通文件   d 目录   l 符号链接   p 管道   s 套接字   c 字符设备（鼠标、键盘）   b 块设备（U盘、硬盘)    四、用户类型          user 文件所有者（rwx）   group 文件所属组用户（rw-）   other 其他用户（r--）    五、权限          r 读   w 写   x 执行    六、压缩包管理 1. 常见压缩格式  .gz \u0026ndash;gzip .bz2 \u0026ndash;bzip2  2. 常用压缩命令  gzip file 压缩 gunzip *.gz 解压 tar 打包\ntar -zcvf test.tar.gz aa program\ntar -zxvf test.tar.gz -C /tmp rar 需要安装 sudo apt-get install rar\nrar a all aa program\nrar a all aa/ program -r 目录加 -r\nrar x all.rar /tmp zip / unzip 需要安装 sudo apt-get install zip\nzip myzip aa program -r\nunzip myzip.zip -d /tmp  七、软件安装和制裁 1. 在线安装 \u0026ndash; ubuntu  安装：sudo apt-get(apt) install 安装包名称 卸载：sudo apt-get(apt) remove 软件名称 软件列表更新：sudo apt-get(apt) update 清空缓存：sudo apt-get(apt) clean 缓存路径：/var/cache/apt/archives 中的红色 *.deb 文件  2. 软件包安装  安装：sudo dpkg -i xxx.deb 卸载：sudo dpkg -r 软件名称  3. 源码安装 ","permalink":"https://874656645.github.io/rick/posts/117-ubuntu-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","summary":"Linux 命令大全\n一、更新和升级包 1. 更新和升级包 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade 2. 安装软件 sudo apt-get install tree 二、shell 操作和常用命令 1、查看输入的命令历史 history 2、删除光标前面的字符串 ctrl + u 3、删除光标后面的字符串 ctrl + k 4、光标定位到头部 ctrl + a 5、光标定位到尾部 ctrl + e 6、命令、路径补全 Tab 7、缩写别名 alias 8、查看说明 man 5 passwd 9、宿主目录 ~ 10、查看目录内容 tree ~ 11、打印工作目录 pwd 12、表示当前用户是普通用户 $ 13、表示当前用户是超级用户 # 14、切换超级用户 sudo su 15、 查看文件和目录 ls ls -a ls -l // -rwxrw-r-- 1 rick rick 0 Feb 12 18:37 test ls -lh ls -alF // drwxr-xr-x 1 rick rick 4096 Feb 12 18:37 rick/ ll 16、 cd cd /home/rick cd ~ cd cd - // 切换到上一个的历史目录 17、 mkdir 目录名 mkdir aa mkdir aa/bb rm aa -r mkdir aa/bb/cc -p 18、 touch 文件名  如果文件不存在，则创建文件 如果文件存在，更新文件时间  19、 rmdir 删除空目录  只能删除空目录  20、 rm 删除目录和文件  删除后很难恢复  rm -r // 用递归的方式删除目录 rm -ri // 提示 rm aa/* -r // 删除 aa 目录下的所有文件和目录 21、 cp 拷贝 cp file file1 // file1 不存在，则创建 file1 并把 file 中的内容拷贝进去 cp file file1 // file1 存在，则会用 file 中的内容覆盖 file1 中的内容 cp file dir // 将 file 拷贝到 dir 目录下 cp dir dir1 // dir1 目录不存在，则把 dir 的所有子目录拷贝到 dir1 目录下 rm dir1/* -r cp dir dir1 // dir1 目录存在，则把 dir 整个目录拷贝到 dir1 目录下 22、 mv mv file file1 // file1 不存在，则是将 file 文件改名为 file1 mv file file1 // file1 存在，则用 file 中的内容覆盖 file1 中的内容，并删除 file mv file dir // dir 存在，将 file 移动到 dir 目录下 mv dir dir1 // dir1 不存在，就是将 dir 改名为 dir1 mv dir dir1 // dir1 存在，则将 dir 目录移动到 dir1下 23、 cat 将文件内容打印到终端  适用文件内容较小的情况  23、 more 将文件内容打印到终端  不能向上翻页 Enter 向下滚动一行 空格：向下翻页 退出：q  23、 less 将文件内容打印到终端  Enter 或 ctrl + n : 向下滚动一行 ctrl + p : 向上滚动一行 pgdn : 向下翻页 空格 : 向下翻页 pgup : 向上翻页 q : 退出  23、 head 打印文件内容的前 10 行到终端 24、 tail 打印文件内容的后 10 行到终端 25、 ln 创建软硬链接  创建软链接 ln -s 全文件名 链接名称 创建硬链接（在其他多个目录中管理文件，并且能时时同步修改） ln 文件名 链接名  26、 chmod 修改权限 chmod uo-rw program chmod u+r,g-x program chmod -440 program chmod 777 program 27、 chown 修改所有者或所属组 sudo chown sys program sudo chown rick:sys program 28、 chgrp 所属组 sudo chgrp rick program","title":"Linux 常用命令"},{"content":"void printArr(const char ** p, int len){ for(int i = 0; i \u0026lt; len; ++i){ cout \u0026lt;\u0026lt; p[i] \u0026lt;\u0026lt; endl; } } void sortSelect(const char ** p, int len){ for(int i = 0; i \u0026lt; len - 1; ++i){ int max = i; for(int j = i + 1; j \u0026lt; len; ++j){ if(p[j] \u0026gt; p[max]){ max = j; } } // 交换  if(i != max){ const char* tmp = p[i]; p[i] = p[max]; p[max] = tmp; } } } int main() { const char* arr[] = {\u0026#34;aa\u0026#34;, \u0026#34;bb\u0026#34;, \u0026#34;cc\u0026#34;, \u0026#34;dd\u0026#34;, \u0026#34;ee\u0026#34;}; int len = sizeof(arr) / sizeof(char*); cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; printArr(arr, len); sortSelect(arr, len); cout \u0026lt;\u0026lt; \u0026#34;----------------\u0026#34; \u0026lt;\u0026lt; endl; printArr(arr, len); return 0; } 输出：\n5 aa bb cc dd ee ---------------- ee dd cc bb aa ","permalink":"https://874656645.github.io/rick/posts/116-char-%E6%98%9F%E6%95%B0%E7%BB%84/","summary":"void printArr(const char ** p, int len){ for(int i = 0; i \u0026lt; len; ++i){ cout \u0026lt;\u0026lt; p[i] \u0026lt;\u0026lt; endl; } } void sortSelect(const char ** p, int len){ for(int i = 0; i \u0026lt; len - 1; ++i){ int max = i; for(int j = i + 1; j \u0026lt; len; ++j){ if(p[j] \u0026gt; p[max]){ max = j; } } // 交换  if(i != max){ const char* tmp = p[i]; p[i] = p[max]; p[max] = tmp; } } } int main() { const char* arr[] = {\u0026#34;aa\u0026#34;, \u0026#34;bb\u0026#34;, \u0026#34;cc\u0026#34;, \u0026#34;dd\u0026#34;, \u0026#34;ee\u0026#34;}; int len = sizeof(arr) / sizeof(char*); cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; printArr(arr, len); sortSelect(arr, len); cout \u0026lt;\u0026lt; \u0026#34;----------------\u0026#34; \u0026lt;\u0026lt; endl; printArr(arr, len); return 0; } 输出：","title":"char* 数组"},{"content":"装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代。\n装饰模式可以动态给一个类增加功能\n","permalink":"https://874656645.github.io/rick/posts/115-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代。\n装饰模式可以动态给一个类增加功能","title":"装饰器模式"},{"content":"观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者。\n","permalink":"https://874656645.github.io/rick/posts/114-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者。","title":"观察者模式"},{"content":"将一个请求封闭为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作（Action）模式或事务（Transaction）模式。\n命令模式可以将请求者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求\n","permalink":"https://874656645.github.io/rick/posts/113-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","summary":"将一个请求封闭为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作（Action）模式或事务（Transaction）模式。\n命令模式可以将请求者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求","title":"命令模式"},{"content":"策略模式定义了一系列的算法，并将每个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。\n","permalink":"https://874656645.github.io/rick/posts/112-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","summary":"策略模式定义了一系列的算法，并将每个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。","title":"策略模式"},{"content":"定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\nclass TemplateDrink{ public: virtual void boilWater() = 0; virtual void drew() = 0; virtual void pourCup() = 0; virtual void addSomething() = 0; void make(){ boilWater(); drew(); pourCup(); addSomething(); } }; class Tea : public TemplateDrink{ public: void boilWater() override{ cout \u0026lt;\u0026lt; \u0026#34;煮山泉水...\u0026#34; \u0026lt;\u0026lt; endl; } void drew() override{ cout \u0026lt;\u0026lt; \u0026#34;冲龙井茶...\u0026#34; \u0026lt;\u0026lt; endl; } void pourCup() override{ cout \u0026lt;\u0026lt; \u0026#34;倒入茶杯中...\u0026#34; \u0026lt;\u0026lt; endl; } void addSomething() override{ cout \u0026lt;\u0026lt; \u0026#34;加点柠檬...\u0026#34; \u0026lt;\u0026lt; endl; } }; class Coffee : public TemplateDrink{ public: void boilWater() override{ cout \u0026lt;\u0026lt; \u0026#34;煮矿泉水...\u0026#34; \u0026lt;\u0026lt; endl; } void drew() override{ cout \u0026lt;\u0026lt; \u0026#34;冲雀巢咖啡...\u0026#34; \u0026lt;\u0026lt; endl; } void pourCup() override{ cout \u0026lt;\u0026lt; \u0026#34;倒入咖啡杯中...\u0026#34; \u0026lt;\u0026lt; endl; } void addSomething() override{ cout \u0026lt;\u0026lt; \u0026#34;加点糖和牛奶...\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Tea myTea; myTea.make(); cout \u0026lt;\u0026lt; \u0026#34;-------------------\u0026#34; \u0026lt;\u0026lt; endl; Coffee myCoffee; myCoffee.make(); return 0; } ","permalink":"https://874656645.github.io/rick/posts/111-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","summary":"定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\nclass TemplateDrink{ public: virtual void boilWater() = 0; virtual void drew() = 0; virtual void pourCup() = 0; virtual void addSomething() = 0; void make(){ boilWater(); drew(); pourCup(); addSomething(); } }; class Tea : public TemplateDrink{ public: void boilWater() override{ cout \u0026lt;\u0026lt; \u0026#34;煮山泉水...\u0026#34; \u0026lt;\u0026lt; endl; } void drew() override{ cout \u0026lt;\u0026lt; \u0026#34;冲龙井茶...\u0026#34; \u0026lt;\u0026lt; endl; } void pourCup() override{ cout \u0026lt;\u0026lt; \u0026#34;倒入茶杯中...\u0026#34; \u0026lt;\u0026lt; endl; } void addSomething() override{ cout \u0026lt;\u0026lt; \u0026#34;加点柠檬.","title":"模板方法模式"},{"content":"有一个已经写好的接口，但是不符合需求，适配器就是将已有的接口转化为需要的形式\nclass MyPrint{ public: void operator()(int a, int b){ cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; } }; class TargetInterface{ public: virtual void operator()(int v) = 0; }; class MyAdaptor : public TargetInterface{ public: MyAdaptor(int param):param(param){} void operator()(int v){ print(v, param); } private: MyPrint print; int param; }; MyAdaptor myBind2nd(int v){ return MyAdaptor(v); } int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(i); } for_each(v.begin(), v.end(), myBind2nd(10)); return 0; } ","permalink":"https://874656645.github.io/rick/posts/110-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"有一个已经写好的接口，但是不符合需求，适配器就是将已有的接口转化为需要的形式\nclass MyPrint{ public: void operator()(int a, int b){ cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; } }; class TargetInterface{ public: virtual void operator()(int v) = 0; }; class MyAdaptor : public TargetInterface{ public: MyAdaptor(int param):param(param){} void operator()(int v){ print(v, param); } private: MyPrint print; int param; }; MyAdaptor myBind2nd(int v){ return MyAdaptor(v); } int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(i); } for_each(v.begin(), v.","title":"适配器模式"},{"content":"将复杂的子系统抽象到同一个接口进行管理，外界只需要通过此接口与子类系统进行交互，而不必直接与复杂的子类系统进行交互\n案例：家庭影院外观模式 实现KTV模式：电视打开，灯关掉，音响打开，麦克风打开，DVD打开\n实现游戏模式：电视打开，音响打开，游戏机打开\n","permalink":"https://874656645.github.io/rick/posts/109-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","summary":"将复杂的子系统抽象到同一个接口进行管理，外界只需要通过此接口与子类系统进行交互，而不必直接与复杂的子类系统进行交互\n案例：家庭影院外观模式 实现KTV模式：电视打开，灯关掉，音响打开，麦克风打开，DVD打开\n实现游戏模式：电视打开，音响打开，游戏机打开","title":"外观模式"},{"content":"为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。\n","permalink":"https://874656645.github.io/rick/posts/108-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","summary":"为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。","title":"代理模式"},{"content":" 单例在内存中只有一份，在内存中不会占用太多，程序退出时会随着程序统一释放内存，所以可以不必特意释放  一、懒汉式 不是线程安全的，所以多线程使用要加锁\nclass Singleton{ public: static Singleton* getInstance(){ if(s_instance == nullptr){ s_instance = new Singleton; } return s_instance; } // 可有可无，程序结束时，系统会自动回收程序的所有内存  class Garbo{ ~Garbo(){ if(s_instance){ cout \u0026lt;\u0026lt; \u0026#34;gc...\u0026#34; \u0026lt;\u0026lt; endl; delete s_instance; } } }; private: Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;Singleton()...\u0026#34; \u0026lt;\u0026lt; endl; } Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* s_instance; static Garbo s_gc; }; Singleton* Singleton::s_instance = nullptr; int main() { cout \u0026lt;\u0026lt; \u0026#34;main()...\u0026#34; \u0026lt;\u0026lt; endl; Singleton* s = Singleton::getInstance(); return 0; } 输出：\nmain()... Singleton()... 二、饿汉式 在 main 函数之前，单例就创建好了，所以是线程安全的\nclass Singleton{ public: static Singleton* getInstance(){ return s_instance; } private: Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;Singleton()...\u0026#34; \u0026lt;\u0026lt; endl; } Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* s_instance; }; Singleton* Singleton::s_instance = new Singleton; int main() { cout \u0026lt;\u0026lt; \u0026#34;main()...\u0026#34; \u0026lt;\u0026lt; endl; Singleton* s = Singleton::getInstance(); return 0; } 输出：\nSingleton()... main()... 三、更加简单的方式 class Singleton{ public: static Singleton* getInstance(){ static Singleton* s_instance = new Singleton; return s_instance; } void sayHello(){ cout \u0026lt;\u0026lt; \u0026#34;Hi there\u0026#34; \u0026lt;\u0026lt; endl; } private: Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;Singleton()...\u0026#34; \u0026lt;\u0026lt; endl; } Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; }; int main() { cout \u0026lt;\u0026lt; \u0026#34;main()...\u0026#34; \u0026lt;\u0026lt; endl; Singleton* s1 = Singleton::getInstance(); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s1-\u0026gt;sayHello(); Singleton* s2 = Singleton::getInstance(); cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; s2-\u0026gt;sayHello(); return 0; } 输出：\nmain()... Singleton()... 0x55cc7de532c0 Hi there 0x55cc7de532c0 Hi there ","permalink":"https://874656645.github.io/rick/posts/107-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","summary":"单例在内存中只有一份，在内存中不会占用太多，程序退出时会随着程序统一释放内存，所以可以不必特意释放  一、懒汉式 不是线程安全的，所以多线程使用要加锁\nclass Singleton{ public: static Singleton* getInstance(){ if(s_instance == nullptr){ s_instance = new Singleton; } return s_instance; } // 可有可无，程序结束时，系统会自动回收程序的所有内存  class Garbo{ ~Garbo(){ if(s_instance){ cout \u0026lt;\u0026lt; \u0026#34;gc...\u0026#34; \u0026lt;\u0026lt; endl; delete s_instance; } } }; private: Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;Singleton()...\u0026#34; \u0026lt;\u0026lt; endl; } Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* s_instance; static Garbo s_gc; }; Singleton* Singleton::s_instance = nullptr; int main() { cout \u0026lt;\u0026lt; \u0026#34;main().","title":"单例模式"},{"content":" 抽象工厂针对的是产品族，而不是产品等级 产品族：同一产地或者同一厂商，功能不同 产品等级：功能相同，产地或者厂商不同 对于增加产品族，符合开闭原则 对于增加产品等级，不符合开闭原则  // 抽象工厂模式 class AbstractApple{ public: virtual void showName() = 0; }; class AbstractBanana{ public: virtual void showName() = 0; }; class AbstractPear{ public: virtual void showName() = 0; }; class ChinaApple : public AbstractApple{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是中国苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class ChinaBanana : public AbstractBanana{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是中国香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class ChinaPear : public AbstractPear{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是中国鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class USAApple : public AbstractApple{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是美国苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class USABanana : public AbstractBanana{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是美国香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class USAPear : public AbstractPear{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是美国鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class JapanApple : public AbstractApple{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是日本苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class JapanBanana : public AbstractBanana{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是日本香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class JapanPear : public AbstractPear{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是日本鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class AbstractFactory{ public: virtual AbstractApple* CreateApple() = 0; virtual AbstractBanana* CreateBanana() = 0; virtual AbstractPear* CreatePear() = 0; }; class ChinaFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new ChinaApple; } AbstractBanana* CreateBanana() override{ return new ChinaBanana; } AbstractPear* CreatePear() override{ return new ChinaPear; } }; class USAFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new USAApple; } AbstractBanana* CreateBanana() override{ return new USABanana; } AbstractPear* CreatePear() override{ return new USAPear; } }; class JapanFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new JapanApple; } AbstractBanana* CreateBanana() override{ return new JapanBanana; } AbstractPear* CreatePear() override{ return new JapanPear; } }; int main() { AbstractFactory* factory = nullptr; AbstractApple* apple = nullptr; AbstractBanana* banana = nullptr; AbstractPear* pear = nullptr; // 中国  factory = new ChinaFactory; apple = factory-\u0026gt;CreateApple(); apple-\u0026gt;showName(); banana = factory-\u0026gt;CreateBanana(); banana-\u0026gt;showName(); pear = factory-\u0026gt;CreatePear(); pear-\u0026gt;showName(); delete pear; delete banana; delete apple; delete factory; // 美国  factory = new USAFactory; apple = factory-\u0026gt;CreateApple(); apple-\u0026gt;showName(); banana = factory-\u0026gt;CreateBanana(); banana-\u0026gt;showName(); pear = factory-\u0026gt;CreatePear(); pear-\u0026gt;showName(); delete pear; delete banana; delete apple; delete factory; // 日本  factory = new JapanFactory; apple = factory-\u0026gt;CreateApple(); apple-\u0026gt;showName(); banana = factory-\u0026gt;CreateBanana(); banana-\u0026gt;showName(); pear = factory-\u0026gt;CreatePear(); pear-\u0026gt;showName(); delete pear; delete banana; delete apple; delete factory; return 0; } ","permalink":"https://874656645.github.io/rick/posts/106-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","summary":" 抽象工厂针对的是产品族，而不是产品等级 产品族：同一产地或者同一厂商，功能不同 产品等级：功能相同，产地或者厂商不同 对于增加产品族，符合开闭原则 对于增加产品等级，不符合开闭原则  // 抽象工厂模式 class AbstractApple{ public: virtual void showName() = 0; }; class AbstractBanana{ public: virtual void showName() = 0; }; class AbstractPear{ public: virtual void showName() = 0; }; class ChinaApple : public AbstractApple{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是中国苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class ChinaBanana : public AbstractBanana{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是中国香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class ChinaPear : public AbstractPear{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是中国鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class USAApple : public AbstractApple{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是美国苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class USABanana : public AbstractBanana{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是美国香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class USAPear : public AbstractPear{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是美国鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class JapanApple : public AbstractApple{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是日本苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class JapanBanana : public AbstractBanana{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是日本香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class JapanPear : public AbstractPear{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是日本鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class AbstractFactory{ public: virtual AbstractApple* CreateApple() = 0; virtual AbstractBanana* CreateBanana() = 0; virtual AbstractPear* CreatePear() = 0; }; class ChinaFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new ChinaApple; } AbstractBanana* CreateBanana() override{ return new ChinaBanana; } AbstractPear* CreatePear() override{ return new ChinaPear; } }; class USAFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new USAApple; } AbstractBanana* CreateBanana() override{ return new USABanana; } AbstractPear* CreatePear() override{ return new USAPear; } }; class JapanFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new JapanApple; } AbstractBanana* CreateBanana() override{ return new JapanBanana; } AbstractPear* CreatePear() override{ return new JapanPear; } }; int main() { AbstractFactory* factory = nullptr; AbstractApple* apple = nullptr; AbstractBanana* banana = nullptr; AbstractPear* pear = nullptr; // 中国  factory = new ChinaFactory; apple = factory-\u0026gt;CreateApple(); apple-\u0026gt;showName(); banana = factory-\u0026gt;CreateBanana(); banana-\u0026gt;showName(); pear = factory-\u0026gt;CreatePear(); pear-\u0026gt;showName(); delete pear; delete banana; delete apple; delete factory; // 美国  factory = new USAFactory; apple = factory-\u0026gt;CreateApple(); apple-\u0026gt;showName(); banana = factory-\u0026gt;CreateBanana(); banana-\u0026gt;showName(); pear = factory-\u0026gt;CreatePear(); pear-\u0026gt;showName(); delete pear; delete banana; delete apple; delete factory; // 日本  factory = new JapanFactory; apple = factory-\u0026gt;CreateApple(); apple-\u0026gt;showName(); banana = factory-\u0026gt;CreateBanana(); banana-\u0026gt;showName(); pear = factory-\u0026gt;CreatePear(); pear-\u0026gt;showName(); delete pear; delete banana; delete apple; delete factory; return 0; } ","title":"抽象工厂模式"},{"content":"工厂方法模式 = 简单工厂模式 + 开闭原则\n类的个数成倍增多，维护成本很高\n适用场景：\n 客户端不知道它所需要的对象的类 抽象工厂类通过其子类来指定创建哪个对象  // 工厂方法模式 class AbstractFruit{ public: virtual void showName() = 0; }; class Apple : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Banana : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Pear : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; // 抽象工厂 class AbstractFruitFactory{ public: virtual AbstractFruit* CreateFruit() = 0; }; class AppleFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Apple; } }; class PearFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Pear; } }; class BananaFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Banana; } }; int main() { AbstractFruitFactory* factory = nullptr; AbstractFruit* fruit = nullptr; factory = new AppleFactory; fruit = factory-\u0026gt;CreateFruit(); fruit-\u0026gt;showName(); delete fruit; delete factory; factory = new BananaFactory; fruit = factory-\u0026gt;CreateFruit(); fruit-\u0026gt;showName(); delete fruit; delete factory; factory = new PearFactory; fruit = factory-\u0026gt;CreateFruit(); fruit-\u0026gt;showName(); delete fruit; delete factory; return 0; } ","permalink":"https://874656645.github.io/rick/posts/105-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","summary":"工厂方法模式 = 简单工厂模式 + 开闭原则\n类的个数成倍增多，维护成本很高\n适用场景：\n 客户端不知道它所需要的对象的类 抽象工厂类通过其子类来指定创建哪个对象  // 工厂方法模式 class AbstractFruit{ public: virtual void showName() = 0; }; class Apple : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Banana : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Pear : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; // 抽象工厂 class AbstractFruitFactory{ public: virtual AbstractFruit* CreateFruit() = 0; }; class AppleFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Apple; } }; class PearFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Pear; } }; class BananaFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Banana; } }; int main() { AbstractFruitFactory* factory = nullptr; AbstractFruit* fruit = nullptr; factory = new AppleFactory; fruit = factory-\u0026gt;CreateFruit(); fruit-\u0026gt;showName(); delete fruit; delete factory; factory = new BananaFactory; fruit = factory-\u0026gt;CreateFruit(); fruit-\u0026gt;showName(); delete fruit; delete factory; factory = new PearFactory; fruit = factory-\u0026gt;CreateFruit(); fruit-\u0026gt;showName(); delete fruit; delete factory; return 0; } ","title":"工厂方法模式"},{"content":" 实现了客户端与功能类的解耦 但是违反了类的单一职责原则，整个类的代码冗长，阅读难度、维护难度和测试难度也很大 违反了开闭原则，增添功能要修改源代码  适用场景：\n 工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂 客户端只知道传入工厂类的参数，对于如何创建对象并不关心  // 简单工厂模式 class AbstractFruit{ public: virtual void showName() = 0; }; class Apple : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Banana : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Pear : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class FruitFactory{ public: static AbstractFruit* CreateFruit(string flag){ if(flag == \u0026#34;apple\u0026#34;){ return new Apple; } else if(flag == \u0026#34;banana\u0026#34;){ return new Banana; } else if(flag == \u0026#34;pear\u0026#34;){ return new Pear; } else{ return nullptr; } } }; int main() { AbstractFruit* fruit = FruitFactory::CreateFruit(\u0026#34;apple\u0026#34;); fruit-\u0026gt;showName(); delete fruit; fruit = FruitFactory::CreateFruit(\u0026#34;banana\u0026#34;); fruit-\u0026gt;showName(); delete fruit; fruit = FruitFactory::CreateFruit(\u0026#34;pear\u0026#34;); fruit-\u0026gt;showName(); delete fruit; return 0; } ","permalink":"https://874656645.github.io/rick/posts/104-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","summary":" 实现了客户端与功能类的解耦 但是违反了类的单一职责原则，整个类的代码冗长，阅读难度、维护难度和测试难度也很大 违反了开闭原则，增添功能要修改源代码  适用场景：\n 工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂 客户端只知道传入工厂类的参数，对于如何创建对象并不关心  // 简单工厂模式 class AbstractFruit{ public: virtual void showName() = 0; }; class Apple : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Banana : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Pear : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class FruitFactory{ public: static AbstractFruit* CreateFruit(string flag){ if(flag == \u0026#34;apple\u0026#34;){ return new Apple; } else if(flag == \u0026#34;banana\u0026#34;){ return new Banana; } else if(flag == \u0026#34;pear\u0026#34;){ return new Pear; } else{ return nullptr; } } }; int main() { AbstractFruit* fruit = FruitFactory::CreateFruit(\u0026#34;apple\u0026#34;); fruit-\u0026gt;showName(); delete fruit; fruit = FruitFactory::CreateFruit(\u0026#34;banana\u0026#34;); fruit-\u0026gt;showName(); delete fruit; fruit = FruitFactory::CreateFruit(\u0026#34;pear\u0026#34;); fruit-\u0026gt;showName(); delete fruit; return 0; } ","title":"简单工厂模式"},{"content":"传统过程式设计 传统的过程式设计倾向于使高层次的模块依赖于低层次的模块，抽象层依赖于具体实现层\n// 底层实现 class BankWorker{ public: void saveService(){ cout \u0026lt;\u0026lt; \u0026#34;办理存款业务...\u0026#34; \u0026lt;\u0026lt; endl; } void transferService(){ cout \u0026lt;\u0026lt; \u0026#34;办理转账业务...\u0026#34; \u0026lt;\u0026lt; endl; } void payService(){ cout \u0026lt;\u0026lt; \u0026#34;办理支付业务...\u0026#34; \u0026lt;\u0026lt; endl; } }; // 中层封装 void doSaveBusiness(BankWorker* worker){ worker-\u0026gt;saveService(); } void doTransferBusiness(BankWorker* worker){ worker-\u0026gt;transferService(); } void doPayBusiness(BankWorker* worker){ worker-\u0026gt;payService(); } // 高层调用 void test1(){ BankWorker* bw = new BankWorker; doSaveBusiness(bw); doPayBusiness(bw); doTransferBusiness(bw); delete bw; } 依赖倒转 // 抽象层 class AbstractWorker{ public: virtual void doBusiness() = 0; }; // 实现层 class SaveBankWorker:public AbstractWorker{ public: void doBusiness()override{ cout \u0026lt;\u0026lt; \u0026#34;办理存款业务...\u0026#34; \u0026lt;\u0026lt; endl; } }; class PayBankWorker:public AbstractWorker{ public: void doBusiness()override{ cout \u0026lt;\u0026lt; \u0026#34;办理支付业务...\u0026#34; \u0026lt;\u0026lt; endl; } }; class TransferBankWorker:public AbstractWorker{ public: void doBusiness()override{ cout \u0026lt;\u0026lt; \u0026#34;办理转账业务...\u0026#34; \u0026lt;\u0026lt; endl; } }; // 业务封装 void doBusiness(AbstractWorker* aw){ aw-\u0026gt;doBusiness(); delete aw; } // 高层调用 void test2(){ doBusiness(new SaveBankWorker); doBusiness(new PayBankWorker); doBusiness(new TransferBankWorker); } ","permalink":"https://874656645.github.io/rick/posts/103-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/","summary":"传统过程式设计 传统的过程式设计倾向于使高层次的模块依赖于低层次的模块，抽象层依赖于具体实现层\n// 底层实现 class BankWorker{ public: void saveService(){ cout \u0026lt;\u0026lt; \u0026#34;办理存款业务...\u0026#34; \u0026lt;\u0026lt; endl; } void transferService(){ cout \u0026lt;\u0026lt; \u0026#34;办理转账业务...\u0026#34; \u0026lt;\u0026lt; endl; } void payService(){ cout \u0026lt;\u0026lt; \u0026#34;办理支付业务...\u0026#34; \u0026lt;\u0026lt; endl; } }; // 中层封装 void doSaveBusiness(BankWorker* worker){ worker-\u0026gt;saveService(); } void doTransferBusiness(BankWorker* worker){ worker-\u0026gt;transferService(); } void doPayBusiness(BankWorker* worker){ worker-\u0026gt;payService(); } // 高层调用 void test1(){ BankWorker* bw = new BankWorker; doSaveBusiness(bw); doPayBusiness(bw); doTransferBusiness(bw); delete bw; } 依赖倒转 // 抽象层 class AbstractWorker{ public: virtual void doBusiness() = 0; }; // 实现层 class SaveBankWorker:public AbstractWorker{ public: void doBusiness()override{ cout \u0026lt;\u0026lt; \u0026#34;办理存款业务.","title":"依赖倒转原则"},{"content":"优先使用组合的方式，而不是继承\nclass AbstractCar{ public: virtual void run() = 0; }; class BMW:public AbstractCar{ public: void run()override{ cout \u0026lt;\u0026lt; \u0026#34;BMW run\u0026#34; \u0026lt;\u0026lt; endl; } }; class DaZhong:public AbstractCar{ public: void run()override{ cout \u0026lt;\u0026lt; \u0026#34;DaZhong run\u0026#34; \u0026lt;\u0026lt; endl; } }; #if 0// 错误的做法 class Person : public BMW{ public: void drive(){ run(); } }; void test1(){ Person p; p.drive(); } #endif // 正确做法 class Person{ public: Person(){ car = nullptr; } Person(AbstractCar* c){ car = c; } void drive(){ car-\u0026gt;run(); delete car; } void drive(AbstractCar* car){ car-\u0026gt;run(); delete car; } private: AbstractCar* car; }; void test2(){ // 方式一：  Person* p = new Person(new BMW); p-\u0026gt;drive(); delete p; p = new Person(new DaZhong); p-\u0026gt;drive(); delete p; // 方式二：  Person pp; pp.drive(new BMW); pp.drive(new DaZhong); } int main() { test2(); return 0; } ","permalink":"https://874656645.github.io/rick/posts/102-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/","summary":"优先使用组合的方式，而不是继承\nclass AbstractCar{ public: virtual void run() = 0; }; class BMW:public AbstractCar{ public: void run()override{ cout \u0026lt;\u0026lt; \u0026#34;BMW run\u0026#34; \u0026lt;\u0026lt; endl; } }; class DaZhong:public AbstractCar{ public: void run()override{ cout \u0026lt;\u0026lt; \u0026#34;DaZhong run\u0026#34; \u0026lt;\u0026lt; endl; } }; #if 0// 错误的做法 class Person : public BMW{ public: void drive(){ run(); } }; void test1(){ Person p; p.drive(); } #endif // 正确做法 class Person{ public: Person(){ car = nullptr; } Person(AbstractCar* c){ car = c; } void drive(){ car-\u0026gt;run(); delete car; } void drive(AbstractCar* car){ car-\u0026gt;run(); delete car; } private: AbstractCar* car; }; void test2(){ // 方式一：  Person* p = new Person(new BMW); p-\u0026gt;drive(); delete p; p = new Person(new DaZhong); p-\u0026gt;drive(); delete p; // 方式二：  Person pp; pp.","title":"合成复用原则"},{"content":"又叫最少知识原则\n封装一个中间层进行隔离\nclass AbstractBuilding{ public: virtual string getQuality()const = 0; virtual void sale() = 0; }; class BuildingA:public AbstractBuilding{ public: BuildingA(){ m_quality = \u0026#34;高品质\u0026#34;; } string getQuality()const override{ return m_quality; } void sale()override{ cout \u0026lt;\u0026lt; \u0026#34;楼盘A：\u0026#34; \u0026lt;\u0026lt; m_quality \u0026lt;\u0026lt; endl; } private: string m_quality; }; class BuildingB:public AbstractBuilding{ public: BuildingB(){ m_quality = \u0026#34;低品质\u0026#34;; } string getQuality()const override{ return m_quality; } void sale()override{ cout \u0026lt;\u0026lt; \u0026#34;楼盘B：\u0026#34; \u0026lt;\u0026lt; m_quality \u0026lt;\u0026lt; endl; } private: string m_quality; }; // 错误的做法 // 客户端 void test1(){ string myRequest = \u0026#34;低品质\u0026#34;; BuildingA* bA = new BuildingA; if(bA-\u0026gt;getQuality() == myRequest){ bA-\u0026gt;sale(); delete bA; } BuildingB* bB = new BuildingB; if(bB-\u0026gt;getQuality() == myRequest){ bB-\u0026gt;sale(); delete bB; } } // 正确做法 // 封装一个中间类 class Mediator{ public: Mediator(){ AbstractBuilding* b = new BuildingA; vb.push_back(b); b = new BuildingB; vb.push_back(b); } AbstractBuilding* getBuilding(string req){ for(const auto \u0026amp;b : vb){ if(b-\u0026gt;getQuality() == req){ return b; } } return NULL; } ~Mediator(){ for(auto \u0026amp;b : vb){ if(b != NULL){ delete b; } } } private: vector\u0026lt;AbstractBuilding*\u0026gt; vb; }; // 客户端 void test2(){ string myRequest = \u0026#34;低品质\u0026#34;; Mediator m; AbstractBuilding* b = m.getBuilding(myRequest); if(b != NULL){ b-\u0026gt;sale(); } else{ cout \u0026lt;\u0026lt; \u0026#34;未找到需要的楼盘\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { test2(); return 0; } ","permalink":"https://874656645.github.io/rick/posts/101-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/","summary":"又叫最少知识原则\n封装一个中间层进行隔离\nclass AbstractBuilding{ public: virtual string getQuality()const = 0; virtual void sale() = 0; }; class BuildingA:public AbstractBuilding{ public: BuildingA(){ m_quality = \u0026#34;高品质\u0026#34;; } string getQuality()const override{ return m_quality; } void sale()override{ cout \u0026lt;\u0026lt; \u0026#34;楼盘A：\u0026#34; \u0026lt;\u0026lt; m_quality \u0026lt;\u0026lt; endl; } private: string m_quality; }; class BuildingB:public AbstractBuilding{ public: BuildingB(){ m_quality = \u0026#34;低品质\u0026#34;; } string getQuality()const override{ return m_quality; } void sale()override{ cout \u0026lt;\u0026lt; \u0026#34;楼盘B：\u0026#34; \u0026lt;\u0026lt; m_quality \u0026lt;\u0026lt; endl; } private: string m_quality; }; // 错误的做法 // 客户端 void test1(){ string myRequest = \u0026#34;低品质\u0026#34;; BuildingA* bA = new BuildingA; if(bA-\u0026gt;getQuality() == myRequest){ bA-\u0026gt;sale(); delete bA; } BuildingB* bB = new BuildingB; if(bB-\u0026gt;getQuality() == myRequest){ bB-\u0026gt;sale(); delete bB; } } // 正确做法 // 封装一个中间类 class Mediator{ public: Mediator(){ AbstractBuilding* b = new BuildingA; vb.","title":"迪米特法则"},{"content":"对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码\n如下所示，如果想要扩展乘法、除法、取模等算法，就不用修改原码，只需增加新类\nclass AbstractCalculator{ public: virtual void setOperatorNum(int a, int b) = 0; virtual int getResult() = 0; }; class PlusCalculator:public AbstractCalculator{ public: void setOperatorNum(int a, int b)override{ m_a = a; m_b = b; } int getResult()override{ return m_a + m_b; } private: int m_a{0}; int m_b{0}; }; class MinusCalculator:public AbstractCalculator{ public: void setOperatorNum(int a, int b)override{ m_a = a; m_b = b; } int getResult()override{ return m_a - m_b; } private: int m_a{0}; int m_b{0}; }; int main() { AbstractCalculator* calculator = new PlusCalculator; calculator-\u0026gt;setOperatorNum(10, 20); cout \u0026lt;\u0026lt; calculator-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete calculator; calculator = nullptr; calculator = new MinusCalculator; calculator-\u0026gt;setOperatorNum(10, 20); cout \u0026lt;\u0026lt; calculator-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete calculator; calculator = nullptr; return 0; } ","permalink":"https://874656645.github.io/rick/posts/100-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/","summary":"对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码\n如下所示，如果想要扩展乘法、除法、取模等算法，就不用修改原码，只需增加新类\nclass AbstractCalculator{ public: virtual void setOperatorNum(int a, int b) = 0; virtual int getResult() = 0; }; class PlusCalculator:public AbstractCalculator{ public: void setOperatorNum(int a, int b)override{ m_a = a; m_b = b; } int getResult()override{ return m_a + m_b; } private: int m_a{0}; int m_b{0}; }; class MinusCalculator:public AbstractCalculator{ public: void setOperatorNum(int a, int b)override{ m_a = a; m_b = b; } int getResult()override{ return m_a - m_b; } private: int m_a{0}; int m_b{0}; }; int main() { AbstractCalculator* calculator = new PlusCalculator; calculator-\u0026gt;setOperatorNum(10, 20); cout \u0026lt;\u0026lt; calculator-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete calculator; calculator = nullptr; calculator = new MinusCalculator; calculator-\u0026gt;setOperatorNum(10, 20); cout \u0026lt;\u0026lt; calculator-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete calculator; calculator = nullptr; return 0; } ","title":"开闭原则"},{"content":"原则目的：高内聚，低耦合\n 单一职责原则 Single Responsibility Principal（SRP）：类的职责单一，对外只提供一种功能 开闭原则 Open-Closed Principal（OCP）：对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码 里氏代换原则 Liskov Substitution Principal（LSP）：任何抽象类出现的地方都可以用他的实现类进行替换（多态） 依赖倒转原则 Dependence Inversion Principal（DIP）：依赖于抽象（接口），不要依赖具体的实现（类），针对接口编程 接口隔离原则 Interface Segregation Principal（ISP）：一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去 合成复用原则 Composite Reuse Principal（CRP）：对于继承和组合，优先使用组合 迪米特法则 Law of Demeter（LoD）：一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节（黑盒原理）  ","permalink":"https://874656645.github.io/rick/posts/99-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","summary":"原则目的：高内聚，低耦合\n 单一职责原则 Single Responsibility Principal（SRP）：类的职责单一，对外只提供一种功能 开闭原则 Open-Closed Principal（OCP）：对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码 里氏代换原则 Liskov Substitution Principal（LSP）：任何抽象类出现的地方都可以用他的实现类进行替换（多态） 依赖倒转原则 Dependence Inversion Principal（DIP）：依赖于抽象（接口），不要依赖具体的实现（类），针对接口编程 接口隔离原则 Interface Segregation Principal（ISP）：一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去 合成复用原则 Composite Reuse Principal（CRP）：对于继承和组合，优先使用组合 迪米特法则 Law of Demeter（LoD）：一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节（黑盒原理）  ","title":"面向对象设计原则"},{"content":"设计模式\n一、概念  设计模式是在特定环境下人们解决某类重复出现的问题的一套成功或有效的解决方案。 软件模式并非仅限于设计模式，还包括架构模式、分析模式、过程模式等。 在一定环境下，用固定套路解决问题。 设计模式的基础是多态。  二、目的  学习设计模式有助于更加深入的理解面向对象思想 如何将代码分散在几个不同的类中 为什么要有接口 何谓针对抽象编程 何时不应该使用继承 如何不修改源代码增加新功能 更好地阅读和理解现有类库与其它系统中的源代码  三、软件设计模式种类 GoF 提出的设计模式有 23 种，加简单工厂模式，一共 24 种\n1、创建型模式 Creational 6种 如何创建对象\n 单例模式 简单工厂模式 工厂方法模式 抽象工厂模式 原型模式 建造者模式  2、结构型模式 Structural 7种 如何实现类或对象的组合\n让类和类进行组合，获得更大的结构\n 适配器模式 桥接模式 组合模式 装饰模式 外观模式 享元模式 代理模式  3、行为型模式 Behavioral 11种 类或对象怎样交互以及怎样分配职责\n 职责链模式 命令模式 解释器模式 迭代器模式 中介模式 备忘录模式 观察者模式 状态模式 策略模式 模板方法模式 访问者模式  ","permalink":"https://874656645.github.io/rick/posts/98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"设计模式\n一、概念  设计模式是在特定环境下人们解决某类重复出现的问题的一套成功或有效的解决方案。 软件模式并非仅限于设计模式，还包括架构模式、分析模式、过程模式等。 在一定环境下，用固定套路解决问题。 设计模式的基础是多态。  二、目的  学习设计模式有助于更加深入的理解面向对象思想 如何将代码分散在几个不同的类中 为什么要有接口 何谓针对抽象编程 何时不应该使用继承 如何不修改源代码增加新功能 更好地阅读和理解现有类库与其它系统中的源代码  三、软件设计模式种类 GoF 提出的设计模式有 23 种，加简单工厂模式，一共 24 种\n1、创建型模式 Creational 6种 如何创建对象\n 单例模式 简单工厂模式 工厂方法模式 抽象工厂模式 原型模式 建造者模式  2、结构型模式 Structural 7种 如何实现类或对象的组合\n让类和类进行组合，获得更大的结构\n 适配器模式 桥接模式 组合模式 装饰模式 外观模式 享元模式 代理模式  3、行为型模式 Behavioral 11种 类或对象怎样交互以及怎样分配职责\n 职责链模式 命令模式 解释器模式 迭代器模式 中介模式 备忘录模式 观察者模式 状态模式 策略模式 模板方法模式 访问者模式  ","title":"设计模式"},{"content":"一、用例图  用例代表系统的某项完整功能 从客户角度来描述系统功能 包括参与者、用例、关系  1. 泛化关系 Generalization  父类和子类的关系  2. 包含关系 Include  一个功能肯定会使用另一个功能  3. 扩展关系 Extend  完成某个功能的时候偶尔会执行另一个功能  二、类图 用来显示系统中的类，接口以及它们之间的关系\n1. 泛化关系 Generalization（is a） 一种类与类之间的继承关系\n2. 实现关系 Realization（is a） 类与抽象类之间的实现关系\n3. 依赖关系 Dependence（use a） 两个相对独立的系统，一个系统负责构造另一个系统的实例，或者依赖另一个系统的服务\n类 A 做为类 B 方法的形参，而不是类 B 的成员属性\n4. 关联关系 Directed Association 两个相对独立的系统，一个系统的实例与另一个系统的一些实例存在固定的对应关系\n  聚合 Aggregation\n 聚合关系是关联关系的一种，是更强的关联关系 聚合是整体和部分之间的关系，例如汽车由引擎、轮胎以及其它零件组成 聚合关系也是通过成员变量来实现的，但是，关联关系所涉及的两个类处在同一个层次上，而聚合关系中，两个类处于不同层次上，一个代表整体，一个代表部分 整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享    组合 Composition\n  三、对象图 四、时序图 五、活动图 ","permalink":"https://874656645.github.io/rick/posts/97-uml-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/","summary":"一、用例图  用例代表系统的某项完整功能 从客户角度来描述系统功能 包括参与者、用例、关系  1. 泛化关系 Generalization  父类和子类的关系  2. 包含关系 Include  一个功能肯定会使用另一个功能  3. 扩展关系 Extend  完成某个功能的时候偶尔会执行另一个功能  二、类图 用来显示系统中的类，接口以及它们之间的关系\n1. 泛化关系 Generalization（is a） 一种类与类之间的继承关系\n2. 实现关系 Realization（is a） 类与抽象类之间的实现关系\n3. 依赖关系 Dependence（use a） 两个相对独立的系统，一个系统负责构造另一个系统的实例，或者依赖另一个系统的服务\n类 A 做为类 B 方法的形参，而不是类 B 的成员属性\n4. 关联关系 Directed Association 两个相对独立的系统，一个系统的实例与另一个系统的一些实例存在固定的对应关系\n  聚合 Aggregation\n 聚合关系是关联关系的一种，是更强的关联关系 聚合是整体和部分之间的关系，例如汽车由引擎、轮胎以及其它零件组成 聚合关系也是通过成员变量来实现的，但是，关联关系所涉及的两个类处在同一个层次上，而聚合关系中，两个类处于不同层次上，一个代表整体，一个代表部分 整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享    组合 Composition\n  三、对象图 四、时序图 五、活动图 ","title":"UML 统一建模语言"},{"content":"  仿函数适配器 bind1st、bind2nd 将二元仿函数转为一元仿函数\n  仿函数适配器 not1、not2\n  仿函数适配器 ptr_fun 将普通函数转为函数对象，然后就可以与其它仿函数适配器一起使用了\n  仿函数适配器 mem_fun、mem_fun_ref 将成员函数转为适配器\n  class MyPrint : public binary_function\u0026lt;int, int, void\u0026gt;{ public: void operator()(int v, int val) const{ cout \u0026lt;\u0026lt; \u0026#34;v: \u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;, val: \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34;, v + val: \u0026#34; \u0026lt;\u0026lt; v + val \u0026lt;\u0026lt; endl; } }; void myPrint(int v, int val){ cout \u0026lt;\u0026lt; v + val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } class MySort: public binary_function\u0026lt;int, int, bool\u0026gt;{ public: bool operator() (int lhs, int rhs)const{ return lhs \u0026gt; rhs; } }; class MyGreater: public unary_function\u0026lt;int, bool\u0026gt;{ public: bool operator()(int v)const{ return v \u0026gt; 50; } }; void printVec(const vector\u0026lt;int\u0026gt; \u0026amp;v){ for(const auto \u0026amp;p : v){ cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } class Person{ public: Person(int id, int age):id(id), age(age){} void show(){ cout \u0026lt;\u0026lt; \u0026#34;id: \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;, age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl; } int id; int age; }; int main(){ vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(rand() % 100); } // bind1st bind2nd  for_each(v.begin(), v.end(), bind1st(MyPrint(), 100)); cout \u0026lt;\u0026lt; endl; // ptr_fun  for_each(v.begin(), v.end(), bind2nd(ptr_fun(myPrint), 100)); cout \u0026lt;\u0026lt; endl; printVec(v); // not1 not2  sort(v.begin(), v.end(), not2(MySort())); printVec(v); auto it = find_if(v.begin(), v.end(), not1(MyGreater())); if(it != v.end()){ cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } // mem_fun_ref mem_fun  vector\u0026lt;Person\u0026gt; vp; vp.emplace_back(Person(1, 2)); vp.emplace_back(Person(3, 4)); vp.emplace_back(Person(5, 6)); for_each(vp.begin(), vp.end(), mem_fun_ref(\u0026amp;Person::show)); cout \u0026lt;\u0026lt; \u0026#34;--------------\u0026#34; \u0026lt;\u0026lt; endl; vector\u0026lt;Person*\u0026gt; vpp; vpp.emplace_back(new Person(1, 2)); vpp.emplace_back(new Person(3, 4)); vpp.emplace_back(new Person(5, 6)); for_each(vpp.begin(), vpp.end(), mem_fun(\u0026amp;Person::show)); return 0; } v: 100, val: 83, v + val: 183 v: 100, val: 86, v + val: 186 v: 100, val: 77, v + val: 177 v: 100, val: 15, v + val: 115 v: 100, val: 93, v + val: 193 v: 100, val: 35, v + val: 135 v: 100, val: 86, v + val: 186 v: 100, val: 92, v + val: 192 v: 100, val: 49, v + val: 149 v: 100, val: 21, v + val: 121 183 186 177 115 193 135 186 192 149 121 83 86 77 15 93 35 86 92 49 21 15 21 35 49 77 83 86 86 92 93 15 id: 1, age: 2 id: 3, age: 4 id: 5, age: 6 -------------- id: 1, age: 2 id: 3, age: 4 id: 5, age: 6 ","permalink":"https://874656645.github.io/rick/posts/96-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8/","summary":"仿函数适配器 bind1st、bind2nd 将二元仿函数转为一元仿函数\n  仿函数适配器 not1、not2\n  仿函数适配器 ptr_fun 将普通函数转为函数对象，然后就可以与其它仿函数适配器一起使用了\n  仿函数适配器 mem_fun、mem_fun_ref 将成员函数转为适配器\n  class MyPrint : public binary_function\u0026lt;int, int, void\u0026gt;{ public: void operator()(int v, int val) const{ cout \u0026lt;\u0026lt; \u0026#34;v: \u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;, val: \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34;, v + val: \u0026#34; \u0026lt;\u0026lt; v + val \u0026lt;\u0026lt; endl; } }; void myPrint(int v, int val){ cout \u0026lt;\u0026lt; v + val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } class MySort: public binary_function\u0026lt;int, int, bool\u0026gt;{ public: bool operator() (int lhs, int rhs)const{ return lhs \u0026gt; rhs; } }; class MyGreater: public unary_function\u0026lt;int, bool\u0026gt;{ public: bool operator()(int v)const{ return v \u0026gt; 50; } }; void printVec(const vector\u0026lt;int\u0026gt; \u0026amp;v){ for(const auto \u0026amp;p : v){ cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } class Person{ public: Person(int id, int age):id(id), age(age){} void show(){ cout \u0026lt;\u0026lt; \u0026#34;id: \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;, age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl; } int id; int age; }; int main(){ vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.","title":"函数对象适配器"},{"content":"  有的情况下，现在的折衷方案比未来的理想方案好得多\n  我考虑问题的本质是什么，再定义一个类抓住这个本质，并确保这个类能独立地工作。然后在遇到符合这个本质的问题时就使用这个类。\n  只要类定义正确，我就只能按照我编写它的初衷那样去用它。\n  C++ 哲学：抽象，实用，只为用到的东西付出代价。\n  类设计者的核查表：\n 你的类需要一个构造函数吗？ 你的数据成员是私有的吗？（使用函数，可以延迟计算，不必时时计算，保证数据成员的准确性） 你的类需要一个无参的构造函数吗？（对象数组） 是不是每个构造函数初始化所有的数据成员？ 类需要析构函数吗？ 类需要一个虚析构函数吗？ 你的类需要复制构造函数吗？（是否需要深拷贝） 你的类需要一个赋值操作符吗？ 你的赋值操作符能正确地将对象赋给对象本身吗？ 你的类需要定义关系操作符吗？ 删除数组时你记住了用 delete[] 吗？ 记得在复制构造函数和赋值操作符的参数类型中加上 const 了吗？ 如果函数有引用参数，它们应该是 const 引用吗？ 记得适当地声明成员函数为 const 的了吗？    代理类：用类来表示概念（RAII）\nclass Vehicle{ public: virtual double weight() = 0; virtual void start() = 0; virtual Vehicle* copy() const = 0; virtual ~Vehicle(){} }; class RoadVehicle: public Vehicle{ /* ... */ }; class AutoVehicle: public RoadVehicle{ /* ... */ }; class Aircraft: public Vehicle{ /* ... */ }; class Helicopter: public Aircraft{ /* ... */ }; // 定义代理类 class VehicleSurrogate{ public: VehicleSurrogate(){ // 空代理  vp(0); } VehicleSurrogate(const Vehicle\u0026amp; v){ vp = v.copy(); } ~VehicleSurrogate(){ delete vp; } VehicleSurrogate(const VehicleSurrogate\u0026amp; v){ vp(v.vp ? v.vp-\u0026gt;copy() : 0); } VehicleSurrogate\u0026amp; operator=(const VehicleSurrogate\u0026amp;){ if(this != \u0026amp;v){ delete vp; vp = (v.vp ? v.vp-\u0026gt;copy() : 0); } return *this; } /* 其实代理类也可以不依依写出 Vehicle 所能支持的其他操作 只需要实现 * 和 -\u0026gt; 的操作符重载即可，做一次转发， 但这样就过多地暴露了内存分配方面的策略，不太安全 */ double weight() const{ if(vp == 0){ throw \u0026#34;empty VehicleSurrogate.weight()\u0026#34;; } return vp-\u0026gt;weight(); } void start() { if(vp == 0){ throw \u0026#34;empty VehicleSurrogate.start()\u0026#34;; } return vp-\u0026gt;start(); } private: Vehicle* vp; }; int main(){ // Vehicle parking_lot[1000]; // wrong  VehicleSurrogate parking_lot[1000]; // OK  AutoVehicle x; parking_lot[num_vehicles++] = x; return 0; }   Handle 句柄类：就是一种只包含单个对象的容器 与智能指针的理念类似，智能指针更像是 Handle 类的抽象\nclass Point{ public: Point(int x = 0, int y = 0):xval(x), yval(y){ cout \u0026lt;\u0026lt; \u0026#34;Point()\u0026#34; \u0026lt;\u0026lt; endl; } Point(const Point\u0026amp; p){ cout \u0026lt;\u0026lt; \u0026#34;Point(const Point\u0026amp; p)\u0026#34; \u0026lt;\u0026lt; endl; xval = p.xval; yval = p.yval; } ~Point(){ cout \u0026lt;\u0026lt; \u0026#34;~Point()\u0026#34; \u0026lt;\u0026lt; endl; } int x() const {return xval;} int y() const {return yval;} Point\u0026amp; x(int xv){ xval = xv; return *this; } Point\u0026amp; y(int yv){ yval = yv; return *this; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;x: \u0026#34; \u0026lt;\u0026lt; xval \u0026lt;\u0026lt; \u0026#34; y: \u0026#34; \u0026lt;\u0026lt; yval \u0026lt;\u0026lt; endl; } private: int xval, yval; }; class Handle; class UPoint{ friend class Handle; Point p; int u; UPoint():u(1){} UPoint(int x, int y):p(x, y), u(1){} UPoint(const Point\u0026amp; p0):p(p0), u(1){} }; class Handle{ public: Handle():up(new UPoint){} Handle(int x, int y):up(new UPoint(x, y)){} Handle(const Point \u0026amp;p):up(new UPoint(p)){} Handle(const Handle \u0026amp;h):up(h.up){++up-\u0026gt;u;} ~Handle(){ if(--up-\u0026gt;u == 0){ delete up; } } Handle\u0026amp; operator=(const Handle\u0026amp; h){ ++h.up-\u0026gt;u; if(--up-\u0026gt;u == 0){ delete up; } up = h.up; cout \u0026lt;\u0026lt; up-\u0026gt;u \u0026lt;\u0026lt; endl; return *this; } int x() const{ return up-\u0026gt;p.x(); } int y() const{ return up-\u0026gt;p.y(); } /*指针语义 不必复制 UPoint 对象 Handle\u0026amp; x(int x){ up-\u0026gt;p.x(x); return *this; } Handle\u0026amp; y(int y){ up-\u0026gt;p.y(y); return *this; } */ /*值语义 写时复制 */ Handle\u0026amp; x(int x){ copyWhenWrite(); up-\u0026gt;p.x(x); return *this; } Handle\u0026amp; y(int y){ copyWhenWrite(); up-\u0026gt;p.y(y); return *this; } private: void copyWhenWrite(){ if(up-\u0026gt;u != 1){ --up-\u0026gt;u; up = new UPoint(up-\u0026gt;p); } } private: UPoint * up; }; int main() { Point p(10, 20); Handle hp(p); // 通过拷贝构造创建一个p的副本，并将 handle绑定到该副本  Handle hpp(hp); Handle hppp(hp); Handle hpppp; hpppp = hp; hpppp.x(100).y(200); cout \u0026lt;\u0026lt; hp.x() \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; hp.y() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; hpppp.x() \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; hpppp.y() \u0026lt;\u0026lt; endl; return 0; } 输出：\nPoint() Point(const Point\u0026amp; p) 1 2 3 Point() ~Point() 4 Point(const Point\u0026amp; p) 10, 20 100, 200 ~Point() ~Point() ~Point()   对象和值之间的差别只在要改变对象时才显现出来。换句话说，就是值和不可变的对象是无法区分的。\n  ","permalink":"https://874656645.github.io/rick/posts/95-c++-%E6%B2%89%E6%80%9D%E5%BD%95%E7%AC%94%E8%AE%B0/","summary":"有的情况下，现在的折衷方案比未来的理想方案好得多\n  我考虑问题的本质是什么，再定义一个类抓住这个本质，并确保这个类能独立地工作。然后在遇到符合这个本质的问题时就使用这个类。\n  只要类定义正确，我就只能按照我编写它的初衷那样去用它。\n  C++ 哲学：抽象，实用，只为用到的东西付出代价。\n  类设计者的核查表：\n 你的类需要一个构造函数吗？ 你的数据成员是私有的吗？（使用函数，可以延迟计算，不必时时计算，保证数据成员的准确性） 你的类需要一个无参的构造函数吗？（对象数组） 是不是每个构造函数初始化所有的数据成员？ 类需要析构函数吗？ 类需要一个虚析构函数吗？ 你的类需要复制构造函数吗？（是否需要深拷贝） 你的类需要一个赋值操作符吗？ 你的赋值操作符能正确地将对象赋给对象本身吗？ 你的类需要定义关系操作符吗？ 删除数组时你记住了用 delete[] 吗？ 记得在复制构造函数和赋值操作符的参数类型中加上 const 了吗？ 如果函数有引用参数，它们应该是 const 引用吗？ 记得适当地声明成员函数为 const 的了吗？    代理类：用类来表示概念（RAII）\nclass Vehicle{ public: virtual double weight() = 0; virtual void start() = 0; virtual Vehicle* copy() const = 0; virtual ~Vehicle(){} }; class RoadVehicle: public Vehicle{ /* .","title":"C++ 沉思录笔记"},{"content":"","permalink":"https://874656645.github.io/rick/posts/94-%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F%E6%A1%88%E4%BE%8B/","summary":"","title":"机房预约系统案例"},{"content":" while 循环中的 switch, break 只能中断 switch，不能中断 while 循环  void managerMenue(){ while(true){ cout \u0026lt;\u0026lt; \u0026#34;这是子菜单\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;是否返回主菜单？\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;1 是\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;2 否\u0026#34; \u0026lt;\u0026lt; endl; int i = 0; cin \u0026gt;\u0026gt; i; switch(i){ case 1: break; case 2: return; default: break; } // if(i == 1){  // // system(\u0026#34;reset\u0026#34;);  // break;  // }  // else if(i == 2){  // return;  // }  // else{  // cout \u0026lt;\u0026lt; \u0026#34;输入有误，请重新输入\u0026#34; \u0026lt;\u0026lt; endl;  // }  } cout \u0026lt;\u0026lt; \u0026#34;这是子菜单循环外代码\u0026#34; \u0026lt;\u0026lt; endl; } int main() { while(true){ cout \u0026lt;\u0026lt; \u0026#34;欢迎登陆！\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;这是主菜单\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;请输入选项：\u0026#34; \u0026lt;\u0026lt; endl; int i = 0; cin \u0026gt;\u0026gt; i; // switch(i)  // {  // case 1:  // system(\u0026#34;reset\u0026#34;);  // managerMenue();  // break;  // case 2:  // break;  // }  if(i == 1){ // system(\u0026#34;reset\u0026#34;);  managerMenue(); // break;  } else{ break; } cout \u0026lt;\u0026lt; \u0026#34;switch 外代码\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;while 外代码\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://874656645.github.io/rick/posts/93-switch-%E4%B8%8E-if-else-%E5%8C%BA%E5%88%AB/","summary":" while 循环中的 switch, break 只能中断 switch，不能中断 while 循环  void managerMenue(){ while(true){ cout \u0026lt;\u0026lt; \u0026#34;这是子菜单\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;是否返回主菜单？\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;1 是\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;2 否\u0026#34; \u0026lt;\u0026lt; endl; int i = 0; cin \u0026gt;\u0026gt; i; switch(i){ case 1: break; case 2: return; default: break; } // if(i == 1){  // // system(\u0026#34;reset\u0026#34;);  // break;  // }  // else if(i == 2){  // return;  // }  // else{  // cout \u0026lt;\u0026lt; \u0026#34;输入有误，请重新输入\u0026#34; \u0026lt;\u0026lt; endl;  // }  } cout \u0026lt;\u0026lt; \u0026#34;这是子菜单循环外代码\u0026#34; \u0026lt;\u0026lt; endl; } int main() { while(true){ cout \u0026lt;\u0026lt; \u0026#34;欢迎登陆！\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;这是主菜单\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;请输入选项：\u0026#34; \u0026lt;\u0026lt; endl; int i = 0; cin \u0026gt;\u0026gt; i; // switch(i)  // {  // case 1:  // system(\u0026#34;reset\u0026#34;);  // managerMenue();  // break;  // case 2:  // break;  // }  if(i == 1){ // system(\u0026#34;reset\u0026#34;);  managerMenue(); // break;  } else{ break; } cout \u0026lt;\u0026lt; \u0026#34;switch 外代码\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;while 外代码\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","title":"switch 与 if Else 区别"},{"content":"","permalink":"https://874656645.github.io/rick/posts/92-%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/","summary":"","title":"演讲比赛流程管理案例"},{"content":"一、常用遍历算法 1. for_each 2. transform  搬运的目标容器必须要提前开辟空间（resize 而不是 reserve），否则无法正常搬运  int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(i); } vector\u0026lt;int\u0026gt; v1; v1.resize(v.size()); // 要用 resize, 不能用 reserve  transform(v.begin(), v.end(), v1.begin(), [](int v){ return v * 2;}); for_each(v1.begin(), v1.end(), [](int v){ cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); cout \u0026lt;\u0026lt; endl; return 0; } 二、常用查找算法 1. find 2. find_if 3. adjacent_find 4. binary_search  无序序列不可用  5. count 6. count_if 三、常用排序算法 1. sort  不支持随机访问的容器不可用  2. random_shuffle 洗牌  指定范围内的元素随机调整次序 不支持随机访问的容器不可用 如果想每次都是随机序列，就添加一个随机种子  int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(i); } vector\u0026lt;int\u0026gt; v1; v1.resize(v.size()); srand((unsigned int)time(NULL)); // 设置随机种子  random_shuffle(v.begin(), v.end()); for_each(v.begin(), v.end(), [](int v){ cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); cout \u0026lt;\u0026lt; endl; return 0; } 3. merge  合并的两个容器要求是有序的，合并后也是有序的 两个序列的排序规则要一致 目标容器也要提前开辟空间  int main() { vector\u0026lt;int\u0026gt; v; vector\u0026lt;int\u0026gt; v1; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(i); v.push_back(i + 1); } vector\u0026lt;int\u0026gt; v2; v2.resize(v.size() + v1.size()); // 目标容器开辟空间  merge(v.begin(), v.end(), v1.begin(), v1.end(), v2.begin()); for_each(v2.begin(), v2.end(), [](int v){ cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); cout \u0026lt;\u0026lt; endl; return 0; } 输出：\n0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 4. reverse  不支持随机访问的容器不可用  四、常用拷贝和替换算法 1. copy  目标容器要提前开辟空间 等价于 = 运算符或者 拷贝构造  2. replace 3. replace_if 4. swap 五、算术生成算法 (numeric) 1. accumulate 计算容器元素累计总和 2. fill 向容器中添加元素 六、常用集合算法 1. set_intersection  求两个容器的交集 两个序列都是有序的，而且排序标准要一致 默认是按升序处理 结果交集序列也是有序的  int main() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for(int i = 0; i \u0026lt; 10; ++i){ v1.push_back(9 - i); v2.push_back(14 - i); } vector\u0026lt;int\u0026gt; v3; v3.resize(min(v1.size(), v2.size())); vector\u0026lt;int\u0026gt;::iterator itEnd = set_intersection(v1.begin(), v1.end() , v2.begin(), v2.end(), v3.begin(), [](int a, int b){ return a \u0026gt; b;}); for_each(v3.begin(), itEnd, [](int v){ cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); cout \u0026lt;\u0026lt; endl; return 0; } 输出：\n9 8 7 6 5 2. set_union  求两个容器的并集  3. set_difference  求两个容器的差集  ","permalink":"https://874656645.github.io/rick/posts/91-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","summary":"一、常用遍历算法 1. for_each 2. transform  搬运的目标容器必须要提前开辟空间（resize 而不是 reserve），否则无法正常搬运  int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(i); } vector\u0026lt;int\u0026gt; v1; v1.resize(v.size()); // 要用 resize, 不能用 reserve  transform(v.begin(), v.end(), v1.begin(), [](int v){ return v * 2;}); for_each(v1.begin(), v1.end(), [](int v){ cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); cout \u0026lt;\u0026lt; endl; return 0; } 二、常用查找算法 1. find 2. find_if 3. adjacent_find 4. binary_search  无序序列不可用  5.","title":"常用算法"},{"content":"算术仿函数 template\u0026lt;class T\u0026gt; T plus\u0026lt;T\u0026gt; //加法仿函数 template\u0026lt;class T\u0026gt; T minus\u0026lt;T\u0026gt; //减法仿函数 template\u0026lt;class T\u0026gt; T multiplies\u0026lt;T\u0026gt; //乘法仿函数 template\u0026lt;class T\u0026gt; T divides\u0026lt;T\u0026gt; //除法仿函数 template\u0026lt;class T\u0026gt; T modulus\u0026lt;T\u0026gt; //取模仿函数 template\u0026lt;class T\u0026gt; T negate\u0026lt;T\u0026gt; //取反仿函数 一元谓词 关系仿函数 template\u0026lt;class T\u0026gt; bool equal_to\u0026lt;T\u0026gt; //等于 template\u0026lt;class T\u0026gt; bool not_equal_to\u0026lt;T\u0026gt; //不等于 template\u0026lt;class T\u0026gt; bool greater\u0026lt;T\u0026gt; //大于 template\u0026lt;class T\u0026gt; bool greater_equal\u0026lt;T\u0026gt; //大于等于 template\u0026lt;class T\u0026gt; bool less\u0026lt;T\u0026gt; //小于 template\u0026lt;class T\u0026gt; bool less_equal\u0026lt;T\u0026gt; //小于等于 逻辑仿函数 template\u0026lt;class T\u0026gt; bool logical_and\u0026lt;T\u0026gt; //逻辑与 template\u0026lt;class T\u0026gt; bool logical_or\u0026lt;T\u0026gt; //逻辑或 template\u0026lt;class T\u0026gt; bool logical_not\u0026lt;T\u0026gt; //逻辑非 ","permalink":"https://874656645.github.io/rick/posts/90-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-functional/","summary":"算术仿函数 template\u0026lt;class T\u0026gt; T plus\u0026lt;T\u0026gt; //加法仿函数 template\u0026lt;class T\u0026gt; T minus\u0026lt;T\u0026gt; //减法仿函数 template\u0026lt;class T\u0026gt; T multiplies\u0026lt;T\u0026gt; //乘法仿函数 template\u0026lt;class T\u0026gt; T divides\u0026lt;T\u0026gt; //除法仿函数 template\u0026lt;class T\u0026gt; T modulus\u0026lt;T\u0026gt; //取模仿函数 template\u0026lt;class T\u0026gt; T negate\u0026lt;T\u0026gt; //取反仿函数 一元谓词 关系仿函数 template\u0026lt;class T\u0026gt; bool equal_to\u0026lt;T\u0026gt; //等于 template\u0026lt;class T\u0026gt; bool not_equal_to\u0026lt;T\u0026gt; //不等于 template\u0026lt;class T\u0026gt; bool greater\u0026lt;T\u0026gt; //大于 template\u0026lt;class T\u0026gt; bool greater_equal\u0026lt;T\u0026gt; //大于等于 template\u0026lt;class T\u0026gt; bool less\u0026lt;T\u0026gt; //小于 template\u0026lt;class T\u0026gt; bool less_equal\u0026lt;T\u0026gt; //小于等于 逻辑仿函数 template\u0026lt;class T\u0026gt; bool logical_and\u0026lt;T\u0026gt; //逻辑与 template\u0026lt;class T\u0026gt; bool logical_or\u0026lt;T\u0026gt; //逻辑或 template\u0026lt;class T\u0026gt; bool logical_not\u0026lt;T\u0026gt; //逻辑非 ","title":"内建函数对象 functional"},{"content":"函数对象 重载函数调用操作符 () 的 类，其对象常称为函数对象\n 函数对象可以有自己的状态 函数对象可以作为参数传递 一个参数的函数对象叫做一元仿函数 两个参数的函数对象叫做二元仿函数  什么是谓词 返回 bool 类型的仿函数称为谓词\n一元谓词 如果 operator() 接受一个参数，那么叫做一元谓词\n比如 find_if 算法\n二元谓词 如果 operator() 接受两个参数，那么叫做二元谓词\n比如 sort 算法\n","permalink":"https://874656645.github.io/rick/posts/89-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%B8%8E-predicate-%E8%B0%93%E8%AF%8D/","summary":"函数对象 重载函数调用操作符 () 的 类，其对象常称为函数对象\n 函数对象可以有自己的状态 函数对象可以作为参数传递 一个参数的函数对象叫做一元仿函数 两个参数的函数对象叫做二元仿函数  什么是谓词 返回 bool 类型的仿函数称为谓词\n一元谓词 如果 operator() 接受一个参数，那么叫做一元谓词\n比如 find_if 算法\n二元谓词 如果 operator() 接受两个参数，那么叫做二元谓词\n比如 sort 算法","title":"函数对象与 predicate 谓词"},{"content":"特点  所有元素都会根据元素的键值自动排序 默认排序规则是从小到大，可以通过仿函数指定排序规则 map / multimap 属于关联式容器，底层结构是用红黑树实现 不可以修改键值，可以通过删除再插入的方式实现 可以根据 key 值快速找到 value 值 可以通过下标 [] 的方式快速查找、插入和更新对应的 value  案例  公司今天招聘了10个员工（ABCDEFGHIJ），10 名员工进入公司之后，需要指派员工在哪个部门工作 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 随机给 10 名员工分配部门和工资 通过 multimap 进行信息的插入 key(部门编号) value(员工) 分部门显示员工信息  思路：\n 创建 10 名员工，放到 vector 中 遍历 vector 容器，取出每个员工，进行随机分组 分组后，将员工部门编号作为 key，具体员工作为 value，放入到 multimap 容器中 分部门显示员工信息  class Worker{ public: Worker(string name, int salary){ m_name = name; m_salary = salary; } void printWorker(){ cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34; 工资：\u0026#34; \u0026lt;\u0026lt; m_salary \u0026lt;\u0026lt; endl; } private: string m_name; int m_salary; }; void createWorkers(vector\u0026lt;Worker\u0026gt; \u0026amp;v){ string nameSeed = \u0026#34;ABCDEFGHIJ\u0026#34;; for(int i = 0; i \u0026lt; nameSeed.length(); ++i){ string name = \u0026#34;员工\u0026#34;; // 注意：不能写成 name = \u0026#34;员工\u0026#34; + nameSeed[i]  name += nameSeed[i]; v.push_back(Worker(name, rand() % 10000 + 5000)); } } void groupWorker(vector\u0026lt;Worker\u0026gt; \u0026amp;v, multimap\u0026lt;int, Worker\u0026gt; \u0026amp;m){ for(const auto \u0026amp;w : v){ int depId = rand() % 3; m.insert({depId, w}); } } int main() { srand((unsigned int)time(NULL)); // 创建员工  vector\u0026lt;Worker\u0026gt; vWorker; createWorkers(vWorker); // 员工分组  multimap\u0026lt;int, Worker\u0026gt; mWorker; groupWorker(vWorker, mWorker); // 打印 multimap 结果  for(auto it = mWorker.begin(); it != mWorker.end(); it++){ cout \u0026lt;\u0026lt; \u0026#34;部门：\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34;; it-\u0026gt;second.printWorker(); } cout \u0026lt;\u0026lt; \u0026#34;-----------------------------\u0026#34; \u0026lt;\u0026lt; endl; // 按部门分组打印  cout \u0026lt;\u0026lt; \u0026#34;部门0：\u0026#34; \u0026lt;\u0026lt; endl; auto it = mWorker.find(0); int num = mWorker.count(0); for(int i = 0; it != mWorker.end() \u0026amp;\u0026amp; i \u0026lt; num; it++, i++){ it-\u0026gt;second.printWorker(); } cout \u0026lt;\u0026lt; \u0026#34;-----------------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;部门1：\u0026#34; \u0026lt;\u0026lt; endl; it = mWorker.find(1); num = mWorker.count(1); for(int i = 0; it != mWorker.end() \u0026amp;\u0026amp; i \u0026lt; num; it++, i++){ it-\u0026gt;second.printWorker(); } cout \u0026lt;\u0026lt; \u0026#34;-----------------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;部门2：\u0026#34; \u0026lt;\u0026lt; endl; it = mWorker.find(2); num = mWorker.count(2); for(int i = 0; it != mWorker.end() \u0026amp;\u0026amp; i \u0026lt; num; it++, i++){ it-\u0026gt;second.printWorker(); } return 0; } 输出：\n部门：0 姓名：员工D 工资：6725 部门：0 姓名：员工H 工资：12290 部门：0 姓名：员工I 工资：8753 部门：1 姓名：员工A 工资：11577 部门：1 姓名：员工C 工资：10892 部门：1 姓名：员工F 工资：12622 部门：2 姓名：员工B 工资：6047 部门：2 姓名：员工E 工资：5629 部门：2 姓名：员工G 工资：8954 部门：2 姓名：员工J 工资：11160 ----------------------------- 部门0： 姓名：员工D 工资：6725 姓名：员工H 工资：12290 姓名：员工I 工资：8753 ----------------------------- 部门1： 姓名：员工A 工资：11577 姓名：员工C 工资：10892 姓名：员工F 工资：12622 ----------------------------- 部门2： 姓名：员工B 工资：6047 姓名：员工E 工资：5629 姓名：员工G 工资：8954 姓名：员工J 工资：11160 ","permalink":"https://874656645.github.io/rick/posts/88-map-multimap-%E5%AE%B9%E5%99%A8/","summary":"特点  所有元素都会根据元素的键值自动排序 默认排序规则是从小到大，可以通过仿函数指定排序规则 map / multimap 属于关联式容器，底层结构是用红黑树实现 不可以修改键值，可以通过删除再插入的方式实现 可以根据 key 值快速找到 value 值 可以通过下标 [] 的方式快速查找、插入和更新对应的 value  案例  公司今天招聘了10个员工（ABCDEFGHIJ），10 名员工进入公司之后，需要指派员工在哪个部门工作 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 随机给 10 名员工分配部门和工资 通过 multimap 进行信息的插入 key(部门编号) value(员工) 分部门显示员工信息  思路：\n 创建 10 名员工，放到 vector 中 遍历 vector 容器，取出每个员工，进行随机分组 分组后，将员工部门编号作为 key，具体员工作为 value，放入到 multimap 容器中 分部门显示员工信息  class Worker{ public: Worker(string name, int salary){ m_name = name; m_salary = salary; } void printWorker(){ cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34; 工资：\u0026#34; \u0026lt;\u0026lt; m_salary \u0026lt;\u0026lt; endl; } private: string m_name; int m_salary; }; void createWorkers(vector\u0026lt;Worker\u0026gt; \u0026amp;v){ string nameSeed = \u0026#34;ABCDEFGHIJ\u0026#34;; for(int i = 0; i \u0026lt; nameSeed.","title":"map multimap 容器"},{"content":" 关联式容器 底层结构使用红黑树实现（二叉树-\u0026gt;二叉搜索树-\u0026gt;平衡二叉树-\u0026gt;红黑树） 自动排序 不可以修改值，可以通过删除再插入的方式实现  自定义数据类型：\nclass Person{ public: Person(string name, int age, int height){ this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; this-\u0026gt;m_height = height; } bool operator\u0026lt;(const Person \u0026amp;p2) const{ // 注意：函数和形参都要添加 const 修饰符  if(this-\u0026gt;m_age == p2.m_age){ return this-\u0026gt;m_height \u0026gt; p2.m_height; } return this-\u0026gt;m_age \u0026lt; p2.m_age; } void printPerson()const{ cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; \u0026#34; 身高：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_height \u0026lt;\u0026lt; endl; } private: string m_name; int m_age; int m_height; }; int main() { set\u0026lt;Person\u0026gt; lp; lp.insert(Person(\u0026#34;刘备\u0026#34;, 35 , 175)); lp.insert(Person(\u0026#34;曹操\u0026#34;, 45 , 180)); lp.insert(Person(\u0026#34;孙权\u0026#34;, 40 , 170)); lp.insert(Person(\u0026#34;赵云\u0026#34;, 25 , 190)); lp.insert(Person(\u0026#34;张飞\u0026#34;, 35 , 160)); lp.insert(Person(\u0026#34;关羽\u0026#34;, 35 , 200)); for(const auto \u0026amp;p : lp){ p.printPerson(); } return 0; } ","permalink":"https://874656645.github.io/rick/posts/87-set-multiset-%E5%AE%B9%E5%99%A8/","summary":"关联式容器 底层结构使用红黑树实现（二叉树-\u0026gt;二叉搜索树-\u0026gt;平衡二叉树-\u0026gt;红黑树） 自动排序 不可以修改值，可以通过删除再插入的方式实现  自定义数据类型：\nclass Person{ public: Person(string name, int age, int height){ this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; this-\u0026gt;m_height = height; } bool operator\u0026lt;(const Person \u0026amp;p2) const{ // 注意：函数和形参都要添加 const 修饰符  if(this-\u0026gt;m_age == p2.m_age){ return this-\u0026gt;m_height \u0026gt; p2.m_height; } return this-\u0026gt;m_age \u0026lt; p2.m_age; } void printPerson()const{ cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; \u0026#34; 身高：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_height \u0026lt;\u0026lt; endl; } private: string m_name; int m_age; int m_height; }; int main() { set\u0026lt;Person\u0026gt; lp; lp.","title":"set multiset 容器"},{"content":"注意事项  双向循环链表 不支持随机访问 因为不支持随机访问，所以也不能用全局的排序算法 sort 一般不支持随机访问的容器会自己提供 sort 方法 自定义类型要指定排序规则  排序案例 案例描述：将 Person 自定义数据类型进行排序，Person 中属性有姓名、年龄、身高\n排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序\nclass Person{ public: Person(string name, int age, int height){ this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; this-\u0026gt;m_height = height; } bool operator\u0026lt;(const Person \u0026amp;p2){ if(this-\u0026gt;m_age == p2.m_age){ return this-\u0026gt;m_height \u0026gt; p2.m_height; } return this-\u0026gt;m_age \u0026lt; p2.m_age; } void printPerson()const{ cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; \u0026#34; 身高：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_height \u0026lt;\u0026lt; endl; } private: string m_name; int m_age; int m_height; }; int main() { list\u0026lt;Person\u0026gt; lp; lp.push_back(Person(\u0026#34;刘备\u0026#34;, 35 , 175)); lp.push_back(Person(\u0026#34;曹操\u0026#34;, 45 , 180)); lp.push_back(Person(\u0026#34;孙权\u0026#34;, 40 , 170)); lp.push_back(Person(\u0026#34;赵云\u0026#34;, 25 , 190)); lp.push_back(Person(\u0026#34;张飞\u0026#34;, 35 , 160)); lp.push_back(Person(\u0026#34;关羽\u0026#34;, 35 , 200)); for(const auto \u0026amp;p : lp){ p.printPerson(); } cout \u0026lt;\u0026lt; \u0026#34;排序后：\u0026#34; \u0026lt;\u0026lt; endl; lp.sort(); for(const auto \u0026amp;p : lp){ p.printPerson(); } return 0; } 输出：\n姓名：刘备 年龄：35 身高：175 姓名：曹操 年龄：45 身高：180 姓名：孙权 年龄：40 身高：170 姓名：赵云 年龄：25 身高：190 姓名：张飞 年龄：35 身高：160 姓名：关羽 年龄：35 身高：200 排序后： 姓名：赵云 年龄：25 身高：190 姓名：关羽 年龄：35 身高：200 姓名：刘备 年龄：35 身高：175 姓名：张飞 年龄：35 身高：160 姓名：孙权 年龄：40 身高：170 姓名：曹操 年龄：45 身高：180 ","permalink":"https://874656645.github.io/rick/posts/86-list-%E5%AE%B9%E5%99%A8/","summary":"注意事项  双向循环链表 不支持随机访问 因为不支持随机访问，所以也不能用全局的排序算法 sort 一般不支持随机访问的容器会自己提供 sort 方法 自定义类型要指定排序规则  排序案例 案例描述：将 Person 自定义数据类型进行排序，Person 中属性有姓名、年龄、身高\n排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序\nclass Person{ public: Person(string name, int age, int height){ this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; this-\u0026gt;m_height = height; } bool operator\u0026lt;(const Person \u0026amp;p2){ if(this-\u0026gt;m_age == p2.m_age){ return this-\u0026gt;m_height \u0026gt; p2.m_height; } return this-\u0026gt;m_age \u0026lt; p2.m_age; } void printPerson()const{ cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; \u0026#34; 身高：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_height \u0026lt;\u0026lt; endl; } private: string m_name; int m_age; int m_height; }; int main() { list\u0026lt;Person\u0026gt; lp; lp.","title":"list 容器"},{"content":" 先进先出 不允许遍历元素  queue 队列操作：\nsize()\nempty()\n","permalink":"https://874656645.github.io/rick/posts/85-queue-%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8/","summary":"先进先出 不允许遍历元素  queue 队列操作：\nsize()\nempty()","title":"queue 队列容器适配器"},{"content":" 先进后出 栈不允许遍历元素 不能随机存取  stack 栈操作:\nsize()\nempty()\n","permalink":"https://874656645.github.io/rick/posts/84-stack-%E6%A0%88%E5%AE%B9%E5%99%A8/","summary":"先进后出 栈不允许遍历元素 不能随机存取  stack 栈操作:\nsize()\nempty()","title":"stack 栈容器适配器"},{"content":"有 5 名选手：选手 ABCDE，10 个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。\n分析：\n 创建五名选手，放到 vector 中 遍历 vector 容器，取出来每一个选手，执行 for 循环，可以把 10 个评委打分存到 deque 容器中 sort 算法对 deque 容器中分数排序，去除最高和最低分 deque 容器遍历一遍，累加总分 获取平均分  class Player{ public: Player(string name){ m_name = name; m_avgScore = 0; } void setAvgScore(int v){ m_avgScore = v; } void printInfo()const{ cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;的平均分为：\u0026#34; \u0026lt;\u0026lt; m_avgScore \u0026lt;\u0026lt; endl; } private: string m_name; int m_avgScore; }; void createPlayers(vector\u0026lt;Player\u0026gt; \u0026amp;v){ string nameSeed = \u0026#34;ABCDE\u0026#34;; for(int i = 0; i \u0026lt; nameSeed.length(); ++i){ string name = \u0026#34;选手\u0026#34;; name += nameSeed[i]; v.push_back(Player(name)); } } void scorePlayers(vector\u0026lt;Player\u0026gt; \u0026amp;v){ for(auto \u0026amp;p : v){ // 把 10 个评委打分存到 deque 容器中  deque\u0026lt;int\u0026gt; scores; for(int i = 0; i \u0026lt; 10; ++i){ scores.push_back(rand() % 41 + 60); } // sort 算法对 deque 容器中分数排序，去除最高和最低分  sort(scores.begin(), scores.end()); #if 0// 测试打印分数 p.printInfo(); cout \u0026lt;\u0026lt; \u0026#34;------------------\u0026#34; \u0026lt;\u0026lt; endl; for(const auto \u0026amp;s : scores){ cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; #endif  scores.pop_back(); scores.pop_front(); // deque 容器遍历一遍，累加总分并计算平均分  int num = 0; for(const auto \u0026amp;s : scores){ num += s; } p.setAvgScore(num / scores.size()); } } void printScore(const vector\u0026lt;Player\u0026gt; \u0026amp;v){ for(const auto \u0026amp;p : v){ p.printInfo(); } } int main() { srand((unsigned int)time(NULL)); // 创建五名选手  vector\u0026lt;Player\u0026gt; v; createPlayers(v); // 10 个评委打分  scorePlayers(v); // 打印平均分  printScore(v); return 0; } 输出：\n选手A的平均分为：81 选手B的平均分为：84 选手C的平均分为：82 选手D的平均分为：83 选手E的平均分为：68 ","permalink":"https://874656645.github.io/rick/posts/83-%E8%AF%84%E5%A7%94%E6%89%93%E5%88%86%E6%A1%88%E4%BE%8B/","summary":"有 5 名选手：选手 ABCDE，10 个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。\n分析：\n 创建五名选手，放到 vector 中 遍历 vector 容器，取出来每一个选手，执行 for 循环，可以把 10 个评委打分存到 deque 容器中 sort 算法对 deque 容器中分数排序，去除最高和最低分 deque 容器遍历一遍，累加总分 获取平均分  class Player{ public: Player(string name){ m_name = name; m_avgScore = 0; } void setAvgScore(int v){ m_avgScore = v; } void printInfo()const{ cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;的平均分为：\u0026#34; \u0026lt;\u0026lt; m_avgScore \u0026lt;\u0026lt; endl; } private: string m_name; int m_avgScore; }; void createPlayers(vector\u0026lt;Player\u0026gt; \u0026amp;v){ string nameSeed = \u0026#34;ABCDE\u0026#34;; for(int i = 0; i \u0026lt; nameSeed.","title":"评委打分案例"},{"content":"#include \u0026lt;ctime\u0026gt;using namespace std; int main() { srand((unsigned int)time(NULL)); cout \u0026lt;\u0026lt; rand() % 40 \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://874656645.github.io/rick/posts/82-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/","summary":"#include \u0026lt;ctime\u0026gt;using namespace std; int main() { srand((unsigned int)time(NULL)); cout \u0026lt;\u0026lt; rand() % 40 \u0026lt;\u0026lt; endl; return 0; } ","title":"生成随机数"},{"content":"deque 容器的空间不用手动收缩，类内部会自动处理\n","permalink":"https://874656645.github.io/rick/posts/81-deque-%E5%AE%B9%E5%99%A8/","summary":"deque 容器的空间不用手动收缩，类内部会自动处理","title":"deque 容器"},{"content":" resize() 或者 erase() 后 vector 的空间大小不会自动减小  int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 100000; ++i){ v.push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------------------\u0026#34; \u0026lt;\u0026lt; endl; v.resize(10); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------------------\u0026#34; \u0026lt;\u0026lt; endl; vector\u0026lt;int\u0026gt;(v).swap(v); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; return 0; } 输出：\nsize: 100000 capacity: 131072 ----------------------- size: 10 capacity: 131072 ----------------------- size: 10 capacity: 10 ","permalink":"https://874656645.github.io/rick/posts/80-%E5%B7%A7%E5%A6%99%E6%94%B6%E7%BC%A9-vector-%E7%A9%BA%E9%97%B4/","summary":"resize() 或者 erase() 后 vector 的空间大小不会自动减小  int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 100000; ++i){ v.push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------------------\u0026#34; \u0026lt;\u0026lt; endl; v.resize(10); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------------------\u0026#34; \u0026lt;\u0026lt; endl; vector\u0026lt;int\u0026gt;(v).swap(v); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.","title":"巧妙收缩 vector 空间"},{"content":"结论  allocator 分配器是定义内存模型的类，用于标准库的某些部分，尤其是 STL 容器，如果所有标准容器的最后一个(可选)模板参数没有指定，那么它将使用这个分配器，并且它是标准库中唯一一个预定义的分配器 vector 中存放的如果是对象类型，则会通过 allocator 在堆上开辟足够的空间来存放和管理集合中的对象 vector 中存放指针类型，一定要记得手动释放内存  存放对象 class Person{ public: Person(int age, int id){ m_age = age; m_id = id; cout \u0026lt;\u0026lt; \u0026#34;Person(int, int)...\u0026#34; \u0026lt;\u0026lt; endl; } Person(const Person\u0026amp; p){ m_age = p.m_age; m_id = p.m_id; cout \u0026lt;\u0026lt; \u0026#34;Person(const Person\u0026amp; p)...\u0026#34; \u0026lt;\u0026lt; endl; } ~Person(){ cout \u0026lt;\u0026lt; \u0026#34;~Person()...\u0026#34; \u0026lt;\u0026lt; endl; } void* operator new(size_t size){ void* p = malloc(size); cout \u0026lt;\u0026lt; \u0026#34;new()...\u0026#34; \u0026lt;\u0026lt; endl; return p; } void operator delete(void *p){ cout \u0026lt;\u0026lt; \u0026#34;delete()...\u0026#34; \u0026lt;\u0026lt; endl; if(p != NULL){ free(p); p = NULL; } } void show(){ cout \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; m_age \u0026lt;\u0026lt; \u0026#34; Id: \u0026#34; \u0026lt;\u0026lt; m_id \u0026lt;\u0026lt; endl; } private: int m_age; int m_id; }; void printPerson(Person \u0026amp;p){ p.show(); } int main() { // vector 中存放对象类型  std::vector\u0026lt;Person\u0026gt; v; v.reserve(3); v.push_back(Person(10, 20)); v.push_back(Person(30, 40)); v.push_back(Person(50, 60)); // 遍历 vector  for(vector\u0026lt;Person\u0026gt;::iterator it = v.begin(); it != v.end(); it++){ // 迭代器是指针  it-\u0026gt;show(); // 也可以这么写  // (*it).show();  } for_each(v.begin(), v.end(), printPerson); // 回调函数不支持函数重载？？  // 测试删除  Person* pp = \u0026amp;v[0]; // 记录 vector 中第一个元素的地址  // 方式一  v.clear(); // 这种释放方式，pp 指针仍然可以访问已释放的地址，存在安全隐患  // 方式二  vector\u0026lt;Person\u0026gt;().swap(v); // 这种方式不仅可以释放内存，还可以防止其它指针对已经释放的内存进行非法访问  // 利用 swap 函数和临时对象交换内存，交换以后，临时对象消失  cout \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; if(pp != NULL){ pp-\u0026gt;show(); }else{ cout \u0026lt;\u0026lt; \u0026#34;空指针\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 方式一输出：\nPerson(int, int)... Person(const Person\u0026amp; p)... ~Person()... Person(int, int)... Person(const Person\u0026amp; p)... ~Person()... Person(int, int)... Person(const Person\u0026amp; p)... ~Person()... Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 ~Person()... ~Person()... ~Person()... 0 Age: 10 Id: 20 方式二输出：\nPerson(int, int)... Person(const Person\u0026amp; p)... ~Person()... Person(int, int)... Person(const Person\u0026amp; p)... ~Person()... Person(int, int)... Person(const Person\u0026amp; p)... ~Person()... Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 ~Person()... ~Person()... ~Person()... 0 Age: 0 Id: 0 存放指针 void printPerson(Person *\u0026amp;p){ if(p == NULL){ cout \u0026lt;\u0026lt; \u0026#34;指针为空\u0026#34; \u0026lt;\u0026lt; endl; return; } p-\u0026gt;show(); } void delPerson(Person *\u0026amp;p){ delete p; p = NULL; } int main() { // vector 中存放对象指针，就必须手动释放内存  vector\u0026lt;Person*\u0026gt; v; v.reserve(3); v.push_back(new Person(10, 20)); v.push_back(new Person(30, 40)); v.push_back(new Person(50, 60)); for_each(v.begin(), v.end(), printPerson); // 不支持函数重载？？  // 手动释放内存  // for_each(v.begin(), v.end(), delPerson);  // for_each(v.begin(), v.end(), printPerson);  // 删除测试  Person *pp = v[0]; // 记录 vector 中第一个元素的地址，实际上是拷贝了指向第一个 Person 对象的地址  // 除非手动 delete 掉 vector 中的指针，否则不管是 clear 还是 swap 都没有真正释放内存  // 这两种方式只是把 vector 对象释放了，存储的指针所指向的空间并没有释放  // 方式一  v.clear(); // 这种情况下，pp 指针仍然可以访问  // 方式二  vector\u0026lt;Person*\u0026gt;().swap(v); cout \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; if(pp != NULL){ pp-\u0026gt;show(); }else{ cout \u0026lt;\u0026lt; \u0026#34;空指针\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 方式一输出：\nnew()... Person(int, int)... new()... Person(int, int)... new()... Person(int, int)... Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 0 Age: 10 Id: 20 方式二输出：\nnew()... Person(int, int)... new()... Person(int, int)... new()... Person(int, int)... Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 0 Age: 10 Id: 20 手动释放内存输出：\nnew()... Person(int, int)... new()... Person(int, int)... new()... Person(int, int)... Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 ~Person()... delete()... ~Person()... delete()... ~Person()... delete()... 指针为空 指针为空 指针为空 0 空指针 ","permalink":"https://874656645.github.io/rick/posts/79-vector-%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E5%AD%98%E6%94%BE%E5%9C%A8%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%A0%88%E4%B8%8A/","summary":"结论  allocator 分配器是定义内存模型的类，用于标准库的某些部分，尤其是 STL 容器，如果所有标准容器的最后一个(可选)模板参数没有指定，那么它将使用这个分配器，并且它是标准库中唯一一个预定义的分配器 vector 中存放的如果是对象类型，则会通过 allocator 在堆上开辟足够的空间来存放和管理集合中的对象 vector 中存放指针类型，一定要记得手动释放内存  存放对象 class Person{ public: Person(int age, int id){ m_age = age; m_id = id; cout \u0026lt;\u0026lt; \u0026#34;Person(int, int)...\u0026#34; \u0026lt;\u0026lt; endl; } Person(const Person\u0026amp; p){ m_age = p.m_age; m_id = p.m_id; cout \u0026lt;\u0026lt; \u0026#34;Person(const Person\u0026amp; p)...\u0026#34; \u0026lt;\u0026lt; endl; } ~Person(){ cout \u0026lt;\u0026lt; \u0026#34;~Person()...\u0026#34; \u0026lt;\u0026lt; endl; } void* operator new(size_t size){ void* p = malloc(size); cout \u0026lt;\u0026lt; \u0026#34;new()...\u0026#34; \u0026lt;\u0026lt; endl; return p; } void operator delete(void *p){ cout \u0026lt;\u0026lt; \u0026#34;delete().","title":"vector 中的元素存放在堆上还是栈上"},{"content":" 平时要有容器、算法、迭代器的思维模式 容器提供迭代器，算法使用迭代器  // 算法 int count(int* begin, int* end, int val){ int n = 0; while(begin != end){ if(*begin == val){ n++; } begin++; } return n; } int main() { // 容器  int arr[] = {1, 3, 0, 5, 1, 3, 1, 0}; // 迭代器  int* begin = arr; int* end = *(\u0026amp;arr + 1); int n = count(begin, end, 1); cout \u0026lt;\u0026lt; \u0026#34;count: \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://874656645.github.io/rick/posts/78-stl-hello-world/","summary":" 平时要有容器、算法、迭代器的思维模式 容器提供迭代器，算法使用迭代器  // 算法 int count(int* begin, int* end, int val){ int n = 0; while(begin != end){ if(*begin == val){ n++; } begin++; } return n; } int main() { // 容器  int arr[] = {1, 3, 0, 5, 1, 3, 1, 0}; // 迭代器  int* begin = arr; int* end = *(\u0026amp;arr + 1); int n = count(begin, end, 1); cout \u0026lt;\u0026lt; \u0026#34;count: \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } ","title":"STL Hello World"},{"content":"一、文件读写  文件输入流 ifstream 文件输出流 ofstream 文件输入输出流 fstream 文件的打开方式 文件流的状态 文件流的定位：文件指针（输入指针、输出指针）  二、文本文件 #include \u0026lt;iostream\u0026gt;#include \u0026lt;fstream\u0026gt;using namespace std; void ReadWriteFile(){ ifstream ifs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\source.txt\u0026#34;, ios::in); ofstream ofs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\target.txt\u0026#34;, ios::out | ios::app); if (!ifs) { cout \u0026lt;\u0026lt; \u0026#34;输入文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } if (!ofs) { cout \u0026lt;\u0026lt; \u0026#34;输出文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } char ch; while (ifs.get(ch)) { cout \u0026lt;\u0026lt; ch; ofs \u0026lt;\u0026lt; ch; } ifs.close(); ofs.close(); } 三、二进制文件  文本文件和二进制文件在计算机中都是以二进制的方式存储的 程序中的对象都是二进制存储的 Windows 中的文本文件换行符用 \\r\\n 表示，二进制是以 \\n 存储，所以存储和显示时会做一下转换 Linux 中二进制和文本文件换行都是以 \\n 存储和表示  class Person { private: int m_age; int m_id; public: Person():m_age(0), m_id(0){ } Person(int age, int id){ m_age = age; m_id = id; } ~Person() = default; void show(){ cout \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; m_age \u0026lt;\u0026lt; \u0026#34; ID: \u0026#34; \u0026lt;\u0026lt; m_id \u0026lt;\u0026lt; endl; } }; void BinaryReadWrite(){ // 存储二进制  ofstream ofs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\target.txt\u0026#34;, ios::out | ios::binary); if (!ofs) { cout \u0026lt;\u0026lt; \u0026#34;存储文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } Person p1(10, 20), p2(30, 40); ofs.write((const char*)\u0026amp;p1, sizeof(Person)); ofs.write((const char*)\u0026amp;p2, sizeof(Person)); ofs.close(); // 读取二进制  ifstream ifs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\target.txt\u0026#34;, ios::in | ios::binary); if (!ifs) { cout \u0026lt;\u0026lt; \u0026#34;读取文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } Person p3, p4; ifs.read((char*)\u0026amp;p3, sizeof(Person)); ifs.read((char*)\u0026amp;p4, sizeof(Person)); p3.show(); p4.show(); ifs.close(); } ","permalink":"https://874656645.github.io/rick/posts/77-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","summary":"一、文件读写  文件输入流 ifstream 文件输出流 ofstream 文件输入输出流 fstream 文件的打开方式 文件流的状态 文件流的定位：文件指针（输入指针、输出指针）  二、文本文件 #include \u0026lt;iostream\u0026gt;#include \u0026lt;fstream\u0026gt;using namespace std; void ReadWriteFile(){ ifstream ifs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\source.txt\u0026#34;, ios::in); ofstream ofs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\target.txt\u0026#34;, ios::out | ios::app); if (!ifs) { cout \u0026lt;\u0026lt; \u0026#34;输入文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } if (!ofs) { cout \u0026lt;\u0026lt; \u0026#34;输出文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } char ch; while (ifs.get(ch)) { cout \u0026lt;\u0026lt; ch; ofs \u0026lt;\u0026lt; ch; } ifs.close(); ofs.close(); } 三、二进制文件  文本文件和二进制文件在计算机中都是以二进制的方式存储的 程序中的对象都是二进制存储的 Windows 中的文本文件换行符用 \\r\\n 表示，二进制是以 \\n 存储，所以存储和显示时会做一下转换 Linux 中二进制和文本文件换行都是以 \\n 存储和表示  class Person { private: int m_age; int m_id; public: Person():m_age(0), m_id(0){ } Person(int age, int id){ m_age = age; m_id = id; } ~Person() = default; void show(){ cout \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; m_age \u0026lt;\u0026lt; \u0026#34; ID: \u0026#34; \u0026lt;\u0026lt; m_id \u0026lt;\u0026lt; endl; } }; void BinaryReadWrite(){ // 存储二进制  ofstream ofs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\target.","title":"文件操作"},{"content":"#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;iomanip\u0026gt; // 控制符头文件using namespace std; // 格式化输出 void func(){ // 方式一：使用成员方法  int number = 10; cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; cout.unsetf(ios::dec); // 八进制  cout.setf(ios::oct); cout.setf(ios::showbase); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // 012  // 十六进制  cout.unsetf(ios::oct); cout.setf(ios::hex); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // 0xa  // 固定宽度  cout.width(10); cout.fill(\u0026#39;*\u0026#39;); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // *******0xa  // 上面的设置只对当前输出有效，下次的输出格式要重新设置  cout.setf(ios::left); cout.width(10); cout.fill(\u0026#39;*\u0026#39;); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // 0xa*******  // 方式二：使用控制符的方式  cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; setiosflags(ios::showbase) \u0026lt;\u0026lt; setiosflags(ios::right) \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; setfill(\u0026#39;~\u0026#39;) \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // ~~~~~~~0xa } ","permalink":"https://874656645.github.io/rick/posts/76-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/","summary":"#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;iomanip\u0026gt; // 控制符头文件using namespace std; // 格式化输出 void func(){ // 方式一：使用成员方法  int number = 10; cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; cout.unsetf(ios::dec); // 八进制  cout.setf(ios::oct); cout.setf(ios::showbase); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // 012  // 十六进制  cout.unsetf(ios::oct); cout.setf(ios::hex); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // 0xa  // 固定宽度  cout.width(10); cout.fill(\u0026#39;*\u0026#39;); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // *******0xa  // 上面的设置只对当前输出有效，下次的输出格式要重新设置  cout.setf(ios::left); cout.width(10); cout.","title":"格式化输出"},{"content":"C++ 异常\n C++11 不再建议使用异常规范  // 异常规范 只能抛出 int float char 三种类型的异常 C++11以后不再建议使用 void func1() throw(int, float, char){ throw \u0026#34;string\u0026#34;; // terminate called after throwing an instance of \u0026#39;char const*\u0026#39; } // 不能抛出任何类型的异常 OK void func2() throw(){ throw -1; // terminate called after throwing an instance of \u0026#39;int\u0026#39; } // 可以抛出任何类型的异常 void func3(){ throw \u0026#34;error\u0026#34;; } int main() { try{ func1(); } catch(char const * e){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; } catch(...){ // 捕获所有异常  cout \u0026lt;\u0026lt; \u0026#34;捕获未知异常\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } ","permalink":"https://874656645.github.io/rick/posts/75-%E5%BC%82%E5%B8%B8%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E/","summary":"C++ 异常\n C++11 不再建议使用异常规范  // 异常规范 只能抛出 int float char 三种类型的异常 C++11以后不再建议使用 void func1() throw(int, float, char){ throw \u0026#34;string\u0026#34;; // terminate called after throwing an instance of \u0026#39;char const*\u0026#39; } // 不能抛出任何类型的异常 OK void func2() throw(){ throw -1; // terminate called after throwing an instance of \u0026#39;int\u0026#39; } // 可以抛出任何类型的异常 void func3(){ throw \u0026#34;error\u0026#34;; } int main() { try{ func1(); } catch(char const * e){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; } catch(.","title":"异常接口声明"},{"content":"异常被抛出后，从进入 try 块起到异常被抛出前，这期间在栈上构造的所有对象都会被自动析构，析构的顺序与构造的顺序相反。\n与 return 类似\nclass Test{ public: Test(string name){ m_name = name; cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;被构造了\u0026#34; \u0026lt;\u0026lt; endl; } ~Test(){ cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;被析构了\u0026#34; \u0026lt;\u0026lt; endl; } private: string m_name; }; double func1(int x, int y){ Test t1(\u0026#34;t1\u0026#34;), t2(\u0026#34;t2\u0026#34;); if(y == 0){ throw y; } return x / y; } int main() { try{ Test t3(\u0026#34;t3\u0026#34;), t4(\u0026#34;t4\u0026#34;); func1(10, 0); } catch(int e){ cout \u0026lt;\u0026lt; \u0026#34;除数为 \u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; } return 0; } t3被构造了 t4被构造了 t1被构造了 t2被构造了 t2被析构了 t1被析构了 t4被析构了 t3被析构了 除数为 0 ","permalink":"https://874656645.github.io/rick/posts/74-%E6%A0%88%E8%A7%A3%E6%97%8B-unwinding/","summary":"异常被抛出后，从进入 try 块起到异常被抛出前，这期间在栈上构造的所有对象都会被自动析构，析构的顺序与构造的顺序相反。\n与 return 类似\nclass Test{ public: Test(string name){ m_name = name; cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;被构造了\u0026#34; \u0026lt;\u0026lt; endl; } ~Test(){ cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;被析构了\u0026#34; \u0026lt;\u0026lt; endl; } private: string m_name; }; double func1(int x, int y){ Test t1(\u0026#34;t1\u0026#34;), t2(\u0026#34;t2\u0026#34;); if(y == 0){ throw y; } return x / y; } int main() { try{ Test t3(\u0026#34;t3\u0026#34;), t4(\u0026#34;t4\u0026#34;); func1(10, 0); } catch(int e){ cout \u0026lt;\u0026lt; \u0026#34;除数为 \u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; } return 0; } t3被构造了 t4被构造了 t1被构造了 t2被构造了 t2被析构了 t1被析构了 t4被析构了 t3被析构了 除数为 0 ","title":"栈解旋 Unwinding"},{"content":"一、try、catch、throw  可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型 C++ 异常机制是跨函数的，且是必须处理的。如果中间函数没有处理就一直抛到最顶层，如果 main 函数也不处理，程序就会挂掉  int main( ) { try{ throw \u0026#34;exception\u0026#34;; }catch(const char * e){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; }catch(...){ // 捕获所有异常  cout \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; } { cout \u0026lt;\u0026lt; \u0026#34;finally\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输出：\nStart exception finally 0 Finish 二、std::exception class exception { public: exception() throw(); exception(const exception\u0026amp; rhs) throw(); exception\u0026amp; operator=(const exception\u0026amp; rhs) throw(); virtual ~exception() throw(); virtual const char *what() const throw(); }; 派生了两个异常类：\n   类名 描述     logic_erro 报告程序的逻辑错误，可在程序执行前被检测到   runtime_erro 报告程序运行时的错误，只有在运行的时候才能检测到    由logic_erro派生的异常类：\n   类名 描述     domain_error 报告违反了前置条件   invalid_argument 指出函数的一个无效参数   length_error 指出有一个产生超过NPOS长度的对象的企图（NPOS为size_t的最大可表现值   out_of_range 报告参数越界   bad_cast 在运行时类型识别中有一个无效的dynamic_cast表达式   bad_typeid 报告在表达式typeid(*p)中有一个空指针P    由runtime_error派生的异常：\n   类名 描述     range_error 报告违反了后置条件   overflow_error 报告一个算术溢出   bad_alloc 报告一个存储分配错误    三、自定义异常 可以通过继承和重载 exception 类来定义新的异常\nstruct MyException : public exception { const char * what () const throw () // 表明没有任何异常抛出  { return \u0026#34;C++ Exception\u0026#34;; } }; int main() { try { throw MyException(); } catch(MyException\u0026amp; e) { cout \u0026lt;\u0026lt; \u0026#34;MyException caught\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } catch(std::exception\u0026amp; e) { //其他的错误  } catch(...) { cout \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; } { cout \u0026lt;\u0026lt; \u0026#34;finally\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } Start MyException caught C++ Exception finally 0 Finish ","permalink":"https://874656645.github.io/rick/posts/57-%E5%BC%82%E5%B8%B8/","summary":"一、try、catch、throw  可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型 C++ 异常机制是跨函数的，且是必须处理的。如果中间函数没有处理就一直抛到最顶层，如果 main 函数也不处理，程序就会挂掉  int main( ) { try{ throw \u0026#34;exception\u0026#34;; }catch(const char * e){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; }catch(...){ // 捕获所有异常  cout \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; } { cout \u0026lt;\u0026lt; \u0026#34;finally\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输出：\nStart exception finally 0 Finish 二、std::exception class exception { public: exception() throw(); exception(const exception\u0026amp; rhs) throw(); exception\u0026amp; operator=(const exception\u0026amp; rhs) throw(); virtual ~exception() throw(); virtual const char *what() const throw(); }; 派生了两个异常类：","title":"异常"},{"content":"1. static_cast\u0026lt;\u0026gt;  可以转换内置数据类型； 不可以转换没有关系的指针或引用； 可以转换有继承关系的指针或引用（父类转子类或子类转父类都可以）；  // static_cast\u0026lt;\u0026gt;  // 1. 内置对象  int a = 97; char c = static_cast\u0026lt;char\u0026gt;(a); // OK  cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; // 2. 自定义类型对象  // Building bb;  // Animal aa = static_cast\u0026lt;Animal\u0026gt;(bb); // error: no matching function for call to ‘Animal::Animal(Building\u0026amp;)’  // 3. 不同类型的指针转换  // int *p = \u0026amp;a;  // char *pc = static_cast\u0026lt;char*\u0026gt;(p); // error: invalid static_cast from type ‘int*’ to type ‘char*’  // cout \u0026lt;\u0026lt; pc \u0026lt;\u0026lt; endl;  // Animal * pa = NULL;  // Building *pb = static_cast\u0026lt;Building*\u0026gt;(pa); // error: invalid static_cast from type ‘Animal*’ to type ‘Building*’  // 4. 有继承关系的指针或引用  Animal * pa = NULL; Cat *pc = static_cast\u0026lt;Cat*\u0026gt;(pa); // OK  pa = static_cast\u0026lt;Animal*\u0026gt;(pc); // OK 2. dynamic_cast\u0026lt;\u0026gt;  只能转换有继承关系的指针或引用，且只能将子类转为父类（从大到小），因为将父类转为子类会不安全（从小到大）  // dynamic_cast\u0026lt;\u0026gt;  // 1. 内置对象  // c = dynamic_cast\u0026lt;char\u0026gt;(a); // error: cannot dynamic_cast ‘a’ (of type ‘int’) to type ‘char’ (target is not pointer or reference)  // 2. 非继承关系指针  // Building *pb = dynamic_cast\u0026lt;Building*\u0026gt;(pa); // error: cannot dynamic_cast ‘pa’ (of type ‘class Animal*’) to type ‘class Building*’ (source type is not polymorphic)  // 3. 继承关系指针会做安全检查，只能将子类指针转为父类指针  // pc = dynamic_cast\u0026lt;Cat*\u0026gt;(pa); // error: cannot dynamic_cast ‘pa’ (of type ‘class Animal*’) to type ‘class Cat*’ (source type is not polymorphic)  pa = dynamic_cast\u0026lt;Animal*\u0026gt;(pc); // OK  3. const_cast\u0026lt;\u0026gt;  只能转换指针或引用类型，添加或去除 const 修饰 非 const 的可以直接转为 const 类型，但反之不行  int i = 0; int *a = \u0026amp;i const int* b = const_cast\u0026lt;const int*\u0026gt;(a); const int* bb = a; // OK a = const_cast\u0026lt;int*\u0026gt;(b); // OK a = b; // error: invalid conversion from ‘const int*’ to ‘int*’ [-fpermissive] 4. reinterpret_cast\u0026lt;\u0026gt; 对任何类型的指针进行强制转换，包括函数指针\n","permalink":"https://874656645.github.io/rick/posts/73-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","summary":"1. static_cast\u0026lt;\u0026gt;  可以转换内置数据类型； 不可以转换没有关系的指针或引用； 可以转换有继承关系的指针或引用（父类转子类或子类转父类都可以）；  // static_cast\u0026lt;\u0026gt;  // 1. 内置对象  int a = 97; char c = static_cast\u0026lt;char\u0026gt;(a); // OK  cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; // 2. 自定义类型对象  // Building bb;  // Animal aa = static_cast\u0026lt;Animal\u0026gt;(bb); // error: no matching function for call to ‘Animal::Animal(Building\u0026amp;)’  // 3. 不同类型的指针转换  // int *p = \u0026amp;a;  // char *pc = static_cast\u0026lt;char*\u0026gt;(p); // error: invalid static_cast from type ‘int*’ to type ‘char*’  // cout \u0026lt;\u0026lt; pc \u0026lt;\u0026lt; endl;  // Animal * pa = NULL;  // Building *pb = static_cast\u0026lt;Building*\u0026gt;(pa); // error: invalid static_cast from type ‘Animal*’ to type ‘Building*’  // 4.","title":"类型转换"},{"content":"要求  可以对内置数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及 operator= 防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量  实现 template\u0026lt;class T\u0026gt; class MyArray{ public: MyArray(int capacity){ this-\u0026gt;m_capacity = capacity; this-\u0026gt;m_size = 0; this-\u0026gt;m_addr = new T[this-\u0026gt;m_capacity]; } MyArray(const MyArray\u0026amp; arr){ if(arr.m_addr == NULL){ return; } // 深拷贝  this-\u0026gt;m_capacity = arr.m_capacity; this-\u0026gt;m_size = arr.m_size; this-\u0026gt;m_addr = new T[this-\u0026gt;m_capacity]; for(int i = 0; i \u0026lt; m_size; ++i){ // T 类型是可拷贝的，= 运算符也是深拷贝  this-\u0026gt;m_addr[i] = arr.m_addr[i]; } } MyArray\u0026amp; operator=(const MyArray\u0026amp; arr){ if(this == \u0026amp;arr){ return *this; } if(this-\u0026gt;m_addr != NULL){ delete[] this-\u0026gt;m_addr; this-\u0026gt;m_addr = NULL; this-\u0026gt;m_capacity = 0; this-\u0026gt;m_size = 0; } this-\u0026gt;m_capacity = arr.m_capacity; this-\u0026gt;m_size = arr.m_size; this-\u0026gt;m_addr = new T[this-\u0026gt;m_capacity]; for(int i = 0; i \u0026lt; this-\u0026gt;m_size; ++i){ this-\u0026gt;m_addr[i] = arr.m_addr[i]; } return *this; } T\u0026amp; operator[](int index){ return this-\u0026gt;m_addr[index]; } void pushBack(T\u0026amp; data){ if(this-\u0026gt;m_size == this-\u0026gt;m_capacity){ return; } this-\u0026gt;m_addr[this-\u0026gt;m_size] = data; this-\u0026gt;m_size++; } // 可以接收右值引用  void pushBack(T\u0026amp;\u0026amp; data){ if(this-\u0026gt;m_size == this-\u0026gt;m_capacity){ return; } this-\u0026gt;m_addr[this-\u0026gt;m_size] = data; this-\u0026gt;m_size++; } // 这种方式也可以接收右值引用  void pushBack(const T\u0026amp; data){ if(this-\u0026gt;m_size == this-\u0026gt;m_capacity){ return; } this-\u0026gt;m_addr[this-\u0026gt;m_size] = data; this-\u0026gt;m_size++; } void popBack(){ if(this-\u0026gt;m_size == 0){ return; } this-\u0026gt;m_size--; } int getCapacity() const{ return m_capacity; } int getSize() const{ return m_size; } ~MyArray(){ if(this-\u0026gt;m_addr != NULL){ delete[] this-\u0026gt;m_addr; this-\u0026gt;m_addr = NULL; this-\u0026gt;m_size = 0; } } private: int m_capacity; int m_size; T *m_addr; }; int main() { int a = 10, b = 20, c = 30; MyArray\u0026lt;int\u0026gt; arr(10); arr.pushBack(a); arr.pushBack(b); arr.pushBack(c); arr.pushBack(100); arr.pushBack(200); for(int i = 0; i \u0026lt; arr.getSize(); ++i){ cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;-----------\u0026#34; \u0026lt;\u0026lt; endl; arr.popBack(); for(int i = 0; i \u0026lt; arr.getSize(); ++i){ cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;+++++++++++\u0026#34; \u0026lt;\u0026lt; endl; MyArray\u0026lt;int\u0026gt; arr2(arr); for(int i = 0; i \u0026lt; arr2.getSize(); ++i){ cout \u0026lt;\u0026lt; arr2[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;+++++++++++\u0026#34; \u0026lt;\u0026lt; endl; MyArray\u0026lt;int\u0026gt; arr3(5); arr3.pushBack(1); arr3.pushBack(2); arr3.pushBack(3); arr2 = arr3; for(int i = 0; i \u0026lt; arr2.getSize(); ++i){ cout \u0026lt;\u0026lt; arr2[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 输出：\n10 20 30 100 200 ----------- 10 20 30 100 +++++++++++ 10 20 30 100 +++++++++++ 1 2 3 ","permalink":"https://874656645.github.io/rick/posts/72-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/","summary":"要求  可以对内置数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及 operator= 防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量  实现 template\u0026lt;class T\u0026gt; class MyArray{ public: MyArray(int capacity){ this-\u0026gt;m_capacity = capacity; this-\u0026gt;m_size = 0; this-\u0026gt;m_addr = new T[this-\u0026gt;m_capacity]; } MyArray(const MyArray\u0026amp; arr){ if(arr.m_addr == NULL){ return; } // 深拷贝  this-\u0026gt;m_capacity = arr.m_capacity; this-\u0026gt;m_size = arr.m_size; this-\u0026gt;m_addr = new T[this-\u0026gt;m_capacity]; for(int i = 0; i \u0026lt; m_size; ++i){ // T 类型是可拷贝的，= 运算符也是深拷贝  this-\u0026gt;m_addr[i] = arr.m_addr[i]; } } MyArray\u0026amp; operator=(const MyArray\u0026amp; arr){ if(this == \u0026amp;arr){ return *this; } if(this-\u0026gt;m_addr !","title":"自定义数组实现"},{"content":"一、类模板写法 1. 声明和定义写在一起 template\u0026lt;class T\u0026gt; class Person{ // 友元重载  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Person\u0026lt;T\u0026gt; \u0026amp;p){ cout \u0026lt;\u0026lt; p.m_age; return os; } // 普通友元函数  friend void printP(Person\u0026lt;T\u0026gt; p){ cout \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; } public: Person(T age){ this-\u0026gt;m_age = age; } void Show(){ cout \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } private: T m_age; }; int main() { Person\u0026lt;int\u0026gt; p(20); p.Show(); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; printP(p); return 0; } 2. 声明和定义分开写，但在同一文件中 template\u0026lt;class T\u0026gt; class Person{ public: Person(T age); void Show(); private: T m_age; }; template\u0026lt;class T\u0026gt; Person\u0026lt;T\u0026gt;::Person(T age){ this-\u0026gt;m_age = age; } template\u0026lt;class T\u0026gt; void Person\u0026lt;T\u0026gt;::Show(){ cout \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } int main() { Person\u0026lt;int\u0026gt; p(20); p.Show(); return 0; } 二、类模板派生  类模板派生普通类； 类模板派生类模板；  template\u0026lt;class T\u0026gt; class Base{ public: Base(T a){ this-\u0026gt;m_a = a; } void show(){ cout \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } private: T m_a; }; class Derive1 : public Base\u0026lt;int\u0026gt;{ public: Derive1(int a):Base\u0026lt;int\u0026gt;(a){ } }; template\u0026lt;class T1, class T2\u0026gt; class Derive2 : public Base\u0026lt;T1\u0026gt;{ public: Derive2(T1 a, T2 b):Base\u0026lt;T1\u0026gt;(a){ this-\u0026gt;b = b; } void show(){ Base\u0026lt;T1\u0026gt;::show(); cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } private: T2 b; }; int main() { Derive1 d(10); d.show(); cout \u0026lt;\u0026lt; \u0026#34;---------\u0026#34; \u0026lt;\u0026lt; endl; Derive2\u0026lt;int, char\u0026gt; dd(100, \u0026#39;a\u0026#39;); dd.show(); return 0; } 输出：\n10 --------- 100 a 三、类模板中写友元函数 1. 声明和定义一起写 template\u0026lt;class T\u0026gt; class Person{ // 友元重载  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Person\u0026lt;T\u0026gt; \u0026amp;p){ os \u0026lt;\u0026lt; p.m_age; return os; } // 普通友元  friend void printP(Person\u0026lt;T\u0026gt; p){ cout \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; } public: Person(T age){ this-\u0026gt;m_age = age; } void Show(){ cout \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } private: T m_age; }; int main() { Person\u0026lt;int\u0026gt; p(20); p.Show(); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; printP(p); return 0; } 2. 声明和定义分开写 // 前置声明 template\u0026lt;class T\u0026gt; class Person; template\u0026lt;class T\u0026gt; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Person\u0026lt;T\u0026gt; \u0026amp;p); template\u0026lt;class T\u0026gt; void printP(Person\u0026lt;T\u0026gt; p); template\u0026lt;class T\u0026gt; class Person{ // 友元重载  friend ostream\u0026amp; operator\u0026lt;\u0026lt; \u0026lt;T\u0026gt;(ostream \u0026amp;os, Person\u0026lt;T\u0026gt; \u0026amp;p); // 普通友元  friend void printP\u0026lt;T\u0026gt;(Person\u0026lt;T\u0026gt; p); public: Person(T age); void Show(); private: T m_age; }; template\u0026lt;class T\u0026gt; Person\u0026lt;T\u0026gt;::Person(T age){ this-\u0026gt;m_age = age; } template\u0026lt;class T\u0026gt; void Person\u0026lt;T\u0026gt;::Show(){ cout \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } template\u0026lt;class T\u0026gt; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Person\u0026lt;T\u0026gt; \u0026amp;p){ os \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; return os; } template\u0026lt;class T\u0026gt; void printP(Person\u0026lt;T\u0026gt; p){ cout \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; } int main() { Person\u0026lt;int\u0026gt; p(20); p.Show(); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; printP(p); return 0; } 四、结论  类模板中不要滥用友元； 将类模板的声明和定义放在同一个文件中，一般为 .hpp 文件；  五、类模板中的 static 变量 每个具体的类都有属于自己的静态变量，每个具体类的实例对象共享自己具体类的静态变量\ntemplate\u0026lt;class T\u0026gt; int Person\u0026lt;T\u0026gt;::s_a = 0; int main() { Person\u0026lt;int\u0026gt; p1(10), p2(20); Person\u0026lt;char\u0026gt; pp1(10), pp2(20); p1.s_a = 1; pp1.s_a = 100; cout \u0026lt;\u0026lt; p2.s_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pp2.s_a \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 100 ","permalink":"https://874656645.github.io/rick/posts/71-%E7%B1%BB%E6%A8%A1%E6%9D%BF/","summary":"一、类模板写法 1. 声明和定义写在一起 template\u0026lt;class T\u0026gt; class Person{ // 友元重载  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Person\u0026lt;T\u0026gt; \u0026amp;p){ cout \u0026lt;\u0026lt; p.m_age; return os; } // 普通友元函数  friend void printP(Person\u0026lt;T\u0026gt; p){ cout \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; } public: Person(T age){ this-\u0026gt;m_age = age; } void Show(){ cout \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } private: T m_age; }; int main() { Person\u0026lt;int\u0026gt; p(20); p.Show(); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; printP(p); return 0; } 2. 声明和定义分开写，但在同一文件中 template\u0026lt;class T\u0026gt; class Person{ public: Person(T age); void Show(); private: T m_age; }; template\u0026lt;class T\u0026gt; Person\u0026lt;T\u0026gt;::Person(T age){ this-\u0026gt;m_age = age; } template\u0026lt;class T\u0026gt; void Person\u0026lt;T\u0026gt;::Show(){ cout \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } int main() { Person\u0026lt;int\u0026gt; p(20); p.","title":"类模板"},{"content":"各个 .cpp 文件是独立编译的，如果有其它的类和函数会先在本 .o 文件中生成符号，由最后的链接器去其它 .o 文件找具体的函数定义\n .c .cpp 文件经过 预编译器拷贝头文件、宏展开 生成 .i 文件（文本文件）\ng++ -E main.cpp -o main.i .i 文件经过 编译器 生成汇编程序 .s（文本文件）\ng++ -S main.i -o main.s .s 文件经过 汇编器 生成可定位目标文件 .o （二进制）\nWindows:\ng++ -c main.s -o main.obj\nLinux:\ng++ -c main.s -o main.o .o 文件经过 链接器 生成可执行目标文件 .exe .dll\ng++ main.s -o main  ","permalink":"https://874656645.github.io/rick/posts/70-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","summary":"各个 .cpp 文件是独立编译的，如果有其它的类和函数会先在本 .o 文件中生成符号，由最后的链接器去其它 .o 文件找具体的函数定义\n .c .cpp 文件经过 预编译器拷贝头文件、宏展开 生成 .i 文件（文本文件）\ng++ -E main.cpp -o main.i .i 文件经过 编译器 生成汇编程序 .s（文本文件）\ng++ -S main.i -o main.s .s 文件经过 汇编器 生成可定位目标文件 .o （二进制）\nWindows:\ng++ -c main.s -o main.obj\nLinux:\ng++ -c main.s -o main.o .o 文件经过 链接器 生成可执行目标文件 .exe .dll\ng++ main.s -o main  ","title":"编译过程"},{"content":" 函数模板必须严格类型匹配，普通函数则可以进行数据类型隐式转换 对于内置数据类型，函数模板可进行推导，自定义类型不可以 函数模板可被重载 C++ 编译器优先考虑普通函数 可以通过空模板实参列表的语法限定编译器只能通过模板匹配 如果函数模板可以产生一个更好的匹配，就选择模板 编译器根据函数模板调用情况，从函数模板和具体类型产生不同的函数\n编译器会对函数模板进行两次编译  在声明的地方对模板代码本身进行编译； 在调用的地方对参数替换后的代码进行编译    template\u0026lt;class T\u0026gt; T MyAdd(T a, T b){ return a + b; } // 函数一 int MyAdd(int a, int b){ return a + b; } // 函数二 int MyAdd(int a, char c){ return a + c; } int main() { cout \u0026lt;\u0026lt; MyAdd(1, 2) \u0026lt;\u0026lt; endl; // 优先调用普通函数  cout \u0026lt;\u0026lt; MyAdd\u0026lt;\u0026gt;(1, 2) \u0026lt;\u0026lt; endl; // 强制调用模板函数  cout \u0026lt;\u0026lt; MyAdd(1.1, 2.2) \u0026lt;\u0026lt; endl; // 函数模板数据类型推导  cout \u0026lt;\u0026lt; MyAdd\u0026lt;double\u0026gt;(1.1, 2.2) \u0026lt;\u0026lt; endl; // 显式调用  cout \u0026lt;\u0026lt; MyAdd(1, \u0026#39;a\u0026#39;) \u0026lt;\u0026lt; endl; // 没有函数二则调用函数一 MyAdd (a=1, c=97 \u0026#39;a\u0026#39;)  cout \u0026lt;\u0026lt; MyAdd(\u0026#39;a\u0026#39;, 1) \u0026lt;\u0026lt; endl; // 没有函数一则调用函数二 MyAdd (a=97, c=1 \u0026#39;\\001\u0026#39;)  return 0; } 输出：\n3 3 3.3 3.3 98 98 ","permalink":"https://874656645.github.io/rick/posts/69-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/","summary":"函数模板必须严格类型匹配，普通函数则可以进行数据类型隐式转换 对于内置数据类型，函数模板可进行推导，自定义类型不可以 函数模板可被重载 C++ 编译器优先考虑普通函数 可以通过空模板实参列表的语法限定编译器只能通过模板匹配 如果函数模板可以产生一个更好的匹配，就选择模板 编译器根据函数模板调用情况，从函数模板和具体类型产生不同的函数\n编译器会对函数模板进行两次编译  在声明的地方对模板代码本身进行编译； 在调用的地方对参数替换后的代码进行编译    template\u0026lt;class T\u0026gt; T MyAdd(T a, T b){ return a + b; } // 函数一 int MyAdd(int a, int b){ return a + b; } // 函数二 int MyAdd(int a, char c){ return a + c; } int main() { cout \u0026lt;\u0026lt; MyAdd(1, 2) \u0026lt;\u0026lt; endl; // 优先调用普通函数  cout \u0026lt;\u0026lt; MyAdd\u0026lt;\u0026gt;(1, 2) \u0026lt;\u0026lt; endl; // 强制调用模板函数  cout \u0026lt;\u0026lt; MyAdd(1.","title":"函数模板"},{"content":"通过函数指针实现多态，注册回调函数的方式\nvoid printAllArray(void* arr, int eleSize, int len, void(*myPrint)(void*)){ char* arrStart = (char*)arr; for(int i = 0; i \u0026lt; len; ++i){ char* eleStart = arrStart + i * eleSize; myPrint(eleStart); } printf(\u0026#34;\\n\u0026#34;); } void printInt(void* data){ int* ele = (int*)data; printf(\u0026#34;%d \u0026#34;, *ele); } struct Person{ char name[64]; int age; }; void printPerson(void* data){ struct Person* ele = (struct Person*)data; printf(\u0026#34;Name: %s, Age: %d \\n\u0026#34;, ele-\u0026gt;name, ele-\u0026gt;age); } int main() { int arr[] = {1, 2, 3, 4, 5}; printAllArray(arr, sizeof(int), 5, printInt); struct Person personArr[] = { {\u0026#34;aaa\u0026#34;, 20}, {\u0026#34;bbb\u0026#34;, 30}, {\u0026#34;ccc\u0026#34;, 40}, {\u0026#34;ddd\u0026#34;, 50}, {\u0026#34;eee\u0026#34;, 60}, }; printAllArray(personArr, sizeof(struct Person), 5, printPerson); return 0; } 输出：\n1 2 3 4 5 Name: aaa, Age: 20 Name: bbb, Age: 30 Name: ccc, Age: 40 Name: ddd, Age: 50 Name: eee, Age: 60 ","permalink":"https://874656645.github.io/rick/posts/68-c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/","summary":"通过函数指针实现多态，注册回调函数的方式\nvoid printAllArray(void* arr, int eleSize, int len, void(*myPrint)(void*)){ char* arrStart = (char*)arr; for(int i = 0; i \u0026lt; len; ++i){ char* eleStart = arrStart + i * eleSize; myPrint(eleStart); } printf(\u0026#34;\\n\u0026#34;); } void printInt(void* data){ int* ele = (int*)data; printf(\u0026#34;%d \u0026#34;, *ele); } struct Person{ char name[64]; int age; }; void printPerson(void* data){ struct Person* ele = (struct Person*)data; printf(\u0026#34;Name: %s, Age: %d \\n\u0026#34;, ele-\u0026gt;name, ele-\u0026gt;age); } int main() { int arr[] = {1, 2, 3, 4, 5}; printAllArray(arr, sizeof(int), 5, printInt); struct Person personArr[] = { {\u0026#34;aaa\u0026#34;, 20}, {\u0026#34;bbb\u0026#34;, 30}, {\u0026#34;ccc\u0026#34;, 40}, {\u0026#34;ddd\u0026#34;, 50}, {\u0026#34;eee\u0026#34;, 60}, }; printAllArray(personArr, sizeof(struct Person), 5, printPerson); return 0; } 输出：","title":"C 语言面向接口编程"},{"content":"三层架构：业务逻辑层、抽象层、实现层\n原则：依赖倒转\n案例一：动物园 设计实现：\n 抽象层：Animal\n提供接口 voice 实现层：Dog、Cat\n分别实现 voice ，发出不同的声音 业务层：main 函数调用，只通过 Animal 的指针统一实现业务  案例二：编写一个 C++ 程序, 计算程序员( programmer )工资  要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer )的工资 要求利用抽象类统一界面，方便程序的扩展，比如:新增，计算架构师( architect ) 的工资  设计实现：\n 抽象层：Programmer\n提供计算工资的接口 实现层：JuniorProgrammer、MidProgrammer、AdvProgrammer\n分别对计算工资接口进行实现 业务层：通过 Programmer 类统一管理，实现业务逻辑，同时业务的可扩展性更强，如新增架构师类型  案例三：电脑组装，面向抽象层编程  组装电脑有 3 个抽象类，抽象的 cpu，抽象的显卡，抽象的内存。 现在要求组装两台电脑，一台是 Intel 的 CPU，Intel 的显卡和 Intel 的内存。另一台是 Intel 的 CPU、Nvidia 的显卡和 Kingston 的内存条。 针对抽象层编程。  设计实现：\n 抽象层：CPU、Card、Storage 三个抽象类和一个组合类 Computer 实现层：IntelCPU、IntelCard、IntelStorage、NvidiaCard、KingstonStorage 派生类 业务层：创建两个 Computer 实例  案例四：几何图形  设计一个基类 Shape 包含成员函数 Show(), 将 Show() 声明为纯虚函数。 Shape 类公有派生矩形类 Square（正方形）和圆类 Circle（圆形） 分别定义 Show() 实现其主要集合元素的显示。使用抽象类 Shape 类型的指针，当它指向某个派生类的对象时，就可以通过访问该对象的虚函数成员 Show() 用 ShowArea() 分别显示各种图形的面积.最后还要显示所有图形的各个面积。要求积累指针数组，数组的每个元素指向一个派生类对象。  设计实现：\n 抽象层：Shape 抽象类，有 Show() 和 ShowArea() 两个纯虚函数 实现层：Square、Circle 派生类，分别拥有自己的属性，并实现基类纯虚函数 业务层：通过 Shape 指针数组管理  案例五：企业员工信息管理系统  某小型公司,主要有四类人员:经理、技术人员、销售经理和推销员。 现在需要存储这些人员的姓名、编号、级别、当月薪水。计算月薪总额并显示全部信息。 人员编号基数为 1000,每输入一个人员信息编号顺序加 1。 程序要有对所有人员提升级别的功能。本例中为简单起见,所有人员的初始级别均为 1 级。然后进行升级,经理升为 4 级,技术人员和销售经理升为 3 级,推销员仍为1级。 月薪计算办法是: 经理拿固定月薪 8000 元;技术人员按每小时 100 元领取月薪; 推销员的月薪按该推销员当月销售额的 4% 提成;销售经理既拿固定月薪也领取销售提成,固定月薪为 5000 元,销售提成为所管辖部门当月销售总额的 5%。  设计实现：\n 抽象层：Employee，拥有姓名、编号、级别、当月薪水基础属性，并提供 pay()、displayStatus() 两个纯虚函数（接口） 实现层：Technician、Manager、Salesman，SalesManager 虚继承于 Manager、Salesman，且分别有自己的特有属性 业务层：分别显示基本信息并计算工资  ","permalink":"https://874656645.github.io/rick/posts/67-%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%BC%96%E7%A8%8B/","summary":"三层架构：业务逻辑层、抽象层、实现层\n原则：依赖倒转\n案例一：动物园 设计实现：\n 抽象层：Animal\n提供接口 voice 实现层：Dog、Cat\n分别实现 voice ，发出不同的声音 业务层：main 函数调用，只通过 Animal 的指针统一实现业务  案例二：编写一个 C++ 程序, 计算程序员( programmer )工资  要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer )的工资 要求利用抽象类统一界面，方便程序的扩展，比如:新增，计算架构师( architect ) 的工资  设计实现：\n 抽象层：Programmer\n提供计算工资的接口 实现层：JuniorProgrammer、MidProgrammer、AdvProgrammer\n分别对计算工资接口进行实现 业务层：通过 Programmer 类统一管理，实现业务逻辑，同时业务的可扩展性更强，如新增架构师类型  案例三：电脑组装，面向抽象层编程  组装电脑有 3 个抽象类，抽象的 cpu，抽象的显卡，抽象的内存。 现在要求组装两台电脑，一台是 Intel 的 CPU，Intel 的显卡和 Intel 的内存。另一台是 Intel 的 CPU、Nvidia 的显卡和 Kingston 的内存条。 针对抽象层编程。  设计实现：","title":"面向抽象类编程"},{"content":"MyString.h\n#ifndef __MYSTRING_H_ #define __MYSTRING_H_  #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; class MyString { // 重载 \u0026lt;\u0026lt;  // 最好是 const 的，可以输出匿名变量（匿名变量不能被非 const 的左值引用接收）  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const MyString \u0026amp;s); // 重载 \u0026gt;\u0026gt;  friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, MyString \u0026amp;s); private: // 字符串的有效长度  int m_len; // 字符串指针  char* m_pStr; public: MyString(); MyString(const char *); MyString(const MyString \u0026amp;); ~MyString(); // 重载 =  MyString\u0026amp; operator=(const MyString \u0026amp;); // 重载 []  char\u0026amp; operator[](int index); // 重载 +  MyString operator+(const MyString \u0026amp;); // 重载 +=  MyString\u0026amp; operator+=(const MyString \u0026amp;); // 重载 ==  bool operator==(const MyString \u0026amp;); // 重载 !=  bool operator!=(const MyString \u0026amp;); }; #endif MyString.cpp\n#include \u0026#34;MyString.h\u0026#34; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const MyString \u0026amp;s){ os \u0026lt;\u0026lt; s.m_pStr; return os; } istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, MyString \u0026amp;s){ char temp[4096] = {0}; is \u0026gt;\u0026gt; temp; if (s.m_pStr != NULL) { s.m_len = 0; free(s.m_pStr); s.m_pStr = NULL; } s.m_len = strlen(temp); s.m_pStr = (char*)malloc(s.m_len); strcpy(s.m_pStr, temp); return is; } MyString::MyString() { m_len = 0; m_pStr = NULL; // 注意 \u0026#39;\\0\u0026#39; NULL \u0026#34;\u0026#34;的区别 } MyString::MyString(const char *c) { if (c != NULL) { m_len = strlen(c); m_pStr = (char*)malloc(m_len + 1); strcpy(m_pStr, c); } cout \u0026lt;\u0026lt; \u0026#34;MyString(const char *c)...\u0026#34; \u0026lt;\u0026lt; endl; } MyString::MyString(const MyString \u0026amp;s) { if (s.m_pStr != NULL) { m_len = s.m_len; m_pStr = (char*)malloc(m_len + 1); strcpy(m_pStr, s.m_pStr); } cout \u0026lt;\u0026lt; \u0026#34;MyString(const MyString \u0026amp;s)...\u0026#34; \u0026lt;\u0026lt; endl; } MyString::~MyString() { m_len = 0; if (m_pStr != NULL) { free(m_pStr); m_pStr = NULL; } cout \u0026lt;\u0026lt; \u0026#34;~MyString()...\u0026#34; \u0026lt;\u0026lt; endl; } MyString\u0026amp; MyString::operator=(const MyString \u0026amp;s) { cout \u0026lt;\u0026lt; \u0026#34;operator=(const MyString \u0026amp;s)...\u0026#34; \u0026lt;\u0026lt; endl; // 1. 是否是给自身赋值  if (this == \u0026amp;s) { return *this; } // 2. 处理自身垃圾  if (m_pStr != NULL) { free(m_pStr); m_pStr = NULL; } // 3. 深拷贝  if (s.m_pStr != NULL) { m_len = s.m_len; m_pStr = (char*)malloc(m_len + 1); strcpy(m_pStr, s.m_pStr); } // 4. 返回自身  return *this; } char\u0026amp; MyString::operator[](int index) { if (m_len == 0) { throw \u0026#34;bad memory\u0026#34;; } if (index \u0026lt; 0 || index \u0026gt;= m_len) { throw \u0026#34;out of range\u0026#34;; } return m_pStr[index]; } MyString MyString::operator+(const MyString \u0026amp;s) { // 方式一：  /* MyString temp; temp.m_len = m_len + s.m_len; temp.m_pStr = (char*)malloc(temp.m_len + 1); // memset(temp.m_pStr, 0, temp.m_len + 1); strcpy(temp.m_pStr, m_pStr); // 注意 strcpy 和 strcat 的使用 strcat(temp.m_pStr, s.m_pStr); // 注意 strcat 的使用 return temp; */ // 方式二：  MyString temp = *this; return temp += s; } MyString\u0026amp; MyString::operator+=(const MyString \u0026amp;s) { if (s.m_len \u0026gt; 0) { // 处理自身垃圾  if (m_pStr != NULL) { char* pTemp = m_pStr; m_len += s.m_len; m_pStr = (char*)malloc(m_len + 1); strcpy(m_pStr, pTemp); strcat(m_pStr, s.m_pStr); free(pTemp); pTemp = NULL; } } return *this; } bool MyString::operator==(const MyString \u0026amp;s) { if (m_len == 0 || s.m_len == 0) { return false; } if(m_len != s.m_len) { return false; } for (int i = 0; i \u0026lt; m_len; i++) { if (m_pStr[i] != s.m_pStr[i]) { return false; } } return true; } bool MyString::operator!=(const MyString \u0026amp;s) { return !(*this == s); } test.cpp\n#include \u0026lt;iostream\u0026gt;#include \u0026#34;MyString.h\u0026#34; using namespace std; int main(){ // 隐式转换  MyString s0 = \u0026#34;123\u0026#34;; cout \u0026lt;\u0026lt; s0 \u0026lt;\u0026lt; endl; // 构造函数  MyString s1(\u0026#34;abc\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // 拷贝构造  MyString s2 = s1; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; // 拷贝构造  MyString s3(s2); cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; // = 操作符  s3 = s1; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; // [] 操作符  cout \u0026lt;\u0026lt; s3[1] \u0026lt;\u0026lt; endl; s3[1] = \u0026#39;1\u0026#39;; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; // + 操作符  cout \u0026lt;\u0026lt; s1 + s2 +s3 \u0026lt;\u0026lt; endl; // += 操作符  s3 += s1; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; // == 操作符  cout \u0026lt;\u0026lt; (s3 == s1) \u0026lt;\u0026lt; endl; // != 操作符  cout \u0026lt;\u0026lt; (s3 != s1) \u0026lt;\u0026lt; endl; return 0; } 输出：\nMyString(const char *c)... abc MyString(const MyString \u0026amp;s)... abc MyString(const MyString \u0026amp;s)... abc operator=(const MyString \u0026amp;s)... abc b a1c abcabca1c ~MyString()... ~MyString()... a1cabc 0 1 ~MyString()... ~MyString()... ~MyString()... ","permalink":"https://874656645.github.io/rick/posts/66-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/","summary":"MyString.h\n#ifndef __MYSTRING_H_ #define __MYSTRING_H_  #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; class MyString { // 重载 \u0026lt;\u0026lt;  // 最好是 const 的，可以输出匿名变量（匿名变量不能被非 const 的左值引用接收）  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const MyString \u0026amp;s); // 重载 \u0026gt;\u0026gt;  friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, MyString \u0026amp;s); private: // 字符串的有效长度  int m_len; // 字符串指针  char* m_pStr; public: MyString(); MyString(const char *); MyString(const MyString \u0026amp;); ~MyString(); // 重载 =  MyString\u0026amp; operator=(const MyString \u0026amp;); // 重载 []  char\u0026amp; operator[](int index); // 重载 +  MyString operator+(const MyString \u0026amp;); // 重载 +=  MyString\u0026amp; operator+=(const MyString \u0026amp;); // 重载 ==  bool operator==(const MyString \u0026amp;); // 重载 !","title":"实现一个简单的字符串类"},{"content":"1. 声明静态数组后一定要进行初始化，否则里面的值都是未知的 int main() { int ia[3] = {0}; // 这虽然只是给第一个元素赋了值，但剩余未赋值的元素都会初始化为0  char ca[3] = {0}; double da[3]; bool ba[3]; short sa[3]; float fa[3]; for(auto \u0026amp; i : da){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } return 0; } 输出：\n6.95128e-310 4.63759e-310 0 2. C++ 数组指针和数组类型  数组类型和数组指针（数组名）不是一种类型，只是恰好指向的地址相同而已 数组名是指针常量（int * const），代表数组中第一个元素的地址 数组类型代表整个数组  int main() { int arr[10]; cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; arr + 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;arr + 1 \u0026lt;\u0026lt; endl; return 0; } 输出：\n0x7fff7fd65c20 0x7fff7fd65c24 ---------- 0x7fff7fd65c20 0x7fff7fd65c48 定义数组类型：\n// 方法一：定义一个数组类型 typedef int(ARRAY_INT_10)[10]; // 方法二：定义一个数组指针（不推荐这种写法） typedef int(*ARRAY_INT_10_P)[10]; int main() { int arr[10]; // 方法一：  ARRAY_INT_10 *arr1 = \u0026amp;arr; for(int i = 0; i \u0026lt; 10; i++){ //arr2[i] = i; // 错误 cannot convert ‘int*’ to ‘int (*)[10]’  // arr 是数组指针，arr1 是数组名  (*arr1)[i] = i; // 正确，要对 arr1 降级  } for(int i = 0; i \u0026lt; 10; i++){ cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;-----\u0026#34; \u0026lt;\u0026lt; endl; // 方法二：  ARRAY_INT_10_P arr2 = \u0026amp;arr; for(int i = 0; i \u0026lt; 10; i++){ cout \u0026lt;\u0026lt; (*arr2)[i] \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;+++++\u0026#34; \u0026lt;\u0026lt; endl; // 方法三：  int(*arr3)[10] = \u0026amp;arr; for(int i = 0; i \u0026lt; 10; i++){ cout \u0026lt;\u0026lt; (*arr3)[i] \u0026lt;\u0026lt; endl; } return 0; } 错误输出：\nmain.cpp:50:26: error: cannot convert ‘int*’ to ‘int (*)[10]’ in initialization 50 | ARRAY_INT_10 *arr2 = arr; | ^~~ | | | int* 输出：\n0 1 2 3 4 5 6 7 8 9 ----- 0 1 2 3 4 5 6 7 8 9 +++++ 0 1 2 3 4 5 6 7 8 9 ","permalink":"https://874656645.github.io/rick/posts/65-%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/","summary":"1. 声明静态数组后一定要进行初始化，否则里面的值都是未知的 int main() { int ia[3] = {0}; // 这虽然只是给第一个元素赋了值，但剩余未赋值的元素都会初始化为0  char ca[3] = {0}; double da[3]; bool ba[3]; short sa[3]; float fa[3]; for(auto \u0026amp; i : da){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } return 0; } 输出：\n6.95128e-310 4.63759e-310 0 2. C++ 数组指针和数组类型  数组类型和数组指针（数组名）不是一种类型，只是恰好指向的地址相同而已 数组名是指针常量（int * const），代表数组中第一个元素的地址 数组类型代表整个数组  int main() { int arr[10]; cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; arr + 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;arr + 1 \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"静态数组初始化"},{"content":"一、安装 C++ 开发环境 Using GCC with MinGW\n 安装 MSYS2 更新 MSYS2 pacman -Syu 在开始菜单中运行 MSYS2 MSYS，更新其余的基本包 pacman -Su 安装 C++ 开发环境：  clang++ x64 gdb: pacman -S --needed base-devel mingw-w64-ucrt-x86_64-clang mingw-w64-ucrt-x86_64-gdb g++ gdb: pacman -S --needed base-devel mingw-w64-x86_64-toolchain clang++ lldb: pacman -S --needed base-devel mingw-w64-clang-x86_64-lldb\n这个库会把 clang clang++ 等库安装到 msys64/clang64/bin 目录，但是 lldb 在 Windows 上的调试效果不如 gdb clang++ x86：pacman -S --needed base-devel mingw-w64-i686-clang   添加环境变量 D:\\msys64\\ucrt64\\bin 检查是否安装成功  clang++ --version g++ --version gdb --version    pacman -Syu // 更新整个系统 pacman -Su // 更新已安装的包 pacman -Ss 关键字 // 搜索含关键字的包 pacman -S 包名 // 安装包，也可以同时安装多个包，只需以空格分隔包名即可 pacman -Rs 包名 // 删除包及其依赖 pacman -R 包名 // 删除包 二、配置 VS Code 主要是修改 task.json 和 launch.json 两个配置文件；\n新版本的 VS Code 按 F5 会自动创建这两个配置文件，稍做修改就可以了；\ntask.json 示例：\n{ \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Build\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;clang++.exe\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-fdiagnostics-color=always\u0026#34;, \u0026#34;-g\u0026#34;, // \u0026#34;${file}\u0026#34;, // 单文件  \u0026#34;${fileDirname}\\\\*.cpp\u0026#34;, // 多文件  \u0026#34;-o\u0026#34;, \u0026#34;${workspaceRoot}\\\\bin64\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;-ggdb3\u0026#34;, // 生成和调试有关的信息  \u0026#34;-Wall\u0026#34;, // 开启额外警告  \u0026#34;-static-libgcc\u0026#34;, // 静态链接  \u0026#34;-std=c++17\u0026#34;, // 使用c++17标准  \u0026#34;-finput-charset=UTF-8\u0026#34;, // 输入编译器文本编码 默认为UTF-8  \u0026#34;-D _USE_MATH_DEFINES\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;detail\u0026#34;: \u0026#34;调试器生成的任务。\u0026#34; } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } launch.json 示例：\n{ // 使用 IntelliSense 了解相关属性。  // 悬停以查看现有属性的描述。  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387  \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Debug\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}\\\\bin64\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;gdb.exe\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;为 gdb 启用整齐打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;Build\u0026#34; } ] } ","permalink":"https://874656645.github.io/rick/posts/64-vs-code-%E6%90%AD%E5%BB%BA-c++-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","summary":"一、安装 C++ 开发环境 Using GCC with MinGW\n 安装 MSYS2 更新 MSYS2 pacman -Syu 在开始菜单中运行 MSYS2 MSYS，更新其余的基本包 pacman -Su 安装 C++ 开发环境：  clang++ x64 gdb: pacman -S --needed base-devel mingw-w64-ucrt-x86_64-clang mingw-w64-ucrt-x86_64-gdb g++ gdb: pacman -S --needed base-devel mingw-w64-x86_64-toolchain clang++ lldb: pacman -S --needed base-devel mingw-w64-clang-x86_64-lldb\n这个库会把 clang clang++ 等库安装到 msys64/clang64/bin 目录，但是 lldb 在 Windows 上的调试效果不如 gdb clang++ x86：pacman -S --needed base-devel mingw-w64-i686-clang   添加环境变量 D:\\msys64\\ucrt64\\bin 检查是否安装成功  clang++ --version g++ --version gdb --version    pacman -Syu // 更新整个系统 pacman -Su // 更新已安装的包 pacman -Ss 关键字 // 搜索含关键字的包 pacman -S 包名 // 安装包，也可以同时安装多个包，只需以空格分隔包名即可 pacman -Rs 包名 // 删除包及其依赖 pacman -R 包名 // 删除包 二、配置 VS Code 主要是修改 task.","title":"VS Code 搭建 c++ gdb 开发环境"},{"content":"C/C++内存对齐详解\n内存对齐规则  对齐系数（也叫对齐模数）：gcc中默认 #pragma pack(4)，可以通过预编译命令 #pragma pack(n)，n = 1,2,4,8,16 来改变这一系数 有效对齐值：是给定值 #pragma pack(n) 和结构体中 最长数据类型长度中较小的那个。有效对齐值也叫 对齐单位    规则一：结构体第一个成员的偏移量 offset 为 0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节\n  规则二：结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节\n注意：上面两条规则都需要得到满足\n注意：成员变量首地址偏移和对齐都是与【有效对齐值】进行比较，而有效对齐值是对齐系数与结构体中最长数据类型中的较小者\n  // 64 位程序 struct { int i; char c1; char c2; }x1; struct{ char c1; int i; char c2; }x2; struct{ char c1; char c2; int i; }x3; struct { short i; char c1; char c2; }y1; struct{ char c1; short i; char c2; }y2; struct{ char c1; char c2; short i; }y3; int main() { printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x1)); // 输出8  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x2)); // 输出12  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x3)); // 输出8  cout \u0026lt;\u0026lt; \u0026#34;----------------\u0026#34; \u0026lt;\u0026lt; endl; printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y1)); // 输出4  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y2)); // 输出6  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y3)); // 输出4  return 0; } 既要考虑首地址偏移，又要是有效对齐值（对齐单位）的整数倍 y1 y2 y3结构体：\n以上测试都是在 Linux 环境下进行的，linux 下默认 #pragma pack(4)，且结构体中最长的数据类型为 2 个字节，所以有效对齐单位为 2 字节，下面根据上面所说的规则以 y2 来分析其内存布局：\n首先使用规则 1，对成员变量进行对齐：\nsizeof(c1) = 1 \u0026lt;= 2 (有效对齐位)，按照 1 字节对齐，占用第 0 单元；\nsizeof(i) = 2 \u0026lt;= 2 (有效对齐位)，相对于结构体首地址的偏移要为 2 的倍数，占用第 2，3 单元；\nsizeof(c2) = 1 \u0026lt;= 2 (有效对齐位)，相对于结构体首地址的偏移要为 1 的倍数，占用第 4 单元；\n然后使用规则 2，对结构体整体进行对齐：\ny2 中变量 i 占用内存最大占 2 字节，而有对齐系数为 4 字节，两者较小值就是 2 字节。因此整体也是按照 2 字节对齐。由规则 1 得到 y2 占 5 个字节，此处再按照规则 2 进行整体的 2 字节对齐，所以整个结构体占用 6 个字节。\n","permalink":"https://874656645.github.io/rick/posts/63-c++-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/","summary":"C/C++内存对齐详解\n内存对齐规则  对齐系数（也叫对齐模数）：gcc中默认 #pragma pack(4)，可以通过预编译命令 #pragma pack(n)，n = 1,2,4,8,16 来改变这一系数 有效对齐值：是给定值 #pragma pack(n) 和结构体中 最长数据类型长度中较小的那个。有效对齐值也叫 对齐单位    规则一：结构体第一个成员的偏移量 offset 为 0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节\n  规则二：结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节\n注意：上面两条规则都需要得到满足\n注意：成员变量首地址偏移和对齐都是与【有效对齐值】进行比较，而有效对齐值是对齐系数与结构体中最长数据类型中的较小者\n  // 64 位程序 struct { int i; char c1; char c2; }x1; struct{ char c1; int i; char c2; }x2; struct{ char c1; char c2; int i; }x3; struct { short i; char c1; char c2; }y1; struct{ char c1; short i; char c2; }y2; struct{ char c1; char c2; short i; }y3; int main() { printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x1)); // 输出8  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x2)); // 输出12  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x3)); // 输出8  cout \u0026lt;\u0026lt; \u0026#34;----------------\u0026#34; \u0026lt;\u0026lt; endl; printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y1)); // 输出4  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y2)); // 输出6  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y3)); // 输出4  return 0; } 既要考虑首地址偏移，又要是有效对齐值（对齐单位）的整数倍 y1 y2 y3结构体：","title":"C++ 内存对齐"},{"content":" 使用模板类 重载 -\u0026gt; 操作符 重载 * 操作符  template\u0026lt;typename T\u0026gt; class MyAutoPtr{ public: MyAutoPtr(T * t){ ptr = t; } ~MyAutoPtr(){ if(ptr != NULL){ delete ptr; ptr = NULL; } } T* operator-\u0026gt;(){ // 相当于 ptr-\u0026gt; , 所以返回 ptr 指针即可，将所有操作转发给真正的指针变量  return ptr; } T\u0026amp; operator*(){ // 相当于 (*ptr) ，所以返回 ptr 指向的对象引用即可  return *ptr; } private: T* ptr; }; class A{ public: A(int a){ cout \u0026lt;\u0026lt; \u0026#34;A(int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; } ~A(){ cout \u0026lt;\u0026lt; \u0026#34;~A()...\u0026#34; \u0026lt;\u0026lt; endl; } void printA(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } private: int a; }; int main( ) { MyAutoPtr\u0026lt;A\u0026gt; p(new A(10)); p-\u0026gt;printA(); // ptr-\u0026gt;printA()  (*p).printA(); // (*ptr).printA()  MyAutoPtr\u0026lt;int\u0026gt; ip(new int(100)); cout \u0026lt;\u0026lt; *ip \u0026lt;\u0026lt; endl; return 0; } 输出：\nA(int)... a = 10 a = 10 100 ~A()... ","permalink":"https://874656645.github.io/rick/posts/62-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","summary":"使用模板类 重载 -\u0026gt; 操作符 重载 * 操作符  template\u0026lt;typename T\u0026gt; class MyAutoPtr{ public: MyAutoPtr(T * t){ ptr = t; } ~MyAutoPtr(){ if(ptr != NULL){ delete ptr; ptr = NULL; } } T* operator-\u0026gt;(){ // 相当于 ptr-\u0026gt; , 所以返回 ptr 指针即可，将所有操作转发给真正的指针变量  return ptr; } T\u0026amp; operator*(){ // 相当于 (*ptr) ，所以返回 ptr 指向的对象引用即可  return *ptr; } private: T* ptr; }; class A{ public: A(int a){ cout \u0026lt;\u0026lt; \u0026#34;A(int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; } ~A(){ cout \u0026lt;\u0026lt; \u0026#34;~A().","title":"自定义智能指针"},{"content":"一、进程与线程  进程是资源分配和调度的一个独立单位；而线程是进程的一个实体，是 CPU 调度和分配的基本单位 同一个进程中的多个线程的内存资源是共享的，各线程都可以改变进程中的变量。因此在执行多线程运算的时候要注意执行顺序  二、并行与并发  并行（parallellism）指的是多个任务在同一时刻同时在执行 并发（concurrency）是指在一个时间段内，多个任务交替进行。虽然看起来像在同时执行，但其实是交替的  三、多任务处理 多线程是多任务处理的一种特殊形式，一般情况下，有基于进程和基于线程的两种类型的多任务处理方式。\n 基于进程的多任务处理是程序的并发执行 基于线程的多任务处理是同一程序的片段的并发执行  四、C++11 线程管理 thread 库  C++11 提供了多线程库，使用时需要 #include \u0026lt;thread\u0026gt; 头文件，该头文件主要包含了对线程的管理类 std::thread 以及其他管理线程相关的类 每个应用程序至少有一个进程，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个子线程。每个线程都需要一个入口函数，入口函数返回退出，该线程也会退出，主线程就是以 main 函数作为入口函数的线程 主线程退出后，运行中的子线程也会被销毁 std::thread 的构造函数需要的是可调用（callable）类型，除了函数外，还可以调用 lambda 表达式、重载了 () 运算符的类的实例 把函数对象传入 std::thread 时，应传入函数名称（不带括号） 当启动一个线程后，一定要在该线程 thread 销毁前，调用 join() 或者 detach()，确定以何种方式等待线程执行结束  detach 方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束 join 方式，等待关联的线程完成，才会继续执行 join() 后的代码 在以 detach 的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用按值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束    1、调用全局函数启动线程 #include \u0026lt;thread\u0026gt; using namespace std; void func(int i){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } int main() { for(int i = 0; i \u0026lt; 4; ++i){ // 创建一个线程t，第一个参数为调用的函数，第二个参数为传递的参数  thread t(func, i); // 表示允许该线程在后台运行  t.detach(); } return 0; } 输出：\nStart 10 2 3 0 Finish 2、调用类成员函数启动线程 class Test{ public: explicit Test(int a){ this-\u0026gt;a = a; } void fuc1(int n){ cout \u0026lt;\u0026lt; \u0026#34;fuc1() n = \u0026#34; \u0026lt;\u0026lt; n * a \u0026lt;\u0026lt; endl; } static void fuc2(int n){ cout \u0026lt;\u0026lt; \u0026#34;static fuc2() n = \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } private: int a; }; int main() { Test t(5); thread t1(\u0026amp;Test::fuc1, \u0026amp;t, 10); t1.join(); thread t2(\u0026amp;Test::fuc2, 100); t2.join(); return 0; } 输出：\nStart fuc1() n = 50 static fuc2() n = 100 0 Finish 3、转移线程的所有权 thread 是可移动的 (movable) 的，但不可复制的 (copyable)。可以通过 move 来改变线程的所有权，灵活的决定线程在什么时候 join 或者 detach\nthread t1(f1); thread t3(move(t1)); 将线程从 t1 转移给 t3，这时候 t1 就不再拥有线程的所有权，调用 t1.join 或 t1.detach 会出现异常，要使用 t3 来管理线程。这也就意味着 thread 可以作为函数的返回类型，或者作为参数传递给函数，能够更为方便的管理线程\n4、线程标识的获取 线程的标识类型为 std:🧵:id，有两种方式获得到线程的 id：\n 通过 thread 的实例调用 get_id() 直接获取 在当前线程上调用 this_thread::get_id() 获取  5、线程暂停 如果让线程从外部暂停会引发很多并发问题，这也是为什么std::thread没有直接提供pause函数的原因。如果线程在运行过程中，确实需要停顿，就可以用 this_thread::sleep_for\nclass Test{ public: explicit Test(int a){ this-\u0026gt;a = a; } void fuc1(int n){ this_thread::sleep_for(chrono::seconds(3)); cout \u0026lt;\u0026lt; \u0026#34;fuc1() n = \u0026#34; \u0026lt;\u0026lt; n * a \u0026lt;\u0026lt; endl; } static void fuc2(int n){ cout \u0026lt;\u0026lt; \u0026#34;static fuc2() n = \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } private: int a; }; int main() { Test t(5); thread t1(\u0026amp;Test::fuc1, \u0026amp;t, 10); cout \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; endl; t1.join(); //t1.detach(); // 主线程销后，t1 这个等待线程也会被销毁（没有执行fuc1函数的输出）  thread t2(\u0026amp;Test::fuc2, 100); cout \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; endl; t2.join(); cout \u0026lt;\u0026lt; \u0026#34;main thread id: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 140270821496576 140270813103872 static fuc2() n = 100 main thread id: 140270844794624 0 Finish 6、异常情况下等待线程完成 为了避免主线程出现异常时将子线程终结，就要保证子线程在函数退出前完成，即在函数退出前调用 join()\n 方法一：异常捕获  void func() { thread t([]{ cout \u0026lt;\u0026lt; \u0026#34;hello C++ 11\u0026#34; \u0026lt;\u0026lt; endl; }); try { do_something_else(); } catch (...) { t.join(); throw; } t.join(); }  方法二：资源获取即初始化（RAII）  无论是何种情况，当函数退出时，对象 guard 调用其析构函数销毁，从而能够保证 join 一定会被调用\nclass thread_guard { private: thread \u0026amp;t; public: /*加入explicit防止隐式转换*/ explicit thread_guard(thread\u0026amp; _t) { t = _t; } thread_guard(const thread_guard\u0026amp;) = delete; //删除默认拷贝构造函数  thread_guard\u0026amp; operator=(const thread_guard\u0026amp;) = delete; //删除默认赋值运算符  ~thread_guard() { if (t.joinable()) t.join(); } }; void func(){ thread t([]{ cout \u0026lt;\u0026lt; \u0026#34;Hello thread\u0026#34; \u0026lt;\u0026lt;endl ; }); thread_guard guard(t); } ","permalink":"https://874656645.github.io/rick/posts/61-c++-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","summary":"一、进程与线程  进程是资源分配和调度的一个独立单位；而线程是进程的一个实体，是 CPU 调度和分配的基本单位 同一个进程中的多个线程的内存资源是共享的，各线程都可以改变进程中的变量。因此在执行多线程运算的时候要注意执行顺序  二、并行与并发  并行（parallellism）指的是多个任务在同一时刻同时在执行 并发（concurrency）是指在一个时间段内，多个任务交替进行。虽然看起来像在同时执行，但其实是交替的  三、多任务处理 多线程是多任务处理的一种特殊形式，一般情况下，有基于进程和基于线程的两种类型的多任务处理方式。\n 基于进程的多任务处理是程序的并发执行 基于线程的多任务处理是同一程序的片段的并发执行  四、C++11 线程管理 thread 库  C++11 提供了多线程库，使用时需要 #include \u0026lt;thread\u0026gt; 头文件，该头文件主要包含了对线程的管理类 std::thread 以及其他管理线程相关的类 每个应用程序至少有一个进程，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个子线程。每个线程都需要一个入口函数，入口函数返回退出，该线程也会退出，主线程就是以 main 函数作为入口函数的线程 主线程退出后，运行中的子线程也会被销毁 std::thread 的构造函数需要的是可调用（callable）类型，除了函数外，还可以调用 lambda 表达式、重载了 () 运算符的类的实例 把函数对象传入 std::thread 时，应传入函数名称（不带括号） 当启动一个线程后，一定要在该线程 thread 销毁前，调用 join() 或者 detach()，确定以何种方式等待线程执行结束  detach 方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束 join 方式，等待关联的线程完成，才会继续执行 join() 后的代码 在以 detach 的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用按值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束    1、调用全局函数启动线程 #include \u0026lt;thread\u0026gt; using namespace std; void func(int i){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } int main() { for(int i = 0; i \u0026lt; 4; ++i){ // 创建一个线程t，第一个参数为调用的函数，第二个参数为传递的参数  thread t(func, i); // 表示允许该线程在后台运行  t.","title":"C++ 多线程"},{"content":"error: cannot bind non-const lvalue reference of type ‘T\u0026amp;’ to an rvalue of type ‘T’\n如果一个参数是以非 const 引用传入，c++ 编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。\n但如果你 把一个临时变量当作非 const 引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉。\n所以，修改一个临时变量是毫无意义的。据此，c++ 编译器加入了临时变量不能作为非 const 引用的这个语义限制。\nc++ 中临时变量是右值类型，不能取引用，只能在当前行使用，不能作为非 const 的引用参数\nstd::move() 返回的也是一个右值\n对于临时变量或字面量的右值引用可以使用 cosnt \u0026amp; 或 \u0026amp;\u0026amp; 类型的参数接收\n一般来说，右值的地址不能通过解引用来获得，因为它们是字面量，或者因为它们本质上是临时的(例如由函数或显式构造函数调用返回的值)。通过将一个对象传递给这个函数，可以获得一个引用它的右值。\nclass T{ public: T(int v){ a = v; } T operator+(T \u0026amp;t){ T temp = this-\u0026gt;a + t.a; return temp; } void printT(T \u0026amp;t){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; t.a \u0026lt;\u0026lt; endl; } // 方式一  void printT(const T \u0026amp;t){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; t.a \u0026lt;\u0026lt; endl; } // 方式二 C++11 以后添加的右值引用新特性  void printT(T \u0026amp;\u0026amp;t){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; t.a \u0026lt;\u0026lt; endl; } private: int a; }; int main() { T t0(0), t1(1), t2(2); t0.printT(t1 + t2); // t1 + t2 返回临时变量 右值  return 0; } 输出：\nmain.cpp:29:18: error: cannot bind non-const lvalue reference of type ‘T\u0026amp;’ to an rvalue of type ‘T’ 29 | t0.printT(t1 + t2); | ~~~^~~~ main.cpp:20:20: note: initializing argument 1 of ‘void T::printT(T\u0026amp;)’ 20 | void printT(T \u0026amp;t){ | ~~~^ ","permalink":"https://874656645.github.io/rick/posts/60-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BAno-const%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0/","summary":"error: cannot bind non-const lvalue reference of type ‘T\u0026amp;’ to an rvalue of type ‘T’\n如果一个参数是以非 const 引用传入，c++ 编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。\n但如果你 把一个临时变量当作非 const 引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉。\n所以，修改一个临时变量是毫无意义的。据此，c++ 编译器加入了临时变量不能作为非 const 引用的这个语义限制。\nc++ 中临时变量是右值类型，不能取引用，只能在当前行使用，不能作为非 const 的引用参数\nstd::move() 返回的也是一个右值\n对于临时变量或字面量的右值引用可以使用 cosnt \u0026amp; 或 \u0026amp;\u0026amp; 类型的参数接收\n一般来说，右值的地址不能通过解引用来获得，因为它们是字面量，或者因为它们本质上是临时的(例如由函数或显式构造函数调用返回的值)。通过将一个对象传递给这个函数，可以获得一个引用它的右值。\nclass T{ public: T(int v){ a = v; } T operator+(T \u0026amp;t){ T temp = this-\u0026gt;a + t.a; return temp; } void printT(T \u0026amp;t){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; t.","title":"临时变量不能绑定 no-const 左值引用类型"},{"content":"#include \u0026lt;iostream\u0026gt; using namespace std; class Complex{ // friend Complex complexAdd(Complex \u0026amp;c1, Complex \u0026amp;c2);  // friend Complex operator+(Complex \u0026amp;c1, Complex \u0026amp;c2);  // friend Complex\u0026amp; operator+= (Complex \u0026amp;c1, Complex \u0026amp;c2);  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Complex \u0026amp;c); friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, Complex \u0026amp;c); public: Complex(){ cout \u0026lt;\u0026lt; \u0026#34;Complex()...\u0026#34; \u0026lt;\u0026lt; endl; a = 0; b = 0; } Complex(int a, int b){ cout \u0026lt;\u0026lt; \u0026#34;Complex(int, int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; this-\u0026gt;b = b; } ~Complex(){ cout \u0026lt;\u0026lt; \u0026#34;~Complex()...\u0026#34; \u0026lt;\u0026lt; endl; } void printComplex(){ cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;b \u0026lt;\u0026lt; \u0026#34;i)\u0026#34; \u0026lt;\u0026lt; endl; } // 方式二：在类内部实现（方式一和二是一样的，所以只能保留一种）  // c1 + c2 的写法会同时匹配这两种实现方式，如果都有实现就会产生二义性  // 不能返回引用类型  // + 操作符重载  Complex operator+(Complex \u0026amp;c2){ Complex temp(this-\u0026gt;a + c2.a, this-\u0026gt;b + c2.b); return temp; } // += 操作符重载  Complex\u0026amp; operator+=(Complex \u0026amp;c2){ cout \u0026lt;\u0026lt; \u0026#34;operator+=()...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a += c2.a; this-\u0026gt;b += c2.b; return *this; } // 单目运算符 前++，因为可以进行连续前++操作，所以返回引用类型  Complex\u0026amp; operator++(){ this-\u0026gt;a++; this-\u0026gt;b++; return *this; } // 单目运算符 后++，不能进行连续 后++ 操作，返回类型加const  // 为了与 前++ 进行区分，使用亚元形参  const Complex operator++(int){ Complex temp(this-\u0026gt;a, this-\u0026gt;b); this-\u0026gt;a++; this-\u0026gt;b++; return temp; } // = 操作符重载  Complex\u0026amp; operator=(Complex \u0026amp;c){ // 1、是否与自身相同  if(this == \u0026amp;c) return *this; // 2、如果自身有开辟内存，就清理自己的垃圾  // 3、深拷贝  this-\u0026gt;a = c.a; this-\u0026gt;b = c.b; return *this; } // [] 操作符重载  int\u0026amp; operator[](int index){ if(index == 1){ return this-\u0026gt;a; } if(index == 2){ return this-\u0026gt;b; } throw \u0026#34;error index\u0026#34;; } // == 操作符重载  bool operator==(Complex \u0026amp;c){ return (this-\u0026gt;a == c.a \u0026amp;\u0026amp; this-\u0026gt;b == c.b); } // != 操作符重载  bool operator!=(Complex \u0026amp;c){ return !(*this == c); } // () 操作符重载，仿函数  bool operator()(){ return (this-\u0026gt;a != 0 \u0026amp;\u0026amp; this-\u0026gt;b != 0); } // new 操作符重载，会传入所创对象的大小（sizeof(Complex)）  // 返回的是 void* 的指针  // p-\u0026gt;operator new(sizeof(Complex))  void* operator new(size_t n){ void* p = malloc(n); cout \u0026lt;\u0026lt; \u0026#34;重载了 new... 空间大小是：\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\t指针地址是：\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return p; } // new[] 操作符重载，这个 n 多了一个指针的大小，不知道为什么？  void* operator new[](size_t n){ void* p = malloc(n); cout \u0026lt;\u0026lt; \u0026#34;重载了 new[]... 空间大小是：\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\t指针地址是：\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return p; } // delete 操作符重载，会传入所要删除的指针，类型是 void*  void operator delete(void *p){ cout \u0026lt;\u0026lt; \u0026#34;重载了 delete... 指针地址是：\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; if(p != NULL){ free((Complex*)p); // 应该也可以不用强转，在 malloc 时会管理一张程序内存分配表，里面有分配指针所对应的大小  p = NULL; } } // delete[] 操作符重载，会传入所要删除的指针，类型是 void*  void operator delete(void *p){ cout \u0026lt;\u0026lt; \u0026#34;重载了 delete[]... 指针地址是：\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; if(p != NULL){ free(p); p = NULL; } } // \u0026amp;\u0026amp; 操作符重载（不建议重载，因为不会发生短路现象）  bool operator\u0026amp;\u0026amp;(Complex \u0026amp;c){ return ((*this)()) \u0026amp;\u0026amp; c(); } // || 操作符重载（不建议重载，因为不会发生短路现象）  bool operator||(Complex \u0026amp;c){ return (*this)() || c(); } private: int a; // 实部  int b; // 虚部 }; #if 0Complex complexAdd(Complex \u0026amp;c1, Complex \u0026amp;c2){ Complex temp(c1.a + c2.a, c1.b + c2.b); return temp; } // 方式一：用全局函数重载(友元重载) Complex operator+(Complex \u0026amp;c1, Complex \u0026amp;c2){ Complex temp(c1.a + c2.a, c1.b + c2.b); return temp; } Complex\u0026amp; operator+= (Complex \u0026amp;c1, Complex \u0026amp;c2){ c1.a += c2.a; c1.b += c2.b; return c1; } #endif // 左移 // 只能用全局函数实现重载，如果在类内部实现，调用形式就成了 c.operator\u0026lt;\u0026lt;(cout) // 因为可以连续调用，所以返回 ostream 对象引用 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Complex \u0026amp;c){ os \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; c.a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; c.b \u0026lt;\u0026lt; \u0026#34;i)\u0026#34; \u0026lt;\u0026lt; endl; return os; } // 右移同理 istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, Complex \u0026amp;c){ cout \u0026lt;\u0026lt; \u0026#34;a: \u0026#34;; is \u0026gt;\u0026gt; c.a; cout \u0026lt;\u0026lt; \u0026#34;b: \u0026#34;; is \u0026gt;\u0026gt; c.b; return is; } int main( ) { Complex c1(1, 2), c2(3, 4); c1.printComplex(); c2.printComplex(); // Complex c3 = complexAdd(c1, c2);  Complex c3 = c1 + c2 + c1; // 方式一等同于 operator+(c1, c2);  // 方式二等同于 c1.operator+(c2);  c3.printComplex(); cin \u0026gt;\u0026gt; c1; // operator\u0026gt;\u0026gt;(cin, c1)  cout \u0026lt;\u0026lt; c1 \u0026lt;\u0026lt; endl; // operator\u0026lt;\u0026lt;(cout, c1)  cout \u0026lt;\u0026lt; c1[1] \u0026lt;\u0026lt; endl; c1[1] = 5; cout \u0026lt;\u0026lt; c1; try{ c1[0] = 0; } catch(char const *e){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; } if(c1()){ cout \u0026lt;\u0026lt; \u0026#34;c1 is valid\u0026#34; \u0026lt;\u0026lt; endl; } else{ cout \u0026lt;\u0026lt; \u0026#34;c1 is not valid\u0026#34; \u0026lt;\u0026lt; endl; } // 测试数组  cout \u0026lt;\u0026lt; \u0026#34;静态数组大小是：\u0026#34; \u0026lt;\u0026lt; sizeof(Complex[2]) \u0026lt;\u0026lt; endl; Complex *cArray = new Complex[2]; // 这里的地址比 delete[] 的地址高了一个字节，不知道为什么？  cout \u0026lt;\u0026lt; \u0026#34;首地址是：\u0026#34; \u0026lt;\u0026lt; (cArray - sizeof(char)) \u0026lt;\u0026lt; endl; delete[] cArray; // 测试 \u0026amp;\u0026amp; || 是否发生短路  c1[1] = c1[2] = 0; if(c1 \u0026amp;\u0026amp; (c1 += c2)){ // c1.operator\u0026amp;\u0026amp;(c1 += c2)  cout \u0026lt;\u0026lt; \u0026#34;真\u0026#34; \u0026lt;\u0026lt; endl; } else{ cout \u0026lt;\u0026lt; \u0026#34;假\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;============\u0026#34; \u0026lt;\u0026lt; endl; c1[1] = -3; c2[2] = -4; if(c1 || (c1 += c2)){ // c1.operator||(c1 += c2)  cout \u0026lt;\u0026lt; \u0026#34;真\u0026#34; \u0026lt;\u0026lt; endl; } else{ cout \u0026lt;\u0026lt; \u0026#34;假\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输出：\n(1, 2i) (3, 4i) (5, 8i) a: 10 b: 20 (10, 20i) 1 (5, 2i) error index c1 is valid 重载了 new... 空间大小是：8 Complex(int, int)... 对象 c1 的地址是：0x5641c235a2c0 ~Complex()... 重载了 delete... 指针地址是：0x5641c235a2c0 静态数组大小是：16 重载了 new[]... 空间大小是：24 指针地址是：0x5640c52efeb0 Complex()... Complex()... 首地址是：0x5640c52efeb8 ~Complex()... ~Complex()... 重载了 delete[]... 指针地址是：0x5640c52efeb0 operator+=()... 真 ============ operator+=()... 假 ","permalink":"https://874656645.github.io/rick/posts/59-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/","summary":"#include \u0026lt;iostream\u0026gt; using namespace std; class Complex{ // friend Complex complexAdd(Complex \u0026amp;c1, Complex \u0026amp;c2);  // friend Complex operator+(Complex \u0026amp;c1, Complex \u0026amp;c2);  // friend Complex\u0026amp; operator+= (Complex \u0026amp;c1, Complex \u0026amp;c2);  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Complex \u0026amp;c); friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, Complex \u0026amp;c); public: Complex(){ cout \u0026lt;\u0026lt; \u0026#34;Complex()...\u0026#34; \u0026lt;\u0026lt; endl; a = 0; b = 0; } Complex(int a, int b){ cout \u0026lt;\u0026lt; \u0026#34;Complex(int, int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; this-\u0026gt;b = b; } ~Complex(){ cout \u0026lt;\u0026lt; \u0026#34;~Complex().","title":"操作符重载"},{"content":"买卖货物问题：\n#include \u0026lt;iostream\u0026gt; using namespace std; class Goods{ public: Goods(){ m_pNext = nullptr; m_weight = 0; cout \u0026lt;\u0026lt; \u0026#34;买入了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } Goods(int weight){ m_pNext = nullptr; m_weight = weight; total_weight += m_weight; cout \u0026lt;\u0026lt; \u0026#34;买入了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } ~Goods(){ total_weight -= m_weight; // m_pNext 不是在本类中 new 的，所以也不用 delete  this-\u0026gt;m_pNext = nullptr; cout \u0026lt;\u0026lt; \u0026#34;卖出了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } static int getTotalWeight(){ return total_weight; } Goods *m_pNext; private: int m_weight; static int total_weight; }; int Goods::total_weight = 0; void buy(Goods *\u0026amp;head, int weight){ Goods *pNewGoods = new Goods(weight); if(head == nullptr){ head = pNewGoods; } else{ pNewGoods-\u0026gt;m_pNext = head; head = pNewGoods; } } void sale(Goods *\u0026amp;head){ if(head == nullptr){ cout \u0026lt;\u0026lt; \u0026#34;没有货物了\u0026#34; \u0026lt;\u0026lt; endl; return; } Goods *temp = head; head = head-\u0026gt;m_pNext; delete temp; temp = nullptr; } int main( ) { Goods *head = nullptr; int choice; do{ // 提供菜单  cout \u0026lt;\u0026lt; \u0026#34;输入 1 进货\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 2 出货\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 0 退出\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; choice; switch(choice){ case 0: // 退出  return 0; case 1: { // 进货  int w = 0; cout \u0026lt;\u0026lt; \u0026#34;输入货物重量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; w; buy(head, w); break; } case 2: // 出货  sale(head); break; } cout \u0026lt;\u0026lt; \u0026#34;目前货物的总重量是：\u0026#34; \u0026lt;\u0026lt; Goods::getTotalWeight() \u0026lt;\u0026lt; endl; }while(1); return 0; } 输出：\n输入 1 进货 输入 2 出货 输入 0 退出 1 输入货物重量： 10 买入了货物，重量是：10 目前货物的总重量是：10 输入 1 进货 输入 2 出货 输入 0 退出 1 输入货物重量： 20 买入了货物，重量是：20 目前货物的总重量是：30 输入 1 进货 输入 2 出货 输入 0 退出 1 输入货物重量： 30 买入了货物，重量是：30 目前货物的总重量是：60 输入 1 进货 输入 2 出货 输入 0 退出 2 卖出了货物，重量是：30 目前货物的总重量是：30 输入 1 进货 输入 2 出货 输入 0 退出 2 卖出了货物，重量是：20 目前货物的总重量是：10 输入 1 进货 输入 2 出货 输入 0 退出 2 卖出了货物，重量是：10 目前货物的总重量是：0 输入 1 进货 输入 2 出货 输入 0 退出 2 没有货物了 目前货物的总重量是：0 输入 1 进货 输入 2 出货 输入 0 退出 0 ","permalink":"https://874656645.github.io/rick/posts/58-%E5%85%B7%E6%9C%89%E9%93%BE%E8%A1%A8%E7%89%B9%E6%80%A7%E7%9A%84%E7%B1%BB/","summary":"买卖货物问题：\n#include \u0026lt;iostream\u0026gt; using namespace std; class Goods{ public: Goods(){ m_pNext = nullptr; m_weight = 0; cout \u0026lt;\u0026lt; \u0026#34;买入了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } Goods(int weight){ m_pNext = nullptr; m_weight = weight; total_weight += m_weight; cout \u0026lt;\u0026lt; \u0026#34;买入了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } ~Goods(){ total_weight -= m_weight; // m_pNext 不是在本类中 new 的，所以也不用 delete  this-\u0026gt;m_pNext = nullptr; cout \u0026lt;\u0026lt; \u0026#34;卖出了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } static int getTotalWeight(){ return total_weight; } Goods *m_pNext; private: int m_weight; static int total_weight; }; int Goods::total_weight = 0; void buy(Goods *\u0026amp;head, int weight){ Goods *pNewGoods = new Goods(weight); if(head == nullptr){ head = pNewGoods; } else{ pNewGoods-\u0026gt;m_pNext = head; head = pNewGoods; } } void sale(Goods *\u0026amp;head){ if(head == nullptr){ cout \u0026lt;\u0026lt; \u0026#34;没有货物了\u0026#34; \u0026lt;\u0026lt; endl; return; } Goods *temp = head; head = head-\u0026gt;m_pNext; delete temp; temp = nullptr; } int main( ) { Goods *head = nullptr; int choice; do{ // 提供菜单  cout \u0026lt;\u0026lt; \u0026#34;输入 1 进货\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 2 出货\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 0 退出\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; choice; switch(choice){ case 0: // 退出  return 0; case 1: { // 进货  int w = 0; cout \u0026lt;\u0026lt; \u0026#34;输入货物重量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; w; buy(head, w); break; } case 2: // 出货  sale(head); break; } cout \u0026lt;\u0026lt; \u0026#34;目前货物的总重量是：\u0026#34; \u0026lt;\u0026lt; Goods::getTotalWeight() \u0026lt;\u0026lt; endl; }while(1); return 0; } 输出：","title":"具有链表特性的类"},{"content":"1、六大组件介绍  容器：数据结构，用来存放数据 算法：常用算法 迭代器：容器和算法之间的胶合剂，“范型指针” 仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数 配置器：为容器分配并管理内存 适配器：修改其他组件接口  2、STL 常用的容器有哪些以及各自的特点是什么?    名称 特点     vector 底层数据结构为数组，支持快速随机访问   list 底层数据结构为双向链表，支持快速增删   deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问   stack 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   queue 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   priority_queue 底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现   set 底层数据结构为红黑树，有序，不重复   multiset 底层数据结构为红黑树，有序，可重复   map 底层数据结构为红黑树，有序，不重复   multimap 底层数据结构为红黑树，有序，可重复   unordered_set 底层数据结构为hash表，无序，不重复   unordered_multiset 底层数据结构为hash表，无序，可重复   unordered_map 底层数据结构为hash表，无序，不重复   unordered_multimap 底层数据结构为hash表，无序，可重复    3、vector 和 list 的区别  vector底层实现是数组，所以在内存中是连续存放的，随机读取效率高，但插入、删除效率低；list底层实现是双向链表，所以在内存中是任意存放的，插入、删除效率高，但访问元素效率低 vector在中间节点进行插入、删除会导致内存拷贝，而list不会 vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请  4、vector 扩容原理 以原内存空间大小的两倍配置一份新的内存空间，并将原空间数据拷贝过来进行初始化\n5、map 和 set 有什么区别  map中的元素是键值对；Set仅是关键字的简单集合 set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key map支持用关键字作下标操作，set不支持下标操作  6、map 和 unordered_map 的区别  map内部实现了一个红黑树，红黑树的每一个节点都代表着map的一个元素，因此所有元素都是有序的，对其进行查找、插入、删除得效率都是O(log n)；但是，因为每个结点都需要额外保存数据，所以空间占用率比较高 unordered_map内部实现了一个哈希表，因此内部元素是无序的，对其进行查找、插入、删除得效率都是O(1)；但是建立哈希表比较费时  7、STL 中迭代器的作用，有指针为何还要迭代器  Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-\u0026gt;、*、++、\u0026ndash;等，相当于一种智能指针 迭代器产生原因：Iterator采用的是面向对象的思想，把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果  ","permalink":"https://874656645.github.io/rick/posts/56-stl-%E6%80%BB%E7%BB%93/","summary":"1、六大组件介绍  容器：数据结构，用来存放数据 算法：常用算法 迭代器：容器和算法之间的胶合剂，“范型指针” 仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数 配置器：为容器分配并管理内存 适配器：修改其他组件接口  2、STL 常用的容器有哪些以及各自的特点是什么?    名称 特点     vector 底层数据结构为数组，支持快速随机访问   list 底层数据结构为双向链表，支持快速增删   deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问   stack 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   queue 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   priority_queue 底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现   set 底层数据结构为红黑树，有序，不重复   multiset 底层数据结构为红黑树，有序，可重复   map 底层数据结构为红黑树，有序，不重复   multimap 底层数据结构为红黑树，有序，可重复   unordered_set 底层数据结构为hash表，无序，不重复   unordered_multiset 底层数据结构为hash表，无序，可重复   unordered_map 底层数据结构为hash表，无序，不重复   unordered_multimap 底层数据结构为hash表，无序，可重复    3、vector 和 list 的区别  vector底层实现是数组，所以在内存中是连续存放的，随机读取效率高，但插入、删除效率低；list底层实现是双向链表，所以在内存中是任意存放的，插入、删除效率高，但访问元素效率低 vector在中间节点进行插入、删除会导致内存拷贝，而list不会 vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请  4、vector 扩容原理 以原内存空间大小的两倍配置一份新的内存空间，并将原空间数据拷贝过来进行初始化","title":"STL 总结"},{"content":"vector 常用操作 #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; int main() { //1.定义和初始化  vector\u0026lt;int\u0026gt; vec1; //默认初始化，vec1为空  vector\u0026lt;int\u0026gt; vec2(vec1); //使用vec1初始化vec2  vector\u0026lt;int\u0026gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2  vector\u0026lt;int\u0026gt; vec4(10); //10个值为0的元素  vector\u0026lt;int\u0026gt; vec5(10,4); //10个值为4的元素  //2.常用操作方法  //2.1 添加函数  vec1.push_back(100); // 尾部添加元素  vec1.insert(vec1.end(),5,3); // 从vec1.back位置插入5个值为3的元素  //2.2 删除函数  vec1.pop_back(); // 删除末尾元素  vec1.erase(vec1.begin(),vec1.begin()+2); // 删除vec1[0]-vec1[2]之间的元素，不包括vec1[2]其他元素前移  vec1.clear(); // 清空元素，元素在内存中并未消失，通常使用swap()来清空  vector\u0026lt;int\u0026gt;().swap(V); // 利用swap函数和临时对象交换内存，交换以后，临时对象消失，释放内存。  // 必须是同类型的 vector  // 且只有存储对象时才有效  //2.3 遍历函数  vec1[0]; //取得第一个元素  vec1.at(int pos); //返回pos位置元素的引用  vec1.front(); //返回首元素的引用  vec1.back(); //返回尾元素的引用  vector\u0026lt;int\u0026gt;::iterator begin= vec1.begin(); //返回向量头指针，指向第一个元素  vector\u0026lt;int\u0026gt;::iterator end= vec1.end(); //返回向量尾指针，指向向量最后一个元素的下一个位置  vector\u0026lt;int\u0026gt;::iterator rbegin= vec1.rbegin(); //反向迭代器，指向最后一个元素  vector\u0026lt;int\u0026gt;::iterator rend= vec1.rend(); //反向迭代器，指向第一个元素之前的位置  //2.4 判断函数  bool isEmpty = vec1.empty(); //判断是否为空  //2.5 大小函数  int size = vec1.size(); //元素个数  vec1.capacity(); //返回容器当前能够容纳的元素个数  vec1.max_size(); //返回容器最大的可能存储的元素个数  //2.6 改动函数  vec1.assign(int n,const T\u0026amp; x); //赋n个值为x的元素到vec1中，这会清除掉vec1中以前的内容。  vec1.assign(const_iterator first,const_iterator last); //当前向量中[first,last)中元素设置成迭代器所指向量的元素，这会清除掉vec1中以前的内容。 } ","permalink":"https://874656645.github.io/rick/posts/55-vector/","summary":"vector 常用操作 #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; int main() { //1.定义和初始化  vector\u0026lt;int\u0026gt; vec1; //默认初始化，vec1为空  vector\u0026lt;int\u0026gt; vec2(vec1); //使用vec1初始化vec2  vector\u0026lt;int\u0026gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2  vector\u0026lt;int\u0026gt; vec4(10); //10个值为0的元素  vector\u0026lt;int\u0026gt; vec5(10,4); //10个值为4的元素  //2.常用操作方法  //2.1 添加函数  vec1.push_back(100); // 尾部添加元素  vec1.insert(vec1.end(),5,3); // 从vec1.back位置插入5个值为3的元素  //2.2 删除函数  vec1.pop_back(); // 删除末尾元素  vec1.erase(vec1.begin(),vec1.begin()+2); // 删除vec1[0]-vec1[2]之间的元素，不包括vec1[2]其他元素前移  vec1.clear(); // 清空元素，元素在内存中并未消失，通常使用swap()来清空  vector\u0026lt;int\u0026gt;().swap(V); // 利用swap函数和临时对象交换内存，交换以后，临时对象消失，释放内存。  // 必须是同类型的 vector  // 且只有存储对象时才有效  //2.3 遍历函数  vec1[0]; //取得第一个元素  vec1.","title":"vector"},{"content":"STL六大组件\nSTL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。STL中包括六大组件：容器、算法、迭代器、适配器、仿函数、空间配置器\n适配器：适配器是一种设计模式(设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结)，该中模式是将一个类的接口转换成客户希望的另外一个接口。\n一、容器 序列式容器（vector、deque、list）、关联式容器（map、set）、容器适配器（stack、queue、priority_queue）\n1. vector 是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。由于具有连续的存储空间，所以在插入和删除操作方面，效率比较慢\n2. deque deque 是 double ended queue 的缩写，双向队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。与 vector 不同，deque 不能保证将所有元素存储在连续的存储空间上\n3. list list 是 STL 实现的双向链表，与 vector 相比, 它允许快速的插入和删除，但是随机访问却比较慢\n4. map、multimap、unordered_map、unordered_multimap  map 是 STL 的一个关联容器，它是一种键值对容器，里面的数据都是成对出现的，且键值是唯一的，可在我们处理一对一数据的时候，在编程上提供快速通道。map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。 multimap 中的元素也是有序的，但允许存在相同键值的 unordered_map 中的元素是唯一的，但无序（也不是插入顺序），而是根据它们的散列值（hash values）组织成桶（buckets），从而允许通过键值直接快速访问单个元素（速度一般比 map 更快） unordered_multimap 无序且不唯一  5. set、multiset、unordered_set、unordered_multiset  set 的含义是集合，它是一个有序的容器，里面的元素都是唯一且排序好的，支持插入、删除、查找等操作，就像一个集合一样，所有的操作都是严格在 logn时间内完成，效率非常高，使用方法类似 list multiset 也是排序好的，但是可以存有相同的元素 unordered_set 无序但元素是不可重复的 unordered_multiset 无序，元素也不唯一  二、容器适配器 虽然 stack、queue、priority_queue 中也可以存放元素，但在 STL 中并没有将其划分在容器的行列，而是将其称为容器适配器，这是因为每个容器在底层都有自己的实现方式，而 stack、queue、priority_queue 只是在底层将其他容器进行了封装\nstd::stack template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class stack; std::queue template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class queue; std::priority_queue template\u0026lt;class T, class Container = vector\u0026lt;T\u0026gt;, class Compare = less\u0026lt;typename Container::value_type\u0026gt;\u0026gt; class priority_queue; 为什么选择 deque 作为 stack 和 queue 的底层默认容器？\nstack 是后进先出的特殊线性数据结构，只要具有 push_back() 和 pop_back() 操作的线性结构，都可以作为 stack 的底层容器，比如 vector 和 list 都可以；\nqueue 是先进先出的特殊线性数据结构，只要具有 push_back() 和 pop_front() 操作的线性结构，都可以作为 queue 的底层容器，比如 list。\n但是 STL 中对 stack 和 queue 默认选择 deque 作为其底层容器，主要是因为：\n stack 和 queue 不需要遍历(因此 stack 和 queue 没有迭代器)，只需要在固定的一端或者两端进行操作。 在 stack 中元素增长时，deque 比 vector 的效率高。 在 queue 中的元素增长时，deque 不仅效率高，而且内存使用率高  三、算法  十大经典算法  ","permalink":"https://874656645.github.io/rick/posts/54-c++-stl/","summary":"STL六大组件\nSTL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。STL中包括六大组件：容器、算法、迭代器、适配器、仿函数、空间配置器\n适配器：适配器是一种设计模式(设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结)，该中模式是将一个类的接口转换成客户希望的另外一个接口。\n一、容器 序列式容器（vector、deque、list）、关联式容器（map、set）、容器适配器（stack、queue、priority_queue）\n1. vector 是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。由于具有连续的存储空间，所以在插入和删除操作方面，效率比较慢\n2. deque deque 是 double ended queue 的缩写，双向队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。与 vector 不同，deque 不能保证将所有元素存储在连续的存储空间上\n3. list list 是 STL 实现的双向链表，与 vector 相比, 它允许快速的插入和删除，但是随机访问却比较慢\n4. map、multimap、unordered_map、unordered_multimap  map 是 STL 的一个关联容器，它是一种键值对容器，里面的数据都是成对出现的，且键值是唯一的，可在我们处理一对一数据的时候，在编程上提供快速通道。map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。 multimap 中的元素也是有序的，但允许存在相同键值的 unordered_map 中的元素是唯一的，但无序（也不是插入顺序），而是根据它们的散列值（hash values）组织成桶（buckets），从而允许通过键值直接快速访问单个元素（速度一般比 map 更快） unordered_multimap 无序且不唯一  5. set、multiset、unordered_set、unordered_multiset  set 的含义是集合，它是一个有序的容器，里面的元素都是唯一且排序好的，支持插入、删除、查找等操作，就像一个集合一样，所有的操作都是严格在 logn时间内完成，效率非常高，使用方法类似 list multiset 也是排序好的，但是可以存有相同的元素 unordered_set 无序但元素是不可重复的 unordered_multiset 无序，元素也不唯一  二、容器适配器 虽然 stack、queue、priority_queue 中也可以存放元素，但在 STL 中并没有将其划分在容器的行列，而是将其称为容器适配器，这是因为每个容器在底层都有自己的实现方式，而 stack、queue、priority_queue 只是在底层将其他容器进行了封装\nstd::stack template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class stack; std::queue template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class queue; std::priority_queue template\u0026lt;class T, class Container = vector\u0026lt;T\u0026gt;, class Compare = less\u0026lt;typename Container::value_type\u0026gt;\u0026gt; class priority_queue; 为什么选择 deque 作为 stack 和 queue 的底层默认容器？","title":"C++ STL"},{"content":"C++ 中 new 操作符内幕：new operator、operator new、placement new \n1、new / delete 具体步骤 new\n 第一步：调用 operator new 函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值 第三部：对象构造完成后，返回一个指向该对象的指针  delete\n 第一步：调用对象的析构函数 第二步：编译器调用 operator delete 函数释放内存空间  2、new/delete 与 malloc/free 的区别是什么？  malloc/free 是 C 语言的标准库函数， new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存 malloc/free 不会去自动调用构造和析构函数，对于基本数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求 malloc/free 需要指定分配内存的大小，而 new/delete 会自动计算所需内存大小 new 返回的是指定对象的指针，而 malloc 返回的是 void*，因此 malloc 的返回值一般都需要进行强制类型转换  operator new 重载：\nclass Person{ public: Person(){ id = 0; score = 0; cout \u0026lt;\u0026lt; \u0026#34;Person()\u0026#34; \u0026lt;\u0026lt; endl; } Person(int id, int score):id(id),score(score){ cout \u0026lt;\u0026lt; \u0026#34;Person(int, int)\u0026#34; \u0026lt;\u0026lt; endl; } Person(const Person \u0026amp;p){ cout \u0026lt;\u0026lt; \u0026#34;Person(const Person \u0026amp;p)\u0026#34; \u0026lt;\u0026lt; endl; id = p.id; score = p.score; } // operator new  void* operator new(size_t s){ cout \u0026lt;\u0026lt; \u0026#34;new 1\u0026#34; \u0026lt;\u0026lt; endl; void* p = malloc(s); return p; } // placement new  void* operator new(size_t s, void* p){ cout \u0026lt;\u0026lt; \u0026#34;new 2\u0026#34; \u0026lt;\u0026lt; endl; return p; } int id; int score; }; int main() { void* p = malloc(sizeof(Person)); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; Person* pp = new (p) Person(10, 20); cout \u0026lt;\u0026lt; pp \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pp-\u0026gt;id \u0026lt;\u0026lt; endl; Person* myP = new Person; return 0; } 输出：\n0x55b01ec9aeb0 new 2 Person(int, int) 0x55b01ec9aeb0 10 new 1 Person() 3、C++内存管理 在 C++ 中，虚拟内存分为代码段、数据段、BSS段、堆区、栈区以及文件映射区六部分\n 代码段：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码 数据段：存储程序中已初始化的全局变量和静态变量 BSS段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量（这个段的数据全都是0） 堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存 映射区：存储动态链接库以及调用mmap函数进行的文件映射 栈区：使用栈空间存储函数的返回地址、参数、局部变量、返回值（最靠近CPU的区）  4、内存的分配方式（三种）   静态存储区分配：是在程序编译时就已经分配好的，在整个运行期间都存在，如全局变量、常量、静态变量\n  栈上分配：函数内的局部变量就是从这分配的，但分配的内存容易有限\n  堆上分配：也称动态分配，如我们用 new,malloc 分配内存，用 delete,free 来释放的内存。堆内存空间可由用户手动分配和释放，所以其生存周期由用户指定，较为灵活。但频繁的分配、释放大小不同的堆空间会产生内存碎片\n  5、内存池 内存池是一种内存分配方式。通常我们习惯直接使用new、malloc申请内存，这样做的缺点在于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，预先申请分配一定数量、大小相等（一般情况下）的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是，使得内存分配效率得到提升\n6、内存泄漏 内存泄漏一般是指堆内存的泄漏，也就是程序在运行过程中动态申请的内存空间不再使用后没有及时释放，导致那块内存不能被再次使用\n7、C++中的不安全是什么概念？ C++中的不安全包括两种：一是程序得不到正确的结果，二是发生不可预知的错误（占用了不该用的内存空间）。可能会发生如下问题：\n 最严重的：内存泄漏，程序崩溃； 一般严重的：发生一些逻辑错误，且不便于调试； 较轻的：丢失部分数据，就像强制转换一样  8、内存中的堆与栈有什么区别？  申请方式：栈由系统自动分配和管理，堆由程序员手动分配和管理 效率：栈由系统分配，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行，因此，其速度快，不会有内存碎片；堆由程序员分配，堆是由C/C++函数库提供的，机制复杂，需要一系列分配内存、合并内存和释放内存的算法，因此效率较低，可能由于操作不当产生内存碎片 扩展方向：栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展 程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间；同时，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间  ","permalink":"https://874656645.github.io/rick/posts/53-new-delete-%E4%B8%8E%E5%86%85%E5%AD%98/","summary":"C++ 中 new 操作符内幕：new operator、operator new、placement new \n1、new / delete 具体步骤 new\n 第一步：调用 operator new 函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值 第三部：对象构造完成后，返回一个指向该对象的指针  delete\n 第一步：调用对象的析构函数 第二步：编译器调用 operator delete 函数释放内存空间  2、new/delete 与 malloc/free 的区别是什么？  malloc/free 是 C 语言的标准库函数， new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存 malloc/free 不会去自动调用构造和析构函数，对于基本数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求 malloc/free 需要指定分配内存的大小，而 new/delete 会自动计算所需内存大小 new 返回的是指定对象的指针，而 malloc 返回的是 void*，因此 malloc 的返回值一般都需要进行强制类型转换  operator new 重载：\nclass Person{ public: Person(){ id = 0; score = 0; cout \u0026lt;\u0026lt; \u0026#34;Person()\u0026#34; \u0026lt;\u0026lt; endl; } Person(int id, int score):id(id),score(score){ cout \u0026lt;\u0026lt; \u0026#34;Person(int, int)\u0026#34; \u0026lt;\u0026lt; endl; } Person(const Person \u0026amp;p){ cout \u0026lt;\u0026lt; \u0026#34;Person(const Person \u0026amp;p)\u0026#34; \u0026lt;\u0026lt; endl; id = p.","title":"new delete 与内存"},{"content":"在堆上声明一个数组 int main( ) { #if 0// 方式一： int** pArr = NULL; pArr = new int*[4]; for(int i = 0; i \u0026lt; 4; i++){ pArr[i] = new int[8]; } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ if(j == 0) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pArr[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; } } // 删除 for(int i = 0; i \u0026lt; 4; ++i){ delete [] pArr[i]; } delete [] pArr; #endif  // 方式二：  cout \u0026lt;\u0026lt; sizeof(int[5]) \u0026lt;\u0026lt; endl; // 初始化  int(*pArr)[8] = new int[4][8]; memset(pArr, 0, sizeof(int[4][8])); // 或者  // int(*pArr)[8] = new int[4][8]{{0}};  cout \u0026lt;\u0026lt; sizeof(int[4][8]) \u0026lt;\u0026lt; endl; for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ cout \u0026lt;\u0026lt; pArr[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; } cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; delete[] pArr; // 取地址  int arr[3][4]{{0}}; int(*p)[3][4] = \u0026amp;arr; cout \u0026lt;\u0026lt; arr[2][3] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p[2][3] \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 0\t0\t0\t0\t0\t0\t0\t0\t0\t1\t2\t3\t4\t5\t6\t7\t0\t2\t4\t6\t8\t10\t12\t14\t0\t3\t6\t9\t12\t15\t18\t21\t0 Finish 在栈上声明一个数组 int main( ) { int a[3]; // 全部初始化为 0  int b[3]{4}; // 第一个值是 4，其余初始化为 0  int c[3] = {4}; // 同上  // new 一维数组  int* d = new int[3]{4}; // 同上  // 与 vector 不同  vector\u0026lt;int\u0026gt; v(3, 4);// 3 个值都是 4  return 0; } ","permalink":"https://874656645.github.io/rick/posts/52-new-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/","summary":"在堆上声明一个数组 int main( ) { #if 0// 方式一： int** pArr = NULL; pArr = new int*[4]; for(int i = 0; i \u0026lt; 4; i++){ pArr[i] = new int[8]; } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ if(j == 0) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pArr[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; } } // 删除 for(int i = 0; i \u0026lt; 4; ++i){ delete [] pArr[i]; } delete [] pArr; #endif  // 方式二：  cout \u0026lt;\u0026lt; sizeof(int[5]) \u0026lt;\u0026lt; endl; // 初始化  int(*pArr)[8] = new int[4][8]; memset(pArr, 0, sizeof(int[4][8])); // 或者  // int(*pArr)[8] = new int[4][8]{{0}};  cout \u0026lt;\u0026lt; sizeof(int[4][8]) \u0026lt;\u0026lt; endl; for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ cout \u0026lt;\u0026lt; pArr[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; } cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; delete[] pArr; // 取地址  int arr[3][4]{{0}}; int(*p)[3][4] = \u0026amp;arr; cout \u0026lt;\u0026lt; arr[2][3] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p[2][3] \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"new 二维数组"},{"content":"1. this指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用该成员函数的对象的首地址\n 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值 this 是个右值，所以不能取 this 的地址  2. delete this  类的成员函数中可以调用 delete this，但是在释放后，对象后续调用的方法不能再用到 this 指针 delete this 释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，此时其中的值是不确定的 delete 的本质是为将被释放的内存调用一个或多个析构函数，如果在类的析构函数中调用 delete this，会陷入无限递归，造成栈溢出  3. 一个空类class中有什么？ 构造函数、拷贝构造函数、析构函数、赋值运算符重载、取地址操作符重载、被 const 修饰的取地址操作符重载\n4. C++ 计算一个类的 sizeof  一个空的类 sizeof 返回 1，因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址 类内的普通成员函数不参与 sizeof 的统计，因为 sizeof 是针对实例的，而普通成员函数，是针对类体的 一个类如果含有虚函数，则这个类中有一个指向虚函数表的指针（虚函数指针），32位程序占4个字节，64位程序占8个字节 静态成员不影响类的大小，被编译器放在程序的数据段中 普通继承的类sizeof，会得到基类的大小加上派生类自身成员的大小 当存在虚拟继承时，派生类中会有一个指向虚基类表的指针。所以其大小应为普通继承的大小，再加上虚基类表的指针大小  5. 构造函数和析构函数能被继承吗? 不能。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么\n6. 构造函数能不能是虚函数？ 不能。虚函数对应一个虚函数表，可是这个虚函数表存储在对象的内存空间的。问题就在于，如果构造函数是虚的，就需要通过 虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，就不会有虚函数表\n7. 构造函数和析构函数能不能被重载？ 构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数。\n8. 构造函数调用顺序，析构函数调用顺序？ 基类的构造函数——\u0026gt;成员类对象的构造函数——\u0026gt;派生类的构造函数；\n析构函数相反：派生类析构——\u0026gt;成员类对象析构——\u0026gt;基类析构\n9. 构造函数和析构函数调用时机  全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数 局部自动对象：建立对象时调用构造函数，函数结束时调用析构函数 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数 静态局部变量对象：建立对象时调用构造函数，在主函数结束时调用析构函数  10. 拷贝构造函数中深拷贝和浅拷贝区别  深拷贝会先申请一块和拷贝数据一样大的内存空间，然后将数据逐字节拷贝过去，拷贝后两个指针指向不同的两个内存空间 浅拷贝仅是拷贝指针地址，拷贝后两个指针指向同一个内存空间\n当浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针，因为所指向的内存空间已经被释放了  11. 什么时候必须重写拷贝构造函数？ 当构造函数涉及到动态内存分配时，要自己写拷贝构造函数，并且要深拷贝\n12. 面向过程编程和面向对象编程的区别  面向过程：就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现（函数驱动） 面向对象：面向对象是一种对现实世界理解和抽象的方法，强调的是通过将需求要素转化为对象进行问题处理的一种思想（对象驱动）  13. 为什么内联函数，构造函数，静态成员函数不能为virtual函数？  内联函数：内联函数是在编译时期展开，而虚函数的特性是运行时才动态联编，所以两者矛盾，不能定义内联函数为虚函数 构造函数：构造函数用来创建一个新的对象，而虚函数的运行是建立在对象的基础上，在构造函数执行时，对象尚未形成，所以不能将构造函数定义为虚函数 静态成员函数：静态成员函数属于一个类而非某一对象，没有this指针，它无法进行对象的判别 友元函数：C++不支持友元函数的继承，对于没有继承性的函数没有虚函数  ","permalink":"https://874656645.github.io/rick/posts/51-%E7%B1%BB%E5%85%B6%E5%AE%83%E6%80%BB%E7%BB%93/","summary":"1. this指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用该成员函数的对象的首地址\n 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值 this 是个右值，所以不能取 this 的地址  2. delete this  类的成员函数中可以调用 delete this，但是在释放后，对象后续调用的方法不能再用到 this 指针 delete this 释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，此时其中的值是不确定的 delete 的本质是为将被释放的内存调用一个或多个析构函数，如果在类的析构函数中调用 delete this，会陷入无限递归，造成栈溢出  3. 一个空类class中有什么？ 构造函数、拷贝构造函数、析构函数、赋值运算符重载、取地址操作符重载、被 const 修饰的取地址操作符重载\n4. C++ 计算一个类的 sizeof  一个空的类 sizeof 返回 1，因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址 类内的普通成员函数不参与 sizeof 的统计，因为 sizeof 是针对实例的，而普通成员函数，是针对类体的 一个类如果含有虚函数，则这个类中有一个指向虚函数表的指针（虚函数指针），32位程序占4个字节，64位程序占8个字节 静态成员不影响类的大小，被编译器放在程序的数据段中 普通继承的类sizeof，会得到基类的大小加上派生类自身成员的大小 当存在虚拟继承时，派生类中会有一个指向虚基类表的指针。所以其大小应为普通继承的大小，再加上虚基类表的指针大小  5. 构造函数和析构函数能被继承吗? 不能。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么\n6. 构造函数能不能是虚函数？ 不能。虚函数对应一个虚函数表，可是这个虚函数表存储在对象的内存空间的。问题就在于，如果构造函数是虚的，就需要通过 虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，就不会有虚函数表","title":"类其它总结"},{"content":" 构造函数可以互调，但不能在函数体内，只能通过初始化列表的形式 构造函数中不要写业务逻辑 析构函数中不要 delete this ，这会导致析构递归，最终导致栈溢出  class Test{ public: Test(int a, int b, int c){ _a = a; _b = b; _c = c; } // 正确  Test(int a, int b):Test(a, b, 100){ } /* // 错误 Test(int a, int b){ _a = a; _b = b; Test(a, b, 100); // 此处只是产生一个临时对象，马上又被释放掉了，没有任何意义 } */ int getA(){ return _a; } int getB(){ return _b; } int getC(){ return _c; } private: int _a; int _b; int _c; }; int main( ) { Test t1(10, 20); cout \u0026lt;\u0026lt; t1.getA() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; t1.getB() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; t1.getC() \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 10 20 100 0 Finish ","permalink":"https://874656645.github.io/rick/posts/50-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BA%92%E8%B0%83/","summary":"构造函数可以互调，但不能在函数体内，只能通过初始化列表的形式 构造函数中不要写业务逻辑 析构函数中不要 delete this ，这会导致析构递归，最终导致栈溢出  class Test{ public: Test(int a, int b, int c){ _a = a; _b = b; _c = c; } // 正确  Test(int a, int b):Test(a, b, 100){ } /* // 错误 Test(int a, int b){ _a = a; _b = b; Test(a, b, 100); // 此处只是产生一个临时对象，马上又被释放掉了，没有任何意义 } */ int getA(){ return _a; } int getB(){ return _b; } int getC(){ return _c; } private: int _a; int _b; int _c; }; int main( ) { Test t1(10, 20); cout \u0026lt;\u0026lt; t1.","title":"构造函数重载与互调"},{"content":"思路是借助类的静态成员函数\n方式一：\nclass A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void setCur(){ s_curA = this; } static void callback(){ s_curA-\u0026gt;print(); } private: static A* s_curA; int m_a; }; A* A::s_curA = nullptr; typedef void (*FUN_S)(); void Handle(FUN_S call){ call(); } int main( ) { A a(10), b(20); a.setCur(); Handle(A::callback); b.setCur(); Handle(A::callback); return 0; } 方式二：\nclass A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } static void callback(void *a){ ((A*)a)-\u0026gt;print(); } private: int m_a; }; typedef void (*FUN)(void *); void Handle(void *a, FUN call){ call(a); } int main( ) { A a(10), b(20); Handle(\u0026amp;a, A::callback); Handle(\u0026amp;b, A::callback); return 0; } 输出：\nStart m_a = 10 m_a = 20 0 Finish 还可以进一步封装：\ntypedef void (*FUN_S)(); void Handle(FUN_S call){ cout \u0026lt;\u0026lt; \u0026#34;Handle(FUN_S) begin...\u0026#34; \u0026lt;\u0026lt; endl; call(); cout \u0026lt;\u0026lt; \u0026#34;Handle(FUN_S) end...\u0026#34; \u0026lt;\u0026lt; endl; } typedef void (*FUN)(void *); void Handle(void *a, FUN call){ cout \u0026lt;\u0026lt; \u0026#34;Handle(void *, FUN) begin...\u0026#34; \u0026lt;\u0026lt; endl; call(a); cout \u0026lt;\u0026lt; \u0026#34;Handle(void *, FUN) end...\u0026#34; \u0026lt;\u0026lt; endl; } class A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void setCur(){ s_curA = this; } void startup(){ setCur(); Handle(A::callback); } void startup(int){ Handle(this, A::callback); } static void callback(){ s_curA-\u0026gt;print(); } static void callback(void *a){ ((A*)a)-\u0026gt;print(); } private: static A* s_curA; int m_a; }; A* A::s_curA = nullptr; int main( ) { A a(10), b(20); a.startup(); b.startup(); cout \u0026lt;\u0026lt; \u0026#34;======================================\u0026#34; \u0026lt;\u0026lt; endl; a.startup(1); b.startup(1); return 0; } 输出：\nStart Handle(FUN_S) begin... m_a = 10 Handle(FUN_S) end... Handle(FUN_S) begin... m_a = 20 Handle(FUN_S) end... ====================================== Handle(void *, FUN) begin... m_a = 10 Handle(void *, FUN) end... Handle(void *, FUN) begin... m_a = 20 Handle(void *, FUN) end... 0 Finish ","permalink":"https://874656645.github.io/rick/posts/49-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","summary":"思路是借助类的静态成员函数\n方式一：\nclass A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void setCur(){ s_curA = this; } static void callback(){ s_curA-\u0026gt;print(); } private: static A* s_curA; int m_a; }; A* A::s_curA = nullptr; typedef void (*FUN_S)(); void Handle(FUN_S call){ call(); } int main( ) { A a(10), b(20); a.setCur(); Handle(A::callback); b.setCur(); Handle(A::callback); return 0; } 方式二：\nclass A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } static void callback(void *a){ ((A*)a)-\u0026gt;print(); } private: int m_a; }; typedef void (*FUN)(void *); void Handle(void *a, FUN call){ call(a); } int main( ) { A a(10), b(20); Handle(\u0026amp;a, A::callback); Handle(\u0026amp;b, A::callback); return 0; } 输出：","title":"类的成员函数作为回调函数"},{"content":" 父类指针可以new子类对象，子类指针不可以new父类对象，但是可以接收强转的已经存在的父类指针 父类指针指向本类对象，调用的虚函数和普通函数都是自己的 将子类指针指向父类对象，虚函数执行的是父类的，也可以调用子类函数（这种操作是错误的，编译会报错，虽然可通过指针强转，但是不建议这样做，可能会导致未知错误） 父类指针指向子类对象，虚函数执行的是子类的，并且不能调用子类的函数 父类指针与子类指针之间赋值可以理解为指针所指内容的一种浅拷贝\nFather *f = (Father*)Child * 子类的虚函数指针覆盖父类的，并且子类特有的函数指针不会拷贝过去\nChild *c = (Child*)new Father父类的虚函数指针覆盖子类的，同时也有子类特有的函数指针  class A{ public: void printA(){ cout \u0026lt;\u0026lt; \u0026#34;printA()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void print(){ cout \u0026lt;\u0026lt; \u0026#34;A::print()\u0026#34; \u0026lt;\u0026lt; endl; } }; class B:public A{ public: void printB(){ cout \u0026lt;\u0026lt; \u0026#34;printB()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void print() override{ cout \u0026lt;\u0026lt; \u0026#34;B::print() b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } private: int b; }; int main( ) { // 1、指向自己的类对象（将父类对象赋值给父类指针）  A *a = new A; // 1.1 调用自己的函数  a-\u0026gt;printA(); // printA()  // 1.2 调用虚函数  a-\u0026gt;print(); // A::print()  // 2、将指向父类的父类指针强转为子类指针（将父类对象赋值给子类指针）  // b = new A; // error: incompatible pointer types assigning to \u0026#39;B *\u0026#39; from \u0026#39;A *\u0026#39;  B *b = (B*)new A; // 2.1 调用父类函数  b-\u0026gt;printA(); // printA()  // 2.2 调用虚函数（执行父类的）  b-\u0026gt;print(); // A::print() 调用父类的  // 2.3 可以调用子类函数  b-\u0026gt;printB(); // printB() b = 0  // 3、将子类对象赋值给父类指针  a = new B; // 3.1 调用父类函数  a-\u0026gt;printA(); // printA()  // 3.2 调用子类的函数  // a-\u0026gt;printB(); // error: no member named \u0026#39;printB\u0026#39; in \u0026#39;A\u0026#39;; did you mean \u0026#39;printA\u0026#39;?  // 3.3 调用虚函数（执行子类的）  a-\u0026gt;print(); // B::print() b = 0  // 4、指向子类对象的子类指针强转为父类指针（效果等同情况3）  b = new B; a = (A*)b; a-\u0026gt;printA(); // printA()  //a-\u0026gt;printB(); // error: no member named \u0026#39;printB\u0026#39; in \u0026#39;A\u0026#39;  a-\u0026gt;print(); // B::print() b = 0  return 0; } ","permalink":"https://874656645.github.io/rick/posts/48-%E7%B1%BB%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8E%9F%E5%88%99/","summary":"父类指针可以new子类对象，子类指针不可以new父类对象，但是可以接收强转的已经存在的父类指针 父类指针指向本类对象，调用的虚函数和普通函数都是自己的 将子类指针指向父类对象，虚函数执行的是父类的，也可以调用子类函数（这种操作是错误的，编译会报错，虽然可通过指针强转，但是不建议这样做，可能会导致未知错误） 父类指针指向子类对象，虚函数执行的是子类的，并且不能调用子类的函数 父类指针与子类指针之间赋值可以理解为指针所指内容的一种浅拷贝\nFather *f = (Father*)Child * 子类的虚函数指针覆盖父类的，并且子类特有的函数指针不会拷贝过去\nChild *c = (Child*)new Father父类的虚函数指针覆盖子类的，同时也有子类特有的函数指针  class A{ public: void printA(){ cout \u0026lt;\u0026lt; \u0026#34;printA()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void print(){ cout \u0026lt;\u0026lt; \u0026#34;A::print()\u0026#34; \u0026lt;\u0026lt; endl; } }; class B:public A{ public: void printB(){ cout \u0026lt;\u0026lt; \u0026#34;printB()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void print() override{ cout \u0026lt;\u0026lt; \u0026#34;B::print() b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } private: int b; }; int main( ) { // 1、指向自己的类对象（将父类对象赋值给父类指针）  A *a = new A; // 1.","title":"类的兼容性原则"},{"content":" 如果类的内部没有专门创建实例的代码，则是无法创建任何实例的 如果父类构造函数设置成了私有的，则子类无法编译，因为在初始化子类时会先执行父类的构造  class A{ public: private: A(int ){ } }; class B:public A{ public: int x; }; int main( ) { B b; b.x = 0; return 0; } 输出：\nStart prog.cc:19:7: error: call to implicitly-deleted default constructor of \u0026#39;B\u0026#39; B b; ^ prog.cc:13:9: note: default constructor of \u0026#39;B\u0026#39; is implicitly deleted because base class \u0026#39;A\u0026#39; has an inaccessible default constructor class B:public A{ ^ 1 error generated. 1 Finish ","permalink":"https://874656645.github.io/rick/posts/47-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%A7%81%E6%9C%89/","summary":" 如果类的内部没有专门创建实例的代码，则是无法创建任何实例的 如果父类构造函数设置成了私有的，则子类无法编译，因为在初始化子类时会先执行父类的构造  class A{ public: private: A(int ){ } }; class B:public A{ public: int x; }; int main( ) { B b; b.x = 0; return 0; } 输出：\nStart prog.cc:19:7: error: call to implicitly-deleted default constructor of \u0026#39;B\u0026#39; B b; ^ prog.cc:13:9: note: default constructor of \u0026#39;B\u0026#39; is implicitly deleted because base class \u0026#39;A\u0026#39; has an inaccessible default constructor class B:public A{ ^ 1 error generated. 1 Finish ","title":"构造函数私有"},{"content":"一、只能在堆上 方法：将析构函数设置为私有\n原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象\nclass Test { public: void printT(){ cout \u0026lt;\u0026lt; \u0026#34;printT\u0026#34; \u0026lt;\u0026lt; endl; } void freeT(){ delete this; } private: ~Test(){ cout \u0026lt;\u0026lt; \u0026#34;~Test()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main( ) { // 不能在栈上创建对象  //Test t; // prog.cc:25:10: error: variable of type \u0026#39;Test\u0026#39; has private destructor  // 只能在堆上创建对象  Test *t = new Test; t-\u0026gt;printT(); // 销毁对象  t-\u0026gt;freeT(); return 0; } 输出：\nStart printT ~Test() 0 Finish 二、只能在栈上 方法：将 new 和 delete 重载为私有\n原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象\n","permalink":"https://874656645.github.io/rick/posts/46-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/","summary":"一、只能在堆上 方法：将析构函数设置为私有\n原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象\nclass Test { public: void printT(){ cout \u0026lt;\u0026lt; \u0026#34;printT\u0026#34; \u0026lt;\u0026lt; endl; } void freeT(){ delete this; } private: ~Test(){ cout \u0026lt;\u0026lt; \u0026#34;~Test()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main( ) { // 不能在栈上创建对象  //Test t; // prog.cc:25:10: error: variable of type \u0026#39;Test\u0026#39; has private destructor  // 只能在堆上创建对象  Test *t = new Test; t-\u0026gt;printT(); // 销毁对象  t-\u0026gt;freeT(); return 0; } 输出：\nStart printT ~Test() 0 Finish 二、只能在栈上 方法：将 new 和 delete 重载为私有","title":"定义一个只能在堆上（栈上）生成对象的类"},{"content":" 抽象类：含有纯虚函数的类，不能实例化对象 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：\n1）所有成员都是 public，没有私有和受保护的非静态成员；\n2）没有定义任何构造函数；\n3）没有类内初始化；\n4）没有基类，也没有 virtual 函数  // 接口类 class A { virtual void printA() = 0; // 纯虚函数 }; // 抽象类 class AA:public A { public: // 覆写接口类的纯虚函数  void printA() override { cout \u0026lt;\u0026lt; \u0026#34;class AA printA()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void printAA() = 0; }; // 可实例化的类 class B:public AA { public: // 覆写父类（抽象类）的纯虚函数  void printAA() override { cout \u0026lt;\u0026lt; \u0026#34;class B printAA()\u0026#34; \u0026lt;\u0026lt; endl; } void printB() { cout \u0026lt;\u0026lt; \u0026#34;printB()\u0026#34; \u0026lt;\u0026lt; endl; } }; // 聚合类 class C { public: int x; int y; void print(){ cc(); } private: void cc(){ cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;, z = \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; } static int z; }; int C::z = 0; class D { public: int a; int b; C c; void print(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; c.print(); } }; int main( ) { B b; b.printA(); b.printB(); // 初始化聚合类  D d = {1, 2, {3, 4}}; d.print(); return 0; } 输出：\nStart class AA printA() class B printAA() printB() a = 1, b = 2 x = 3, y = 4, z = 0 0 Finish 既然有抽象类，为什么要用接口呢？\n 接口带来的最大好处就是避免了多继承带来的复杂性和低效性，并且同时可以提供多重继承的好处 抽象类对事物进行抽象，更多的是为了继承，为了扩展，为了实现代码的重用，子类和父类之间体现的是is-a关系 接口则更多的体现一种行为约束，一种规则，一旦实现了这个接口，就要给出这个接口中所有方法的具体实现，也就是说实现类对于接口中所有的方法都是有意义的 接口用于抽象事物的特性，抽象类用于代码复用  ","permalink":"https://874656645.github.io/rick/posts/45-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E7%B1%BB%E8%81%9A%E5%90%88%E7%B1%BB/","summary":"抽象类：含有纯虚函数的类，不能实例化对象 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：\n1）所有成员都是 public，没有私有和受保护的非静态成员；\n2）没有定义任何构造函数；\n3）没有类内初始化；\n4）没有基类，也没有 virtual 函数  // 接口类 class A { virtual void printA() = 0; // 纯虚函数 }; // 抽象类 class AA:public A { public: // 覆写接口类的纯虚函数  void printA() override { cout \u0026lt;\u0026lt; \u0026#34;class AA printA()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void printAA() = 0; }; // 可实例化的类 class B:public AA { public: // 覆写父类（抽象类）的纯虚函数  void printAA() override { cout \u0026lt;\u0026lt; \u0026#34;class B printAA()\u0026#34; \u0026lt;\u0026lt; endl; } void printB() { cout \u0026lt;\u0026lt; \u0026#34;printB()\u0026#34; \u0026lt;\u0026lt; endl; } }; // 聚合类 class C { public: int x; int y; void print(){ cc(); } private: void cc(){ cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;, z = \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; } static int z; }; int C::z = 0; class D { public: int a; int b; C c; void print(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; c.","title":"抽象类、接口类、聚合类"},{"content":"虚继承和虚基类 参考\n 在C++中，在定义公共基类A的派生类B、C\u0026hellip;的时候，如果在继承方式前使用关键字virtual对继承方式限定，这样的继承方式就是虚拟继承，公共基类A成为虚基类。这样，在具有公共基类的、使用了虚拟继承方式的多个派生类B、C\u0026hellip;的公共派生类D中，该基类A的成员就只有一份拷贝 一个类有多个基类，这样的继承关系称为多继承。在多继承的情况下，如果不同基类的成员名称相同，匹配度相同, 则会造成二义性。为了避免多继承产生的二义性，在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 会在虚继承的类中生成一个指向虚基类的指针 {vbptr} 会在内存中生成一个虚基类表 D::$vbtable@B@  微软的Visual Studio提供给用户显示C++对象在内存中的布局的选项\ncl [filename].cpp /d1 reportSingleClassLayout[className]\n一般继承：\nclass A { public: int dataA; }; class B:public A { public: int dataB; }; class C:public A { public: int dataC; }; class D : public B, public C { public: int dataD; }; 输出：\nclass D size(20): +--- 0 | +--- (base class B) 0 | | +--- (base class A) 0 | | | dataA | | +--- 4 | | dataB | +--- 8 | +--- (base class C) 8 | | +--- (base class A) 8 | | | dataA | | +--- 12 | | dataC | +--- 16 | dataD +--- 调用：\nint main( ) { D d; cout \u0026lt;\u0026lt; d.dataA \u0026lt;\u0026lt; endl; return 0; } 调用输出：\nStart prog.cc:29:15: error: non-static member \u0026#39;dataA\u0026#39; found in multiple base-class subobjects of type \u0026#39;A\u0026#39;: class D -\u0026gt; class B -\u0026gt; class A class D -\u0026gt; class C -\u0026gt; class A cout \u0026lt;\u0026lt; d.dataA \u0026lt;\u0026lt; endl; ^ prog.cc:9:9: note: member found by ambiguous name lookup int dataA; ^ 1 error generated. 1 Finish 虚继承：\nclass A { public: int dataA; }; class B:virtual public A { public: int dataB; }; class C:virtual public A { public: int dataC; }; class D : public B, public C { public: int dataD; }; B 类输出：\nclass B size(12): +--- 0 | {vbptr} 4 | dataB +--- +--- (virtual base A) 8 | dataA +--- B::$vbtable@: 0 | 0 1 | 8 (Bd(B+0)A) vbi: class offset o.vbptr o.vbte fVtorDisp A 8 0 4 0 C 类输出：\nclass C size(12): +--- 0 | {vbptr} 4 | dataC +--- +--- (virtual base A) 8 | dataA +--- C::$vbtable@: 0 | 0 1 | 8 (Cd(C+0)A) vbi: class offset o.vbptr o.vbte fVtorDisp A 8 0 4 0 D 类输出：\nclass D size(24): +--- 0 | +--- (base class B) 0 | | {vbptr} 4 | | dataB | +--- 8 | +--- (base class C) 8 | | {vbptr} 12 | | dataC | +--- 16 | dataD +--- +--- (virtual base A) 20 | dataA +--- D::$vbtable@B@: 0 | 0 1 | 20 (Dd(B+0)A) D::$vbtable@C@: 0 | 0 1 | 12 (Dd(C+0)A) vbi: class offset o.vbptr o.vbte fVtorDisp A 20 0 4 0 ","permalink":"https://874656645.github.io/rick/posts/44-%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB/","summary":"虚继承和虚基类 参考\n 在C++中，在定义公共基类A的派生类B、C\u0026hellip;的时候，如果在继承方式前使用关键字virtual对继承方式限定，这样的继承方式就是虚拟继承，公共基类A成为虚基类。这样，在具有公共基类的、使用了虚拟继承方式的多个派生类B、C\u0026hellip;的公共派生类D中，该基类A的成员就只有一份拷贝 一个类有多个基类，这样的继承关系称为多继承。在多继承的情况下，如果不同基类的成员名称相同，匹配度相同, 则会造成二义性。为了避免多继承产生的二义性，在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 会在虚继承的类中生成一个指向虚基类的指针 {vbptr} 会在内存中生成一个虚基类表 D::$vbtable@B@  微软的Visual Studio提供给用户显示C++对象在内存中的布局的选项\ncl [filename].cpp /d1 reportSingleClassLayout[className]\n一般继承：\nclass A { public: int dataA; }; class B:public A { public: int dataB; }; class C:public A { public: int dataC; }; class D : public B, public C { public: int dataD; }; 输出：\nclass D size(20): +--- 0 | +--- (base class B) 0 | | +--- (base class A) 0 | | | dataA | | +--- 4 | | dataB | +--- 8 | +--- (base class C) 8 | | +--- (base class A) 8 | | | dataA | | +--- 12 | | dataC | +--- 16 | dataD +--- 调用：","title":"虚继承和虚基类"},{"content":"1. C++ 多态分类及实现  重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载（静态多态、静态编译） 子类多态（Subtype Polymorphism，运行期）：虚函数（动态多态、动态编译） 参数多态（Parametric Polymorphism，编译期）：类模板（泛型）、函数模板（函数指针） 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换  2. 虚表指针、虚函数指针、虚函数表  虚表指针：在含有虚函数的类的对象中，指向虚函数表的指针，在运行时确定 虚函数指针：指向虚函数的地址的指针 {vfptr} 虚函数表：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚函数表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建 Shape::$vftable@  class Shape { public: virtual ~Shape(){ cout \u0026lt;\u0026lt; \u0026#34;~Shape()\u0026#34; \u0026lt;\u0026lt; endl; } }; class Point { public: ~Point(){ cout \u0026lt;\u0026lt; \u0026#34;~Point()\u0026#34; \u0026lt;\u0026lt; endl; } private: int m_x{0}; int m_y{0}; char m_c; }; class Circle : public Shape { public: ~Circle(){ cout \u0026lt;\u0026lt; \u0026#34;~Circle()\u0026#34; \u0026lt;\u0026lt; endl; } private: Point m_p; }; int main( ) { // 8 类中存有指向虚函数表的指针  cout \u0026lt;\u0026lt; sizeof(Shape) \u0026lt;\u0026lt; endl; // 16 类中存有指向虚函数表的指针  // 以及Point对象的大小（此时Point类中不包含任何变量），虽然真实大小是 8 + 1  // 但是额外多的1个字节导致内存大小扩增了 8(每次扩增的最小数值是8 \u0026lt;alignment member\u0026gt; (size=7))  cout \u0026lt;\u0026lt; sizeof(Circle) \u0026lt;\u0026lt; endl; // 8 类中的int占4个字节，char占1个字节  // 但每次扩增的最小数值是4(\u0026lt;alignment member\u0026gt; (size=3))  cout \u0026lt;\u0026lt; sizeof(Point) \u0026lt;\u0026lt; endl; Circle c; return 0; } Start 8 24 12 ~Circle() ~Point() ~Shape() 0 Finish Shape 类\n// 没有虚函数 class Shape size(1): +--- +--- // 有虚析构函数 class Shape size(8): +--- 0 | {vfptr} +--- Shape::$vftable@: | \u0026amp;Shape_meta | 0 0 | \u0026amp;Shape::{dtor} Shape::{dtor} this adjustor: 0 Shape::__delDtor this adjustor: 0 Shape::__vecDelDtor this adjustor: 0 Point 类\nclass Point size(8): +--- 0 | m_x 4 | m_y 8 | m_c | \u0026lt;alignment member\u0026gt; (size=3) +--- Circle 类\nclass Circle size(24): +--- 0 | +--- (base class Shape) 0 | | {vfptr} | +--- 8 | Point m_p | \u0026lt;alignment member\u0026gt; (size=4) +--- Circle::$vftable@: | \u0026amp;Circle_meta | 0 0 | \u0026amp;Circle::{dtor} Circle::{dtor} this adjustor: 0 Circle::__delDtor this adjustor: 0 Circle::__vecDelDtor this adjustor: 0 ","permalink":"https://874656645.github.io/rick/posts/43-%E5%A4%9A%E6%80%81%E6%80%BB%E7%BB%93/","summary":"1. C++ 多态分类及实现  重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载（静态多态、静态编译） 子类多态（Subtype Polymorphism，运行期）：虚函数（动态多态、动态编译） 参数多态（Parametric Polymorphism，编译期）：类模板（泛型）、函数模板（函数指针） 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换  2. 虚表指针、虚函数指针、虚函数表  虚表指针：在含有虚函数的类的对象中，指向虚函数表的指针，在运行时确定 虚函数指针：指向虚函数的地址的指针 {vfptr} 虚函数表：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚函数表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建 Shape::$vftable@  class Shape { public: virtual ~Shape(){ cout \u0026lt;\u0026lt; \u0026#34;~Shape()\u0026#34; \u0026lt;\u0026lt; endl; } }; class Point { public: ~Point(){ cout \u0026lt;\u0026lt; \u0026#34;~Point()\u0026#34; \u0026lt;\u0026lt; endl; } private: int m_x{0}; int m_y{0}; char m_c; }; class Circle : public Shape { public: ~Circle(){ cout \u0026lt;\u0026lt; \u0026#34;~Circle()\u0026#34; \u0026lt;\u0026lt; endl; } private: Point m_p; }; int main( ) { // 8 类中存有指向虚函数表的指针  cout \u0026lt;\u0026lt; sizeof(Shape) \u0026lt;\u0026lt; endl; // 16 类中存有指向虚函数表的指针  // 以及Point对象的大小（此时Point类中不包含任何变量），虽然真实大小是 8 + 1  // 但是额外多的1个字节导致内存大小扩增了 8(每次扩增的最小数值是8 \u0026lt;alignment member\u0026gt; (size=7))  cout \u0026lt;\u0026lt; sizeof(Circle) \u0026lt;\u0026lt; endl; // 8 类中的int占4个字节，char占1个字节  // 但每次扩增的最小数值是4(\u0026lt;alignment member\u0026gt; (size=3))  cout \u0026lt;\u0026lt; sizeof(Point) \u0026lt;\u0026lt; endl; Circle c; return 0; } Start 8 24 12 ~Circle() ~Point() ~Shape() 0 Finish Shape 类","title":"多态总结"},{"content":"1. 函数默认参数和占位参数（亚元） 形参中的占位参数又叫亚元，并没有什么实际意义，只在函数重载中起到作用\n// 亚元，设置了默认值所以调用时可以不传参数 // 否则就必须传入两个参数 void foo(int a, int = 0){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } int main() { foo(20); return 0; } 2. 函数重载  函数名相同，形参列表不同（形参个数、类型、顺序） 函数返回值不起作用 函数重载和默认参数不要同时使用（函数调用时容易产生二义性） 倾轧技术（name mangling），底层会将函数名进行编译  用 v c i f l d 表示 void char int float long double 及其引用 int fun(int) =\u0026gt; fun_i\nint fun(int, char, double) =\u0026gt; fun_icd   重载函数匹配顺序  如果能够严格匹配，则调用完全匹配的 如果没有完全匹配的，则调用隐式转换的 都匹配不上，编译失败    3. 函数指针 int test(int a, int b){ cout \u0026lt;\u0026lt; \u0026#34;test(\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; return 0; } // 方式一： typedef int(FUN)(int, int); // 方式二： typedef int(*FUN_P)(int, int); int main() { // 方式一：  FUN *f1 = NULL; f1 = test; f1(10, 20); (*f1)(10, 20); // 方式二：  FUN_P f2 = NULL; f2 = test; f2(10, 20); // 方式三：  int (*f3)(int, int) = NULL; f3 = test; f3(10, 20); return 0; } 输出：\nStart test(10, 20) test(10, 20) test(10, 20) test(10, 20) 0 Finish ","permalink":"https://874656645.github.io/rick/posts/42-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%92%8C%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0/","summary":"1. 函数默认参数和占位参数（亚元） 形参中的占位参数又叫亚元，并没有什么实际意义，只在函数重载中起到作用\n// 亚元，设置了默认值所以调用时可以不传参数 // 否则就必须传入两个参数 void foo(int a, int = 0){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } int main() { foo(20); return 0; } 2. 函数重载  函数名相同，形参列表不同（形参个数、类型、顺序） 函数返回值不起作用 函数重载和默认参数不要同时使用（函数调用时容易产生二义性） 倾轧技术（name mangling），底层会将函数名进行编译  用 v c i f l d 表示 void char int float long double 及其引用 int fun(int) =\u0026gt; fun_i\nint fun(int, char, double) =\u0026gt; fun_icd   重载函数匹配顺序  如果能够严格匹配，则调用完全匹配的 如果没有完全匹配的，则调用隐式转换的 都匹配不上，编译失败    3.","title":"函数默认参数和占位参数"},{"content":"一、程序运行前  代码区（只读的、共享） 数据区（全局变量和静态变量）  二、程序运行后  栈区 堆区 全局静态区（全局变量、静态变量、常量） 代码区  Linux程序运行内存虚拟地址空间：\n三、全局变量与静态变量的区别 作用域不同\n全局变量默认是 extern 的\n静态变量是文件作用域\nC/C++中extern关键字详解\n","permalink":"https://874656645.github.io/rick/posts/41-%E5%86%85%E5%AD%98%E5%8C%BA%E9%97%B4%E5%88%92%E5%88%86/","summary":"一、程序运行前  代码区（只读的、共享） 数据区（全局变量和静态变量）  二、程序运行后  栈区 堆区 全局静态区（全局变量、静态变量、常量） 代码区  Linux程序运行内存虚拟地址空间：\n三、全局变量与静态变量的区别 作用域不同\n全局变量默认是 extern 的\n静态变量是文件作用域\nC/C++中extern关键字详解","title":"内存区间划分"},{"content":" 指针也是一种变量，作为函数形参和返回值的时候也是值拷贝（拷贝的是一个地址） 使用指针引用的方式，代码更加简洁，逻辑更加清晰 释放掉指针指向的空间后，一定记得把指针置空 声明指针时就进行初始化或将其指向 NULL 是个好习惯  指针值拷贝：\nvoid test(int * a){ a = new int(20); //*a = 20;  cout \u0026lt;\u0026lt; \u0026#34;test point a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;test:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; } int main() { int *a = new int(10); cout \u0026lt;\u0026lt; \u0026#34;main point a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;main:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; test(a); cout \u0026lt;\u0026lt; \u0026#34;main:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart main point a = 0x7ffea2597be0 main:0x195d010\ta = 10 test point a = 0x7ffea2597ba8 test:0x195e040\ta = 20 main:0x195d010\ta = 10 0 Finish struct teacher{ char name[64]; int id; }; // 方式一： // 如果想要在函数内部实现指针内存分配 // 就只能用二级指针的形参 int getTT(struct teacher ** tpp){ struct teacher *tp = (struct teacher *)malloc(sizeof(struct teacher)); if(tp == NULL){ return -1; } tp-\u0026gt;id = 100; strcpy(tp-\u0026gt;name, \u0026#34;zhang3\u0026#34;); *tpp = tp; return 0; } // 如果是想释放指针，也可以用一级指针 void freeTT(struct teacher **tpp){ if(tpp == NULL){ return; } if(*tpp != NULL){ free(*tpp); *tpp = NULL; } } void freeTT(struct teacher *tpp){ if(tpp == NULL){ return; } if(tpp != NULL){ free(tpp); // 此处的tpp是一个指针复本，置空没有效果  // 所以只能在外部将指针置空  tpp = NULL; } } // 方式二： // 指针引用的方式，更加简洁 int getT(struct teacher *\u0026amp; tp){ tp = (struct teacher *)malloc(sizeof(struct teacher)); if(tp == NULL){ return -1; } tp-\u0026gt;id = 100; strcpy(tp-\u0026gt;name, \u0026#34;zhang3\u0026#34;); return 0; } void freeT(struct teacher *\u0026amp; tp){ if(tp == NULL){ return; } free(tp); tp = NULL; } int main() { struct teacher *tp = NULL; // 1、利用二级指针  //getTT(\u0026amp;tp);  // 2、利用指针引用  getT(tp); cout \u0026lt;\u0026lt; tp-\u0026gt;id \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tp-\u0026gt;name \u0026lt;\u0026lt; endl; //freeTT(\u0026amp;tp);  freeT(tp); cout \u0026lt;\u0026lt; \u0026#34;==========================\u0026#34; \u0026lt;\u0026lt; endl; if(tp == NULL){ cout \u0026lt;\u0026lt; \u0026#34;free ok\u0026#34; \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; tp-\u0026gt;id \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tp-\u0026gt;name \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 100 zhang3 ========================== free ok 0 Finish ","permalink":"https://874656645.github.io/rick/posts/40-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/","summary":"指针也是一种变量，作为函数形参和返回值的时候也是值拷贝（拷贝的是一个地址） 使用指针引用的方式，代码更加简洁，逻辑更加清晰 释放掉指针指向的空间后，一定记得把指针置空 声明指针时就进行初始化或将其指向 NULL 是个好习惯  指针值拷贝：\nvoid test(int * a){ a = new int(20); //*a = 20;  cout \u0026lt;\u0026lt; \u0026#34;test point a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;test:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; } int main() { int *a = new int(10); cout \u0026lt;\u0026lt; \u0026#34;main point a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;main:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; test(a); cout \u0026lt;\u0026lt; \u0026#34;main:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"指针引用"},{"content":"一、抽象、封装 数据抽象：是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制，是一种依赖于接口实现分离的设计技术\n数据封装：是一种把数据和操作数据的函数捆绑在一起的机制\n1. 好处  类的内部受到保护，不会因无意的用户级错误导致对象状态受损 类实现可能随着时间的推移而发生变化，数据抽象可以更好的应对不断变化的需求  2. 策略  通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。 抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可  3. 接口 接口描述了类的行为和功能，而不需要完成类的特定实现。如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类\n设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n可用于实例化对象的类被称为具体类\n接口的好处实现了解耦合的作用。 可以将软件架构分为业务逻辑层、抽象层和实现层\n二、继承 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。类派生列表以一个或多个基类命名\n派生类可以访问基类中所有的非私有成员，同时，一个派生类继承了所有的基类方法，但下列情况除外：\n 基类的构造函数、析构函数和拷贝构造函数 基类的重载运算符 基类的友元函数  三、多态 虚函数：虚函数是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链编到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链编，或后期绑定。\n 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数 一般要将父类的析构函数设置为虚函数，如果不把父类的析构函数设置为虚函数，在 delete 父类指针时就不会调用子类的析构了 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数 若在基类中不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数，在函数参数后直接加 = 0 告诉编译器，函数没有主体，这种虚函数即是纯虚函数  测试类：\n// 基类 Shape class Shape { protected: int width, height; public: Shape(int a = 0, int b = 0) { width = a; height = b; } virtual ~Shape() { cout \u0026lt;\u0026lt; \u0026#34;Shape destructor\u0026#34; \u0026lt;\u0026lt; endl; } // pure virtual function  virtual int area() = 0; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { auto res = area * 70; cout \u0026lt;\u0026lt; \u0026#34;PaintCost: \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return res; } }; class Rectangle: public Shape, public PaintCost { public: Rectangle(int a = 0, int b = 0):Shape(a, b) { } ~Rectangle() { cout \u0026lt;\u0026lt; \u0026#34;Rectangle destructor\u0026#34; \u0026lt;\u0026lt; endl; } void printPro() { // 访问父类的成员变量（不能访问父类的私有成员）  cout \u0026lt;\u0026lt; \u0026#34;width: \u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34;\\theight: \u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; endl; } int area () { auto area = width * height; cout \u0026lt;\u0026lt; \u0026#34;Rectangle class area: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt;endl; return area; } }; class Triangle: public Shape { public: Triangle(int a = 0, int b = 0):Shape(a, b) { } ~Triangle() { cout \u0026lt;\u0026lt; \u0026#34;Triangle destructor\u0026#34; \u0026lt;\u0026lt; endl; } int area () { auto area = width * height / 2; cout \u0026lt;\u0026lt; \u0026#34;Triangle class area: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt;endl; return area; } }; 多继承：\nint main() { Rectangle rec(10, 20); rec.printPro(); // 调用父类函数  rec.getCost(10); return 0; } 输出：\nStart width: 10\theight: 20 PaintCost: 700 Rectangle destructor Shape destructor 0 Finish 多态：\nint main() { Shape *shape = new Rectangle(10, 7); Triangle tri(10,5); shape-\u0026gt;area(); //Rectangle class area  delete shape; shape = \u0026amp;tri; shape-\u0026gt;area(); //Triangle class area  // delete shape; // 这种指针不能 delete  return 0; } 输出：\nStart Rectangle class area: 70 Rectangle destructor Shape destructor Triangle class area: 25 Triangle destructor Shape destructor 0 Finish 实现多态的原因： 如果父类有 virtual 方法，编译器会创建一个虚函数表（在只读区），同时会在类中存储一个指向虚函数表的指针 VPTR，这个表也会被子类继承，如果子类中重写了父类的虚函数，就会在子类中覆盖所继承的虚函数表中的函数\n虚函数表指针是分步初始化的，在构建父类时指向的还是父类的虚函数表\nclass A{ public: A(){ cout \u0026lt;\u0026lt; \u0026#34;A()...\u0026#34; \u0026lt;\u0026lt; endl; print(); } virtual ~A(){ cout \u0026lt;\u0026lt; \u0026#34;~A()...\u0026#34; \u0026lt;\u0026lt; endl; print(); } virtual void print(){ cout \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; } }; class B : public A{ public: B(){ cout \u0026lt;\u0026lt; \u0026#34;B()...\u0026#34; \u0026lt;\u0026lt; endl; print(); } ~B(){ cout \u0026lt;\u0026lt; \u0026#34;~B()...\u0026#34; \u0026lt;\u0026lt; endl; print(); } virtual void print(){ cout \u0026lt;\u0026lt; \u0026#34;B\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { A *a = new B; delete a; return 0; } 输出：\nA()... A B()... B ~B()... B ~A()... A ","permalink":"https://874656645.github.io/rick/posts/39-%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/","summary":"一、抽象、封装 数据抽象：是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制，是一种依赖于接口实现分离的设计技术\n数据封装：是一种把数据和操作数据的函数捆绑在一起的机制\n1. 好处  类的内部受到保护，不会因无意的用户级错误导致对象状态受损 类实现可能随着时间的推移而发生变化，数据抽象可以更好的应对不断变化的需求  2. 策略  通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。 抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可  3. 接口 接口描述了类的行为和功能，而不需要完成类的特定实现。如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类\n设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n可用于实例化对象的类被称为具体类\n接口的好处实现了解耦合的作用。 可以将软件架构分为业务逻辑层、抽象层和实现层\n二、继承 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。类派生列表以一个或多个基类命名\n派生类可以访问基类中所有的非私有成员，同时，一个派生类继承了所有的基类方法，但下列情况除外：\n 基类的构造函数、析构函数和拷贝构造函数 基类的重载运算符 基类的友元函数  三、多态 虚函数：虚函数是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链编到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链编，或后期绑定。\n 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数 一般要将父类的析构函数设置为虚函数，如果不把父类的析构函数设置为虚函数，在 delete 父类指针时就不会调用子类的析构了 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数 若在基类中不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数，在函数参数后直接加 = 0 告诉编译器，函数没有主体，这种虚函数即是纯虚函数  测试类：\n// 基类 Shape class Shape { protected: int width, height; public: Shape(int a = 0, int b = 0) { width = a; height = b; } virtual ~Shape() { cout \u0026lt;\u0026lt; \u0026#34;Shape destructor\u0026#34; \u0026lt;\u0026lt; endl; } // pure virtual function  virtual int area() = 0; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { auto res = area * 70; cout \u0026lt;\u0026lt; \u0026#34;PaintCost: \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return res; } }; class Rectangle: public Shape, public PaintCost { public: Rectangle(int a = 0, int b = 0):Shape(a, b) { } ~Rectangle() { cout \u0026lt;\u0026lt; \u0026#34;Rectangle destructor\u0026#34; \u0026lt;\u0026lt; endl; } void printPro() { // 访问父类的成员变量（不能访问父类的私有成员）  cout \u0026lt;\u0026lt; \u0026#34;width: \u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34;\\theight: \u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; endl; } int area () { auto area = width * height; cout \u0026lt;\u0026lt; \u0026#34;Rectangle class area: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt;endl; return area; } }; class Triangle: public Shape { public: Triangle(int a = 0, int b = 0):Shape(a, b) { } ~Triangle() { cout \u0026lt;\u0026lt; \u0026#34;Triangle destructor\u0026#34; \u0026lt;\u0026lt; endl; } int area () { auto area = width * height / 2; cout \u0026lt;\u0026lt; \u0026#34;Triangle class area: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt;endl; return area; } }; 多继承：","title":"抽象、封装、继承、多态"},{"content":" 使用 static 关键字来把类成员定义为静态的。静态成员在类的所有对象中是共享的，当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本 如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零 不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数） 普通成员函数有 this 指针，可以访问类中的任意成员；  class A { string name {\u0026#34;C++\u0026#34;}; int id {1024}; static int objCount; public: A(); friend void printA(const A \u0026amp;a); void printA(); static void printC(); }; // 静态成员类外初始化 int A::objCount = 0; A::A(){ objCount++; } void A::printA(){ cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;objCount \u0026lt;\u0026lt; \u0026#34;\\tname = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;id \u0026lt;\u0026lt; endl; } void A::printC(){ // 静态函数内没有this指针  cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; objCount \u0026lt;\u0026lt; endl; // error: \u0026#39;this\u0026#39; is unavailable for static member functions  // cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;objCount \u0026lt;\u0026lt; endl; } void printA(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; a.objCount \u0026lt;\u0026lt; \u0026#34;\\tname = \u0026#34; \u0026lt;\u0026lt; a.name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; a.id \u0026lt;\u0026lt; endl; } int main() { // 类静态成员函数  A::printC(); // 友员函数  A a; printA(a); // 成员函数  A b; b.printA(); return 0; } 输出：\nStart objCount = 0 objCount = 1\tname = C++\tid = 1024 objCount = 2\tname = C++\tid = 1024 0 Finish ","permalink":"https://874656645.github.io/rick/posts/38-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/","summary":"使用 static 关键字来把类成员定义为静态的。静态成员在类的所有对象中是共享的，当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本 如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零 不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数） 普通成员函数有 this 指针，可以访问类中的任意成员；  class A { string name {\u0026#34;C++\u0026#34;}; int id {1024}; static int objCount; public: A(); friend void printA(const A \u0026amp;a); void printA(); static void printC(); }; // 静态成员类外初始化 int A::objCount = 0; A::A(){ objCount++; } void A::printA(){ cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;objCount \u0026lt;\u0026lt; \u0026#34;\\tname = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;id \u0026lt;\u0026lt; endl; } void A::printC(){ // 静态函数内没有this指针  cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; objCount \u0026lt;\u0026lt; endl; // error: \u0026#39;this\u0026#39; is unavailable for static member functions  // cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;objCount \u0026lt;\u0026lt; endl; } void printA(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; a.","title":"类的静态成员"},{"content":"  友元利弊：\n友元不是类的成员但能访问类中的私有成员。友元的作用在于提高程序的运行效率，但也破坏了类的封装。\n  注意事项：\n（1）友元关系不能被继承；\n（2）友元关系是单向的，不具有交换性；\n（3）友元关系不具有传递性；\n  一、友元函数  类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员 尽管友元函数的原型有在类的定义中出现过，但是 友元函数并不是成员函数 this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针  1. 友元函数是全局函数\nclass A { friend void printA(const A \u0026amp;a); public: void printA(); private: string name {\u0026#34;C++\u0026#34;}; int id {1024}; }; void A::printA(){ cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;id \u0026lt;\u0026lt; endl; } // 请注意：printA() 不是任何类的成员函数 void printA(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; a.name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; a.id \u0026lt;\u0026lt; endl; } int main() { A a; printA(a); a.printA(); return 0; } 输出：\nStart name = C++\tid = 1024 name = C++\tid = 1024 0 Finish 2. 友元函数是类的成员方法\n小技巧：为了防止相互嵌套，可以将其中一个类的声明和实现拆开\nclass Point; class PointManager{ public: double getDistance(Point \u0026amp;p1, Point \u0026amp;p2); private: }; class Point{ friend double PointManager::getDistance(Point \u0026amp;p1, Point \u0026amp;p2); public: Point(int x, int y){ this-\u0026gt;x = x; this-\u0026gt;y = y; } private: int x; int y; }; double PointManager::getDistance(Point \u0026amp;p1, Point \u0026amp;p2){ int dx = p1.x - p2.x; int dy = p1.y - p2.y; return sqrt(dx * dx + dy * dy); } int main( ) { Point p1(1, 1), p2(3, 1); PointManager pm; cout \u0026lt;\u0026lt; pm.getDistance(p1, p2) \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 2 0 Finish 二、友元类 class A{ friend class B; // 将 B 声明为友元类后，在 B 中 A 就是透明的 public: A(int a){ this-\u0026gt;a = a; } void printA(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;a \u0026lt;\u0026lt; endl; } private: int a; }; class B{ public: B(int b){ this-\u0026gt;b = b; } void printB(){ A a(10); cout \u0026lt;\u0026lt; \u0026#34;print a in b: \u0026#34; \u0026lt;\u0026lt; a.a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;b \u0026lt;\u0026lt; endl; } private: int b; }; int main( ) { B b(-10); b.printB(); return 0; } Start print a in b: 10 b = -10 0 Finish ","permalink":"https://874656645.github.io/rick/posts/37-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8B%E5%85%83%E7%B1%BB/","summary":"友元利弊：\n友元不是类的成员但能访问类中的私有成员。友元的作用在于提高程序的运行效率，但也破坏了类的封装。\n  注意事项：\n（1）友元关系不能被继承；\n（2）友元关系是单向的，不具有交换性；\n（3）友元关系不具有传递性；\n  一、友元函数  类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员 尽管友元函数的原型有在类的定义中出现过，但是 友元函数并不是成员函数 this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针  1. 友元函数是全局函数\nclass A { friend void printA(const A \u0026amp;a); public: void printA(); private: string name {\u0026#34;C++\u0026#34;}; int id {1024}; }; void A::printA(){ cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;id \u0026lt;\u0026lt; endl; } // 请注意：printA() 不是任何类的成员函数 void printA(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; a.","title":"友元函数与友元类"},{"content":"结论：\n 拷贝构造函数是函数，赋值运算符是运算符的重载； 拷贝构造函数会生成新的类对象，赋值运算符不会； 拷贝构造函数是用一个已存在的对象去构造一个不存在的对象；而赋值运算符重载函数是用一个存在的对象去给另一个已存在并初始化过的对象进行赋值; 若接受返回值的对象已经初始化过，则会调用赋值运算符，且该对象还会调用析构函数，当对象中包含指针时，会使该指针失效，因此需要重载赋值运算符，使用类似深拷贝或移动构造函数的方法赋值，才能避免指针失效。 如果只有显示的构造函数，系统会提供默认的拷贝构造； 如果显示提供了拷贝构造，系统就不会提供默认的无参构造了，用户必需显示提供构造函数； 当既没有显式的构造函数，也没有拷贝构造时，系统才会提供默认的无参构造； 显示提供拷贝构造就必需显示提供构造函数； 显示提供赋值运算符重载就必需显示提供拷贝构造；  成员初始化列表  使用成员变量初始化列表，少了一次调用默认构造函数的过程，提高效率 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 成员变量初始化的顺序跟在初始化列表的顺序无关，与变量声明的顺序有关  测试类 class A { public: A(){ cout \u0026lt;\u0026lt; \u0026#34;default constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } A(int t){ x = new int(0); y = t; cout \u0026lt;\u0026lt; \u0026#34;second constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } A(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;const copy constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; this-\u0026gt;x = a.x; this-\u0026gt;y = a.y; } A\u0026amp; operator = (const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;const assignment constructor\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;x = a.x; this-\u0026gt;y = a.y; return *this; } ~A(){ cout \u0026lt;\u0026lt; \u0026#34;destructor delete \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; delete x; } public: int * x {nullptr}; int y{0}; }; A f(){ A ret(3); cout \u0026lt;\u0026lt; \u0026#34;stack f adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;ret \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; ret.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; ret.y \u0026lt;\u0026lt; endl; return ret; } // 匿名对象 = ret (此处会调用拷贝构造) 一、拷贝构造 1. 对象需要通过另外一个对象进行初始化 int main() { A a(1); A c = a; cout \u0026lt;\u0026lt; \u0026#34;global adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;c \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart second constructor adrres: 0x7ffdf2cf5cc0\tpoint x: 0x1e9db20\ty: 1 const copy constructor adrres: 0x7ffdf2cf5cb0\tpoint x: 0\ty: 0 global adrres: 0x7ffdf2cf5cb0\tpoint x: 0x1e9db20\ty: 1 destructor delete 0x7ffdf2cf5cb0 destructor delete 0x7ffdf2cf5cc0 0 Finish 2. 对象通过值传递方式进入函数 void g(A a){ cout \u0026lt;\u0026lt; \u0026#34;stack g adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; a.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; a.y \u0026lt;\u0026lt; endl; } int main() { A a(1); g(a); return 0; } 输出：\nStart second constructor adrres: 0x7ffddc160510\tpoint x: 0x2448b20\ty: 1 const copy constructor adrres: 0x7ffddc160520\tpoint x: 0\ty: 0 stack g adrres: 0x7ffddc160520\tpoint x: 0x2448b20\ty: 1 destructor delete 0x7ffddc160520 destructor delete 0x7ffddc160510 0 Finish 3. 当对象以值传递的方式从函数返回  函数返回匿名对象时会调用拷贝构造 变量在接收匿名对象时就不会调用拷贝构造了  class A { //注意把拷贝构造设为禁止使用，否则看不到效果  A(const A \u0026amp;a) = delete; } int main() { f(); // 如果没有变量接收匿名对象，编译器就直接回收了，立即执行对象析构  A c = f(); // 匿名对象直接转正，就不会调用拷贝构造了  A d; d = f(); // 此处会调用 = 号操作符重载（d = 匿名对象）  // 然后匿名对象会执行析构，立即销毁  cout \u0026lt;\u0026lt; \u0026#34;global adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;c \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart prog.cc: In function \u0026#39;A f()\u0026#39;: prog.cc:40:12: error: use of deleted function \u0026#39;A::A(const A\u0026amp;)\u0026#39; 40 | return ret; | ^~~ prog.cc:20:5: note: declared here 20 | A(const A \u0026amp;a) = delete; | ^ 1 Finish 正常输出：虽然没有输出调用拷贝构造的信息，但确实有关系\nStart second constructor adrres: 0x7fff0f7062d0\tpoint x: 0x127eb20\ty: 3 stack f adrres: 0x7fff0f7062d0\tpoint x: 0x127eb20\ty: 3 global adrres: 0x7fff0f7062d0\tpoint x: 0x127eb20\ty: 3 destructor delete 0x7fff0f7062d0 0 Finish 二、赋值构造  注意：拷贝构造不能是 delete 的  1. 对象直接赋值给另一个对象，且接受值的对象已经初始化过 int main() { A a(1); A c; c = a; cout \u0026lt;\u0026lt; \u0026#34;global adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;c \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart second constructor adrres: 0x7ffee27a6fa0\tpoint x: 0xcdeb20\ty: 1 default constructor adrres: 0x7ffee27a6f90\tpoint x: 0\ty: 0 const assignment constructor global adrres: 0x7ffee27a6f90\tpoint x: 0xcdeb20\ty: 1 destructor delete 0x7ffee27a6f90 destructor delete 0x7ffee27a6fa0 0 Finish 2. 对象以值传递方式从函数返回，且接受返回值的对象已经初始化过  注意：返回函数调用后，会调用析构，如果对象中包含指针时，会使该指针失效  int main() { A c; c = f(); // 此时调用指针会出错，f()结束，调用对象析构，对象中的指针被 delete 掉了  // cout \u0026lt;\u0026lt; *c.x \u0026lt;\u0026lt; endl;  cout \u0026lt;\u0026lt; \u0026#34;global adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;c \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart default constructor adrres: 0x7ffd3aed2be0\tpoint x: 0\ty: 0 second constructor adrres: 0x7ffd3aed2bf0\tpoint x: 0x1475b20\ty: 3 stack f adrres: 0x7ffd3aed2bf0\tpoint x: 0x1475b20\ty: 3 const assignment constructor destructor delete 0x7ffd3aed2bf0 global adrres: 0x7ffd3aed2be0\tpoint x: 0x1475b20\ty: 3 destructor delete 0x7ffd3aed2be0 0 Finish ","permalink":"https://874656645.github.io/rick/posts/36-%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0/","summary":"结论：\n 拷贝构造函数是函数，赋值运算符是运算符的重载； 拷贝构造函数会生成新的类对象，赋值运算符不会； 拷贝构造函数是用一个已存在的对象去构造一个不存在的对象；而赋值运算符重载函数是用一个存在的对象去给另一个已存在并初始化过的对象进行赋值; 若接受返回值的对象已经初始化过，则会调用赋值运算符，且该对象还会调用析构函数，当对象中包含指针时，会使该指针失效，因此需要重载赋值运算符，使用类似深拷贝或移动构造函数的方法赋值，才能避免指针失效。 如果只有显示的构造函数，系统会提供默认的拷贝构造； 如果显示提供了拷贝构造，系统就不会提供默认的无参构造了，用户必需显示提供构造函数； 当既没有显式的构造函数，也没有拷贝构造时，系统才会提供默认的无参构造； 显示提供拷贝构造就必需显示提供构造函数； 显示提供赋值运算符重载就必需显示提供拷贝构造；  成员初始化列表  使用成员变量初始化列表，少了一次调用默认构造函数的过程，提高效率 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 成员变量初始化的顺序跟在初始化列表的顺序无关，与变量声明的顺序有关  测试类 class A { public: A(){ cout \u0026lt;\u0026lt; \u0026#34;default constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } A(int t){ x = new int(0); y = t; cout \u0026lt;\u0026lt; \u0026#34;second constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } A(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;const copy constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; this-\u0026gt;x = a.","title":"构造、拷贝构造、赋值构造"},{"content":" 重载： 在同一作用域中，两个函数名相同，但是参数列表不同（个数、类型、顺序），返回值类型没有要求； 重写： 子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写； 重定义： 派生类中函数与基类中的函数同名，但是这个函数在基类中并没有被定义为虚函数 隐藏： 派生类中重定义了父类的函数，此时基类的函数会被隐藏； 模板： 函数模板是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表，只适用于 参数个数相同而类型不同 的函数。 构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数  1、重载  类的静态函数也可以重载； 形参中一级指针和二级指针被认为是不同类型的参数；  class A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;print()\u0026#34; \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void freeP(A ** p){ if(p == NULL){ return; } if(*p != NULL){ free(*p); *p = NULL; } } void freeP(A * p){ if(p != NULL){ free(p); p = NULL; } } static void printS(){ cout \u0026lt;\u0026lt; \u0026#34;printS() s_a = \u0026#34; \u0026lt;\u0026lt; s_a \u0026lt;\u0026lt; endl; } static void printS(int s){ cout \u0026lt;\u0026lt; \u0026#34;printS(int s) \u0026#34; \u0026lt;\u0026lt; s_a * s \u0026lt;\u0026lt; endl; } static void printS(void *p, int s){ cout \u0026lt;\u0026lt; \u0026#34;printS(void *p, int s) \u0026#34; \u0026lt;\u0026lt; ((A*)p)-\u0026gt;m_a * s \u0026lt;\u0026lt; endl; } static int s_a; private: int m_a; }; int A::s_a = 0; int main( ) { A *a = new A(1); a-\u0026gt;printS(a, 20); a-\u0026gt;print(); A::s_a = 10; a-\u0026gt;printS(); a-\u0026gt;printS(10); a-\u0026gt;freeP(a); if(a == NULL){ cout \u0026lt;\u0026lt; \u0026#34;*a is not valid\u0026#34; \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; \u0026#34;*a is valid\u0026#34; \u0026lt;\u0026lt; endl; a-\u0026gt;print(); return 0; } 输出：\nStart printS(void *p, int s) 20 print()m_a = 1 printS() s_a = 10 printS(int s) 100 *a is valid print()m_a = 0 0 Finish ","permalink":"https://874656645.github.io/rick/posts/35-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F%E6%A8%A1%E6%9D%BF/","summary":"重载： 在同一作用域中，两个函数名相同，但是参数列表不同（个数、类型、顺序），返回值类型没有要求； 重写： 子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写； 重定义： 派生类中函数与基类中的函数同名，但是这个函数在基类中并没有被定义为虚函数 隐藏： 派生类中重定义了父类的函数，此时基类的函数会被隐藏； 模板： 函数模板是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表，只适用于 参数个数相同而类型不同 的函数。 构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数  1、重载  类的静态函数也可以重载； 形参中一级指针和二级指针被认为是不同类型的参数；  class A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;print()\u0026#34; \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void freeP(A ** p){ if(p == NULL){ return; } if(*p != NULL){ free(*p); *p = NULL; } } void freeP(A * p){ if(p != NULL){ free(p); p = NULL; } } static void printS(){ cout \u0026lt;\u0026lt; \u0026#34;printS() s_a = \u0026#34; \u0026lt;\u0026lt; s_a \u0026lt;\u0026lt; endl; } static void printS(int s){ cout \u0026lt;\u0026lt; \u0026#34;printS(int s) \u0026#34; \u0026lt;\u0026lt; s_a * s \u0026lt;\u0026lt; endl; } static void printS(void *p, int s){ cout \u0026lt;\u0026lt; \u0026#34;printS(void *p, int s) \u0026#34; \u0026lt;\u0026lt; ((A*)p)-\u0026gt;m_a * s \u0026lt;\u0026lt; endl; } static int s_a; private: int m_a; }; int A::s_a = 0; int main( ) { A *a = new A(1); a-\u0026gt;printS(a, 20); a-\u0026gt;print(); A::s_a = 10; a-\u0026gt;printS(); a-\u0026gt;printS(10); a-\u0026gt;freeP(a); if(a == NULL){ cout \u0026lt;\u0026lt; \u0026#34;*a is not valid\u0026#34; \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; \u0026#34;*a is valid\u0026#34; \u0026lt;\u0026lt; endl; a-\u0026gt;print(); return 0; } 输出：","title":"函数重载、重写、隐藏、模板"},{"content":"当一个函数被声明为内联函数之后，在编译阶段，编译器会用内联函数的函数体取替换程序中出现的内联函数调用表达式，而其他的函数都是在运行时才被替换，这其实就是用空间换时间，提高了函数调用的效率。同时，内联函数具有几个特点：\n 适用于函数体积很小并频繁使用的函数 内联函数中不可以出现循环、递归或开关操作 内联函数的声明必须在函数定义之前 内联函数的定义必须出现在内联函数的第一次调用前 在类中声明同时定义的成员函数（除了虚函数）会自动隐式的当成内联函数 虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联  优点：\n 内联函数在被调用处进行代码展开，省去了参数压栈、跳转返回、栈帧开辟与回收，结果返回等操作，从而提高程序运行速度； 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换，而宏定义则不会； 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能； 内联函数在运行时可调试，而宏定义不可以。  缺点：\n 代码膨胀，消耗了更多的内存空间； inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接； 内联函数其实是不可控的，它只是对编译器的建议，是否对函数内联，决定权在于编译器; 不能对函数进行取址操作  ","permalink":"https://874656645.github.io/rick/posts/34-inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/","summary":"当一个函数被声明为内联函数之后，在编译阶段，编译器会用内联函数的函数体取替换程序中出现的内联函数调用表达式，而其他的函数都是在运行时才被替换，这其实就是用空间换时间，提高了函数调用的效率。同时，内联函数具有几个特点：\n 适用于函数体积很小并频繁使用的函数 内联函数中不可以出现循环、递归或开关操作 内联函数的声明必须在函数定义之前 内联函数的定义必须出现在内联函数的第一次调用前 在类中声明同时定义的成员函数（除了虚函数）会自动隐式的当成内联函数 虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联  优点：\n 内联函数在被调用处进行代码展开，省去了参数压栈、跳转返回、栈帧开辟与回收，结果返回等操作，从而提高程序运行速度； 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换，而宏定义则不会； 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能； 内联函数在运行时可调试，而宏定义不可以。  缺点：\n 代码膨胀，消耗了更多的内存空间； inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接； 内联函数其实是不可控的，它只是对编译器的建议，是否对函数内联，决定权在于编译器; 不能对函数进行取址操作  ","title":"inline 内联函数"},{"content":"Unix 的 fork 函数 fork函数可以创建一个和当前映像一样的子进程，这个函数会返回两个值：从子进程返回0，从父进程返回子进程的PID；\n 1）在父进程中，fork返回新创建子进程的进程ID； 2）在子进程中，fork返回0； 3）如果出现错误，fork返回一个负值；  #include \u0026lt;iostream\u0026gt;#include \u0026lt;unistd.h\u0026gt; using namespace std; int main() { pid_t fpid; //fpid表示fork函数返回的值  int count = 0; cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; fpid = fork(); if (fpid \u0026lt; 0) printf(\u0026#34;error in fork!\\n\u0026#34;); else if (fpid == 0) { printf(\u0026#34;i am the child process, my process id is %d\\n\u0026#34;,getpid()); cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; count++; } else { printf(\u0026#34;i am the parent process, my process id is %d\\n\u0026#34;,getpid()); cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; count++; } printf(\u0026#34;统计结果是: %d\\n\u0026#34;,count); return 0; } 输出：\nStart 0x7ffd3ed42530 i am the parent process, my process id is 22 0x7ffd3ed42530 统计结果是: 1 i am the child process, my process id is 23 0x7ffd3ed42530 统计结果是: 1 0 Finish ","permalink":"https://874656645.github.io/rick/posts/33-fork-unix/","summary":"Unix 的 fork 函数 fork函数可以创建一个和当前映像一样的子进程，这个函数会返回两个值：从子进程返回0，从父进程返回子进程的PID；\n 1）在父进程中，fork返回新创建子进程的进程ID； 2）在子进程中，fork返回0； 3）如果出现错误，fork返回一个负值；  #include \u0026lt;iostream\u0026gt;#include \u0026lt;unistd.h\u0026gt; using namespace std; int main() { pid_t fpid; //fpid表示fork函数返回的值  int count = 0; cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; fpid = fork(); if (fpid \u0026lt; 0) printf(\u0026#34;error in fork!\\n\u0026#34;); else if (fpid == 0) { printf(\u0026#34;i am the child process, my process id is %d\\n\u0026#34;,getpid()); cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; count++; } else { printf(\u0026#34;i am the parent process, my process id is %d\\n\u0026#34;,getpid()); cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; count++; } printf(\u0026#34;统计结果是: %d\\n\u0026#34;,count); return 0; } 输出：","title":"fork Unix"},{"content":"C++ 是 C 的超集和增强，校验更加严格\nC 主要是面向过程，C++ 是面向对象，面向过程是函数驱动，面向对象是对象驱动\n1 新增命名空间  给{}作用域起了个名称，后面不用加分号; 命名空间可以嵌套  namespace X { namespace Y { } } 2 新增引用类型  引用在一定程度上可以替代指针，作用与常指针类似 int * const a 引用没有定义，是一种关系声明，声明它和原有某一变量（实体）的关系，\n故而类型与原类型保持一致，且不分配内存，与被引用的变量有相同的地址 声明时必须初始化，一经声明，不可变更 可对引用再次引用，多次引用的结果是某一变量具有多个别名 \u0026amp; 符号在 = 号左边是引用，在 = 号右边为取地址  3 枚举检测增强  不能将整型隐式转化为枚举  4 变量定义增强  C++ 变量不必都声明在函数顶部，可以随使用随定义  5 全局变量定义检测严格  C 全局变量重复定义，C++ 不可以，全局变量检测增强  // C 语言 int g_val; // bss段 int g_val = 10; // data段 6 函数形参个数和函数返回值检测增强 // C 语言 f() // 默认返回值 int { return 10; } int g(int a) { return 10; } // 调用 g(10, 20, 30, 40); // 可编译通过，但是有警告 7 struct 结构体增强  功能与类基本等同，只不过 class 默认是 private 权限，struct 默认是 public 权限  // C 语言声明结构体变量 struct Student s; // C++ 语言声明结构体变量 Student s; 8 新增 bool 关键字，1 个字节  C 用 0 表示 false，非 0 表示 true C++ 中 bool 为 1 个字节，但是只有 true 和 false 两个值  9 三目运算符增强（语法糖）  C 中三目运算符不可以当左值  // C 语言 int a = 10, b = 20; ((a \u0026lt; b) ? a : b) = 50; // 错误 *((a \u0026lt; b) ? \u0026amp;a : \u0026amp;b) = 50; // 正确，a 此时是50 // C++ 三目运算左值 int a = 10, b = 20; ((a \u0026lt; b) ? a : b) = 50; // 正确，a 此时是50（返回的是引用） 10 const 增强  C中的 const 变量可以通过指针的方式进行修改，是假常量  // C 语言 const int a = 10; int *p = \u0026amp;a; *p = 20; printf(\u0026#34;a = %d\u0026#34;, a);  C++ 中的 const 变量放在了全局空间的符号表中，是不可更改的  // C++ 语言 const int a = 10; // 常量区符号表中（key value 键值对），编译过程中进行替换  // #define 是在预处理阶段展开，不受作用域限制 int *p = \u0026amp;a; // 在栈中开辟了一个临时变量空间 *p = 20; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // a = 10 cout \u0026lt;\u0026lt; \u0026#34;*p = \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; // *p = 20 ","permalink":"https://874656645.github.io/rick/posts/32-c-%E4%B8%8E-c++-%E7%9A%84%E5%B7%AE%E5%BC%82/","summary":"C++ 是 C 的超集和增强，校验更加严格\nC 主要是面向过程，C++ 是面向对象，面向过程是函数驱动，面向对象是对象驱动\n1 新增命名空间  给{}作用域起了个名称，后面不用加分号; 命名空间可以嵌套  namespace X { namespace Y { } } 2 新增引用类型  引用在一定程度上可以替代指针，作用与常指针类似 int * const a 引用没有定义，是一种关系声明，声明它和原有某一变量（实体）的关系，\n故而类型与原类型保持一致，且不分配内存，与被引用的变量有相同的地址 声明时必须初始化，一经声明，不可变更 可对引用再次引用，多次引用的结果是某一变量具有多个别名 \u0026amp; 符号在 = 号左边是引用，在 = 号右边为取地址  3 枚举检测增强  不能将整型隐式转化为枚举  4 变量定义增强  C++ 变量不必都声明在函数顶部，可以随使用随定义  5 全局变量定义检测严格  C 全局变量重复定义，C++ 不可以，全局变量检测增强  // C 语言 int g_val; // bss段 int g_val = 10; // data段 6 函数形参个数和函数返回值检测增强 // C 语言 f() // 默认返回值 int { return 10; } int g(int a) { return 10; } // 调用 g(10, 20, 30, 40); // 可编译通过，但是有警告 7 struct 结构体增强  功能与类基本等同，只不过 class 默认是 private 权限，struct 默认是 public 权限  // C 语言声明结构体变量 struct Student s; // C++ 语言声明结构体变量 Student s; 8 新增 bool 关键字，1 个字节  C 用 0 表示 false，非 0 表示 true C++ 中 bool 为 1 个字节，但是只有 true 和 false 两个值  9 三目运算符增强（语法糖）  C 中三目运算符不可以当左值  // C 语言 int a = 10, b = 20; ((a \u0026lt; b) ?","title":"C 与 C++ 的差异"},{"content":"int add(int count, ...) { // 指针大小与程序位数有关（32位指针是4个字节，64位指针是8个字节）  int intSize = sizeof(int*) / sizeof(int); int sum = 0; // cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl;  int *p = \u0026amp;count + intSize; // cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;  for (int i = 0; i \u0026lt; count; ++i) { sum += *p; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; p += intSize; } return sum; } int main() { cout \u0026lt;\u0026lt; add(3, 1, 2, 3) \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 2 3 6 ","permalink":"https://874656645.github.io/rick/posts/31-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%E5%85%A5%E6%A0%88/","summary":"int add(int count, ...) { // 指针大小与程序位数有关（32位指针是4个字节，64位指针是8个字节）  int intSize = sizeof(int*) / sizeof(int); int sum = 0; // cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl;  int *p = \u0026amp;count + intSize; // cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;  for (int i = 0; i \u0026lt; count; ++i) { sum += *p; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; p += intSize; } return sum; } int main() { cout \u0026lt;\u0026lt; add(3, 1, 2, 3) \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"函数形参从右到左入栈"},{"content":"1. 32 位和 64 位程序指针是多少位 32位指针大小为4个字节，64位指针大小位8个字节\n2. 指针加 1，是对该指针增加 1 个储存单位 “存储单位”，指的是指针指向的数据类型所占的内存的字节数。不同类型的指针加1后，增加的大小不同。\nint main() { int a[] = {1, 2, 3, 4, 5}; // \u0026amp;a是数组指针，其类型为 int (*)[5]，a是长度为5的int数组指针，所以要加 5*sizeof(int)，所以ptr实际是a[5]；  // \u0026amp;a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）  // 但是prt与(\u0026amp;a+1)类型是不一样的(这点很重要，prt指向的是整形)，所以prt-1只会减去sizeof(int)  int *ptr = (int*)(\u0026amp;a + 1); cout \u0026lt;\u0026lt; *(a + 1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *(ptr - 1) \u0026lt;\u0026lt; endl; return 0; } 输出：\n2 5 注： a，\u0026amp;a的地址是一样的，但意思不一样：\n a是数组首地址，也就是a[0]的地址，a+1是数组下一元素的地址，即a[1] \u0026amp;a是对象（整个数组作为一个对象）首地址，而\u0026amp;a+1是下一个对象的地址，即a[5].  ","permalink":"https://874656645.github.io/rick/posts/30-%E6%8C%87%E9%92%88-+1/","summary":"1. 32 位和 64 位程序指针是多少位 32位指针大小为4个字节，64位指针大小位8个字节\n2. 指针加 1，是对该指针增加 1 个储存单位 “存储单位”，指的是指针指向的数据类型所占的内存的字节数。不同类型的指针加1后，增加的大小不同。\nint main() { int a[] = {1, 2, 3, 4, 5}; // \u0026amp;a是数组指针，其类型为 int (*)[5]，a是长度为5的int数组指针，所以要加 5*sizeof(int)，所以ptr实际是a[5]；  // \u0026amp;a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）  // 但是prt与(\u0026amp;a+1)类型是不一样的(这点很重要，prt指向的是整形)，所以prt-1只会减去sizeof(int)  int *ptr = (int*)(\u0026amp;a + 1); cout \u0026lt;\u0026lt; *(a + 1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *(ptr - 1) \u0026lt;\u0026lt; endl; return 0; } 输出：\n2 5 注： a，\u0026amp;a的地址是一样的，但意思不一样：\n a是数组首地址，也就是a[0]的地址，a+1是数组下一元素的地址，即a[1] \u0026amp;a是对象（整个数组作为一个对象）首地址，而\u0026amp;a+1是下一个对象的地址，即a[5].  ","title":"指针 + 1"},{"content":"template\u0026lt;class T\u0026gt; class Test { public: Test(T t){ m_t = t;}; // explicit Test(T t){ m_t = t;};  T getValue(){ return m_t; }; private: T m_t; }; int main() { Test\u0026lt;int\u0026gt; tInt(1); cout \u0026lt;\u0026lt; tInt.getValue() \u0026lt;\u0026lt; endl; Test\u0026lt;double\u0026gt; tD(1.15); cout \u0026lt;\u0026lt; tD.getValue() \u0026lt;\u0026lt; endl; Test\u0026lt;float\u0026gt; tF = 1.3f; // 构造函数没有explicit修饰，可以隐式转换  cout \u0026lt;\u0026lt; tF.getValue() \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 1 1.15 1.3 0 Finish ","permalink":"https://874656645.github.io/rick/posts/29-%E6%A8%A1%E6%9D%BF%E7%B1%BB/","summary":"template\u0026lt;class T\u0026gt; class Test { public: Test(T t){ m_t = t;}; // explicit Test(T t){ m_t = t;};  T getValue(){ return m_t; }; private: T m_t; }; int main() { Test\u0026lt;int\u0026gt; tInt(1); cout \u0026lt;\u0026lt; tInt.getValue() \u0026lt;\u0026lt; endl; Test\u0026lt;double\u0026gt; tD(1.15); cout \u0026lt;\u0026lt; tD.getValue() \u0026lt;\u0026lt; endl; Test\u0026lt;float\u0026gt; tF = 1.3f; // 构造函数没有explicit修饰，可以隐式转换  cout \u0026lt;\u0026lt; tF.getValue() \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 1 1.15 1.3 0 Finish ","title":"模板类"},{"content":"template \u0026lt;typename T\u0026gt; inline const T\u0026amp; Max (const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? b:a; }; int main() { int i = 39; int j = 20; cout \u0026lt;\u0026lt; \u0026#34;Max(i, j): \u0026#34; \u0026lt;\u0026lt; Max(i, j) \u0026lt;\u0026lt; endl; double f1 = 13.5; double f2 = 20.7; cout \u0026lt;\u0026lt; \u0026#34;Max(f1, f2): \u0026#34; \u0026lt;\u0026lt; Max(f1, f2) \u0026lt;\u0026lt; endl; string s1 = \u0026#34;Hello\u0026#34;; string s2 = \u0026#34;World\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Max(s1, s2): \u0026#34; \u0026lt;\u0026lt; Max(s1, s2) \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart Max(i, j): 39 Max(f1, f2): 20.7 Max(s1, s2): World 0 Finish ","permalink":"https://874656645.github.io/rick/posts/28-%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/","summary":"template \u0026lt;typename T\u0026gt; inline const T\u0026amp; Max (const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? b:a; }; int main() { int i = 39; int j = 20; cout \u0026lt;\u0026lt; \u0026#34;Max(i, j): \u0026#34; \u0026lt;\u0026lt; Max(i, j) \u0026lt;\u0026lt; endl; double f1 = 13.5; double f2 = 20.7; cout \u0026lt;\u0026lt; \u0026#34;Max(f1, f2): \u0026#34; \u0026lt;\u0026lt; Max(f1, f2) \u0026lt;\u0026lt; endl; string s1 = \u0026#34;Hello\u0026#34;; string s2 = \u0026#34;World\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Max(s1, s2): \u0026#34; \u0026lt;\u0026lt; Max(s1, s2) \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"模板函数"},{"content":" 注：软件版本为10.6，需要 服务端 token 注：天地图官网的服务（https://t0.tianditu.gov.cn/img_w/wmts）使用的 dpi 大小采用的是国家标准，并不是 OGC 标准，会导致 ArcMap 加载影像后，矢量化的坐标不对  影像底图：\nhttp://t0.tianditu.com/img_c/esri/wmts 天地图影像（经纬度，CGCS2000）\nhttp://t0.tianditu.com/cia_c/esri/wmts 天地图影像注记（经纬度，CGCS2000）\nhttp://t0.tianditu.com/img_w/esri/wmts 天地图影像（墨卡托，WGS1984）\nhttp://t0.tianditu.com/cia_w/esri/wmts 天地图影像注记（墨卡托，WGS1984）\n矢量底图：\nhttp://t0.tianditu.com/vec_c/esri/wmts 天地图矢量（经纬度，CGCS2000）\nhttp://t0.tianditu.com/cva_c/esri/wmts 天地图矢量注记（经纬度，CGCS2000）\nhttp://t0.tianditu.com/vec_w/esri/wmts 天地图矢量（墨卡托，WGS1984）\nhttp://t0.tianditu.com/cva_w/esri/wmts 天地图矢量注记（墨卡托，WGS1984）\nArcMap WMTS\n","permalink":"https://874656645.github.io/rick/posts/27-arcmap-%E5%8A%A0%E8%BD%BD%E5%A4%A9%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1/","summary":"注：软件版本为10.6，需要 服务端 token 注：天地图官网的服务（https://t0.tianditu.gov.cn/img_w/wmts）使用的 dpi 大小采用的是国家标准，并不是 OGC 标准，会导致 ArcMap 加载影像后，矢量化的坐标不对  影像底图：\nhttp://t0.tianditu.com/img_c/esri/wmts 天地图影像（经纬度，CGCS2000）\nhttp://t0.tianditu.com/cia_c/esri/wmts 天地图影像注记（经纬度，CGCS2000）\nhttp://t0.tianditu.com/img_w/esri/wmts 天地图影像（墨卡托，WGS1984）\nhttp://t0.tianditu.com/cia_w/esri/wmts 天地图影像注记（墨卡托，WGS1984）\n矢量底图：\nhttp://t0.tianditu.com/vec_c/esri/wmts 天地图矢量（经纬度，CGCS2000）\nhttp://t0.tianditu.com/cva_c/esri/wmts 天地图矢量注记（经纬度，CGCS2000）\nhttp://t0.tianditu.com/vec_w/esri/wmts 天地图矢量（墨卡托，WGS1984）\nhttp://t0.tianditu.com/cva_w/esri/wmts 天地图矢量注记（墨卡托，WGS1984）\nArcMap WMTS","title":"ArcMap 加载天地图服务"},{"content":"#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;using namespace std; // 声明函数指针变量 int (*fn)(int) = NULL; // 定义函数指针类型 typedef int (*Fn)(int); int cal(int v){ return v; }; // 函数指针做为形参 void proc(int v, Fn f){ cout \u0026lt;\u0026lt; f(v) \u0026lt;\u0026lt; endl; }; int main() { fn = cal; cout \u0026lt;\u0026lt; (*fn)(10) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; fn(10) \u0026lt;\u0026lt; endl; Fn f1 = cal; cout \u0026lt;\u0026lt; (*f1)(20) \u0026lt;\u0026lt; endl; proc(30, cal); return 0; } Start 10 10 20 30 0 Finish ","permalink":"https://874656645.github.io/rick/posts/26-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/","summary":"#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;using namespace std; // 声明函数指针变量 int (*fn)(int) = NULL; // 定义函数指针类型 typedef int (*Fn)(int); int cal(int v){ return v; }; // 函数指针做为形参 void proc(int v, Fn f){ cout \u0026lt;\u0026lt; f(v) \u0026lt;\u0026lt; endl; }; int main() { fn = cal; cout \u0026lt;\u0026lt; (*fn)(10) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; fn(10) \u0026lt;\u0026lt; endl; Fn f1 = cal; cout \u0026lt;\u0026lt; (*f1)(20) \u0026lt;\u0026lt; endl; proc(30, cal); return 0; } Start 10 10 20 30 0 Finish ","title":"函数指针"},{"content":"  指针函数本质是一个函数，返回值是一个指针；\n  函数指针是指向函数的一个指针变量；\n  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt; using namespace std; // 指针函数fun char * fun(const char * p) { cout \u0026lt;\u0026lt; \u0026#34;fun: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return nullptr; }; // 函数指针pf char * (*pf)(const char * p); int main() { pf = fun; // 函数指针pf指向函数fun  pf(\u0026#34;Hello\u0026#34;); return 0; } ","permalink":"https://874656645.github.io/rick/posts/25-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/","summary":"  指针函数本质是一个函数，返回值是一个指针；\n  函数指针是指向函数的一个指针变量；\n  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt; using namespace std; // 指针函数fun char * fun(const char * p) { cout \u0026lt;\u0026lt; \u0026#34;fun: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return nullptr; }; // 函数指针pf char * (*pf)(const char * p); int main() { pf = fun; // 函数指针pf指向函数fun  pf(\u0026#34;Hello\u0026#34;); return 0; } ","title":"指针函数和函数指针"},{"content":" 修饰构造函数，防止隐式转换，赋值初始化，赋值列表初始化 修饰转换函数，可以防止隐式转换，但按语境转换除外 explicit 可加在带多个参数的构造方法上(converting to ‘XXX’ from initializer list)  struct B { explicit B(int) {} explicit operator bool() const { return true; } }; int main() { B b1(1); // OK：直接初始化  B b2 = 1; // 错误：被 explicit 修饰构造函数的对象不可以赋值初始化  B b3{ 1 }; // OK：直接列表初始化  B b4 = { 1 }; // 错误：被 explicit 修饰构造函数的对象不可以赋值列表初始化  B b5 = (B)1; // OK：允许 static_cast 的显式转换  if (b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b6(b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b7 = b1; // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换  bool b8 = static_cast\u0026lt;bool\u0026gt;(b1); // OK：static_cast 进行直接初始化  return 0; } 从初始化列表隐式转换：\nclass T{ public: T(int a, int b){ cout \u0026lt;\u0026lt; \u0026#34;T(int, int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; this-\u0026gt;b = b; } ~T(){ cout \u0026lt;\u0026lt; \u0026#34;~T()...\u0026#34; \u0026lt;\u0026lt; endl; } void printT(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } private: int a; int b; }; T func(){ cout \u0026lt;\u0026lt; \u0026#34;in func()...\u0026#34; \u0026lt;\u0026lt; endl; return {3, 4}; } int main() { T t = func(); t.printT(); return 0; } 输出：\nin func()... T(int, int)... a = 3, b = 4 ~T()... ","permalink":"https://874656645.github.io/rick/posts/24-explicit-%E5%85%B3%E9%94%AE%E5%AD%97/","summary":"修饰构造函数，防止隐式转换，赋值初始化，赋值列表初始化 修饰转换函数，可以防止隐式转换，但按语境转换除外 explicit 可加在带多个参数的构造方法上(converting to ‘XXX’ from initializer list)  struct B { explicit B(int) {} explicit operator bool() const { return true; } }; int main() { B b1(1); // OK：直接初始化  B b2 = 1; // 错误：被 explicit 修饰构造函数的对象不可以赋值初始化  B b3{ 1 }; // OK：直接列表初始化  B b4 = { 1 }; // 错误：被 explicit 修饰构造函数的对象不可以赋值列表初始化  B b5 = (B)1; // OK：允许 static_cast 的显式转换  if (b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b6(b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b7 = b1; // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换  bool b8 = static_cast\u0026lt;bool\u0026gt;(b1); // OK：static_cast 进行直接初始化  return 0; } 从初始化列表隐式转换：","title":"explicit（显式）关键字"},{"content":"局部变量、静态局部变量、全局变量、全局静态变量、字符串常量以及动态申请的内存区\n 局部变量存储在栈中 全局变量、静态变量（全局和局部静态变量）存储在静态存储区 new申请的内存是在堆中 字符串常量也是存储在静态存储区   栈中的变量内存会随着定义所在区间的结束自动释放；而对于堆，需要手动free，否则它就一直存在，直到程序结束； 对于静态存储区，其中的变量常量在程序运行期间会一直存在，不会释放，且变量常量在其中只有一份拷贝，不会出现相同的变量和常量的不同拷贝。  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt; using namespace std; //返回的是局部变量的地址，该地址位于动态数据区，栈里 char *s1() { char* p1 = \u0026#34;qqq\u0026#34;;//为了测试‘char p[]=\u0026#34;Hello world!\u0026#34;’中的字符串在静态存储区是否也有一份拷贝  char p[]=\u0026#34;Hello world!\u0026#34;; char* p2 = \u0026#34;w\u0026#34;;//为了测试‘char p[]=\u0026#34;Hello world!\u0026#34;’中的字符串在静态存储区是否也有一份拷贝  printf(\u0026#34;in s1 p=%p\\n\u0026#34;, p); printf(\u0026#34;in s1 p1=%p\\n\u0026#34;, p1); printf(\u0026#34;in s1: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!\u0026#34;)); printf(\u0026#34;in s1 p2=%p\\n\u0026#34;, p2); return p1; // 这里不能返回局部变量 p } //返回的是字符串常量的地址，该地址位于静态数据区 char *s2() { char *q=\u0026#34;Hello world!\u0026#34;; printf(\u0026#34;in s2 q=%p\\n\u0026#34;, q); printf(\u0026#34;in s2: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!\u0026#34;)); return q; } //返回的是静态局部变量的地址，该地址位于静态数据区 char *s3() { static char r[]=\u0026#34;Hello world!\u0026#34;; printf(\u0026#34;in s3 r=%p\\n\u0026#34;, r); printf(\u0026#34;in s3: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!\u0026#34;)); return r; } int main() { char *t1, *t2, *t3; t1=s1(); t2=s2(); t3=s3(); printf(\u0026#34;in main:\u0026#34;); printf(\u0026#34;p=%p, q=%p, r=%p\\n\u0026#34;, t1, t2, t3); printf(\u0026#34;%s\\n\u0026#34;, t1); printf(\u0026#34;%s\\n\u0026#34;, t2); printf(\u0026#34;%s\\n\u0026#34;, t3); cout \u0026lt;\u0026lt; sizeof(\u0026#39;a\u0026#39;) \u0026lt;\u0026lt; endl; return 0; } 输出：\nin s1 p=0x7ffef76f34d3 in s1 p1=0x401010 in s1: string\u0026#39;s address: 0x40102f in s1 p2=0x401014 in s2 q=0x40102f in s2: string\u0026#39;s address: 0x40102f in s3 r=0x601798 in s3: string\u0026#39;s address: 0x40102f in main:p=0x401010, q=0x40102f, r=0x601798 qqq Hello world! Hello world! 1 这个结果正好应证了上面解释，同时，还可是得出一个结论： 字符串常量，之所以称之为常量，因为它可一看作是一个没有命名的字符串且为常量，存放在静态数据区。 这里说的静态数据区，是相对于堆、栈等动态数据区而言的。 静态数据区存放的是全局变量和静态变量，从这一点上来说，字符串常量又可以称之为一个无名的静态变量， 因为\u0026quot;Hello world!\u0026quot;这个字符串在函数 s1和s2 中都引用了，但在内存中却只有一份拷贝，这与静态变量性质相当神似。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt;int main() { const char *b = NULL, *c = NULL; char a[] = \u0026#34;hello world!\u0026#34;; b = \u0026#34;hello world!\u0026#34;; c = \u0026#34;hello world!\u0026#34;; printf(\u0026#34;%p\\n\u0026#34;, a); printf(\u0026#34;%p\\n\u0026#34;, b); printf(\u0026#34;%p\\n\u0026#34;, c); printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;(\u0026#34;hello world!\u0026#34;)); } 输出：\nStart 0x7ffca882ddf3 0x400d40 0x400d40 0x400d40 0 Finish ","permalink":"https://874656645.github.io/rick/posts/23-c++-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8/","summary":"局部变量、静态局部变量、全局变量、全局静态变量、字符串常量以及动态申请的内存区\n 局部变量存储在栈中 全局变量、静态变量（全局和局部静态变量）存储在静态存储区 new申请的内存是在堆中 字符串常量也是存储在静态存储区   栈中的变量内存会随着定义所在区间的结束自动释放；而对于堆，需要手动free，否则它就一直存在，直到程序结束； 对于静态存储区，其中的变量常量在程序运行期间会一直存在，不会释放，且变量常量在其中只有一份拷贝，不会出现相同的变量和常量的不同拷贝。  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt; using namespace std; //返回的是局部变量的地址，该地址位于动态数据区，栈里 char *s1() { char* p1 = \u0026#34;qqq\u0026#34;;//为了测试‘char p[]=\u0026#34;Hello world!\u0026#34;’中的字符串在静态存储区是否也有一份拷贝  char p[]=\u0026#34;Hello world!\u0026#34;; char* p2 = \u0026#34;w\u0026#34;;//为了测试‘char p[]=\u0026#34;Hello world!\u0026#34;’中的字符串在静态存储区是否也有一份拷贝  printf(\u0026#34;in s1 p=%p\\n\u0026#34;, p); printf(\u0026#34;in s1 p1=%p\\n\u0026#34;, p1); printf(\u0026#34;in s1: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!\u0026#34;)); printf(\u0026#34;in s1 p2=%p\\n\u0026#34;, p2); return p1; // 这里不能返回局部变量 p } //返回的是字符串常量的地址，该地址位于静态数据区 char *s2() { char *q=\u0026#34;Hello world!\u0026#34;; printf(\u0026#34;in s2 q=%p\\n\u0026#34;, q); printf(\u0026#34;in s2: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!","title":"C++ 字符串常量存储"},{"content":"1、const 修饰指针和引用 常对象：const Class A 只能调用 const 成员函数\n常量指针：const int * 所指的地址内容为 常量只读，但是可指向其它对象的地址（可以重指向）\n指针常量：int * const 指针所指的地址不能变（不可以重指向），但地址的内容可以被修改，与引用变量效果类似\n常量引用：const int \u0026amp; 相当于是对象的一个别名，对象内容为 只读，并且不能指向其它对象\nconst int \u0026amp;a = 40 与 constexpr int a = 40 效果类似，但后者只能在全局区声明\nconst int \u0026amp;a = 40 等同于 const int * const a = new int(40)（指针的指向和存放的内容都不可更改）\nClassA myA(10), myB(-10); const ClassA a; // 常对象（只能调用常成员函数） const ClassA * b = \u0026amp;myA; // 常量指针 ClassA * const b = \u0026amp;myA; // 指针常量 const ClassA \u0026amp;bb = myB; // 常量引用  b = \u0026amp;myB; // 合法（可以指向其它对象） b-\u0026gt;setA(10); // 错误（只读） bb.setA(100); // 错误（只读） bb = myA; // 错误（不可指向其它对象） char greet[] = \u0026#34;Hello\u0026#34;, w[] = \u0026#34;World\u0026#34;; const char * p = greet; char * const pp = greet; cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; *p = \u0026#39;W\u0026#39;; //error: assignment of read-only location \u0026#39;* p\u0026#39;  // *p = \u0026#39;W\u0026#39;; p = w; // 合法（常量指针可以改变指向，不能改变存储的内容） pp = w; //error: assignment of read-only variable \u0026#39;pp\u0026#39;  // pp = w; *pp = \u0026#39;W\u0026#39;; // 合法（指针常量可以改变存储的内容，不能改变指向） cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; w \u0026lt;\u0026lt; endl; return 0; 2、const变量存放位置  局部变量存放在栈区 对于全局对象，编译期一般不分配内存，放在符号表中以提高访问效率 对于字面值常量，存放在常量存储区  ","permalink":"https://874656645.github.io/rick/posts/22-const-%E4%BF%AE%E9%A5%B0%E7%AC%A6/","summary":"1、const 修饰指针和引用 常对象：const Class A 只能调用 const 成员函数\n常量指针：const int * 所指的地址内容为 常量只读，但是可指向其它对象的地址（可以重指向）\n指针常量：int * const 指针所指的地址不能变（不可以重指向），但地址的内容可以被修改，与引用变量效果类似\n常量引用：const int \u0026amp; 相当于是对象的一个别名，对象内容为 只读，并且不能指向其它对象\nconst int \u0026amp;a = 40 与 constexpr int a = 40 效果类似，但后者只能在全局区声明\nconst int \u0026amp;a = 40 等同于 const int * const a = new int(40)（指针的指向和存放的内容都不可更改）\nClassA myA(10), myB(-10); const ClassA a; // 常对象（只能调用常成员函数） const ClassA * b = \u0026amp;myA; // 常量指针 ClassA * const b = \u0026amp;myA; // 指针常量 const ClassA \u0026amp;bb = myB; // 常量引用  b = \u0026amp;myB; // 合法（可以指向其它对象） b-\u0026gt;setA(10); // 错误（只读） bb.","title":"const 修饰符"},{"content":" 路径中有空格  m_process-\u0026gt;startDetached(strAppDir + \u0026quot;/ThreeDScreen.exe\u0026quot;, QStringList())\n杀死一个进程（注：-t 参数会将创建的子进程一起杀死）  QProcess::startDetached(\u0026quot;taskkill -t -f /IM iexplore.exe\u0026quot;);\n","permalink":"https://874656645.github.io/rick/posts/21-qprocess-%E4%BD%BF%E7%94%A8/","summary":"路径中有空格  m_process-\u0026gt;startDetached(strAppDir + \u0026quot;/ThreeDScreen.exe\u0026quot;, QStringList())\n杀死一个进程（注：-t 参数会将创建的子进程一起杀死）  QProcess::startDetached(\u0026quot;taskkill -t -f /IM iexplore.exe\u0026quot;);","title":"QProcess 使用"},{"content":" QString使用的是UTF-8编码 从字符常量中获取中文  QString msg = QString::fromLocal8Bit(\u0026quot;This is a debug message at 中文\u0026quot;);\n以QString做为形参变量传递  qDebug(msg.toUtf8());\nQString与操作系统间读写，会自动将UTF-8与操作系统的编码做转换（比如日志系统）  void QtLog::WriteLine(const QString \u0026amp;logFileName, const QString \u0026amp;logMsg) { QFile file(logFileName); file.open(QIODevice::WriteOnly | QIODevice::Append); QTextStream text_stream(\u0026amp;file); text_stream \u0026lt;\u0026lt; logMsg \u0026lt;\u0026lt; \u0026#34;\\r\\n\u0026#34;; file.flush(); file.close(); } QString strAppDir = QCoreApplication::applicationDirPath(); // 不用转码  QString message, text, fileName = strAppDir + \u0026#34;/Log/\u0026#34;; QDir dir(fileName); if (!dir.exists()) { // 注：不能创建两级文件夹  bool ismkdir = dir.mkdir(fileName); } ","permalink":"https://874656645.github.io/rick/posts/20-qstring-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","summary":" QString使用的是UTF-8编码 从字符常量中获取中文  QString msg = QString::fromLocal8Bit(\u0026quot;This is a debug message at 中文\u0026quot;);\n以QString做为形参变量传递  qDebug(msg.toUtf8());\nQString与操作系统间读写，会自动将UTF-8与操作系统的编码做转换（比如日志系统）  void QtLog::WriteLine(const QString \u0026amp;logFileName, const QString \u0026amp;logMsg) { QFile file(logFileName); file.open(QIODevice::WriteOnly | QIODevice::Append); QTextStream text_stream(\u0026amp;file); text_stream \u0026lt;\u0026lt; logMsg \u0026lt;\u0026lt; \u0026#34;\\r\\n\u0026#34;; file.flush(); file.close(); } QString strAppDir = QCoreApplication::applicationDirPath(); // 不用转码  QString message, text, fileName = strAppDir + \u0026#34;/Log/\u0026#34;; QDir dir(fileName); if (!dir.exists()) { // 注：不能创建两级文件夹  bool ismkdir = dir.mkdir(fileName); } ","title":"QString 中文乱码"},{"content":"1、设置IE为单进程模式  64位操作系统的 IE 默认每个 Tab 页都是一个进程，并且 Tab 页的进程是 32 位的，主进程是 64 位的，如下图所示  值为0时是单进程模式，1是多进程\n","permalink":"https://874656645.github.io/rick/posts/19-ie64-%E4%BD%8D%E6%8F%92%E4%BB%B6/","summary":"1、设置IE为单进程模式  64位操作系统的 IE 默认每个 Tab 页都是一个进程，并且 Tab 页的进程是 32 位的，主进程是 64 位的，如下图所示  值为0时是单进程模式，1是多进程","title":"IE 64位插件"},{"content":"1、查看纹理 渲染——材质编辑器——精简材质编辑器\n2、合并Mesh——附加 3、资源跟踪器快捷键 Shift + T ","permalink":"https://874656645.github.io/rick/posts/18-3dmax-%E6%93%8D%E4%BD%9C/","summary":"1、查看纹理 渲染——材质编辑器——精简材质编辑器\n2、合并Mesh——附加 3、资源跟踪器快捷键 Shift + T ","title":"3DMax 操作"},{"content":"1、随机数 python 脚本\nimport random def randNum(): res = random.randint(1, 7) return res 2、自增 python 脚本\ntotal = 0 def accumulate(increment): global total if total: total += increment else: total = increment return total ","permalink":"https://874656645.github.io/rick/posts/17-arcgis-%E5%AD%97%E6%AE%B5%E9%9A%8F%E6%9C%BA%E6%95%B0/","summary":"1、随机数 python 脚本\nimport random def randNum(): res = random.randint(1, 7) return res 2、自增 python 脚本\ntotal = 0 def accumulate(increment): global total if total: total += increment else: total = increment return total ","title":"ArcGIS 字段计算（自增、随机数）"},{"content":"1、随机数 SQL 脚本\nupdate \u0026#34;CYBuildings2\u0026#34; set \u0026#34;imgIndex\u0026#34; = FLOOR(1 + (RANDOM()+9223372036854775808)/2.0/9223372036854775808 * 7); ","permalink":"https://874656645.github.io/rick/posts/16-sqlite-%E9%9A%8F%E6%9C%BA%E6%95%B0/","summary":"1、随机数 SQL 脚本\nupdate \u0026#34;CYBuildings2\u0026#34; set \u0026#34;imgIndex\u0026#34; = FLOOR(1 + (RANDOM()+9223372036854775808)/2.0/9223372036854775808 * 7); ","title":"Sqlite 随机数"},{"content":"查看库的版本（win32 or 64） 1、通过 vs 自带工具 dumpbin.exe dumpbin.exe /headers dll文件路径\n2、使用 notepad++ 直接用 记事本 或者 notepad++ 打开exe文件（dll文件），会有很多乱码，不要头疼，接下来只需要在第二段中找到 PE 两个字母，在其后的不远出会出现d 或者L。若是d，则证明该程序是64位；若是L，则证明是32位。\n","permalink":"https://874656645.github.io/rick/posts/15-%E6%9F%A5%E7%9C%8B-dll-%E7%89%88%E6%9C%AC/","summary":"查看库的版本（win32 or 64） 1、通过 vs 自带工具 dumpbin.exe dumpbin.exe /headers dll文件路径\n2、使用 notepad++ 直接用 记事本 或者 notepad++ 打开exe文件（dll文件），会有很多乱码，不要头疼，接下来只需要在第二段中找到 PE 两个字母，在其后的不远出会出现d 或者L。若是d，则证明该程序是64位；若是L，则证明是32位。","title":"查看 dll 版本"},{"content":"miniconda包管理器常用命令 0、指定conda的工作平台 set CONDA_FORCE_32BIT=1 // 指定 conda 的工作平台为 win-32\nset CONDA_FORCE_32BIT= // 指定 conda 的工作平台为 x64\n1、指定conda的资源镜像 # 推荐使用中科大的 conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free # 清华的镜像好像用不了了 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free # 设置搜索时显示通道地址 conda config --set show_channel_urls yes 执行此命令后会在当前的用户文件夹下生成一个 .condarc 的配置文件\n2、搜索某个库的所有版本 conda search gdal\n3、查看当前环境下已安装的包 conda list\n4、创建一个虚拟环境 conda create --name python34 python=3.4\n5、激活某个环境 activate python34 // for windows\nsource activate python34 // for Linux \u0026amp; Mac\n6、取消激活 conda deactivate // for windows\nsource conda deactivate // for Linux \u0026amp; Mac\n7、删除一个环境 conda remove --name python34 --all\n8、查看已安装的环境 conda info -e\n9、查看当前激活环境下的安装包 conda list\n10、查看某个指定环境的安装包 conda list -n python34\n11、安装到当前激活环境 conda install gdal\n12、安装到指定环境 conda install -n python34 numpy\n13、清理 conda clean -p // 删除没有用的包\nconda clean -t // 删除tar打包\n14、查看帮助 conda --help conda -h conda env -h conda update -h 15、查看当前所有环境 conda info --envs\n","permalink":"https://874656645.github.io/rick/posts/14-conda-learn/","summary":"miniconda包管理器常用命令 0、指定conda的工作平台 set CONDA_FORCE_32BIT=1 // 指定 conda 的工作平台为 win-32\nset CONDA_FORCE_32BIT= // 指定 conda 的工作平台为 x64\n1、指定conda的资源镜像 # 推荐使用中科大的 conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free # 清华的镜像好像用不了了 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free # 设置搜索时显示通道地址 conda config --set show_channel_urls yes 执行此命令后会在当前的用户文件夹下生成一个 .condarc 的配置文件\n2、搜索某个库的所有版本 conda search gdal\n3、查看当前环境下已安装的包 conda list\n4、创建一个虚拟环境 conda create --name python34 python=3.4\n5、激活某个环境 activate python34 // for windows\nsource activate python34 // for Linux \u0026amp; Mac\n6、取消激活 conda deactivate // for windows","title":"Conda Learn"},{"content":"win10 小娜开始菜单无法搜索应用 1.用管理员权限打开 powershell.exe 或者 cmd;\n2.在其中输入下列命令，重新注册激活小娜\nGet-AppXPackage -Name Microsoft.Windows.Cortana | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register \u0026quot;$($_.InstallLocation)\\AppXManifest.xml\u0026quot;}\n","permalink":"https://874656645.github.io/rick/posts/13-restart-cortana/","summary":"win10 小娜开始菜单无法搜索应用 1.用管理员权限打开 powershell.exe 或者 cmd;\n2.在其中输入下列命令，重新注册激活小娜\nGet-AppXPackage -Name Microsoft.Windows.Cortana | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register \u0026quot;$($_.InstallLocation)\\AppXManifest.xml\u0026quot;}","title":"Restart Cortana"},{"content":"cmake命令\n1、生成 VS 2015 win64 版本的解决方案 注：下面的命令要在cmd下使用，power shell不可以\ncmake -H. -B./cmk_build/Win64 -G \u0026quot;Visual Studio 15 2017 Win64\u0026quot;\n2、指定目标版本 cmake -D CMAKE_SYSTEM_VERSION=8.1 -H. -B./cmk_build/Win64 -G \u0026quot;Visual Studio 15 2017 Win64\u0026quot;\n3、使用 MinGW 编译器 cmake -H. -B./cmk_build/MinGW -G \u0026quot;MinGW Makefiles\u0026quot;\n","permalink":"https://874656645.github.io/rick/posts/12-cmake-learn/","summary":"cmake命令\n1、生成 VS 2015 win64 版本的解决方案 注：下面的命令要在cmd下使用，power shell不可以\ncmake -H. -B./cmk_build/Win64 -G \u0026quot;Visual Studio 15 2017 Win64\u0026quot;\n2、指定目标版本 cmake -D CMAKE_SYSTEM_VERSION=8.1 -H. -B./cmk_build/Win64 -G \u0026quot;Visual Studio 15 2017 Win64\u0026quot;\n3、使用 MinGW 编译器 cmake -H. -B./cmk_build/MinGW -G \u0026quot;MinGW Makefiles\u0026quot;","title":"Cmake Learn"},{"content":"vcpkg安装及使用\n注意：需要安装vs的英文语言包1、指定 vcpkg 中 msvc 的编译版本 在 vcpkg/triplets/文件夹下的所有cmake文件中添加代码 set(VCPKG_PLATFORM_TOOLSET v140)\n如果同时安装了vs2017，需要确保安装vs2017的英文语言包\n","permalink":"https://874656645.github.io/rick/posts/11-vcpkg-learn/","summary":"vcpkg安装及使用\n注意：需要安装vs的英文语言包1、指定 vcpkg 中 msvc 的编译版本 在 vcpkg/triplets/文件夹下的所有cmake文件中添加代码 set(VCPKG_PLATFORM_TOOLSET v140)\n如果同时安装了vs2017，需要确保安装vs2017的英文语言包","title":"Vcpkg Learn"},{"content":"Power shell执行策略 原文网址\n1、查看当前的安全策略 Get-ExecutionPolicy\n2、修改执行策略 ps:这种方法会将执行策略保存到注册表\nSet-ExecutionPolicy UnRestricted\nor\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned\n3、查看所有支持的执行策略 [System.Enum]::GetNames([Microsoft.PowerShell.ExecutionPolicy])\n4、获取影响当前会话的所有执行策略 Get-ExecutionPolicy -List\n6、为当前 Windows PowerShell 会话设置执行策略 PowerShell.exe -ExecutionPolicy RemoteSigned\n","permalink":"https://874656645.github.io/rick/posts/10-power-shell-executionpolicy/","summary":"Power shell执行策略 原文网址\n1、查看当前的安全策略 Get-ExecutionPolicy\n2、修改执行策略 ps:这种方法会将执行策略保存到注册表\nSet-ExecutionPolicy UnRestricted\nor\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned\n3、查看所有支持的执行策略 [System.Enum]::GetNames([Microsoft.PowerShell.ExecutionPolicy])\n4、获取影响当前会话的所有执行策略 Get-ExecutionPolicy -List\n6、为当前 Windows PowerShell 会话设置执行策略 PowerShell.exe -ExecutionPolicy RemoteSigned","title":"Power Shell ExecutionPolicy"},{"content":"1、使用requests库访问网址 2、使用xpath技术提取网页目标图片网址 3、通过os库保存图片到本地 #coding = utf-8 import requests import os from lxml import etree from urllib.parse import quote,unquote # import urllib.request class DmdSpider(object): name = \u0026#34;dmd\u0026#34; save_path = \u0026#39;E:/python/manhuadao/pics/\u0026#39; __picNo = 0 # 访问漫画岛网页 def start_request(self, url): header = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\u0026#39;} r = requests.get(url, params=header) # print(r.text) self.__get_imgs(r) # 自动跳转下一页 html = etree.HTML(r.text) next_urls = html.xpath(\u0026#39;//div[@class=\u0026#34;read-bottom\u0026#34;]//a[@class=\u0026#34;next\u0026#34;]/@href\u0026#39;) # print(next) for href in next_urls: nexturl = href.split(\u0026#39;=\u0026#39;)[-1] self.start_request(unquote(nexturl)) # 使用xpath提取网页中的图片网址 def __get_imgs(self, resbonse): html = etree.HTML(resbonse.text) # print(html) # result = etree.tostring(html) # print(result.decode(\u0026#34;utf-8\u0026#34;)) img_srcs = html.xpath(\u0026#39;//div[@class=\u0026#34;center-t\u0026#34;]//div[@class=\u0026#34;main-content\u0026#34;]//img/@src\u0026#39;) # print(img_srcs) for url in img_srcs: self.__save_img(url) # 下载图片 def __save_img(self, url): # arr = url.split(\u0026#39;-\u0026#39;) # picName = arr[-1].split(\u0026#39;.\u0026#39;)[0] header = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\u0026#39;} # request = urllib.request.Request(url, None, header)  # response = urllib.request.urlopen(request) # with open(\u0026#39;E:/python/manhuadao/pics/%s.jpg\u0026#39; %picName, \u0026#34;wb\u0026#34;) as f: # f.write(response.read()) # print(response) response = requests.get(url, params = header) # print(response.content) if not os.path.exists(self.save_path): os.makedirs(self.save_path) with open(self.save_path + \u0026#39;%s.jpg\u0026#39;%self.__picNo, \u0026#34;wb\u0026#34;) as f: f.write(response.content) self.__picNo = self.__picNo + 1 def main(): dmd = DmdSpider() dmd.start_request(\u0026#39;http://www.manhuadao.cn/Comic/ComicView?comicid=58df8c73d401da325c9cf77c\u0026amp;chapterid=9587480\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: main() ","permalink":"https://874656645.github.io/rick/posts/9-crawl-pictures-from-website/","summary":"1、使用requests库访问网址 2、使用xpath技术提取网页目标图片网址 3、通过os库保存图片到本地 #coding = utf-8 import requests import os from lxml import etree from urllib.parse import quote,unquote # import urllib.request class DmdSpider(object): name = \u0026#34;dmd\u0026#34; save_path = \u0026#39;E:/python/manhuadao/pics/\u0026#39; __picNo = 0 # 访问漫画岛网页 def start_request(self, url): header = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\u0026#39;} r = requests.get(url, params=header) # print(r.text) self.__get_imgs(r) # 自动跳转下一页 html = etree.HTML(r.text) next_urls = html.xpath(\u0026#39;//div[@class=\u0026#34;read-bottom\u0026#34;]//a[@class=\u0026#34;next\u0026#34;]/@href\u0026#39;) # print(next) for href in next_urls: nexturl = href.","title":"Crawl Pictures From Website"},{"content":"原文网址\n在python中使用virtualenv创建虚拟环境 注意：要使用cmd命令行，不能使用Power Shell1、使用pip安装 pip install virtualenv\n2、创建项目目录并用cd进入 mkdir E:\\python\\Virtualenv cd E:\\python\\Virtualenv 3、创建虚拟环境 virtualenv -p c:\\Python36\\python.exe env\n或者\nvirtualenv env\n此命令会在当前目录下创建一个env目录\n4、启动虚拟环境 env\\Scripts\\activate\n5、离开虚拟环境 deactivate\n6、删除env文件夹即可 ","permalink":"https://874656645.github.io/rick/posts/8-python-virtualenv/","summary":"原文网址\n在python中使用virtualenv创建虚拟环境 注意：要使用cmd命令行，不能使用Power Shell1、使用pip安装 pip install virtualenv\n2、创建项目目录并用cd进入 mkdir E:\\python\\Virtualenv cd E:\\python\\Virtualenv 3、创建虚拟环境 virtualenv -p c:\\Python36\\python.exe env\n或者\nvirtualenv env\n此命令会在当前目录下创建一个env目录\n4、启动虚拟环境 env\\Scripts\\activate\n5、离开虚拟环境 deactivate\n6、删除env文件夹即可 ","title":"Python Virtualenv"},{"content":"原文网址\n1. Using a virtual environment (recommended) pip install virtualenv\n详细操作\n2. Creating a new Scrapy project scrapy startproject tutorial\n3. Writing a spider to crawl a site and extract data This is the code for our first Spider. Save it in a file named quotes_spider.py under the tutorial/spiders directory in your project:\nimport scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; def start_requests(self): urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, \u0026#39;http://quotes.toscrape.com/page/2/\u0026#39;, ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self, response): page = response.url.split(\u0026#34;/\u0026#34;)[-2] filename = \u0026#39;quotes-%s.html\u0026#39; % page with open(filename, \u0026#39;wb\u0026#39;) as f: f.write(response.body) self.log(\u0026#39;Saved file %s\u0026#39; % filename) 3.1 Extracting data in our spider import scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; start_urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, \u0026#39;http://quotes.toscrape.com/page/2/\u0026#39;, ] def parse(self, response): for quote in response.css(\u0026#39;div.quote\u0026#39;): yield { \u0026#39;text\u0026#39;: quote.css(\u0026#39;span.text::text\u0026#39;).get(), \u0026#39;author\u0026#39;: quote.css(\u0026#39;small.author::text\u0026#39;).get(), \u0026#39;tags\u0026#39;: quote.css(\u0026#39;div.tags a.tag::text\u0026#39;).getall(), } 3.2 Storing the scraped data scrapy crawl quotes -o quotes.json\nor\nscrapy crawl quotes -o quotes.jl\n4. Exporting the scraped data using the command line scrapy crawl quotes\n5. Changing spider to recursively follow links import scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; start_urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, ] def parse(self, response): for quote in response.css(\u0026#39;div.quote\u0026#39;): yield { \u0026#39;text\u0026#39;: quote.css(\u0026#39;span.text::text\u0026#39;).get(), \u0026#39;author\u0026#39;: quote.css(\u0026#39;small.author::text\u0026#39;).get(), \u0026#39;tags\u0026#39;: quote.css(\u0026#39;div.tags a.tag::text\u0026#39;).getall(), } next_page = response.css(\u0026#39;li.next a::attr(href)\u0026#39;).get() if next_page is not None: next_page = response.urljoin(next_page) yield scrapy.Request(next_page, callback=self.parse) 5.1 A shortcut for creating Requests import scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; start_urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, ] def parse(self, response): for quote in response.css(\u0026#39;div.quote\u0026#39;): yield { \u0026#39;text\u0026#39;: quote.css(\u0026#39;span.text::text\u0026#39;).get(), \u0026#39;author\u0026#39;: quote.css(\u0026#39;span small::text\u0026#39;).get(), \u0026#39;tags\u0026#39;: quote.css(\u0026#39;div.tags a.tag::text\u0026#39;).getall(), } next_page = response.css(\u0026#39;li.next a::attr(href)\u0026#39;).get() if next_page is not None: yield response.follow(next_page, callback=self.parse) 6. Using spider arguments scrapy crawl quotes -o quotes-humor.json -a tag=humor\nimport scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; def start_requests(self): url = \u0026#39;http://quotes.toscrape.com/\u0026#39; tag = getattr(self, \u0026#39;tag\u0026#39;, None) if tag is not None: url = url + \u0026#39;tag/\u0026#39; + tag yield scrapy.Request(url, self.parse) def parse(self, response): for quote in response.css(\u0026#39;div.quote\u0026#39;): yield { \u0026#39;text\u0026#39;: quote.css(\u0026#39;span.text::text\u0026#39;).get(), \u0026#39;author\u0026#39;: quote.css(\u0026#39;small.author::text\u0026#39;).get(), } next_page = response.css(\u0026#39;li.next a::attr(href)\u0026#39;).get() if next_page is not None: yield response.follow(next_page, self.parse) ","permalink":"https://874656645.github.io/rick/posts/7-scrapy-learn/","summary":"原文网址\n1. Using a virtual environment (recommended) pip install virtualenv\n详细操作\n2. Creating a new Scrapy project scrapy startproject tutorial\n3. Writing a spider to crawl a site and extract data This is the code for our first Spider. Save it in a file named quotes_spider.py under the tutorial/spiders directory in your project:\nimport scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; def start_requests(self): urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, \u0026#39;http://quotes.toscrape.com/page/2/\u0026#39;, ] for url in urls: yield scrapy.","title":"Scrapy Learn"},{"content":"1. 配置npm镜像源 1.1 临时使用 npm --registry https://registry.npm.taobao.org install --save-dev electron\n1.2 持久使用 npm config set registry https://registry.npm.taobao.org\n1.3 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info electron 1.4 通过cnpm使用 npm install -g cnpm --registry=https://registry.npm.taobao.org\n1.5 使用 cnpm install express\n","permalink":"https://874656645.github.io/rick/posts/6-npm-commond-learning/","summary":"1. 配置npm镜像源 1.1 临时使用 npm --registry https://registry.npm.taobao.org install --save-dev electron\n1.2 持久使用 npm config set registry https://registry.npm.taobao.org\n1.3 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info electron 1.4 通过cnpm使用 npm install -g cnpm --registry=https://registry.npm.taobao.org\n1.5 使用 cnpm install express","title":"Npm Commond Learning"},{"content":"1. Use npm run example 1.1 Clone repository git clone https://github.com/electron/electron-quick-start\n1.2 Go into the repository cd electron-quick-start\n1.3 Install dependencies PS:为了加快下载依赖模块的速度，通过修改镜像源ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ npm install\n或者是\nnpm install --registry=https://registry.npm.taobao.org\n1.4 Run the app npm start\n2. Use yarn create a electron program 2.1 Create a program folder md electron-yarn-cz\n进入项目文件夹\ncd electron-yarn-cz\n2.2 Create a program config file yarn init\n2.3 Instal electron environment yarn add electron --dev --registry=https://registry.npm.taobao.org\n2.4 Add main.js and index.html 2.5 Edit package.json file \u0026#34;main\u0026#34;: \u0026#34;main.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;electron .\u0026#34; } 3. 打包项目 _推荐devtron 和 electron-builder 2个开发工具，配置简单，功能强大\n3.1 添加打包模块 yarn add electron-builder --dev\n3.2 在package.js中添加命令 \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;electron .\u0026#34;, \u0026#34;pack\u0026#34;: \u0026#34;electron-builder --dir\u0026#34;, \u0026#34;dist\u0026#34;: \u0026#34;electron-builder\u0026#34; } 3.3 运行 yarn dist ","permalink":"https://874656645.github.io/rick/posts/5-learn-electron/","summary":"1. Use npm run example 1.1 Clone repository git clone https://github.com/electron/electron-quick-start\n1.2 Go into the repository cd electron-quick-start\n1.3 Install dependencies PS:为了加快下载依赖模块的速度，通过修改镜像源ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ npm install\n或者是\nnpm install --registry=https://registry.npm.taobao.org\n1.4 Run the app npm start\n2. Use yarn create a electron program 2.1 Create a program folder md electron-yarn-cz\n进入项目文件夹\ncd electron-yarn-cz\n2.2 Create a program config file yarn init\n2.3 Instal electron environment yarn add electron --dev --registry=https://registry.npm.taobao.org\n2.4 Add main.","title":"Learn Electron"},{"content":"win10查看端口使用情况 1. 察看所有已使用的端口 netstat -ano\n2. 查看特定端口的使用 netstat -ano|findstr \u0026quot;443\u0026quot;\n3. 查看占用端口的进程PID tasklist|findstr \u0026quot;7648\u0026quot;\n","permalink":"https://874656645.github.io/rick/posts/4-netstat/","summary":"win10查看端口使用情况 1. 察看所有已使用的端口 netstat -ano\n2. 查看特定端口的使用 netstat -ano|findstr \u0026quot;443\u0026quot;\n3. 查看占用端口的进程PID tasklist|findstr \u0026quot;7648\u0026quot;","title":"Netstat"},{"content":"一、Git 常用命令 1、初始化本地仓库  适合远程仓库是空仓库  cd public git init git remote add blog https://github.com/874656645/rick  如果新建的仓库有东西，最好先克隆到本地，再向里面添加文件  git clone https://github.com/adityatelange/hugo-PaperMod.git\n 克隆含有子仓库的代码  git clone -b exampleSite --recursive https://github.com/adityatelange/hugo-PaperMod.git\n 克隆某一个分支  git clone -b exampleSite https://github.com/adityatelange/hugo-PaperMod.git\n2、更新远程仓库代码到本地 git pull blog master\n3、将变化提交到本地仓库 git commit -m \u0026quot;delete all files\u0026quot;\ngit commit -am \u0026quot;update\u0026quot;\n4、push推送到远程仓库 git push blog master\n5、添加远程仓库别名和网址 git remote add blog https://github.com/874656645/rick\n6、删除配置的远程仓库别名 git remote remove blog\n7、添加文件 git add -A\n8、删除文件 git rm *\n9、删除远程仓库中的文件、文件夹 git rm -r --cached \u0026quot;*.*\u0026quot;\n*.*表示全部文件和文件夹，如果想删除具体的文件或文件夹，使用具体的名称就可以了\n10、查看所有分支并切换 git branch -a\ngit branch -r\ngit checkout dev5\n11、删除远程分支 git push blog --delete name\n12、解决failed to push some refs to git git pull --rebase blog master\n13、不需验证用户名和密码 执行如下命令\ngit config --global credential.helper store\n此命令会在 .gitconfig 文件中添加如下文本\n[credential] helper = store 14、重新输入用户名和密码 git config --system --unset credential.helper\n或者把上面文件中的 store 删掉\n15、添加子仓库 git submodule add \u0026lt;仓库地址\u0026gt; \u0026lt;本地路径\u0026gt;\n添加成功后，在父仓库根目录增加了 .gitmodule 文件，并且在父仓库的 git 配置文件中加入了 submodule 段\n16、checkout 子仓库 git submodule update --init --recursive\ngit submodule init\ngit submodule update\n17、删除子模块 git submodule deinit {MOD_NAME}\n逆初始化模块，其中 {MOD_NAME} 为模块目录，执行后可发现模块目录被清空\ngit rm --cached {MOD_NAME}\n删除 .gitmodules 中记录的模块信息（\u0026ndash;cached 选项清除 .git/modules 中的缓存）\n但是测试有问题， git 配置文件中的 submodule 段和*.git/modules* 中仍有缓存\n18、常用命令 二、连接超时的情况   修改 windows 的 host 文件，win + R 打开运行，输入 drivers，在 etc 目录下找到 host 文件，添加如下内容（注：ip 地址可通过此网站查询）：\n140.82.112.3 github.com git 199.232.69.194 github.global.ssl.fastly.net   还要能科学上网\n  打开 cmd，尝试能否 ping 通 ping github.com\n  ","permalink":"https://874656645.github.io/rick/posts/3-git-commond/","summary":"一、Git 常用命令 1、初始化本地仓库  适合远程仓库是空仓库  cd public git init git remote add blog https://github.com/874656645/rick  如果新建的仓库有东西，最好先克隆到本地，再向里面添加文件  git clone https://github.com/adityatelange/hugo-PaperMod.git\n 克隆含有子仓库的代码  git clone -b exampleSite --recursive https://github.com/adityatelange/hugo-PaperMod.git\n 克隆某一个分支  git clone -b exampleSite https://github.com/adityatelange/hugo-PaperMod.git\n2、更新远程仓库代码到本地 git pull blog master\n3、将变化提交到本地仓库 git commit -m \u0026quot;delete all files\u0026quot;\ngit commit -am \u0026quot;update\u0026quot;\n4、push推送到远程仓库 git push blog master\n5、添加远程仓库别名和网址 git remote add blog https://github.com/874656645/rick\n6、删除配置的远程仓库别名 git remote remove blog","title":"Git Commond"},{"content":"使用 Hugo 创建静态网站 Hugo 官网 Hugo 中文网 网站皮肤\nStep1：创建站点 进入到 E:/Hugo/Sites文件夹\nhugo new site HugoLearning.com\ncd HugoLearning.com\ngit init\nStep2：添加样式主题 在皮肤列表挑选一个心仪的皮肤，找到相关的 GitHub 地址，创建目录 themes，在 themes 目录里把皮肤 git clone 下来\ngit submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke\n编辑 config.toml 配置文件\n最后一行添加 theme = \u0026quot;ananke\u0026quot;\n或者在命令行执行 echo 'theme = \u0026quot;ananke\u0026quot;' \u0026gt;\u0026gt; config.toml\nStep3：添加markdown文件内容 hugo new posts/Hello-Hugo.md\nhugo new --kind post posts/1-Papermod-Theme-中文.md\nNote: post is a kind of archetypes( post.md )\nStep4: 启动网站 hugo server -D\n然后输入控制台提示的网址，比如： http://localhost:1313/\nStep5：生成网站 命令行执行 hugo，在网站目录生成public文件夹，发布的网站文件都在这个文件中\n 注意：如果看不到内容，将md文件中的draft设置为false  Step5：将网站发布到 git 使用git工具将文件上传到远程仓库就可以了，仓库还需要做一些设置；\n","permalink":"https://874656645.github.io/rick/posts/2-hugo-create-a-new-site/","summary":"使用 Hugo 创建静态网站 Hugo 官网 Hugo 中文网 网站皮肤\nStep1：创建站点 进入到 E:/Hugo/Sites文件夹\nhugo new site HugoLearning.com\ncd HugoLearning.com\ngit init\nStep2：添加样式主题 在皮肤列表挑选一个心仪的皮肤，找到相关的 GitHub 地址，创建目录 themes，在 themes 目录里把皮肤 git clone 下来\ngit submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke\n编辑 config.toml 配置文件\n最后一行添加 theme = \u0026quot;ananke\u0026quot;\n或者在命令行执行 echo 'theme = \u0026quot;ananke\u0026quot;' \u0026gt;\u0026gt; config.toml\nStep3：添加markdown文件内容 hugo new posts/Hello-Hugo.md\nhugo new --kind post posts/1-Papermod-Theme-中文.md\nNote: post is a kind of archetypes( post.md )\nStep4: 启动网站 hugo server -D","title":"Hugo Create a New Site by Hugo"}]