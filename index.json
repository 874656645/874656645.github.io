[{"content":"  先序遍历\ntemplate\u0026lt;typename T\u0026gt; void PreOrder(BinaryTreeNode\u0026lt;T\u0026gt;* root){ stack\u0026lt;BinaryTreeNode\u0026lt;T\u0026gt;*\u0026gt; aStack; BinaryTreeNode\u0026lt;T\u0026gt;* pointer = root; aStack.push(nullptr); // 栈底监视哨  while(pointer){ // 或者 !aStack.empty()  Visit(pointer); // 访问当前结点  if(pointer-\u0026gt;rightchild() != nullptr){ // 右孩子入栈  aStack.push(pointer-\u0026gt;rightchild()); } if(pointer-\u0026gt;leftchild() != nullptr){ // 左路下降  pointer = pointer-\u0026gt;leftchild(); }else{ // 左子树访问完毕，转向访问右子树  pointer = aStack.top(); aStack.pop(); } } }   中序遍历\ntemplate\u0026lt;typename T\u0026gt; void InOrder(BinaryTreeNode\u0026lt;T\u0026gt;* root){ stack\u0026lt;BinaryTreeNode\u0026lt;T\u0026gt;*\u0026gt; aStack; BinaryTreeNode\u0026lt;T\u0026gt;* pointer = root; while(!aStack.empty() || pointer){ if(pointer){ // Visit(pointer); // 前序访问点  aStack.push(pointer); // 当前结点入栈  pointer = pointer-\u0026gt;leftchild(); // 指向左子树  } // endif  else{ // 左子树访问完毕，转向右子树  pointer = aStack.top(); aStack.pop(); // 栈顶元素退栈  Visit(pointer); // 访问当前结点  pointer = pointer-\u0026gt;rightchild(); // 转向右孩子  } // endelse  } // endwhile }   后序遍历\nenum class Tags{Left,Right}; // 枚举类型标志位 template\u0026lt;typename T\u0026gt; class StackElement{ BinaryTreeNode\u0026lt;T\u0026gt;* pointer; // 二叉树结点指针  Tags tag; // 标志位 }; template\u0026lt;typename T\u0026gt; void PostOrder(BinaryTreeNode\u0026lt;T\u0026gt;* root){ StackElement\u0026lt;T\u0026gt; element; stack\u0026lt;StackElement\u0026lt;T\u0026gt;\u0026gt; aStack; BinaryTreeNode\u0026lt;T\u0026gt;* pointer = root; while(!aStack.empty() || pointer){ while(pointer){ // 非空指针入栈，并沿左路下降  element.pointer = pointer; element.tag = Left; aStack.push(element); pointer = pointer-\u0026gt;leftchild(); } element = aStack.top(); aStack.pop(); pointer = element.pointer; if(element.tag == Left){ // 如果是从左子树返回  element.tag = Right; aStack.push(element); // 置标志位为 Right  pointer = pointer-\u0026gt;rightchild(); } // endif  else{ // 从右子树返回  Visit(pointer); // 访问当前结点  pointer = nullptr; // 将 pointer 置空，以继续弹栈  } // endelse  } // endwhile }   ","permalink":"https://874656645.github.io/posts/255-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/","summary":"先序遍历\ntemplate\u0026lt;typename T\u0026gt; void PreOrder(BinaryTreeNode\u0026lt;T\u0026gt;* root){ stack\u0026lt;BinaryTreeNode\u0026lt;T\u0026gt;*\u0026gt; aStack; BinaryTreeNode\u0026lt;T\u0026gt;* pointer = root; aStack.push(nullptr); // 栈底监视哨  while(pointer){ // 或者 !aStack.empty()  Visit(pointer); // 访问当前结点  if(pointer-\u0026gt;rightchild() != nullptr){ // 右孩子入栈  aStack.push(pointer-\u0026gt;rightchild()); } if(pointer-\u0026gt;leftchild() != nullptr){ // 左路下降  pointer = pointer-\u0026gt;leftchild(); }else{ // 左子树访问完毕，转向访问右子树  pointer = aStack.top(); aStack.pop(); } } }   中序遍历\ntemplate\u0026lt;typename T\u0026gt; void InOrder(BinaryTreeNode\u0026lt;T\u0026gt;* root){ stack\u0026lt;BinaryTreeNode\u0026lt;T\u0026gt;*\u0026gt; aStack; BinaryTreeNode\u0026lt;T\u0026gt;* pointer = root; while(!aStack.empty() || pointer){ if(pointer){ // Visit(pointer); // 前序访问点  aStack.","title":"数据结构与算法——二叉树遍历"},{"content":"一、相关概念   结点：根节、叶节点、分支结点、兄弟结点、父子结点\n  边、路径\n  结点深度、高度、层数\n 根节点为第 0 层 深度指从根节点到该节点的边的数量 高度指从此节点到叶节点的结点数量    满二叉树、完全二叉树\n 满二叉树指除了度为 0 的叶节点就是度为 2 的分支节点 完全二叉树指只有最下面的两层度是小于 2 的，且最下面的结点都集中在左侧    扩充二叉树\n  二叉树性质\n  ","permalink":"https://874656645.github.io/posts/254-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"一、相关概念   结点：根节、叶节点、分支结点、兄弟结点、父子结点\n  边、路径\n  结点深度、高度、层数\n 根节点为第 0 层 深度指从根节点到该节点的边的数量 高度指从此节点到叶节点的结点数量    满二叉树、完全二叉树\n 满二叉树指除了度为 0 的叶节点就是度为 2 的分支节点 完全二叉树指只有最下面的两层度是小于 2 的，且最下面的结点都集中在左侧    扩充二叉树\n  二叉树性质\n  ","title":"数据结构与算法——二叉树"},{"content":"  模式串 next 向量计算：\n  字符串比较\nint mystrcmp(const char* str1, const char* str2){ int i = 0; while(str1[i] == str2[i] \u0026amp;\u0026amp; str1[i] != \u0026#39;\\0\u0026#39;){ i++; } return str1[i] - str2[i]; }   ","permalink":"https://874656645.github.io/posts/253-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95kmp-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/","summary":"  模式串 next 向量计算：\n  字符串比较\nint mystrcmp(const char* str1, const char* str2){ int i = 0; while(str1[i] == str2[i] \u0026amp;\u0026amp; str1[i] != \u0026#39;\\0\u0026#39;){ i++; } return str1[i] - str2[i]; }   ","title":"数据结构与算法——KMP 字符串匹配算法"},{"content":"  新建项目的时候没有项目模板\n打开 Epic Games Launcher，在 虚幻引擎 -\u0026gt; 库 中选择需要添加组件的引擎版本，打开 选项 面板，勾选需要更改的组件\n  在 Play 模式下切换到鼠标控制\nShift + F1\n  Detaches from the player controller，通过鼠标操作场景和 Editor\nF8\n  指定源码开发工具\nEditor Preferences -\u0026gt; Source Code\n  C++ 代码编译\nEditor 右下角\n  C++ Live Coding 热编译\nCtrl + Alt + F11\n  C++ 项目中使用插件\n如果编译过程中提示错误 ERROR: Expecting to find a type to be declared in a module rules named \u0026lsquo;JsonLibrary\u0026rsquo; in UE5Rules\n在 C++ 项目根目录新建 Plugins 文件夹，并将项目中所使用到的插件目录拷贝到这里，编译器会首先使用当前工程中的插件配置\n解决思路参考这里\n  UE 5 中的 Lumen 系统和以前版本材质兼容问题\n打开材质编辑器，取消 Pixel Depth Offset 参数设置，Lumen 系统暂不支持该参数\n  ","permalink":"https://874656645.github.io/posts/252-unreal5-%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","summary":"新建项目的时候没有项目模板\n打开 Epic Games Launcher，在 虚幻引擎 -\u0026gt; 库 中选择需要添加组件的引擎版本，打开 选项 面板，勾选需要更改的组件\n  在 Play 模式下切换到鼠标控制\nShift + F1\n  Detaches from the player controller，通过鼠标操作场景和 Editor\nF8\n  指定源码开发工具\nEditor Preferences -\u0026gt; Source Code\n  C++ 代码编译\nEditor 右下角\n  C++ Live Coding 热编译\nCtrl + Alt + F11\n  C++ 项目中使用插件\n如果编译过程中提示错误 ERROR: Expecting to find a type to be declared in a module rules named \u0026lsquo;JsonLibrary\u0026rsquo; in UE5Rules","title":"Unreal5——开发、使用问题汇总"},{"content":"一、安装 Quixel Bridge   UE5 中已经集成了 Quixel Bridge 插件，不再需要单独安装（安装包），选择 编辑（Edit）\u0026gt; 插件（Plugins） 。在搜索栏中输入 bridge ，然后点击复选框以启用该插件。\n  如果在插件面板中未显示 Quixel Bridge 插件，需要从 Epic Games 启动程序（Epic Games Launcher） 安装它。打开 Epic Games 启动程序，点击 库（Library） ，然后向下滚动到名为 保管库（Vault） 的分割线。在搜索栏中输入 Bridge 。选择 安装到引擎（Install to Engine） 。重新启动引擎时，可以按如上所述启用该插件。\n  使用 EPIC GAME 账户 登录到 Quixel Bridge 并进行授权，加入 Unreal Unlimited 计划，如有需要，请科学上网\n  如果发现账户无法登录，采用下面的步骤解决：\n科学上网 如果已经运行，请关闭 Bridge； 导航到 C:\\Users[用户]\\AppData\\Roaming 删除 Bridge、Bridge-Bifrost、Megascans Bridge 三个文件夹 重新登录到 Bridge    二、在项目中导入资源   打开 Bridge 面板，搜索自己需要的资源，并将其下载到本地\n  下载完毕后，点旁边的 Add 按钮即可将资源添加到项目中，添加成功后，内容浏览器目录结构如下图所示\n  三、放置 3D 资源到场景   可以直接将缩略图下边为青色的静态网格模型拖拽到场景中，模型资产将自动沿着地面放置，提供了一个简单的方法自动放置在 Cesium World Terrain 模型上。要了解更多关于在 Cesium 中放置物体的信息，请访问 Cesium4Unreal——Place Objects On Globe\n  使用 UE 的植物系统，Quixel Bridge 的 3D Plants 资源提供 Foliage Type 资源（缩略图下边为绿色的部分），详细使用参考 Foliage tutorial\n  使用 Quixel Bridge 中的 Surface 材质\n参考创建地形 和地形材质图层混合\n  使用 Quixel Bridge 中的 Decals 贴花\n  参考：\n Importing Quixel Assets 虚幻引擎Quixel Bridge插件 【扫盲】QuixelBridge桥接管理器使用问题与解决  ","permalink":"https://874656645.github.io/posts/251-cesium-unreal-importing-quixel-assets/","summary":"一、安装 Quixel Bridge   UE5 中已经集成了 Quixel Bridge 插件，不再需要单独安装（安装包），选择 编辑（Edit）\u0026gt; 插件（Plugins） 。在搜索栏中输入 bridge ，然后点击复选框以启用该插件。\n  如果在插件面板中未显示 Quixel Bridge 插件，需要从 Epic Games 启动程序（Epic Games Launcher） 安装它。打开 Epic Games 启动程序，点击 库（Library） ，然后向下滚动到名为 保管库（Vault） 的分割线。在搜索栏中输入 Bridge 。选择 安装到引擎（Install to Engine） 。重新启动引擎时，可以按如上所述启用该插件。\n  使用 EPIC GAME 账户 登录到 Quixel Bridge 并进行授权，加入 Unreal Unlimited 计划，如有需要，请科学上网\n  如果发现账户无法登录，采用下面的步骤解决：\n科学上网 如果已经运行，请关闭 Bridge； 导航到 C:\\Users[用户]\\AppData\\Roaming 删除 Bridge、Bridge-Bifrost、Megascans Bridge 三个文件夹 重新登录到 Bridge    二、在项目中导入资源   打开 Bridge 面板，搜索自己需要的资源，并将其下载到本地","title":"Cesium4Unreal——Importing Quixel Assets"},{"content":"第一步：创建一个关卡  创建一个空的 Unreal 关卡； 登录 Cesium ion 并添加 Cesium World Terrain 和 CesiumSunSky； 设置 CesiumGeoreference 的坐标为 San Francisco International Airport (SFO)；\nOrigin Latitude = 37.61779\nOrigin Longitude = -122.390533\nOrigin Height = 0.0  第二步：添加 PlaneTrack 类   在 UE Editor 中添加 C++ 类，选择 Actor 作为父类，点击【下一步】，输入类名 PlaneTrack，点击【创建类】按钮，此时 Visual Studio 会自动打开，如果没有打开，可以通过【工具】——【打开Visual Studio】手动打开项目\nVS 2022 解决方案类似下图：\n  添加下面的代码到 project.Build.cs 文件：\n// Add Cesium for Unreal plugin dependency path PrivateDependencyModuleNames.AddRange(new string[] { \u0026#34;CesiumRuntime\u0026#34; }); // Tell Unreal Engine to use C++17 CppStandard = CppStandardVersion.Cpp17;   在 PlaneTrack 类中添加一些变量，用来存储数据、样条曲线和坐标转换，并添加必要的头文件：\n... // Add import paths. Make sure they go above the PlaneTrack.generated.h line #include \u0026#34;Components/SplineComponent.h\u0026#34;#include \u0026#34;CesiumGeoreference.h\u0026#34;#include \u0026#34;Engine/DataTable.h\u0026#34;... public: // Spline variable to represent the plane track UPROPERTY(BlueprintReadOnly, Category = \u0026#34;FlightTracker\u0026#34;) USplineComponent* SplineTrack; // Cesium class that contain many useful coordinate conversion functions UPROPERTY(EditAnywhere, Category = \u0026#34;FlightTracker\u0026#34;) ACesiumGeoreference* CesiumGeoreference; // An Unreal Engine data table to store the raw flight data UPROPERTY(EditAnywhere, Category = \u0026#34;FlightTracker\u0026#34;) UDataTable* AircraftsRawDataTable;   打开 PlaneTrack.cpp 文件，在构造函数中初始化 SplineTrack 变量；\nAPlaneTrack::APlaneTrack() { // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don\u0026#39;t need it.  PrimaryActorTick.bCanEverTick = true; // Initialize the track  SplineTrack = CreateDefaultSubobject\u0026lt;USplineComponent\u0026gt;(TEXT(\u0026#34;SplineTrack\u0026#34;)); // This lets us visualize the spline in Play mode  SplineTrack-\u0026gt;SetDrawDebug(true); // Set the color of the spline  SplineTrack-\u0026gt;SetUnselectedSplineSegmentColor(FLinearColor(1.f, 0.f, 0.f)); } CesiumGeoreference 和 AircraftsRawDataTable 变量将在 Unreal Engine Editor 中进行设置\n  编译\n在 UE4 Editor 中，可以点击【编译】按钮，但是 UE5 Editor 并未找到此工具按钮\nUE5 中可以通过两种方式进行编译：\n 通过 VS 启动本地调试，会打开一个 UE Editor，但停止调试后，UE Editor 也会退出。注意：此时工程不能是被 UE Editor 打开的状态，否则会报如下错误\nUnrealBuildTool : error : Unable to build while Live Coding is active. Exit the editor and game, or press Ctrl+Alt+F11 if iterating on code in the editor or game   通过 Ctrl+Alt+F11 快捷键在 Editor 或 game 中进行代码迭代热编译    第三步：导入真实的飞行数据 下载真实的飞行点位数据\n为了使 PlaneTrack 类能访问数据并执行坐标转换，我们将使用虚幻引擎的 DataTable 来存储项目内部的数据。在这一步中，我们将创建一个数据结构来表示飞行数据的结构。\n  在 PlaneTrack.h 文件中，将下面的代码直接插入到类的外面，用来定义航班数据库结构；\nUSTRUCT(BlueprintType) struct FAircraftRawData : public FTableRowBase { GENERATED_USTRUCT_BODY() public: FAircraftRawData() : Longitude(0.0) , Latitude(0.0) , Height(0.0) {} UPROPERTY(EditAnywhere, Category = \u0026#34;FlightTracker\u0026#34;) double Longitude; UPROPERTY(EditAnywhere, Category = \u0026#34;FlightTracker\u0026#34;) double Latitude; UPROPERTY(EditAnywhere, Category = \u0026#34;FlightTracker\u0026#34;) double Height; }; 该结构包含三个成员变量：Longitude、Latitude和Height。这些变量对应于上面原始数据表中的列名。还要注意，该结构继承自 FTableRowBase\n注意：编译代码\n  将 .csv 数据文件拖放到虚幻引擎内容浏览器中。在【选择DataTable的行类型】下拉菜单中选择 AircraftRawData\n  第四步：在飞行轨迹上添加点位   在 PlaneTrack.h 文件中添加下面的包含文件：\n// Imports should be placed above the PlaneTrack.Generated.h line. ... #include \u0026lt;glm/vec3.hpp\u0026gt;#include \u0026#34;CesiumGeospatial/Ellipsoid.h\u0026#34;#include \u0026#34;CesiumGeospatial/Cartographic.h\u0026#34;在 APlaneTrack 类的最后添加下面的方法，用来将数据表中的数据添加到样条曲线的点位：\npublic: // Function to parse the data table and create the spline track UFUNCTION(BlueprintCallable, Category = \u0026#34;FlightTracker\u0026#34;) void LoadSplineTrackPoints();   在 PlaneTrack.cpp 中添加 LoadSplineTrackPoints 方法的函数体；\nvoid APlaneTrack::LoadSplineTrackPoints() { if (this-\u0026gt;AircraftsRawDataTable != nullptr \u0026amp;\u0026amp; this-\u0026gt;CesiumGeoreference != nullptr) { int32 PointIndex = 0; for (auto\u0026amp; row : this-\u0026gt;AircraftsRawDataTable-\u0026gt;GetRowMap()) { FAircraftRawData* Point = (FAircraftRawData*)row.Value; // Get row data point in lat/long/alt and transform it into UE4 points  double PointLatitude = Point-\u0026gt;Latitude; double PointLongitude = Point-\u0026gt;Longitude; double PointHeight = Point-\u0026gt;Height; // Compute the position in UE coordinates  glm::dvec3 UECoords = this-\u0026gt;CesiumGeoreference-\u0026gt;TransformLongitudeLatitudeHeightToUnreal(glm::dvec3(PointLongitude, PointLatitude, PointHeight)); FVector SplinePointPosition = FVector(UECoords.x, UECoords.y, UECoords.z); this-\u0026gt;SplineTrack-\u0026gt;AddSplinePointAtIndex(SplinePointPosition, PointIndex, ESplineCoordinateSpace::World, false); // Get the up vector at the position to orient the aircraft  const CesiumGeospatial::Ellipsoid\u0026amp; Ellipsoid = CesiumGeospatial::Ellipsoid::WGS84; glm::dvec3 upVector = Ellipsoid.geodeticSurfaceNormal(CesiumGeospatial::Cartographic(FMath::DegreesToRadians(PointLongitude), FMath::DegreesToRadians(PointLatitude), FMath::DegreesToRadians(PointHeight))); // Compute the up vector at each point to correctly orient the plane  glm::dvec4 ecefUp(upVector, 0.0); const GeoTransforms\u0026amp; geoTransforms = this-\u0026gt;CesiumGeoreference-\u0026gt;GetGeoTransforms(); const glm::dmat4\u0026amp; ecefToUnreal = geoTransforms.GetEllipsoidCenteredToAbsoluteUnrealWorldTransform(); glm::dvec4 unrealUp = ecefToUnreal * ecefUp; this-\u0026gt;SplineTrack-\u0026gt;SetUpVectorAtSplinePoint(PointIndex, FVector(unrealUp.x, unrealUp.y, unrealUp.z), ESplineCoordinateSpace::World, false); PointIndex++; } this-\u0026gt;SplineTrack-\u0026gt;UpdateSpline(); } } 保存并编译工程\n  在场景中添加 PlaneTrack Actor；\n  选中添加的 PlaneTrack1 Actor，打开【细节】面板，设置 Cesium Georeference 和 Aircrafts Raw Data Table\n  打开【关卡蓝图】,将 PlaneTrack1 Actor 拖入到蓝图中，获取 Spline Track 对象，并添加【清除样条点】节点，当样条第一次添加到场景中时，默认情况下它有两个点。这两个点是任意的，我们不需要，因此可以使用 Clear Spline points 清除它们。\n  添加 Load Spline Track Points 节点，最终蓝图连接如下图：\n由于样条可视化在默认情况下是关闭的，可以通过在控制台命令窗口输入 ShowFlag.Splines 1 命令来打开它，运行后如下图：\n  第五步：添加飞机模型 模型下载网站：\n 波音787 Sketchfab 3D model    导入模型为静态网格模型\n建议每个模型创建一个文件夹，在【内容浏览器】面板新建模型文件夹，然后在新建的文件夹中右击鼠标，在弹出的快捷菜单中选择【导入】\n  添加蓝图类 BP_Aircraft，该类将包含飞机静态网格模型，以及沿着样条曲线路径移动飞机的逻辑\n  在 BP_Aircraft 蓝图类中添加【静态网格体】组件，并指定【静态网格体】为导入的飞机模型\n  在该蓝图类的【事件图表】中添加【自定义事件】并命名为 MoveAircraft\n  在【事件图表】中添加【时间轴】节点并命名为 AircraftMover，这个时间轴将随时间移动飞机模型\n将时间轴的 Alpha 输出引脚提升为变量 Alpha\n  双击时间轴节点，打开【时间轴编辑器】，添加浮点型轨道，添加两个关键帧，时间 = 0，值 = 0，时间 = 1， 值 = 1，勾选【使用最后一个关键帧】\n  添加几个公有变量：\n Duration，float 类型，public 权限，这个变量将用于确定飞机沿路径飞行所需的时间 AircraftStartOffset，float 类型，public 权限，用于确定飞行在时间轴上的哪个位置开始，取值区间为从 0 到 1 PlaneTrack：PlaneTrack 对象引用类型，public 权限，用于存储 PlaneTrack 对象的引用，以检索样条曲线上的点位    如下图连接 MoveAircraft 自定义事件蓝图：\n  通过样条曲线类 PlaneTrack 插值飞机飞行点位，如下图：\n  最后连接到【设置Actor变换】节点：\n  编译保存，并把 BP_Aircraft 蓝图类放入到场景中\n  在关卡蓝图中添加键盘事件，调用 BP_Aircraft 的 MoveAircraft 自定义事件节点\n  在场景中选中 BP_Aircraft Actor，在细节面板中设置 Duration、PlaneTrack、AirplaneOffset\n  第六步：在两个不同的相机视图间切换   在 BP_Aircraft 蓝图类节点下添加两个相机，分别放置在飞机模型的顶部和侧边\n  在关卡蓝图中添加两个快捷键事件，并如下图连接节点\n  参考：\n Build a Flight Tracker with Cesium for Unreal UE-c++代码热编译 设置Visual Studio 编译配置参考 编译游戏项目 使用Datasmith和3ds Max UE4模型整体导入流程  ","permalink":"https://874656645.github.io/posts/250-cesium-unreal-build-a-flight-tracker-with-cesium-for-unreal/","summary":"第一步：创建一个关卡  创建一个空的 Unreal 关卡； 登录 Cesium ion 并添加 Cesium World Terrain 和 CesiumSunSky； 设置 CesiumGeoreference 的坐标为 San Francisco International Airport (SFO)；\nOrigin Latitude = 37.61779\nOrigin Longitude = -122.390533\nOrigin Height = 0.0  第二步：添加 PlaneTrack 类   在 UE Editor 中添加 C++ 类，选择 Actor 作为父类，点击【下一步】，输入类名 PlaneTrack，点击【创建类】按钮，此时 Visual Studio 会自动打开，如果没有打开，可以通过【工具】——【打开Visual Studio】手动打开项目\nVS 2022 解决方案类似下图：\n  添加下面的代码到 project.Build.cs 文件：\n// Add Cesium for Unreal plugin dependency path PrivateDependencyModuleNames.AddRange(new string[] { \u0026#34;CesiumRuntime\u0026#34; }); // Tell Unreal Engine to use C++17 CppStandard = CppStandardVersion.","title":"Cesium4Unreal——Build a Flight Tracker With Cesium for Unreal"},{"content":"void printArr(int *A, int size){ printf(\u0026#34;Elements of array: \u0026#34;); for(int i = 0; i \u0026lt; size; ++i){ printf(\u0026#34;%d\\t\u0026#34;, A[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int C[3][2][2] = {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}; // 虽然地址相同，但代表的意义却不相同  printf(\u0026#34;%p\\t%p\\t%p\\t%p\\t%p\\t%p \\n\u0026#34;, C, *C, C[0], C[0][0], \u0026amp;C[0][0], \u0026amp;C[0][0][0]); printf(\u0026#34;%p\\t%p\\t%p\\n\u0026#34;, *C+1, C[0]+1, C[0][1]); printf(\u0026#34;%p\\t%p\\n\u0026#34;, C, C[0][0] + 1); printf(\u0026#34;%p\\t%p\\n\u0026#34;, C, \u0026amp;C[0][0] + 1); // 分配空间，但不会对元素进行初始化  int *A = (int*)malloc(3 * sizeof(int)); for(int i = 0; i \u0026lt; 3; ++i){ A[i] = i+1; } printArr(A, 3); // 分配空间，并将元素初始化为0  int *B = (int*)calloc(3, sizeof(int)); printArr(B, 3); // 重新分配一块空间（新空间可大可小）  // 并把原来的数据拷贝过来  // 如果新空间首地址与原来空间地址不同，会将原来的内存空间释放  // ，注意：此时不能再继续访问原来的地址，虽然原来的指针并未置空  int *D = (int*)realloc(A, 10 * sizeof(int)); printf(\u0026#34;%p\\t%p\\n\u0026#34;, A, D); printArr(A, 3); // 此时不能访问 A 了，这是危险的行为  printArr(D, 10); // 等同于重新分配了空间  D = (int*)realloc(NULL, 3 * sizeof(int)); // int *D = (int*)malloc(3 * sizeof(int));  printf(\u0026#34;%p\\t%p\\n\u0026#34;, A, D); printArr(D, 3); // 等同于释放了内存空间并将指针置为空值  D = (int*)realloc(D, 0); // free(D);D = nullptr;  printf(\u0026#34;%p\\n\u0026#34;, D); return 0; } 输出：\n0x7fffa5635190\t0x7fffa5635190\t0x7fffa5635190\t0x7fffa5635190\t0x7fffa5635190\t0x7fffa5635190 0x7fffa5635198\t0x7fffa5635198\t0x7fffa5635198 0x7fffa5635190\t0x7fffa5635194 0x7fffa5635190\t0x7fffa5635198 Elements of array: 1\t2\t3\tElements of array: 0\t0\t0\t0x5627f8b9c2c0\t0x5627f8b9c300 Elements of array: 0\t0\t-122118128\tElements of array: 1\t2\t3\t0\t0\t0\t0\t0\t0\t0\t0x5627f8b9c2c0\t0x5627f8b9c2c0 Elements of array: 0\t0\t0\t(nil) ","permalink":"https://874656645.github.io/posts/249-c++-malloc-calloc-realloc-%E6%8C%87%E9%92%88%E6%9D%82%E8%AE%B0/","summary":"void printArr(int *A, int size){ printf(\u0026#34;Elements of array: \u0026#34;); for(int i = 0; i \u0026lt; size; ++i){ printf(\u0026#34;%d\\t\u0026#34;, A[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int C[3][2][2] = {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}; // 虽然地址相同，但代表的意义却不相同  printf(\u0026#34;%p\\t%p\\t%p\\t%p\\t%p\\t%p \\n\u0026#34;, C, *C, C[0], C[0][0], \u0026amp;C[0][0], \u0026amp;C[0][0][0]); printf(\u0026#34;%p\\t%p\\t%p\\n\u0026#34;, *C+1, C[0]+1, C[0][1]); printf(\u0026#34;%p\\t%p\\n\u0026#34;, C, C[0][0] + 1); printf(\u0026#34;%p\\t%p\\n\u0026#34;, C, \u0026amp;C[0][0] + 1); // 分配空间，但不会对元素进行初始化  int *A = (int*)malloc(3 * sizeof(int)); for(int i = 0; i \u0026lt; 3; ++i){ A[i] = i+1; } printArr(A, 3); // 分配空间，并将元素初始化为0  int *B = (int*)calloc(3, sizeof(int)); printArr(B, 3); // 重新分配一块空间（新空间可大可小）  // 并把原来的数据拷贝过来  // 如果新空间首地址与原来空间地址不同，会将原来的内存空间释放  // ，注意：此时不能再继续访问原来的地址，虽然原来的指针并未置空  int *D = (int*)realloc(A, 10 * sizeof(int)); printf(\u0026#34;%p\\t%p\\n\u0026#34;, A, D); printArr(A, 3); // 此时不能访问 A 了，这是危险的行为  printArr(D, 10); // 等同于重新分配了空间  D = (int*)realloc(NULL, 3 * sizeof(int)); // int *D = (int*)malloc(3 * sizeof(int));  printf(\u0026#34;%p\\t%p\\n\u0026#34;, A, D); printArr(D, 3); // 等同于释放了内存空间并将指针置为空值  D = (int*)realloc(D, 0); // free(D);D = nullptr;  printf(\u0026#34;%p\\n\u0026#34;, D); return 0; } 输出：","title":"C++——malloc、calloc、realloc、指针杂记"},{"content":"描述 计算矩阵中，最大和的子矩阵，并输出最大的和\n测试用例 用例一：\n$$\\begin{equation} \\begin{bmatrix*}[c] -3 \u0026amp; -5 \u0026amp; -1 \u0026amp; 5 \\newline 2 \u0026amp; -4 \u0026amp; -2 \u0026amp; 4 \\newline -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; 3 \\end{bmatrix*} \\end{equation}$$\n用例二：\n$$\\begin{equation} \\begin{bmatrix*}[c] -3 \u0026amp; -5 \u0026amp; -1 \u0026amp; 5 \\newline 9 \u0026amp; -4 \u0026amp; -2 \u0026amp; 4 \\newline -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; 3 \\end{bmatrix*} \\end{equation}$$\n用例三：\n$$\\begin{equation} \\begin{bmatrix*}[c] -3 \u0026amp; -5 \u0026amp; -1 \u0026amp; 5 \\newline 7 \u0026amp; -4 \u0026amp; -2 \u0026amp; 4 \\newline -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; 3 \\end{bmatrix*} \\end{equation}$$\n用例四：\n$$\\begin{equation} \\begin{bmatrix*}[c] -3 \u0026amp; -5 \u0026amp; -1 \u0026amp; 5 \\newline 9 \u0026amp; -4 \u0026amp; -2 \u0026amp; 4 \\newline -1 \u0026amp; -2 \u0026amp; -1 \u0026amp; -3 \\end{bmatrix*} \\end{equation}$$\n用例五：\n$$\\begin{equation} \\begin{bmatrix*}[c] -3 \u0026amp; -5 \u0026amp; -1 \u0026amp; 5 \\newline 9 \u0026amp; -4 \u0026amp; -3 \u0026amp; 4 \\newline -1 \u0026amp; -2 \u0026amp; -1 \u0026amp; -3 \\end{bmatrix*} \\end{equation}$$\n用例六：\n$$\\begin{equation} \\begin{bmatrix*}[c] -3 \u0026amp; -5 \u0026amp; -1 \u0026amp; 5 \\newline 9 \u0026amp; 1 \u0026amp; -7 \u0026amp; 4 \\newline -1 \u0026amp; -2 \u0026amp; -1 \u0026amp; -3 \\end{bmatrix*} \\end{equation}$$\n用例七：\n$$\\begin{equation} \\begin{bmatrix*}[c] -3 \u0026amp; 5 \u0026amp; -1 \u0026amp; -5 \\newline 9 \u0026amp; 4 \u0026amp; -7 \u0026amp; -4 \\newline -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; -3 \\end{bmatrix*} \\end{equation}$$\n用例八：\n$$\\begin{equation} \\begin{bmatrix*}[c] -3 \u0026amp; 2 \u0026amp; -1 \u0026amp; 2 \\newline 5 \u0026amp; 4 \u0026amp; -2 \u0026amp; 0 \\newline -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; 2 \\end{bmatrix*} \\end{equation}$$\n用例九：\n$$\\begin{equation} \\begin{bmatrix*}[c] -3 \u0026amp; 5 \u0026amp; -1 \u0026amp; -5 \\newline 2 \u0026amp; 4 \u0026amp; -2 \u0026amp; -4 \\newline -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; -3 \\end{bmatrix*} \\end{equation}$$\n用例十：\n$$\\begin{equation} \\begin{bmatrix*}[c] -3 \u0026amp; 3 \u0026amp; -1 \u0026amp; -5 \\newline 9 \u0026amp; -4 \u0026amp; -7 \u0026amp; -4 \\newline -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; -3 \\end{bmatrix*} \\end{equation}$$\n测试用例十一：\n$$\\begin{equation} \\begin{bmatrix*}[c] 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 5 \u0026amp; 6 \u0026amp; 7 \u0026amp; 8 \\newline 9 \u0026amp; 10 \u0026amp; 11 \u0026amp; 12 \\end{bmatrix*} \\end{equation}$$\n测试用例十二：\n$$\\begin{equation} \\begin{bmatrix*}[c] -1 \u0026amp; -2 \u0026amp; -3 \u0026amp; -4 \\newline -5 \u0026amp; -6 \u0026amp; -7 \u0026amp; -8 \\newline -9 \u0026amp; -10 \u0026amp; -11 \u0026amp; -12 \\end{bmatrix*} \\end{equation}$$\n测试用例十三：\n$$\\begin{equation} \\begin{bmatrix*}[c] -12 \u0026amp; -11 \u0026amp; -10 \u0026amp; -9 \\newline -8 \u0026amp; -7 \u0026amp; -6 \u0026amp; -5 \\newline -4 \u0026amp; -3 \u0026amp; -2 \u0026amp; -1 \\end{bmatrix*} \\end{equation}$$\n方法一：暴力算法 void testMatMaxSum() { /*int arr[][4] = { {-3, -5, -1, 5}, {2, -4, -2, 4}, {-1, 3, -1, 3} };*/ /*int arr[][4] = { {-3, -5, -1, 5}, {9, -4, -2, 4}, {-1, 3, -1, 3} };*/ /*int arr[][4] = { {-3, -5, -1, 5}, {7, -4, -2, 4}, {-1, 3, -1, 3} };*/ /*int arr[][4] = { {-3, -5, -1, 5}, {9, -4, -2, 4}, {-1, -2, -1, -3} };*/ /*int arr[][4] = { {-3, -5, -1, 5}, {9, 1, -3, 4}, {-1, -2, -1, -3} };*/ /*int arr[][4] = { {-3, -5, -1, 5}, {9, 1, -7, 4}, {-1, -2, -1, -3} };*/ /*int arr[][4] = { {-3, 5, -1, -5}, {9, 4, -7, -4}, {-1, 3, -1, -3} };*/ /*int arr[][4] = { {-3, 2, -1, 2}, {5, 4, -2, 0}, {-1, 3, -1, 2} };*/ /*int arr[][4] = { {-3, 5, -1, 5}, {2, 4, -2, 4}, {-1, 3, -1, 3} };*/ /*int arr[][4] = { {-3, 3, -1, -5}, {9, -4, -7, -4}, {-1, 3, -1, -3} };*/ /*int arr[3][4]{ 0 }; int n = 1; for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { arr[i][j] = n++; } }*/ int arr[3][4]{0}; int n = -12; for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { arr[i][j] = n++; } } int dp[4][5]{ 0 }; for (int i = 1; i \u0026lt; 4; ++i) { for (int j = 1; j \u0026lt; 5; ++j) { dp[i][j] = arr[i - 1][j - 1]; } } for (int i = 1; i \u0026lt; 4; ++i) { for (int j = 1; j \u0026lt; 5; ++j) { dp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]; } } int start_x = 1, start_y = 1, end_x = 1, end_y = 1; int max_sum = dp[start_x][start_y]; for (int x = 0; x \u0026lt; 3; x++) { for (int y = 0; y \u0026lt; 4; y++) { for (int i = 1; i \u0026lt; 4-x; i++) { for (int j = 1; j \u0026lt; 5-y; j++) { int b = i + x; int r = j + y; int cur_sum = dp[b][r] - dp[b][j - 1] - dp[i - 1][r] + dp[i - 1][j - 1]; if (max_sum \u0026lt; cur_sum) { max_sum = cur_sum; start_x = i; start_y = j; end_x = b; end_y = r; } } } } } cout \u0026lt;\u0026lt; \u0026#34;max: \u0026#34; \u0026lt;\u0026lt; max_sum \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;左上：[\u0026#34; \u0026lt;\u0026lt; (start_x - 1) \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; (start_y - 1) \u0026lt;\u0026lt; \u0026#34;] 右下：[\u0026#34; \u0026lt;\u0026lt; (end_x - 1) \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; (end_y - 1) \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; } 方法二：模拟人的思维方式 此方法要考虑的情况较多\nvoid testMatMaxSum() { /*int arr[][4] = { {-3, -5, -1, 5}, {2, -4, -2, 4}, {-1, 3, -1, 3} };*/ /*int arr[][4] = { {-3, -5, -1, 5}, {9, -4, -2, 4}, {-1, 3, -1, 3} };*/ /*int arr[][4] = { {-3, -5, -1, 5}, {7, -4, -2, 4}, {-1, 3, -1, 3} };*/ /*int arr[][4] = { {-3, -5, -1, 5}, {9, -4, -2, 4}, {-1, -2, -1, -3} };*/ /*int arr[][4] = { {-3, -5, -1, 5}, {9, 1, -3, 4}, {-1, -2, -1, -3} };*/ /*int arr[][4] = { {-3, -5, -1, 5}, {9, 1, -7, 4}, {-1, -2, -1, -3} };*/ /*int arr[][4] = { {-3, 5, -1, -5}, {9, 4, -7, -4}, {-1, 3, -1, -3} };*/ /*int arr[][4] = { {-3, 2, -1, 2}, {5, 4, -2, 0}, {-1, 3, -1, 2} };*/ /*int arr[][4] = { {-3, 5, -1, 5}, {2, 4, -2, 4}, {-1, 3, -1, 3} };*/ int arr[][4] = { {-3, 3, -1, -5}, {9, -4, -7, -4}, {-1, 3, -1, -3} }; /*int arr[3][4]{ 0 }; int n = 1; for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { arr[i][j] = n++; } }*/ /*int arr[3][4]{0}; int n = -12; for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { arr[i][j] = n++; } }*/ int dp[4][5]{ 0 }; for (int i = 1; i \u0026lt; 4; ++i) { for (int j = 1; j \u0026lt; 5; ++j) { dp[i][j] = arr[i - 1][j - 1]; } } for (int i = 1; i \u0026lt; 4; ++i) { for (int j = 1; j \u0026lt; 5; ++j) { dp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]; } } int dp_max = arr[0][0], real_dp_max = dp_max; int t = 1, l = 1, b = 1, r = 1; for (int i = 1; i \u0026lt; 4; ++i) { int cur_t = 1, cur_l = 1, cur_b = 1, cur_r = 1; for (int j = 1; j \u0026lt; 5; ++j) { // 根据矩阵元素的和的 dp 移动矩阵临时的左上角坐标和右下角坐标 \tif (dp_max \u0026lt; dp[i][j]) { dp_max = dp[i][j]; cur_b = i; cur_r = j; } if (cur_t != 1 || cur_l != 1) { int cur_real_dp_max = dp[i][j] - dp[i][cur_l - 1] - dp[cur_t - 1][j] + dp[cur_t - 1][cur_l - 1]; if (dp_max \u0026lt; cur_real_dp_max) { dp_max = cur_real_dp_max; cur_b = i; cur_r = j; } } if (dp_max \u0026lt; arr[i - 1][j - 1]) { dp_max = arr[i - 1][j - 1]; cur_t = i; cur_l = j; cur_b = i; cur_r = j; } // 判断是否需要改变最终矩阵的左上角和右下角坐标 \t// 如果矩阵的左上角坐标发生过变化，则需要与真实的矩阵最大和进行比较 \tif ((t != 1 || l != 1) \u0026amp;\u0026amp; dp_max \u0026gt; real_dp_max) { int max_t = cur_t \u0026gt; t ? cur_t : t; int max_l = cur_l \u0026gt; l ? cur_l : l; // 分别计算 (t,l)-(max_t,max_l) 矩阵的和 \t// (cur_t,cur_l)-(max_t,max_l) 矩阵的和 \t// 只有当后者大于前者时才需更新矩阵的左上角坐标 \tint max_sum = dp[max_t][max_l] - dp[max_t][l - 1] - dp[t - 1][max_l] + dp[t - 1][l - 1]; int new_sum = dp[max_t][max_l] - dp[max_t][cur_l - 1] - dp[cur_t - 1][max_l] + dp[cur_t - 1][cur_l - 1]; if (max_sum \u0026lt; new_sum) { max_sum = new_sum; t = cur_t; l = cur_l; } if (real_dp_max \u0026lt; max_sum) { b = max_t; r = max_l; real_dp_max = max_sum; } } if (i \u0026gt;= t \u0026amp;\u0026amp; j \u0026gt;= l) { int cur_real_dp_max = dp[i][j] - dp[i][l - 1] - dp[t - 1][j] + dp[t - 1][l - 1]; if (real_dp_max \u0026lt; cur_real_dp_max) { b = i; r = j; real_dp_max = cur_real_dp_max; } } if (real_dp_max \u0026lt; dp_max) { real_dp_max = dp_max; t = cur_t; l = cur_l; b = cur_b; r = cur_r; } } } cout \u0026lt;\u0026lt; \u0026#34;max: \u0026#34; \u0026lt;\u0026lt; real_dp_max \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;左上：[\u0026#34; \u0026lt;\u0026lt; (t - 1) \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; (l - 1) \u0026lt;\u0026lt; \u0026#34;] 右下：[\u0026#34; \u0026lt;\u0026lt; (b - 1) \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; (r - 1) \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; } ","permalink":"https://874656645.github.io/posts/248-c++-%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E5%92%8C%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98/","summary":"描述 计算矩阵中，最大和的子矩阵，并输出最大的和\n测试用例 用例一：\n$$\\begin{equation} \\begin{bmatrix*}[c] -3 \u0026amp; -5 \u0026amp; -1 \u0026amp; 5 \\newline 2 \u0026amp; -4 \u0026amp; -2 \u0026amp; 4 \\newline -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; 3 \\end{bmatrix*} \\end{equation}$$\n用例二：\n$$\\begin{equation} \\begin{bmatrix*}[c] -3 \u0026amp; -5 \u0026amp; -1 \u0026amp; 5 \\newline 9 \u0026amp; -4 \u0026amp; -2 \u0026amp; 4 \\newline -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; 3 \\end{bmatrix*} \\end{equation}$$\n用例三：\n$$\\begin{equation} \\begin{bmatrix*}[c] -3 \u0026amp; -5 \u0026amp; -1 \u0026amp; 5 \\newline 7 \u0026amp; -4 \u0026amp; -2 \u0026amp; 4 \\newline -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; 3 \\end{bmatrix*} \\end{equation}$$","title":"C++——计算最大和子矩阵问题"},{"content":"方法一：使用字符串 注意 ：\n 字符与字符相加返回的是一个整数 字符串与字符相加的问题：  可以使用 + 号运算符，但其中一个操作数需要是 string 类型 如果需要连续相加多个字符，前两个操作数必须有一个是 string 类型的 可以使用 string.append 方法   控制台输入字符串的问题，如果直接使用 cin \u0026gt;\u0026gt; str，遇到空格和回车都会终止读取  例如：在字符串 s 后面添加 \u0026lsquo;a\u0026rsquo;、\u0026lsquo;b\u0026rsquo;、\u0026lsquo;c\u0026rsquo; 三个字符\n参考 C++ 运算符优先级和结合性\nstring s; s = s + \u0026#39;a\u0026#39; + \u0026#39;b\u0026#39; + \u0026#39;c\u0026#39;;\t// 正确 s += \u0026#39;a\u0026#39; + \u0026#39;b\u0026#39; + \u0026#39;c\u0026#39;;\t// 错误 s = \u0026#39;a\u0026#39; + \u0026#39;b\u0026#39; + \u0026#39;c\u0026#39; + s;\t// 错误 int main(){ string LR = \u0026#34;1625\u0026#34;, FB = \u0026#34;3645\u0026#34;, AC = \u0026#34;1324\u0026#34;; string mov; getline(cin, mov); for (char c : mov) { string tmp = \u0026#34;\u0026#34;; switch (c) { case \u0026#39;L\u0026#39;: case \u0026#39;R\u0026#39;: { if (c == \u0026#39;L\u0026#39;) { // LR = tmp + LR[3] + LR[0] + LR[1] + LR[2]; \tLR = LR[3] + string(LR, 0, 3); } else { // LR = tmp + LR[1] + LR[2] + LR[3] + LR[0]; \tLR = string(LR, 1, 3) + LR[0]; } // FB = tmp + FB[0] + LR[1] + FB[2] + LR[3]; \tFB[1] = LR[1]; FB[3] = LR[3]; // AC = tmp + LR[0] + AC[1] + LR[2] + AC[3]; \tAC[0] = LR[0]; AC[2] = LR[2]; break; } case \u0026#39;F\u0026#39;: case \u0026#39;B\u0026#39;: { if (c == \u0026#39;F\u0026#39;) { // FB = tmp + FB[3] + FB[0] + FB[1] + FB[2]; \tFB = FB[3] + string(FB, 0, 3); } else { // FB = tmp + FB[1] + FB[2] + FB[3] + FB[0]; \tFB = string(FB, 1, 3) + FB[0]; } // LR = tmp + LR[0] + FB[1] + LR[2] + FB[3]; \tLR[1] = FB[1]; LR[3] = FB[3]; // AC = tmp + AC[0] + FB[0] + AC[2] + FB[2]; \tAC[1] = FB[0]; AC[3] = FB[2]; break; } case \u0026#39;A\u0026#39;: case \u0026#39;C\u0026#39;: { if (c == \u0026#39;A\u0026#39;) { AC = tmp + AC[3] + AC[0] + AC[1] + AC[2]; } else { AC = tmp + AC[1] + AC[2] + AC[3] + AC[0]; } LR = tmp + AC[0] + LR[1] + AC[2] + LR[3]; FB = tmp + AC[1] + FB[1] + AC[3] + FB[3]; break; } default: break; } } cout \u0026lt;\u0026lt; LR[0] \u0026lt;\u0026lt; LR[2] \u0026lt;\u0026lt; FB[0] \u0026lt;\u0026lt; FB[2] \u0026lt;\u0026lt; LR[3] \u0026lt;\u0026lt; LR[1]; return 0; } 方法二：使用 deque 容器 int main() { //string LR = \u0026#34;1625\u0026#34;, FB = \u0026#34;3645\u0026#34;, AC = \u0026#34;1324\u0026#34;; \tdeque\u0026lt;char\u0026gt; LR, FB, AC; LR.push_back(\u0026#39;1\u0026#39;); LR.push_back(\u0026#39;6\u0026#39;); LR.push_back(\u0026#39;2\u0026#39;); LR.push_back(\u0026#39;5\u0026#39;); FB.push_back(\u0026#39;3\u0026#39;); FB.push_back(\u0026#39;6\u0026#39;); FB.push_back(\u0026#39;4\u0026#39;); FB.push_back(\u0026#39;5\u0026#39;); AC.push_back(\u0026#39;1\u0026#39;); AC.push_back(\u0026#39;3\u0026#39;); AC.push_back(\u0026#39;2\u0026#39;); AC.push_back(\u0026#39;4\u0026#39;); string mov; getline(cin, mov); for (char c : mov) { //string tmp = \u0026#34;\u0026#34;; \tchar tmp; switch (c) { case \u0026#39;L\u0026#39;: case \u0026#39;R\u0026#39;: { if (c == \u0026#39;L\u0026#39;) { tmp = LR.back(); LR.pop_back(); LR.push_front(tmp); //LR = tmp + LR[3] + LR[0] + LR[1] + LR[2]; \t} else { tmp = LR.front(); LR.pop_front(); LR.push_back(tmp); //LR = tmp + LR[1] + LR[2] + LR[3] + LR[0]; \t} //FB = tmp + FB[0] + LR[1] + FB[2] + LR[3]; \tFB[1] = LR[1]; FB[3] = LR[3]; //AC = tmp + LR[0] + AC[1] + LR[2] + AC[3]; \tAC[0] = LR[0]; AC[2] = LR[2]; break; } case \u0026#39;F\u0026#39;: case \u0026#39;B\u0026#39;: { if (c == \u0026#39;F\u0026#39;) { tmp = FB.back(); FB.pop_back(); FB.push_front(tmp); //FB = tmp + FB[3] + FB[0] + FB[1] + FB[2]; \t} else { tmp = FB.front(); FB.pop_front(); FB.push_back(tmp); //FB = tmp + FB[1] + FB[2] + FB[3] + FB[0]; \t} //LR = tmp + LR[0] + FB[1] + LR[2] + FB[3]; \tLR[1] = FB[1]; LR[3] = FB[3]; //AC = tmp + AC[0] + FB[0] + AC[2] + FB[2]; \tAC[1] = FB[0]; AC[3] = FB[2]; break; } case \u0026#39;A\u0026#39;: case \u0026#39;C\u0026#39;: { if (c == \u0026#39;A\u0026#39;) { tmp = AC.back(); AC.pop_back(); AC.push_front(tmp); //AC = tmp + AC[3] + AC[0] + AC[1] + AC[2]; \t} else { tmp = AC.front(); AC.pop_front(); AC.push_back(tmp); //AC = tmp + AC[1] + AC[2] + AC[3] + AC[0]; \t} //LR = tmp + AC[0] + LR[1] + AC[2] + LR[3]; \tLR[0] = AC[0]; LR[2] = AC[2]; //FB = tmp + AC[1] + FB[1] + AC[3] + FB[3]; \tFB[0] = AC[1]; FB[2] = AC[3]; break; } default: break; } } cout \u0026lt;\u0026lt; LR[0] \u0026lt;\u0026lt; LR[2] \u0026lt;\u0026lt; FB[0] \u0026lt;\u0026lt; FB[2] \u0026lt;\u0026lt; LR[3] \u0026lt;\u0026lt; LR[1]; return 0; } ","permalink":"https://874656645.github.io/posts/247-c++-%E6%97%8B%E8%BD%AC%E9%AA%B0%E5%AD%90%E9%97%AE%E9%A2%98/","summary":"方法一：使用字符串 注意 ：\n 字符与字符相加返回的是一个整数 字符串与字符相加的问题：  可以使用 + 号运算符，但其中一个操作数需要是 string 类型 如果需要连续相加多个字符，前两个操作数必须有一个是 string 类型的 可以使用 string.append 方法   控制台输入字符串的问题，如果直接使用 cin \u0026gt;\u0026gt; str，遇到空格和回车都会终止读取  例如：在字符串 s 后面添加 \u0026lsquo;a\u0026rsquo;、\u0026lsquo;b\u0026rsquo;、\u0026lsquo;c\u0026rsquo; 三个字符\n参考 C++ 运算符优先级和结合性\nstring s; s = s + \u0026#39;a\u0026#39; + \u0026#39;b\u0026#39; + \u0026#39;c\u0026#39;;\t// 正确 s += \u0026#39;a\u0026#39; + \u0026#39;b\u0026#39; + \u0026#39;c\u0026#39;;\t// 错误 s = \u0026#39;a\u0026#39; + \u0026#39;b\u0026#39; + \u0026#39;c\u0026#39; + s;\t// 错误 int main(){ string LR = \u0026#34;1625\u0026#34;, FB = \u0026#34;3645\u0026#34;, AC = \u0026#34;1324\u0026#34;; string mov; getline(cin, mov); for (char c : mov) { string tmp = \u0026#34;\u0026#34;; switch (c) { case \u0026#39;L\u0026#39;: case \u0026#39;R\u0026#39;: { if (c == \u0026#39;L\u0026#39;) { // LR = tmp + LR[3] + LR[0] + LR[1] + LR[2]; \tLR = LR[3] + string(LR, 0, 3); } else { // LR = tmp + LR[1] + LR[2] + LR[3] + LR[0]; \tLR = string(LR, 1, 3) + LR[0]; } // FB = tmp + FB[0] + LR[1] + FB[2] + LR[3]; \tFB[1] = LR[1]; FB[3] = LR[3]; // AC = tmp + LR[0] + AC[1] + LR[2] + AC[3]; \tAC[0] = LR[0]; AC[2] = LR[2]; break; } case \u0026#39;F\u0026#39;: case \u0026#39;B\u0026#39;: { if (c == \u0026#39;F\u0026#39;) { // FB = tmp + FB[3] + FB[0] + FB[1] + FB[2]; \tFB = FB[3] + string(FB, 0, 3); } else { // FB = tmp + FB[1] + FB[2] + FB[3] + FB[0]; \tFB = string(FB, 1, 3) + FB[0]; } // LR = tmp + LR[0] + FB[1] + LR[2] + FB[3]; \tLR[1] = FB[1]; LR[3] = FB[3]; // AC = tmp + AC[0] + FB[0] + AC[2] + FB[2]; \tAC[1] = FB[0]; AC[3] = FB[2]; break; } case \u0026#39;A\u0026#39;: case \u0026#39;C\u0026#39;: { if (c == \u0026#39;A\u0026#39;) { AC = tmp + AC[3] + AC[0] + AC[1] + AC[2]; } else { AC = tmp + AC[1] + AC[2] + AC[3] + AC[0]; } LR = tmp + AC[0] + LR[1] + AC[2] + LR[3]; FB = tmp + AC[1] + FB[1] + AC[3] + FB[3]; break; } default: break; } } cout \u0026lt;\u0026lt; LR[0] \u0026lt;\u0026lt; LR[2] \u0026lt;\u0026lt; FB[0] \u0026lt;\u0026lt; FB[2] \u0026lt;\u0026lt; LR[3] \u0026lt;\u0026lt; LR[1]; return 0; } 方法二：使用 deque 容器 int main() { //string LR = \u0026#34;1625\u0026#34;, FB = \u0026#34;3645\u0026#34;, AC = \u0026#34;1324\u0026#34;; \tdeque\u0026lt;char\u0026gt; LR, FB, AC; LR.","title":"C++——旋转骰子问题"},{"content":"目标 对输入的字符串中的单词，把给定的索引区间中的单词逆序\n方法一  通过 strtok（strtok_s、strtok_r） 分割字符串 使用 list 容器存储各个单词 可以通过前插的方式反转指定区间的单词 也可以通过前后交换的方式反转指定区间的单词 顺序输出 list 中的单词  int main(){ string str = \u0026#34;I am a developer\u0026#34;; char *cArr = new char[str.size()+1]{0}; strcpy_s(cArr, str.size()+1, str.c_str());\t// 注意：第二个参数，要拷贝的字符串的长度包括结尾的 \u0026#39;\\0\u0026#39; \tchar *w = nullptr, *rest = nullptr; list\u0026lt;string\u0026gt; wordList; w = strtok_s(cArr, \u0026#34; \u0026#34;, \u0026amp;rest); while (w) { wordList.push_back(w); w = strtok_s(nullptr, \u0026#34; \u0026#34;, \u0026amp;rest); } int startIndex = 0, endIndex = 0; cin \u0026gt;\u0026gt; startIndex \u0026gt;\u0026gt; endIndex; int len = wordList.size(); if (endIndex \u0026gt; startIndex \u0026amp;\u0026amp; startIndex \u0026lt; len - 1) { startIndex = startIndex \u0026gt; -1 ? startIndex : 0; endIndex = endIndex \u0026gt; len - 1 ? len - 1 : endIndex; int i = 0; list\u0026lt;string\u0026gt;::iterator itr = wordList.begin(), startItr = itr, endItr = itr; // 方法一：通过前插，然后删除的方式 \t/* for (itr = wordList.begin(); itr != wordList.end(); ++itr, ++i) { if (i == startIndex) { startItr = itr; ++i; ++itr; break; } } while (i \u0026gt; startIndex \u0026amp;\u0026amp; i \u0026lt;= endIndex) { wordList.insert(startItr, *itr); itr = wordList.erase(itr); startItr--; ++i; } */ // 方法二：通过交换的方式 \tfor (; itr != wordList.end(); ++itr, ++i) { if (i == startIndex) { startItr = itr; }else if(i == endIndex){ endItr = itr; break; } } int step = endIndex - startIndex; for(i = 0; i \u0026lt;= step / 2 \u0026amp;\u0026amp; startItr != endItr; ++i){ string tmp = *startItr; *startItr = *endItr; *endItr = tmp; // 等同于下面的函数调用 \t// iter_swap(startItr, endItr); \tstartItr++; endItr--; } } for (auto word : wordList) { cout \u0026lt;\u0026lt; word \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } delete[] cArr; return 0; } 方法二  通过 substring 提取单词 使用 vector 存储分割的单词 逆序输出指定区间中的单词  int main() { string str = \u0026#34;I am a developer\u0026#34;; vector\u0026lt;string\u0026gt; words; str += \u0026#34; \u0026#34;; size_t startPos = 0, endPos = 0; endPos = str.find(\u0026#39; \u0026#39;, startPos); while (endPos != string::npos) { words.push_back(str.substr(startPos, endPos - startPos)); startPos = endPos + 1; endPos = str.find(\u0026#39; \u0026#39;, startPos); } int beginIndex = 0, endIndex = 0; cin \u0026gt;\u0026gt; beginIndex \u0026gt;\u0026gt; endIndex; int len = words.size();\t// 注意：此处返回的类型是 unsigned int，与负数比较会有问题 \tif (endIndex \u0026gt; beginIndex \u0026amp;\u0026amp; beginIndex \u0026lt; len-1) { beginIndex = beginIndex \u0026gt; -1 ? beginIndex : 0; endIndex = endIndex \u0026gt;= len ? len - 1 : endIndex; for (int i = 0; i \u0026lt; words.size(); ++i) { if (i \u0026gt;= beginIndex \u0026amp;\u0026amp; i \u0026lt;= endIndex) { cout \u0026lt;\u0026lt; words[endIndex - (i - beginIndex)] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } else { cout \u0026lt;\u0026lt; words[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } } else { cout \u0026lt;\u0026lt; str; } return 0; } ","permalink":"https://874656645.github.io/posts/246-c++-liststrcpy_sstrtok_s-%E4%BD%BF%E7%94%A8/","summary":"目标 对输入的字符串中的单词，把给定的索引区间中的单词逆序\n方法一  通过 strtok（strtok_s、strtok_r） 分割字符串 使用 list 容器存储各个单词 可以通过前插的方式反转指定区间的单词 也可以通过前后交换的方式反转指定区间的单词 顺序输出 list 中的单词  int main(){ string str = \u0026#34;I am a developer\u0026#34;; char *cArr = new char[str.size()+1]{0}; strcpy_s(cArr, str.size()+1, str.c_str());\t// 注意：第二个参数，要拷贝的字符串的长度包括结尾的 \u0026#39;\\0\u0026#39; \tchar *w = nullptr, *rest = nullptr; list\u0026lt;string\u0026gt; wordList; w = strtok_s(cArr, \u0026#34; \u0026#34;, \u0026amp;rest); while (w) { wordList.push_back(w); w = strtok_s(nullptr, \u0026#34; \u0026#34;, \u0026amp;rest); } int startIndex = 0, endIndex = 0; cin \u0026gt;\u0026gt; startIndex \u0026gt;\u0026gt; endIndex; int len = wordList.","title":"C++ List、strcpy_s、strtok_s 使用"},{"content":"","permalink":"https://874656645.github.io/posts/245-c++-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%8F%8C%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/","summary":"","title":"C++——类模板双栈模拟队列"},{"content":"","permalink":"https://874656645.github.io/posts/244-c++-%E7%B1%BB%E6%A8%A1%E6%9D%BF/","summary":"","title":"C++——类模板"},{"content":"","permalink":"https://874656645.github.io/posts/243-c++-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/","summary":"","title":"C++——函数模板"},{"content":"","permalink":"https://874656645.github.io/posts/242-c++-%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF/","summary":"","title":"C++——变量模板"},{"content":"","permalink":"https://874656645.github.io/posts/241-c++-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"","title":"C++——Lambda表达式"},{"content":"","permalink":"https://874656645.github.io/posts/240-c++-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E6%9D%82%E8%AE%B0/","summary":"","title":"C++——类型推导杂记"},{"content":"const_cast 和 static_cast int x = 65536; (short \u0026amp;)x = 65535; cout\u0026lt;\u0026lt;x; int main() { const int x = 0; *(int*)\u0026amp;x = 2; cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; // x = 0  (int\u0026amp;)x = 3; int y = x; cout \u0026lt;\u0026lt; \u0026#34;y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; // y = 0  const_cast\u0026lt;int\u0026amp;\u0026gt;(x) = 10; y = x; cout \u0026lt;\u0026lt; \u0026#34;y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; // y = 0  return 0; } struct T{ int x = 0; const int y = 0; int q() const{ *(int*)\u0026amp;y = y + 1; return y; } }; int main() { T m; const T n; int x = m.q(); // 修改可写对象 m 的只读成员 m.y 的值  cout \u0026lt;\u0026lt; m.y \u0026lt;\u0026lt; endl; // 1  x = n.q(); // 修改只读对象 n 的只读成员 n.y 的值  cout \u0026lt;\u0026lt; n.y \u0026lt;\u0026lt; endl; // 1  return 0; } // x 为const全局变量，即全局只读变量，内存分配在受保护的区域 const int x = 0; // y 为可写易变全局变量 volatile int y = 0; int main() { // z 为const自动变量，内存分配在受保护的区域  const int z = 0; // 正确：x有const但被忽略，因为现在只读x的值，转换目标为右值  int w = static_cast\u0026lt;int\u0026gt;(x); cout \u0026lt;\u0026lt; \u0026#34;w = \u0026#34; \u0026lt;\u0026lt; w \u0026lt;\u0026lt; endl; // 错误：转换结果为右值，不能对其赋值  // static_cast\u0026lt;int\u0026gt;(x) = 0;  // 错误：不能去除x的const只读属性，转换目标为左值  // static_cast\u0026lt;int\u0026amp;\u0026gt;(x) = 0;  // 错误：转换结果为右值，不能对其赋值  // static_cast\u0026lt;int\u0026gt;(w) = 0;  // 正确：转换为有址传统左值引用，可添加volatile  static_cast\u0026lt;volatile int\u0026amp;\u0026gt;(w) = 1; cout \u0026lt;\u0026lt; \u0026#34;w = \u0026#34; \u0026lt;\u0026lt; w \u0026lt;\u0026lt; endl; // 错误：无法去除const，将原类型const int*转换为int*，转换用作左值  // *static_cast\u0026lt;int*\u0026gt;(\u0026amp;x) = 0;  // 错误：无法去除全局变量y的volatile属性  // static_cast\u0026lt;int\u0026amp;\u0026gt;(y) = 0;  int\u0026amp;\u0026amp; p = 0; static_cast\u0026lt;int\u0026amp;\u0026gt;(p) = 4; // 正确：无址引用左值变量p是有址的，转换为有址左值  cout \u0026lt;\u0026lt; \u0026#34;p = \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; int\u0026amp; q = w; // static_cast\u0026lt;int\u0026amp;\u0026amp;\u0026gt;(q) = 4; // 错误：可以转换，但转换后的类型无址，不能对其赋值  *const_cast\u0026lt;int*\u0026gt;(\u0026amp;z) = 3; // 正确：运行无异常，但并不能修改z的值  *(int*)\u0026amp;z = 3; // 正确：运行无异常，但并不能修改z的值  const_cast\u0026lt;int\u0026amp;\u0026gt;(y) = 4; // 正确：可以去除全局变量y的volatile属性，::y=4  // 下面的语句会导致程序不执行后面的输出语句  // 全局const只读变量内存受到保护，下面的语句会引发异常 ： 写入位置 0x00007FF75487BDC0 时发生访问冲突。  // const_cast\u0026lt;int\u0026amp;\u0026gt;(x) = 3; // 正确：但运行时出现页面保护访问冲突，x仍然是0  // *const_cast\u0026lt;int*\u0026gt;(\u0026amp;x) = 3; // 正确：但运行时出现页面保护访问冲突，x仍然是0  // *(int*)\u0026amp;x = 3; // 正确：但运行时出现页面保护访问冲突，x仍然是0  cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;z = \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; return 0; } class Test{ public: int number; const int nn; Test(int m):nn(m){ number = m; } void dec()const{ // number--; // error: decrement of member ‘Test::number’ in read-only object  const_cast\u0026lt;Test*\u0026gt;(this)-\u0026gt;number--; // nn--; // error: decrement of member ‘Test::nn’ in read-only object  const_cast\u0026lt;int\u0026amp;\u0026gt;(nn)--; } }; int main() { Test a(7); a.dec(); cout \u0026lt;\u0026lt; a.nn \u0026lt;\u0026lt; endl; // 6 \tcout \u0026lt;\u0026lt; a.number \u0026lt;\u0026lt; endl; // 6 \tconst int xx = 0; const static int\u0026amp; yy = 0; // 临时匿名变量，注意与上一句的差别 \tvolatile int zz = 0; int ww = *const_cast\u0026lt;int*\u0026gt;(\u0026amp;xx) = 2; cout \u0026lt;\u0026lt; xx \u0026lt;\u0026lt; endl; // 0 \tcout \u0026lt;\u0026lt; ww \u0026lt;\u0026lt; endl; // 2 \ta.*const_cast\u0026lt;int Test::*\u0026gt;(\u0026amp;Test::nn) = 3; cout \u0026lt;\u0026lt; a.nn \u0026lt;\u0026lt; endl; // 3 \tconst_cast\u0026lt;volatile int\u0026amp;\u0026gt;(yy) = 4; // 这条语句的执行与编译器有关 \t// VS 可以通过，其他的待测试 \t// 有些编译器可能这句不会执行，从而导致后面的语句也都不会被执行 \tww = yy; cout \u0026lt;\u0026lt; yy \u0026lt;\u0026lt; endl;\t// 4 \tcout \u0026lt;\u0026lt; ww \u0026lt;\u0026lt; endl;\t// 4 \tconst_cast\u0026lt;int\u0026amp;\u0026gt;(zz) = 7; //const_cast\u0026lt;const int\u0026amp;\u0026gt;(zz) = 6; \tcout \u0026lt;\u0026lt; zz \u0026lt;\u0026lt; endl;\t// 7 \tww = const_cast\u0026lt;const int\u0026amp;\u0026gt;(zz); ww = *const_cast\u0026lt;const int*\u0026gt;(\u0026amp;zz); cout \u0026lt;\u0026lt; ww \u0026lt;\u0026lt; endl;\t// 7 \tconst_cast\u0026lt;volatile int\u0026amp;\u0026gt;(ww) = 5; cout \u0026lt;\u0026lt; ww \u0026lt;\u0026lt; endl;\t// 5  return 0; } dynamic_cast  检查是否有虚函数  struct B{ virtual B\u0026amp; f(){ // 注意：* 或 \u0026amp; 才能发生协变  cout \u0026lt;\u0026lt; \u0026#34;B\\n\u0026#34;; return *this; } }a, \u0026amp;b = a; struct D : B{ D\u0026amp; f()override{ cout \u0026lt;\u0026lt; \u0026#34;D\\n\u0026#34;; return *this; } }c, \u0026amp;d = c; int main() { D* p1 = static_cast\u0026lt;D*\u0026gt;(\u0026amp;a); p1-\u0026gt;f(); // B  D* p2 = static_cast\u0026lt;D*\u0026gt;(\u0026amp;b); p2-\u0026gt;f(); // B  D* p3 = dynamic_cast\u0026lt;D*\u0026gt;(\u0026amp;a); // warning: dynamic_cast of ‘B a’ to ‘struct D*’ can never succeed  cout \u0026lt;\u0026lt; p3 \u0026lt;\u0026lt; endl; // 0  // p3-\u0026gt;f();  D* p4 = dynamic_cast\u0026lt;D*\u0026gt;(\u0026amp;b); // warning: dynamic_cast of ‘B a’ to ‘struct D*’ can never succeed  cout \u0026lt;\u0026lt; p4 \u0026lt;\u0026lt; endl; // 0  // p4-\u0026gt;f();  B* p5 = dynamic_cast\u0026lt;B*\u0026gt;(\u0026amp;c); p5-\u0026gt;f(); // D  B* p6 = dynamic_cast\u0026lt;B*\u0026gt;(\u0026amp;d); p6-\u0026gt;f(); // D  D\u0026amp; r1 = static_cast\u0026lt;D\u0026amp;\u0026gt;(a); // 语法正确，但不安全的自上向下转换  r1.f(); // B  D\u0026amp; r2 = static_cast\u0026lt;D\u0026amp;\u0026gt;(b); // 语法正确，但不安全的自上向下转换  r2.f(); // B  // B\u0026amp; r3 = dynamic_cast\u0026lt;D\u0026amp;\u0026gt;(c); // 语法正确，且为安全的自下向上赋值  B\u0026amp; r3 = c; r3.f(); // D  B\u0026amp; r4 = d; // 语法正确，且为安全的自下向上赋值  r4.f(); // D  B\u0026amp;\u0026amp; rr1 = static_cast\u0026lt;D\u0026amp;\u0026amp;\u0026gt;(c); // 将子类向上转换为父类的无址引用  rr1.f(); // D  B\u0026amp;\u0026amp; rr2 = dynamic_cast\u0026lt;D\u0026amp;\u0026amp;\u0026gt;(c); rr2.f(); // D  B\u0026amp;\u0026amp; rr3 = static_cast\u0026lt;D\u0026amp;\u0026amp;\u0026gt;(d); rr3.f(); // D  B\u0026amp; r5 = dynamic_cast\u0026lt;D\u0026amp;\u0026gt;(rr3); // 将父类的无址引用转换为子类的有址引用，并赋值给父类的有址引用  r5.f(); // D  return 0; } reinterpret_cast ","permalink":"https://874656645.github.io/posts/239-c++-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9D%82%E8%AE%B0/","summary":"const_cast 和 static_cast int x = 65536; (short \u0026amp;)x = 65535; cout\u0026lt;\u0026lt;x; int main() { const int x = 0; *(int*)\u0026amp;x = 2; cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; // x = 0  (int\u0026amp;)x = 3; int y = x; cout \u0026lt;\u0026lt; \u0026#34;y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; // y = 0  const_cast\u0026lt;int\u0026amp;\u0026gt;(x) = 10; y = x; cout \u0026lt;\u0026lt; \u0026#34;y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; // y = 0  return 0; } struct T{ int x = 0; const int y = 0; int q() const{ *(int*)\u0026amp;y = y + 1; return y; } }; int main() { T m; const T n; int x = m.","title":"C++——类型转换杂记"},{"content":"","permalink":"https://874656645.github.io/posts/238-c++-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","summary":"","title":"C++——类型转换"},{"content":"","permalink":"https://874656645.github.io/posts/237-c++-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","summary":"","title":"C++——运算符重载"},{"content":" 普通函数、lambda表达式、函数模板和模板实例函数都可以定义异常接口 指针和引用类型的异常都可以支持多态 catch 的子类异常一定要写在父类异常的上面，catch 执行后就不会再执行后面的 catch 语句了 对于指针异常，如果不打算向上抛出，一定要记得 delete const volatile void * 可以捕获抛出的任何指针异常 ... 可以捕获抛出的任何异常 不引发任何异常，在函数后面添加 throw()、throw(void)、noexcept 建议将 noexcept 应用到任何绝不允许异常传播到调用堆栈的函数，当函数被声明为 noexcept 时，它使编译器可以在多种不同的上下文中生成更高效的代码  Exception.h\nstruct A { int a = 1; virtual int getA()const { return a; } }; struct B : A { int a = 2; int getA()const override { return a; } }; #define cout cout\u0026lt;\u0026lt;__FILE__\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34;: Exception: \u0026#34;  void testException() { try { // 抛出子类指针类型的异常 \t//throw new B;  // 抛出子类对象类型的异常 \tthrow B(); } catch (const A e) { cout \u0026lt;\u0026lt; e.getA() \u0026lt;\u0026lt; endl; throw; // 继续向上抛出异常，抛出的仍是原始的异常对象或指针  // 这里抛出的仍然是 B 类型的对象，而不是 e \t} catch (const A* e) // 与 catch (const A\u0026amp; e) 效果相同 \t{ cout \u0026lt;\u0026lt; e-\u0026gt;getA() \u0026lt;\u0026lt; endl; throw; // 继续向上抛出指针类型的异常，所以可以不 delete \t} catch (const B e) { cout \u0026lt;\u0026lt; e.getA() \u0026lt;\u0026lt; endl; } catch (const B* e) { cout \u0026lt;\u0026lt; e-\u0026gt;getA() \u0026lt;\u0026lt; endl; delete e; // 不向上抛出，需要 delete 指针，以免内存泄漏 \t} } main.cpp\n#include \u0026#34;Exception.h\u0026#34; int main() { try { testException(); } catch (const B e) { cout \u0026lt;\u0026lt; e.getA() \u0026lt;\u0026lt; endl; } catch (const B* e) { cout \u0026lt;\u0026lt; e-\u0026gt;getA() \u0026lt;\u0026lt; endl; delete e; } catch (const A e) { cout \u0026lt;\u0026lt; e.getA() \u0026lt;\u0026lt; endl; } catch (const A* e) { cout \u0026lt;\u0026lt; e-\u0026gt;getA() \u0026lt;\u0026lt; endl; delete e; } catch (...) { cout \u0026lt;\u0026lt; \u0026#34;...\\n\u0026#34;; } return 0; } 输出：\nC:\\ExceptionTest.h:27: Exception: 1 C:\\main.cpp:95: Exception: 2 ","permalink":"https://874656645.github.io/posts/236-c++-%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"普通函数、lambda表达式、函数模板和模板实例函数都可以定义异常接口 指针和引用类型的异常都可以支持多态 catch 的子类异常一定要写在父类异常的上面，catch 执行后就不会再执行后面的 catch 语句了 对于指针异常，如果不打算向上抛出，一定要记得 delete const volatile void * 可以捕获抛出的任何指针异常 ... 可以捕获抛出的任何异常 不引发任何异常，在函数后面添加 throw()、throw(void)、noexcept 建议将 noexcept 应用到任何绝不允许异常传播到调用堆栈的函数，当函数被声明为 noexcept 时，它使编译器可以在多种不同的上下文中生成更高效的代码  Exception.h\nstruct A { int a = 1; virtual int getA()const { return a; } }; struct B : A { int a = 2; int getA()const override { return a; } }; #define cout cout\u0026lt;\u0026lt;__FILE__\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34;: Exception: \u0026#34;  void testException() { try { // 抛出子类指针类型的异常 \t//throw new B;  // 抛出子类对象类型的异常 \tthrow B(); } catch (const A e) { cout \u0026lt;\u0026lt; e.","title":"C++——异常的使用"},{"content":"  案例一：\nclass A { public: int a; A(int x) :a(x) { } }; class B : public A { public: B(int x) :A(x) {\t// 这里初始化的是派生树中正常的基类 A  } }; class C { public: C() { } }; class D : virtual public A, public C { public: D(int x) :A(x) { } }; class E : /*public A,*/ public B, public D { // 不允许存在直接基类和间接虚基类的情况 public: E(int x) : A(x), B(x + 5), D(x + 10) {\t// error C2385: 对“A”的访问不明确  // 所以要使用 B::A(x) 或者 D::A(x)  // 此时初始化的都是派生树中虚基类 A  } }; int main(){ E e(0); //cout \u0026lt;\u0026lt; e.a \u0026lt;\u0026lt; endl;\t// 二义性  cout \u0026lt;\u0026lt; e.B::a \u0026lt;\u0026lt; endl; // 5 派生树中正常基类 A 中的 a  cout \u0026lt;\u0026lt; e.D::a \u0026lt;\u0026lt; endl; // 0 派生树中虚基类 A 中的 a  cout \u0026lt;\u0026lt; e.A::a \u0026lt;\u0026lt; endl; // 5 派生树中正常基类 A 中的 a  return 0; }   案例二：\nstruct A { A(){ cout \u0026lt;\u0026lt; \u0026#34;A\u0026#34;; } }; struct B{ B(){ cout \u0026lt;\u0026lt; \u0026#34;B\u0026#34;; } }; struct C { int a; int\u0026amp; b; const int c; C(char d):c(d), b(a) { a = d; cout \u0026lt;\u0026lt; d; } }; struct D{ D(){ cout \u0026lt;\u0026lt; \u0026#34;D\u0026#34;; } }; struct E : A, virtual B, C, virtual D { A x, y; B z; E() : z(), y(), C(\u0026#39;C\u0026#39;) { cout \u0026lt;\u0026lt; \u0026#34;E\u0026#34;; } }; int main(){ E e; // BDACAABE  return 0; }   案例三：\n 派生树从左到右，从下到上 第一级：虚基类 第二级：直接基类 第三级：对象成员 第四级：自身构造函数体 当前类的构造函数和类中每个对象成员都是一棵独立的派生树 每棵派生树的虚基类只构造和析构一次  struct A { A() { cout \u0026lt;\u0026lt; \u0026#34;A\u0026#34;; } }; struct B { const A a; B() { cout \u0026lt;\u0026lt; \u0026#34;B\u0026#34;; } }; struct C { C() { cout \u0026lt;\u0026lt; \u0026#34;C\u0026#34;; } }; struct D { D() { cout \u0026lt;\u0026lt; \u0026#34;D\u0026#34;; } }; struct E : A { E() { cout \u0026lt;\u0026lt; \u0026#34;E\u0026#34;; } }; struct F : B, virtual C { F() { cout \u0026lt;\u0026lt; \u0026#34;F\u0026#34;; } }; struct G : B { G() { cout \u0026lt;\u0026lt; \u0026#34;G\u0026#34;; } }; struct H : virtual C, virtual D { H() { cout \u0026lt;\u0026lt; \u0026#34;H\u0026#34;; } }; struct I : E, F, virtual G, H { E e; F f; I() : f(), e(), F(), E() { cout \u0026lt;\u0026lt; \u0026#34;I\u0026#34;; } }; int main(){ I i; // CABGDAEABFHAECABFI  return 0; }   ","permalink":"https://874656645.github.io/posts/235-c++-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E5%9F%BA%E7%B1%BB/","summary":"案例一：\nclass A { public: int a; A(int x) :a(x) { } }; class B : public A { public: B(int x) :A(x) {\t// 这里初始化的是派生树中正常的基类 A  } }; class C { public: C() { } }; class D : virtual public A, public C { public: D(int x) :A(x) { } }; class E : /*public A,*/ public B, public D { // 不允许存在直接基类和间接虚基类的情况 public: E(int x) : A(x), B(x + 5), D(x + 10) {\t// error C2385: 对“A”的访问不明确  // 所以要使用 B::A(x) 或者 D::A(x)  // 此时初始化的都是派生树中虚基类 A  } }; int main(){ E e(0); //cout \u0026lt;\u0026lt; e.","title":"C++——多继承与虚基类"},{"content":"一、基类中有虚函数但不是虚继承 class A { public: A() { c(); } virtual ~A() { d(); } virtual void c() { cout \u0026lt;\u0026lt; \u0026#34;Construct A\\n\u0026#34;; } virtual void d() { cout \u0026lt;\u0026lt; \u0026#34;Deconstruct A\\n\u0026#34;; } }; class B : public A { public: B() { // 等价于 B() : A(){} \tc(); } ~B() { d(); } void c()override { cout \u0026lt;\u0026lt; \u0026#34;Construct B\\n\u0026#34;; } void d()override { cout \u0026lt;\u0026lt; \u0026#34;Deconstruct B\\n\u0026#34;; } }; int main() { B b; return 0; } Construct A Construct B Deconstruct B Deconstruct A 二、有虚继承 ","permalink":"https://874656645.github.io/posts/234-c++-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%B8%8E%E5%A4%9A%E6%80%81%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/","summary":"一、基类中有虚函数但不是虚继承 class A { public: A() { c(); } virtual ~A() { d(); } virtual void c() { cout \u0026lt;\u0026lt; \u0026#34;Construct A\\n\u0026#34;; } virtual void d() { cout \u0026lt;\u0026lt; \u0026#34;Deconstruct A\\n\u0026#34;; } }; class B : public A { public: B() { // 等价于 B() : A(){} \tc(); } ~B() { d(); } void c()override { cout \u0026lt;\u0026lt; \u0026#34;Construct B\\n\u0026#34;; } void d()override { cout \u0026lt;\u0026lt; \u0026#34;Deconstruct B\\n\u0026#34;; } }; int main() { B b; return 0; } Construct A Construct B Deconstruct B Deconstruct A 二、有虚继承 ","title":"C++——虚函数表与多态（派生类内存布局）"},{"content":"一、 命名空间   嵌套命名空间\nnamespace B{ namespace C{ extern int x; // 声明变量  void g(int); // 声明函数原型  void g(long){ cout \u0026lt;\u0026lt; \u0026#34;B::C::g(long)\\n\u0026#34;; } }; }; using B::C::x; // 声明引用变量 x，把它引入到当前作用域  // 就不能在当前作用域定义同名变量了 using namespace B; // 引用命名空间，但不会把函数和变量引入到当前作用域  // 在当前作用域中仍然可以定义同名的变量和函数 using B::C::g; // 声明引用 void g(int) 和 void g(long)  // 将函数名为 g 的所有函数都引入到当前作用域  namespace B::C{ int y = 1; int x = 2; // 定义变量 x  void g(int a){ // 定义函数 void g(int)  cout \u0026lt;\u0026lt; \u0026#34;B::C::g(int)\\n\u0026#34;; } void g(void){ cout \u0026lt;\u0026lt; \u0026#34;B::C::g(void)\\n\u0026#34;; } }; static int xx = 1; class A{ public: int xx; A(int xx){ A::xx = xx; } }; int main() { static int xx = 2; A a(3); cout \u0026lt;\u0026lt; a.xx \u0026lt;\u0026lt; endl; // 3  cout \u0026lt;\u0026lt; ::xx \u0026lt;\u0026lt; endl; // 1  cout \u0026lt;\u0026lt; xx \u0026lt;\u0026lt; endl; // 2  ::xx = 0; cout \u0026lt;\u0026lt; ::xx \u0026lt;\u0026lt; endl; // 0  cout \u0026lt;\u0026lt; \u0026amp;::xx \u0026lt;\u0026lt; endl; // 0x557c5799c010  cout \u0026lt;\u0026lt; \u0026amp;xx \u0026lt;\u0026lt; endl; // 0x557c5799c014  cout \u0026lt;\u0026lt; B::C::x + B::C::y \u0026lt;\u0026lt; endl; // 3  g(4); // B::C::g(int)  g(4l); // B::C::g(long)  cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; // 2  // g(); // error: no matching function for call to ‘g()’  // using 之前没有该原型  return 0; }   匿名命名空间\n类似静态声明，匿名命名空间中的变量和函数只能在当前模块中使用\nMyTestNamespace cpp 文件：\nnamespace MyTestNamespace { // 匿名命名空间  namespace { int noName = 11; void noNameFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;no name namespace\\n\u0026#34;; } } void globalFunc(); void MyTestClass::testFun() { globalFunc(); std::cout \u0026lt;\u0026lt; noName \u0026lt;\u0026lt; std::endl; noNameFunc(); } }   二、对象作用域 ","permalink":"https://874656645.github.io/posts/233-c++-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7/","summary":"一、 命名空间   嵌套命名空间\nnamespace B{ namespace C{ extern int x; // 声明变量  void g(int); // 声明函数原型  void g(long){ cout \u0026lt;\u0026lt; \u0026#34;B::C::g(long)\\n\u0026#34;; } }; }; using B::C::x; // 声明引用变量 x，把它引入到当前作用域  // 就不能在当前作用域定义同名变量了 using namespace B; // 引用命名空间，但不会把函数和变量引入到当前作用域  // 在当前作用域中仍然可以定义同名的变量和函数 using B::C::g; // 声明引用 void g(int) 和 void g(long)  // 将函数名为 g 的所有函数都引入到当前作用域  namespace B::C{ int y = 1; int x = 2; // 定义变量 x  void g(int a){ // 定义函数 void g(int)  cout \u0026lt;\u0026lt; \u0026#34;B::C::g(int)\\n\u0026#34;; } void g(void){ cout \u0026lt;\u0026lt; \u0026#34;B::C::g(void)\\n\u0026#34;; } }; static int xx = 1; class A{ public: int xx; A(int xx){ A::xx = xx; } }; int main() { static int xx = 2; A a(3); cout \u0026lt;\u0026lt; a.","title":"C++——作用域和可访问性"},{"content":"  【File】-\u0026gt;【Create New Map Catalog】\n  Export\n  导出灰度图\n 关闭【地图渲晕（Disable Hill Shading）】，默认是开启状态，关闭后，并使用【梯度渲染（Gradient Shader）】   导出 PNG 设置    ","permalink":"https://874656645.github.io/posts/232-gis-global-mapper-%E4%BD%BF%E7%94%A8/","summary":"  【File】-\u0026gt;【Create New Map Catalog】\n  Export\n  导出灰度图\n 关闭【地图渲晕（Disable Hill Shading）】，默认是开启状态，关闭后，并使用【梯度渲染（Gradient Shader）】   导出 PNG 设置    ","title":"GIS——Global Mapper 使用"},{"content":" public 继承的派生类和基类具有父子关系 具有父子关系的派生类指针或对象可以不用进行强制类型转换，直接赋值给基类指针或引用 非 public 继承的 派生类指针 要通过强制类型转换（reinterpret_cast 或者 (Base*)）的方式才能赋值给 父类指针 在 派生类内部和派生类的友元函数 中可以用 父类指针 或 父类引用 直接指向 子类指针或对象，也可以直接将 子类对象赋值给父类对象 在其它地方，不能将 非 public 继承 的 派生类对象 赋值给父类对象或引用，提示 不可访问的基类，但可以通过 (Base\u0026amp;\u0026amp;) 这种强制类型转换的方式将派生类对象转换为基类的右值引用，且支持多态（VS 无法编译通过） 父类的析构函数必须是虚函数 即使父类的析构函数不是虚函数，在栈上定义的子类对象销毁时也会调用父类的析构函数 指针、右值引用、左值引用都支持多态 对象间赋值转换不支持多态  class A { int x, y; public: virtual ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A()\\n\u0026#34;; } int getx() { return x; } virtual int vf() const { return 1; } protected: int gety() { return y; } }; class B : protected A { friend int main(); bool visible; public: ~B() { cout \u0026lt;\u0026lt; \u0026#34;~B()\\n\u0026#34;; } using A::gety; A* getFather(){ return this; } private: virtual int vf() const { // 子类内部不受继承方式的影响 \tconst A *pa = this; // 将子类指针赋值给父类指针 \tconst A\u0026amp; ra = *this; // 将父类引用指向子类对象 \tA a = *this; // 将子类对象赋值给父类对象 \t// 父类对象 a 生命期在函数结束后结束 \t// 输出：~A() \tcout \u0026lt;\u0026lt; \u0026#34;in B::vf() A::vf()：\u0026#34; \u0026lt;\u0026lt; A::vf() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;in B::vf() a.vf()：\u0026#34; \u0026lt;\u0026lt; a.vf() \u0026lt;\u0026lt; endl; return 2; } }; int main() { // 指针、右值引用、左值引用都支持多态  // 对象间赋值转换不支持多态  // 1. 对象间赋值转换  // 非友元、非 public 继承不能进行派生类对象和基类对象之间的转换：  // 强制类型转换也不行 error: ‘A’ is an inaccessible base of ‘B’ \t// 编译时根据类型定义静态的检查语义  // class A 和 class B 是父子关系时才可以用下面的赋值  // 或者将 main() 声明为 class B 的友元  A a = B(); // 等同于 A a = static_cast\u0026lt;A\u0026gt;(B());  // 等同于 A a = (A)B();  // B() 产生一个常量对象（右值），生命期在 ；号后结束，自动释放  // a 生命期在函数结束后结束，所以控制台输出为：  // ~B()  // ~A()  // ~A()  cout \u0026lt;\u0026lt; a.vf() \u0026lt;\u0026lt; endl; // 输出 1  A* pa = B().getFather();\t// B() 产生一个常量对象（右值），生命期在 ；号后结束，自动释放 \t// 输出： \t// ~B() \t// ~A() \tcout \u0026lt;\u0026lt; pa-\u0026gt;vf() \u0026lt;\u0026lt; endl;\t// 输出 1  // 2. 右值引用 \tA\u0026amp;\u0026amp; ra1 = B(); // B() 是常量（右值）是无址的 \t// 右值引用 ra1 生命期在函数结束后结束，输出为： \t// ~B()  // ~A() \tcout \u0026lt;\u0026lt; ra1.vf() \u0026lt;\u0026lt; endl; // 输出：2 \tcout \u0026lt;\u0026lt; \u0026amp;ra1 \u0026lt;\u0026lt; endl; // 右值引用变量 ra 为左值，所以有地址 \t// 输出为：0x7fff66900b20  // 非友元、非 public 继承时可进行强制转换  // A\u0026amp;\u0026amp; ra2 = (A\u0026amp;\u0026amp;)B(); // OK \t// VS error C4789: 缓冲区“$S1”(大小为 16 字节)将溢出；24 字节将在偏移 0 时开始写入  // A\u0026amp;\u0026amp; ra3 = reinterpret_cast\u0026lt;A\u0026amp;\u0026amp;\u0026gt;(B()); // error: invalid cast of an rvalue expression of type ‘B’ to type ‘A\u0026amp;\u0026amp;’  // A\u0026amp;\u0026amp; ra4 = static_cast\u0026lt;A\u0026amp;\u0026amp;\u0026gt;(B()); // error: ‘A’ is an inaccessible base of ‘B’  // A\u0026amp;\u0026amp; ra5 = dynamic_cast\u0026lt;A\u0026amp;\u0026amp;\u0026gt;(B()); // error: ‘A’ is an inaccessible base of ‘B’ \t// cout \u0026lt;\u0026lt; ra2.vf() \u0026lt;\u0026lt; endl;\t// 输出 2 \t// 3. 常量引用  // 将父类引用指向子类对象 \t//A\u0026amp; a = B();\t// error：非常量引用的初始值必须为左值（可以取地址的） \tconst A\u0026amp; ca = B(); // OK: 常量引用 ca 生命期在函数结束后结束，输出为： \t// ~B()  // ~A()  // 非父子关系时可进行强制类型转换  // const A\u0026amp; ca = (const A\u0026amp;)B(); // OK  // const A\u0026amp; ca = static_cast\u0026lt;const A\u0026gt;(B()); // error: ‘A’ is an inaccessible base of ‘B’  // const A\u0026amp; ca = dynamic_cast\u0026lt;const A\u0026gt;(B()); // error: cannot dynamic_cast ‘B()’ (of type ‘class B’) to type ‘const class A’ (target is not pointer or reference)  // const A\u0026amp; ca = reinterpret_cast\u0026lt;const A\u0026gt;(B()); // error: invalid cast from type ‘B’ to type ‘const A’  // const A\u0026amp; ca = reinterpret_cast\u0026lt;const A\u0026amp;\u0026gt;(B()); // error: invalid cast of an rvalue expression of type ‘B’ to type ‘const A\u0026amp;’  cout \u0026lt;\u0026lt; ca.vf() \u0026lt;\u0026lt; endl; // 输出为：2 \t// 4. 非常量引用 \tA\u0026amp; la = *(new B()); // 非父子关系时可进行强制类型转换  // A\u0026amp; la = *((A*)new B()); \tcout \u0026lt;\u0026lt; la.vf() \u0026lt;\u0026lt; endl; // 输出 2  delete \u0026amp;la; // 5. 将子类指针赋值给父类指针  A *pa0 = new B(); cout \u0026lt;\u0026lt; pa0-\u0026gt;vf() \u0026lt;\u0026lt; endl; // 输出 2  // 非父子关系时进行强制类型转换  // B *pb = new B(); \t// A *pa1 = static_cast\u0026lt;A*\u0026gt;(pb); // error: ‘A’ is an inaccessible base of ‘B’ \t// A *pa2 = dynamic_cast\u0026lt;A*\u0026gt;(pb); // error: ‘A’ is an inaccessible base of ‘B’ \t// A *pa3 = (A*)pb; // OK \t// A *pa4 = reinterpret_cast\u0026lt;A*\u0026gt;(pb); // OK \t// cout \u0026lt;\u0026lt; pa3-\u0026gt;vf() \u0026lt;\u0026lt; endl; // 2 \t// cout \u0026lt;\u0026lt; pa4-\u0026gt;A::vf() \u0026lt;\u0026lt; endl; // 1  // delete pa3; // 如果 class A 不是虚析构，此处只输出 ~A()  delete pa0; return 0; } ","permalink":"https://874656645.github.io/posts/231-c++-%E7%88%B6%E7%B1%BB%E4%B8%8E%E5%AD%90%E7%B1%BB%E5%9F%BA%E7%B1%BB%E4%B8%8E%E6%B4%BE%E7%94%9F%E7%B1%BB/","summary":"public 继承的派生类和基类具有父子关系 具有父子关系的派生类指针或对象可以不用进行强制类型转换，直接赋值给基类指针或引用 非 public 继承的 派生类指针 要通过强制类型转换（reinterpret_cast 或者 (Base*)）的方式才能赋值给 父类指针 在 派生类内部和派生类的友元函数 中可以用 父类指针 或 父类引用 直接指向 子类指针或对象，也可以直接将 子类对象赋值给父类对象 在其它地方，不能将 非 public 继承 的 派生类对象 赋值给父类对象或引用，提示 不可访问的基类，但可以通过 (Base\u0026amp;\u0026amp;) 这种强制类型转换的方式将派生类对象转换为基类的右值引用，且支持多态（VS 无法编译通过） 父类的析构函数必须是虚函数 即使父类的析构函数不是虚函数，在栈上定义的子类对象销毁时也会调用父类的析构函数 指针、右值引用、左值引用都支持多态 对象间赋值转换不支持多态  class A { int x, y; public: virtual ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A()\\n\u0026#34;; } int getx() { return x; } virtual int vf() const { return 1; } protected: int gety() { return y; } }; class B : protected A { friend int main(); bool visible; public: ~B() { cout \u0026lt;\u0026lt; \u0026#34;~B()\\n\u0026#34;; } using A::gety; A* getFather(){ return this; } private: virtual int vf() const { // 子类内部不受继承方式的影响 \tconst A *pa = this; // 将子类指针赋值给父类指针 \tconst A\u0026amp; ra = *this; // 将父类引用指向子类对象 \tA a = *this; // 将子类对象赋值给父类对象 \t// 父类对象 a 生命期在函数结束后结束 \t// 输出：~A() \tcout \u0026lt;\u0026lt; \u0026#34;in B::vf() A::vf()：\u0026#34; \u0026lt;\u0026lt; A::vf() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;in B::vf() a.","title":"C++——父类与子类、基类与派生类"},{"content":"案例一：\nclass A { int x, y; public: int getx() { return x; } protected: int gety() { return y; } }; class B : private A /* public A */ /* protected A */{ bool visible; public: using A::getx; A::gety;\t// deprecated }; 案例二：\nclass MyList { struct Node { int v; Node* next; Node(int v, Node* n) { this-\u0026gt;v = v; next = n; } ~Node() { cout \u0026lt;\u0026lt; \u0026#34;~Node()\\n\u0026#34;; delete next; next = nullptr; } } *head; public: MyList() { head = nullptr; } ~MyList() { if (head != nullptr) { delete head; head = nullptr; } } int insert(int v) { head = new Node(v, head); if(head) return 1; return 0; } int contain(int v) { // 这里要注意，使用局部变量 \t// 不要使用 head，会改变整个链表的头指针 \tNode* tmp = head; while (tmp != nullptr) { if (tmp-\u0026gt;v == v) return 1; tmp = tmp-\u0026gt;next; } return 0; } }; class MySet : protected MyList { int count; public: MySet() { count = 0; }; using MyList::contain; int insert(int v) { if (!contain(v) \u0026amp;\u0026amp; MyList::insert(v)) return ++count; return 0; } }; int main() { MySet l; l.insert(1); l.insert(2); l.insert(3); cout \u0026lt;\u0026lt; l.insert(4) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; l.contain(3) \u0026lt;\u0026lt; endl; //MyList\u0026amp; list = l;\t// 不允许对不可访问的基类 \u0026#34;MyList\u0026#34; 进行转换  return 0; } ","permalink":"https://874656645.github.io/posts/230-c++-%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%BF%AE%E6%94%B9%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/","summary":"案例一：\nclass A { int x, y; public: int getx() { return x; } protected: int gety() { return y; } }; class B : private A /* public A */ /* protected A */{ bool visible; public: using A::getx; A::gety;\t// deprecated }; 案例二：\nclass MyList { struct Node { int v; Node* next; Node(int v, Node* n) { this-\u0026gt;v = v; next = n; } ~Node() { cout \u0026lt;\u0026lt; \u0026#34;~Node()\\n\u0026#34;; delete next; next = nullptr; } } *head; public: MyList() { head = nullptr; } ~MyList() { if (head !","title":"C++——派生类修改基类成员的访问权限"},{"content":" 含有私有 const 实例数据成员的类必须定义构造函数，且该实例数据成员必须通过构造函数参数列表初始化 虽然 this 是隐含参数，也可以通过添加 const、volatile 修饰符实现函数重载 成员变量的类型会随着对象实例的类型变化而变化，比如一个 volatile int 类型的成员变量，如果对象实例为 const 的，则此时成员变量的类型为 const volatile int 经实验，mutable 不可以和 static、const 一起使用，但可以与 volatile 搭配使用  ","permalink":"https://874656645.github.io/posts/229-c++-constvolatilemutable/","summary":" 含有私有 const 实例数据成员的类必须定义构造函数，且该实例数据成员必须通过构造函数参数列表初始化 虽然 this 是隐含参数，也可以通过添加 const、volatile 修饰符实现函数重载 成员变量的类型会随着对象实例的类型变化而变化，比如一个 volatile int 类型的成员变量，如果对象实例为 const 的，则此时成员变量的类型为 const volatile int 经实验，mutable 不可以和 static、const 一起使用，但可以与 volatile 搭配使用  ","title":"C++——Const、volatile、mutable"},{"content":"实例成员指针  实例成员指针是指向实例成员的指针，可分为实例数据成员指针和实例函数成员指针 构造函数不能被显式调用且只能执行一次，所以不能有指向构造函数的实例成员指针 运算符为 .* 和 -\u0026gt;* 实例成员指针是成员相对于对象首地址的偏移，不是真正代表地址的指针 实例成员指针不能移动 实例成员指针不能转换类型  静态成员指针  静态成员指针前不用加类作用域 静态数据成员指针与普通的变量指针相同 静态函数成员指针与普通的函数指针相同  案例  静态成员指针存放成员地址，实例成员指针存放成员偏移 静态成员指针可以移动，实例成员指针不能移动 静态成员指针可以强制类型转换，实例成员指针不能强制转换类型  class Crowd { public: int a; // 表示在本类中不会修改此变量 \t// 但其它进程有可能会修改，表示会有多进程并发 \tvolatile int b; // C++17 支持 \t// 使用 inline、const 修饰 static 变量可在类体内进行初始化 \tconst static int j = 3; static int num; public: Crowd(); Crowd(int x); ~Crowd(); // 类体内函数定义 \t// 会被内联处理 \tint f() { b++; cout \u0026lt;\u0026lt; \u0026#34;F()\\n\u0026#34;; return b; } // const this 指针，参数类型不同，所以可被重载 \tint f()const { cout \u0026lt;\u0026lt; \u0026#34;const F()\\n\u0026#34;; return b; } static int getNum(); static Crowd\u0026amp; dec(Crowd\u0026amp; a); }; // 静态成员变量类体外初始化 int Crowd::num = 0; Crowd::Crowd() { a = 0; b = 0; Crowd::num++; cout \u0026lt;\u0026lt; \u0026#34;Crowd()\\n\u0026#34;; } Crowd::Crowd(int x): a(x) { b = 0; Crowd::num++; cout \u0026lt;\u0026lt; \u0026#34;Crowd(int)\\n\u0026#34;; } Crowd::~Crowd() { Crowd::num--; } int Crowd::getNum() { return Crowd::num; } Crowd\u0026amp; Crowd::dec(Crowd\u0026amp; a) { a.a = a.a - Crowd::j; return a; } int main() { // 数组会调用无参构造 \tCrowd* arr = new Crowd[3]{ 1,Crowd(2) }; // 第三个元素使用无参构造函数  // 静态数据成员指针 \tint* d = \u0026amp;Crowd::num; // 静态函数成员指针 \tint (*f)() = \u0026amp;Crowd::getNum; cout \u0026lt;\u0026lt; \u0026#34;Crowd number: \u0026#34; \u0026lt;\u0026lt; *d \u0026lt;\u0026lt; endl; Crowd c1; d = \u0026amp;c1.num;\t// 等价于 d = \u0026amp;Crowd::num; \tcout \u0026lt;\u0026lt; \u0026#34;Crowd number: \u0026#34; \u0026lt;\u0026lt; *d \u0026lt;\u0026lt; endl; Crowd c2; cout \u0026lt;\u0026lt; \u0026#34;Crowd number: \u0026#34; \u0026lt;\u0026lt; (*f)() \u0026lt;\u0026lt; endl; // 实例数据成员指针 \tint Crowd::* p = \u0026amp;Crowd::a; // 实例函数成员指针 \tint (Crowd::* pf)() const = \u0026amp;Crowd::f; // 无址引用 \tCrowd\u0026amp;\u0026amp; a = Crowd{ 3 }; Crowd b = Crowd::dec(a); cout \u0026lt;\u0026lt; b.*p \u0026lt;\u0026lt; endl; (b.*pf)(); return 0; } 输出：\nCrowd(int) Crowd(int) Crowd() Crowd number: 3 Crowd() Crowd number: 4 Crowd() Crowd number: 5 Crowd(int) 0 const F() ","permalink":"https://874656645.github.io/posts/228-c++-%E6%88%90%E5%91%98%E6%8C%87%E9%92%88/","summary":"实例成员指针  实例成员指针是指向实例成员的指针，可分为实例数据成员指针和实例函数成员指针 构造函数不能被显式调用且只能执行一次，所以不能有指向构造函数的实例成员指针 运算符为 .* 和 -\u0026gt;* 实例成员指针是成员相对于对象首地址的偏移，不是真正代表地址的指针 实例成员指针不能移动 实例成员指针不能转换类型  静态成员指针  静态成员指针前不用加类作用域 静态数据成员指针与普通的变量指针相同 静态函数成员指针与普通的函数指针相同  案例  静态成员指针存放成员地址，实例成员指针存放成员偏移 静态成员指针可以移动，实例成员指针不能移动 静态成员指针可以强制类型转换，实例成员指针不能强制转换类型  class Crowd { public: int a; // 表示在本类中不会修改此变量 \t// 但其它进程有可能会修改，表示会有多进程并发 \tvolatile int b; // C++17 支持 \t// 使用 inline、const 修饰 static 变量可在类体内进行初始化 \tconst static int j = 3; static int num; public: Crowd(); Crowd(int x); ~Crowd(); // 类体内函数定义 \t// 会被内联处理 \tint f() { b++; cout \u0026lt;\u0026lt; \u0026#34;F()\\n\u0026#34;; return b; } // const this 指针，参数类型不同，所以可被重载 \tint f()const { cout \u0026lt;\u0026lt; \u0026#34;const F()\\n\u0026#34;; return b; } static int getNum(); static Crowd\u0026amp; dec(Crowd\u0026amp; a); }; // 静态成员变量类体外初始化 int Crowd::num = 0; Crowd::Crowd() { a = 0; b = 0; Crowd::num++; cout \u0026lt;\u0026lt; \u0026#34;Crowd()\\n\u0026#34;; } Crowd::Crowd(int x): a(x) { b = 0; Crowd::num++; cout \u0026lt;\u0026lt; \u0026#34;Crowd(int)\\n\u0026#34;; } Crowd::~Crowd() { Crowd::num--; } int Crowd::getNum() { return Crowd::num; } Crowd\u0026amp; Crowd::dec(Crowd\u0026amp; a) { a.","title":"C++——成员指针"},{"content":" volatile 和 const 修饰的变量说明该变量在本程序内不应被修改，但其它程序是可以修改的 volatile 修饰变量，告诉编译器不要优化该变量，每次取值都重新从内存中获取 constexpr 和 inline 修饰的变量，编译器都会进行编译期优化 当对 inline 修饰变量进行取地址操作时，优化会失效 inline 修饰函数相当于 static，只能在当前文件中访问 inline 修饰的变量可以用任意表达式初始化，但这样不保证被优化 inline 其它介绍 static 限制修饰的变量和函数的可见作用域（模块内部），其它的都是副本  ","permalink":"https://874656645.github.io/posts/227-c++-const-volatile-constexpr-inline-static/","summary":" volatile 和 const 修饰的变量说明该变量在本程序内不应被修改，但其它程序是可以修改的 volatile 修饰变量，告诉编译器不要优化该变量，每次取值都重新从内存中获取 constexpr 和 inline 修饰的变量，编译器都会进行编译期优化 当对 inline 修饰变量进行取地址操作时，优化会失效 inline 修饰函数相当于 static，只能在当前文件中访问 inline 修饰的变量可以用任意表达式初始化，但这样不保证被优化 inline 其它介绍 static 限制修饰的变量和函数的可见作用域（模块内部），其它的都是副本  ","title":"C++——volatile、const、constexpr、inline、static"},{"content":"一、部署环境和软件版本 操作系统 版本 win10 JDK 版本 OpenJDK11U-jdk_x64_windows_hotspot_11.0.16.1_1 GeoServer 版本 2.21.1 GeoWebCache 版本 1.21.1 二、说明  安装 JDK，配置 java 环境。 Windows 平台可安装 GeoServer Exe 安装包。 也可以通过 Tomcat 起动服务，需要下载 GeoServer 和 GeoWebCache 的 war 包，并放到 tomcat/webapps 目录下，如果只是发布切片服务，配置 GeoWebCache 即可。  三、软件下载  下载 GeoServer 也可GeoServer 官网下载 下载 GeoWebCache，解压待用  四、配置 GeoServer  将 GeoWebCache 中的 jar 包 \\geowebcache\\WEB-INF\\lib\\gwc-arcgiscache-1.21.1.jar 拷贝到 GeoServer 安装目录 \\webapps\\geoserver\\WEB-INF\\lib。 解压 GeoServer 安装目录下的 jar 包 \\webapps\\geoserver\\WEB-INF\\lib\\gs-gwc-2.21.1.jar 到 gs-gwc-2.21.1 文件夹，将 GeoWebCache 中的 \\geowebcache\\WEB-INF\\geowebcache-arcgiscache-context.xml 文件拷贝到解压的目录 gs-gwc-2.21.1 文件夹下。 修改 gs-gwc-2.21.1 文件夹下的 geowebcache-core-context.xml 文件，添加以下代码：\n\u0026lt;bean id=\u0026quot;gwcArcGIGridsetConfigutation\u0026quot; class=\u0026quot;org.geowebcache.arcgis.layer.ArcGISCacheGridsetConfiguration\u0026quot;/\u0026gt; 修改 gs-gwc-2.21.1 文件夹下的 geowebcache-servlet.xml 文件，添加以下代码：\n\u0026lt;import resource=\u0026quot;geowebcache-arcgiscache-context.xml\u0026quot;/\u0026gt; 将 gs-gwc-2.21.1 文件夹打成 jar 包，替换 GeoServer 安装目录下的 jar 包 \\webapps\\geoserver\\WEB-INF\\lib\\gs-gwc-2.21.1.jar，完成修改。 参考：将文件夹打包成.jar文件 打包，打 jar 包命令：jar -cvfm gs-gwc-2.21.1.jar gs-gwc-2.21.1/META-INF/MANIFEST.MF -C gs-gwc-2.21.1/ .  五、ArcGIS 切片数据 COMPACT（bundle） 格式或 EXPLODED（jpeg、png） 的切片数据均可，参考ArcGIS Desktop 制作影像切片\n六、切片数据配置  打开 \\GeoServer\\gwc\\geowebcache.xml 文件，在 layers 节点下添加 arcgisLayer 节点。  \u0026lt;arcgisLayer\u0026gt; \u0026lt;name\u0026gt;test\u0026lt;/name\u0026gt; \u0026lt;tilingScheme\u0026gt;E:\\\\data\\\\arcgiscache\\\\cachedata\\\\test\\\\conf.xml\u0026lt;/tilingScheme\u0026gt; \u0026lt;tileCachePath\u0026gt;E:\\\\data\\\\arcgiscache\\\\cachedata\\\\test\\\\_alllayers\u0026lt;/tileCachePath\u0026gt; \u0026lt;hexZoom\u0026gt;false\u0026lt;/hexZoom\u0026gt; \u0026lt;/arcgisLayer\u0026gt; 重启 GeoServer 服务，在 切片图层 里就能看到配置的 ArcGIS 切片服务了  参考：\n Geoserver：Geoserver采用内置的GeoWebCache发布Arcgis切片 使用GeoWebCache发布ArcGIS切片地图（实现高清电子地图） GeoServer(GeoWebCache)发布ArcGIS切片的操作方法及利用OpenLayers调用其发布服务的关键代码 GeoWebCache settings  ","permalink":"https://874656645.github.io/posts/226-gis-geoserver-%E5%8F%91%E5%B8%83-arcgis-%E5%88%87%E7%89%87%E7%9A%84-wmts-%E6%9C%8D%E5%8A%A1/","summary":"一、部署环境和软件版本 操作系统 版本 win10 JDK 版本 OpenJDK11U-jdk_x64_windows_hotspot_11.0.16.1_1 GeoServer 版本 2.21.1 GeoWebCache 版本 1.21.1 二、说明  安装 JDK，配置 java 环境。 Windows 平台可安装 GeoServer Exe 安装包。 也可以通过 Tomcat 起动服务，需要下载 GeoServer 和 GeoWebCache 的 war 包，并放到 tomcat/webapps 目录下，如果只是发布切片服务，配置 GeoWebCache 即可。  三、软件下载  下载 GeoServer 也可GeoServer 官网下载 下载 GeoWebCache，解压待用  四、配置 GeoServer  将 GeoWebCache 中的 jar 包 \\geowebcache\\WEB-INF\\lib\\gwc-arcgiscache-1.21.1.jar 拷贝到 GeoServer 安装目录 \\webapps\\geoserver\\WEB-INF\\lib。 解压 GeoServer 安装目录下的 jar 包 \\webapps\\geoserver\\WEB-INF\\lib\\gs-gwc-2.21.1.jar 到 gs-gwc-2.21.1 文件夹，将 GeoWebCache 中的 \\geowebcache\\WEB-INF\\geowebcache-arcgiscache-context.","title":"GIS——GeoServer 发布 ArcGIS 切片的 WMTS 服务"},{"content":" 声明变量时指定排序规则  通过指定模板的第三个参数，对象类型，C++ 2a 支持 lambda 对象\nstruct MyCom{ bool operator()(const string key1, const string key2)const{ return key1 \u0026gt; key2; } }; int main() { // lambda 表达式对象  auto cmp = [](const auto\u0026amp; key1, const auto\u0026amp; key2){return key1 \u0026lt; key2;}; map\u0026lt;string, int, decltype(cmp)\u0026gt; myMap1 = {{\u0026#34;RAM\u0026#34;, 20}, {\u0026#34;GPU\u0026#34;, 15}, {\u0026#34;CPU\u0026#34;, 10} }; // 函数对象  map\u0026lt;string, int, MyCom\u0026gt; myMap2 = {{\u0026#34;CPU\u0026#34;, 10}, {\u0026#34;GPU\u0026#34;, 15}, {\u0026#34;RAM\u0026#34;, 20}}; for(const auto\u0026amp; item : myMap1){ cout \u0026lt;\u0026lt; item.first \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; item.second \u0026lt;\u0026lt; endl; } return 0; } 注意：\n operator() 重载需要 const 修饰符 只能对 key 排序  key_comp  返回 map 比较两个键的 函数对象，该对象是该容器构造函数参数 comp 的副本。\nvalue_comp  返回一个 函数对象，该函数对象通过使用 key_comp 比较函数对象对类型 std :: map :: value_type（key-value pairs） 的对象进行比较。\n按 value 排序  int main() { map\u0026lt;string, int\u0026gt; myMap = {{\u0026#34;RAM\u0026#34;, 10}, {\u0026#34;GPU\u0026#34;, 15},{\u0026#34;CPU\u0026#34;, 20} }; vector\u0026lt;pair\u0026lt;string, int\u0026gt;\u0026gt; vec(myMap.begin(), myMap.end()); sort(vec.begin(), vec.end(), [](const auto\u0026amp; pair1, const auto\u0026amp; pair2){ return pair1.second \u0026lt; pair2.second;}); for(const auto\u0026amp; item : vec){ cout \u0026lt;\u0026lt; item.first \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; item.second \u0026lt;\u0026lt; endl; } return 0; } 参考：\n key_comp value_comp  ","permalink":"https://874656645.github.io/posts/225-stl-map-%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3/","summary":"声明变量时指定排序规则  通过指定模板的第三个参数，对象类型，C++ 2a 支持 lambda 对象\nstruct MyCom{ bool operator()(const string key1, const string key2)const{ return key1 \u0026gt; key2; } }; int main() { // lambda 表达式对象  auto cmp = [](const auto\u0026amp; key1, const auto\u0026amp; key2){return key1 \u0026lt; key2;}; map\u0026lt;string, int, decltype(cmp)\u0026gt; myMap1 = {{\u0026#34;RAM\u0026#34;, 20}, {\u0026#34;GPU\u0026#34;, 15}, {\u0026#34;CPU\u0026#34;, 10} }; // 函数对象  map\u0026lt;string, int, MyCom\u0026gt; myMap2 = {{\u0026#34;CPU\u0026#34;, 10}, {\u0026#34;GPU\u0026#34;, 15}, {\u0026#34;RAM\u0026#34;, 20}}; for(const auto\u0026amp; item : myMap1){ cout \u0026lt;\u0026lt; item.","title":"STL——map 排序相关"},{"content":"ArcGIS Desktop 10.6 一、生成切片方案 打开 ArcGIS Desktop，打开 工具箱( Tools Box ) \u0026ndash;\u0026gt; 系统工具箱( System Tools Box ) \u0026ndash;\u0026gt; 数据管理工具( Data Managment Tools ) \u0026ndash;\u0026gt; 切片缓存( Tile Cache )\u0026ndash;\u0026gt; 生成切片缓存切片方案( Generate Tile Cache Tiling Scheme )\n重要参数：\n 切片格式( Tile Format )：主要是 PNGx、JPEG、MIXED，MIXED 混合格式，指的是在切片的时候，如果检测到瓦片内有透明区域，则这个瓦片使用 PNG32 格式，如果没有，则使用 JPEG 格式。这样做可以在不失去透明通道的前提下，有效降低瓦片数据文件的大小。 切片压缩质量( Tile Compression Quality )：仅对 JPEG（包括 MIXED 中使用 JPEG 的瓦片）有效，参数值需要介于 1-100 之间，默认是 75。 存储格式( Storage Format )：  COMPACT 紧凑格式，也就是把多个瓦片（最多128x128个）存储到一个 bundle 文件的形式，避免出现大量碎文件； EXPLODED 分散格式，就是把每一个瓦片存储成一个图片文件，这个形式的瓦片不能和 tpk 包一起使用。    CGCS2000 切片方案\n二、管理切片缓存 打开 ArcGIS Desktop，打开 工具箱( Tools Box ) \u0026ndash;\u0026gt; 系统工具箱( System Tools Box ) \u0026ndash;\u0026gt; 数据管理工具( Data Managment Tools ) \u0026ndash;\u0026gt; 切片缓存( Tile Cache )\u0026ndash;\u0026gt; 管理切片缓存( Manage Tile Cache )\nCOMPACT 存储格式：\nEXPLODED 存储格式：\n重要参数：\n 管理模式( Manage Mode )：  RECREATE_ALL_TILES： 替换所有瓦片，不管存不存在； RECREATE_EMPTY_TILES： 替换空瓦片，也就是如果存在则不替换； DELETE_TILES： 删除瓦片，这个选项用来删除所有的瓦片数据文件，但是不删除目录结构。（注意：如果输出是已经存在的瓦片目录，则该目录下的 conf.cdi 并不会更新，这在替换了数据源等情况下可能导致输出瓦片与描述信息不对应）    三、导出切片缓存 将 bundle 存储格式导出为图片格式\n打开 ArcGIS Desktop，打开 工具箱( Tools Box ) \u0026ndash;\u0026gt; 系统工具箱( System Tools Box ) \u0026ndash;\u0026gt; 数据管理工具( Data Managment Tools ) \u0026ndash;\u0026gt; 切片缓存( Tile Cache )\u0026ndash;\u0026gt; 导出切片缓存( Export Tile Cache )\n四、注意事项   管理切片缓存错误\n删除 缓存位置( Cache Location ) 下生成的 缓存名称( Cache Name ) 子文件夹，打开 【环境( Environments )】设置对话框，设置 Parallel Processing 参数为 0，然后重新生成\n  参考：\n使用 ArcGIS Desktop 切瓦片\n","permalink":"https://874656645.github.io/posts/224-arcgis-desktop-%E5%88%B6%E4%BD%9C%E5%BD%B1%E5%83%8F%E5%88%87%E7%89%87/","summary":"ArcGIS Desktop 10.6 一、生成切片方案 打开 ArcGIS Desktop，打开 工具箱( Tools Box ) \u0026ndash;\u0026gt; 系统工具箱( System Tools Box ) \u0026ndash;\u0026gt; 数据管理工具( Data Managment Tools ) \u0026ndash;\u0026gt; 切片缓存( Tile Cache )\u0026ndash;\u0026gt; 生成切片缓存切片方案( Generate Tile Cache Tiling Scheme )\n重要参数：\n 切片格式( Tile Format )：主要是 PNGx、JPEG、MIXED，MIXED 混合格式，指的是在切片的时候，如果检测到瓦片内有透明区域，则这个瓦片使用 PNG32 格式，如果没有，则使用 JPEG 格式。这样做可以在不失去透明通道的前提下，有效降低瓦片数据文件的大小。 切片压缩质量( Tile Compression Quality )：仅对 JPEG（包括 MIXED 中使用 JPEG 的瓦片）有效，参数值需要介于 1-100 之间，默认是 75。 存储格式( Storage Format )：  COMPACT 紧凑格式，也就是把多个瓦片（最多128x128个）存储到一个 bundle 文件的形式，避免出现大量碎文件； EXPLODED 分散格式，就是把每一个瓦片存储成一个图片文件，这个形式的瓦片不能和 tpk 包一起使用。    CGCS2000 切片方案","title":"ArcGIS Desktop 制作影像切片"},{"content":"GeoServer Version 2.21.1 一、WMS 服务   获取服务能力元数据：\n  可在网址中指定 version=1.1.0 和 service=WMS 参数\n  获取整个 geoserver 的服务能力，默认 WMS_Capabilities 的 version 是 1.3.0 的\nhttp://172.16.17.127:8066/geoserver/wms?request=getCapabilities\nhttp://172.16.17.127:8066/geoserver/wms?request=getCapabilities\u0026amp;version=1.1.0\n请求网址中不包含工作空间的 1.1.1 版本的 xml 样例\n请求网址中不包含工作空间的 1.3.0 版本的 xml 样例\n  获取其中某个工作空间的服务能力，需要在 geoserver 后面添加工作空间名称\nhttp://172.16.17.127:8066/geoserver/cite/wms?request=getCapabilities\u0026amp;version=1.1.0\n请求网址中包含工作空间的 1.1.1 版本的 xml 样例\n请求网址中包含工作空间的 1.3.0 版本的 xml 样例\n  注意：\n 1.3.0 版本的空间参考标签为 \u0026lt;CRS\u0026gt;，而 1.1.0 版本的空间参考标签为 \u0026lt;SRS\u0026gt; 如果请求的网址指定了工作空间，图层名中就不需要有工作空间名了（比如：cite:hl_2017 和 hl_2017） 1.1.0 版本的图层中包含 geoserver 以图层组方式发布的服务图层，而 1.3.0 版本中就没有了      GeoServer WMS 服务网址请求示例：\n  bbox、width、height、format、srs（version=1.3.0 时为 crs） 为必选参数，styles 参数不是必选\n  OpenLayers 方式浏览：\n不指定工作空间： http://172.16.17.127:8066/geoserver/wms?service=WMS\u0026amp;version=1.1.0\u0026amp;request=GetMap\u0026amp;layers=cite:hl_2017\u0026amp;bbox=3.751160022702132E7%2C4433325.154871847%2C3.757928272385144E7%2C4531336.518872064\u0026amp;width=530\u0026amp;height=768\u0026amp;srs=EPSG%3A4525\u0026amp;styles=\u0026amp;format=application/openlayers 指定工作空间： http://172.16.17.127:8066/geoserver/cite/wms?service=WMS\u0026amp;version=1.1.0\u0026amp;request=GetMap\u0026amp;layers=hl_2017\u0026amp;bbox=3.751160022702132E7%2C4433325.154871847%2C3.757928272385144E7%2C4531336.518872064\u0026amp;width=530\u0026amp;height=768\u0026amp;srs=EPSG%3A4525\u0026amp;styles=\u0026amp;format=application/openlayers   JPEG 格式浏览：\n不指定工作空间： http://172.16.17.127:8066/geoserver/wms?service=WMS\u0026amp;version=1.1.0\u0026amp;request=GetMap\u0026amp;layers=cite:hl_2017\u0026amp;bbox=3.751160022702132E7%2C4433325.154871847%2C3.757928272385144E7%2C4531336.518872064\u0026amp;width=530\u0026amp;height=768\u0026amp;srs=EPSG%3A4525\u0026amp;styles=\u0026amp;format=image/jpeg 指定工作空间： http://172.16.17.127:8066/geoserver/cite/wms?service=WMS\u0026amp;version=1.1.0\u0026amp;request=GetMap\u0026amp;layers=hl_2017\u0026amp;bbox=3.751160022702132E7%2C4433325.154871847%2C3.757928272385144E7%2C4531336.518872064\u0026amp;width=530\u0026amp;height=768\u0026amp;srs=EPSG%3A4525\u0026amp;styles=\u0026amp;format=image/jpeg   PNG 格式浏览：\n不指定工作空间： http://172.16.17.127:8066/geoserver/wms?service=WMS\u0026amp;version=1.1.0\u0026amp;request=GetMap\u0026amp;layers=cite:FHZTGHXZ\u0026amp;bbox=111.37794952600007%2C40.405213106000076%2C111.94963258800004%2C40.86023666700006\u0026amp;width=768\u0026amp;height=611\u0026amp;srs=EPSG%3A4326\u0026amp;styles=\u0026amp;format=image/png 指定工作空间： http://172.16.17.127:8066/geoserver/cite/wms?service=WMS\u0026amp;version=1.1.0\u0026amp;request=GetMap\u0026amp;layers=FHZTGHXZ\u0026amp;bbox=111.37794952600007%2C40.405213106000076%2C111.94963258800004%2C40.86023666700006\u0026amp;width=768\u0026amp;height=611\u0026amp;srs=EPSG%3A4326\u0026amp;styles=\u0026amp;format=image/png ···     平台组织的 WMS 请求网址\nhttp://172.16.17.127:8066/geoserver/cite/wms?service=WMS\u0026amp;version=1.1.0\u0026amp;request=GetMap\u0026amp;layers=hl_2017\u0026amp;srs=EPSG:4326\u0026amp;format=png\u0026amp;width=256\u0026amp;height=256\u0026amp;styles=\u0026amp;bbox=111.37794952600007%2C40.405213106000076%2C111.94963258800004%2C40.86023666700006\n  二、WMTS 服务   获取服务能力的元数据：\nhttp://172.16.17.127:8066/geoserver/gwc/service/wmts?service=WMTS\u0026amp;request=getCapabilities\u0026amp;virsion=1.0.0\n  瓦片访问示例：\nhttp://172.16.17.127:8066/geoserver/gwc/service/wmts?layer=cite%3Ahl_2017\u0026amp;style=\u0026amp;tilematrixset=EPSG%3A4326\u0026amp;Service=WMTS\u0026amp;Request=GetTile\u0026amp;Version=1.0.0\u0026amp;Format=image%2Fpng\u0026amp;TileMatrix=EPSG:4326:9\u0026amp;TileCol=829\u0026amp;TileRow=140\n  GeoServer 发布 ArcGIS 切片服务的过程参考这里，返回的 xml 样例访问示例如下：\ngetCapabilities 请求 1.0.0 版本的包含 ArcGIS 切片服务的 xml 样例\nhttp://localhost:8080/geoserver/gwc/service/wmts?service=WMTS\u0026amp;version=1.0.0\u0026amp;request=GetTile\u0026amp;layer=test\u0026amp;tilematrixset=EPSG:4490_test\u0026amp;format=image/jpeg\u0026amp;tileMatrix=EPSG:4490_test:3\u0026amp;tileRow=6\u0026amp;tileCol=8\n注意：tilematrixset 参数与通过 GeoServer 发布的 WMTS 服务有所不同\n  平台组织的 WMTS 请求网址：\nhttp://localhost:8080/geoserver/gwc/service/wmts?service=WMTS\u0026amp;version=1.0.0\u0026amp;request=GetTile\u0026amp;layer=test\u0026amp;tilematrixset=EPSG:4490_test\u0026amp;format=image/jpeg\u0026amp;tileMatrix=EPSG:4490_test:3\u0026amp;tileRow=6\u0026amp;tileCol=8\n  三、GeoServer   管理界面：\n  存储仓库：数据的存放目录\n  工作空间：类似 mxd 文档，对图层进行组织\n  图层：地图数据\n  图层组：功能类似工作空间，可以添加多个图层的数据\n  参考：\nOGC标准WMTS服务概念与地图商的瓦片编号流派-web地图切片加载\n","permalink":"https://874656645.github.io/posts/223-gis-geoserver-%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1/","summary":"GeoServer Version 2.21.1 一、WMS 服务   获取服务能力元数据：\n  可在网址中指定 version=1.1.0 和 service=WMS 参数\n  获取整个 geoserver 的服务能力，默认 WMS_Capabilities 的 version 是 1.3.0 的\nhttp://172.16.17.127:8066/geoserver/wms?request=getCapabilities\nhttp://172.16.17.127:8066/geoserver/wms?request=getCapabilities\u0026amp;version=1.1.0\n请求网址中不包含工作空间的 1.1.1 版本的 xml 样例\n请求网址中不包含工作空间的 1.3.0 版本的 xml 样例\n  获取其中某个工作空间的服务能力，需要在 geoserver 后面添加工作空间名称\nhttp://172.16.17.127:8066/geoserver/cite/wms?request=getCapabilities\u0026amp;version=1.1.0\n请求网址中包含工作空间的 1.1.1 版本的 xml 样例\n请求网址中包含工作空间的 1.3.0 版本的 xml 样例\n  注意：\n 1.3.0 版本的空间参考标签为 \u0026lt;CRS\u0026gt;，而 1.1.0 版本的空间参考标签为 \u0026lt;SRS\u0026gt; 如果请求的网址指定了工作空间，图层名中就不需要有工作空间名了（比如：cite:hl_2017 和 hl_2017） 1.1.0 版本的图层中包含 geoserver 以图层组方式发布的服务图层，而 1.","title":"GIS——GeoServer 地图服务"},{"content":" 安装相关依赖\nyum install -y perl-ExtUtils-Embed \\ readline-devel zlib-devel pam-devel \\ libxml2-devel libxslt-devel openldap-devel \\ python-devel openssl-devel cmakepcre-develnanowget \\ gcc gcc-c++ ncurses-devel perl git `\n  编译命令：\nmkdir ~/nginx_sources ~/nginx cd ~/nginx_sources git clone https://github.com/winshining/nginx-http-flv-module.git curl -O -L http://hg.nginx.org/nginx/archive/stable-1.22.tar.gz # 其他版本 http://hg.nginx.org/nginx/archive/release-1.23.1.zip tar xzvf stable-1.22.tar.gz cd nginx-stable-1.22 ./auto/configure --prefix=\u0026#34;$HOME/nginx\u0026#34; --sbin-path=\u0026#34;$HOME/nginx\u0026#34; \\ --with-select_module \\ --with-poll_module \\ --with-file-aio \\ --with-http_ssl_module \\ --with-http_realip_module \\ --with-http_sub_module \\ --with-http_flv_module \\ --add-module=\u0026#34;../nginx-http-flv-module\u0026#34; \\ --with-http_mp4_module \\ --with-http_gzip_static_module \\ --with-http_secure_link_module \\ --with-http_stub_status_module \\ --with-http_perl_module \\ --with-ld-opt=\u0026#34;-Wl,-E\u0026#34; make make install   注意事项：\n在目录: /usr/local/lib64/perl5 文件夹下也有需要的动态库和文件（ nginx.so 文件和 nginx.pm 文件）\n  移植后运行，如果出现如下错误提示，说明缺少依赖的动态库 nginx.so 和 nginx.pm 文件：\nCan\u0026#39;t load \u0026#39;./nginx\u0026#39; for module nginx: ./nginx: cannot dynamically load executable at /usr/lib64/perl5/DynaLoader.pm line 190. at -e line 0. Compilation failed in require. BEGIN failed--compilation aborted. nginx: [alert] perl_parse() failed: 255 `\n  参考：\n 【入门】ffmpeg、nginx、nginx-http-flv-module转发rtsp流、VLC查看 Building nginx from Sources  ","permalink":"https://874656645.github.io/posts/222-compile-nginx-on-centos/","summary":"安装相关依赖\nyum install -y perl-ExtUtils-Embed \\ readline-devel zlib-devel pam-devel \\ libxml2-devel libxslt-devel openldap-devel \\ python-devel openssl-devel cmakepcre-develnanowget \\ gcc gcc-c++ ncurses-devel perl git `\n  编译命令：\nmkdir ~/nginx_sources ~/nginx cd ~/nginx_sources git clone https://github.com/winshining/nginx-http-flv-module.git curl -O -L http://hg.nginx.org/nginx/archive/stable-1.22.tar.gz # 其他版本 http://hg.nginx.org/nginx/archive/release-1.23.1.zip tar xzvf stable-1.22.tar.gz cd nginx-stable-1.22 ./auto/configure --prefix=\u0026#34;$HOME/nginx\u0026#34; --sbin-path=\u0026#34;$HOME/nginx\u0026#34; \\ --with-select_module \\ --with-poll_module \\ --with-file-aio \\ --with-http_ssl_module \\ --with-http_realip_module \\ --with-http_sub_module \\ --with-http_flv_module \\ --add-module=\u0026#34;../nginx-http-flv-module\u0026#34; \\ --with-http_mp4_module \\ --with-http_gzip_static_module \\ --with-http_secure_link_module \\ --with-http_stub_status_module \\ --with-http_perl_module \\ --with-ld-opt=\u0026#34;-Wl,-E\u0026#34; make make install   注意事项：","title":"Compile Nginx on CentOS"},{"content":" 应用程序内存空间（局部内存堆），程序进程结束时，会被统一都回收释放 公共内存区（全局内存堆）（写设备驱动程序时会使用），使用不当会造成内存泄漏 extern 不能修饰其他模块的静态变量 函数内用 extern 修饰的变量要么来自全局变量，要么来自本身模块的静态变量 extern 只能修饰外部变量（就近原则），不能修饰局部变量  test.cpp：\n#include \u0026lt;iostream\u0026gt; int etn = 3;\t// 全局变量 static int s_m;\t// 模块静态变量  void layout() { std::cout \u0026lt;\u0026lt; \u0026#34;test.cpp\\tetn=\u0026#34; \u0026lt;\u0026lt; etn \u0026lt;\u0026lt; std::endl; } another.cpp：\nstatic int etn = 4; // 模块静态变量 void myFunc(){ int etn = 5; // 局部自动变量 \t{ extern int etn; int x = etn;// x 是 4 而不是 5 \t} } charTest.cpp：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;locale\u0026gt;void myPrint(){ setlocale(LC_ALL, \u0026#34;chs\u0026#34;); char16_t c1 = u\u0026#39;马\u0026#39;; char32_t c2 = U\u0026#39;马\u0026#39;; wchar_t x = u\u0026#39;马\u0026#39;; wcout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } main.cpp：\n// 模块静态变量 static int x = -1, y = -2; // 全局变量 int i; // extern 全局变量 extern int etn; // 错误，不能 extern 其他模块的静态变量 // extern int s_m;  // x y 也是全局变量，只不过共用一块内存 // 所以会与上面的 x y 冲突 // static union{ // int x = 97; // char y; // };  void layout(); int main() { extern int x; // OK 自身模块的静态变量  x = 11; cout \u0026lt;\u0026lt; ::x \u0026lt;\u0026lt; endl; // 11  static int y = 10; // 局部静态变量  cout\u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; // 10  cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; // 11  cout \u0026lt;\u0026lt; ::y \u0026lt;\u0026lt; endl; // -2 访问模块静态变量  int xx = 555; // 八进制格式化打印  int z = printf(\u0026#34;%#o\\n\u0026#34;, xx); // 01053  // 十六进制格式化打印  z = printf(\u0026#34;%#x\\n\u0026#34;, xx); // 0x22b  // 打印数字 x 的位数  char buf[256]; z = sprintf(buf, \u0026#34;%d\u0026#34;, xx); cout \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; // 3  // 5 个固定宽度 左对齐  printf(\u0026#34;l%-5cr\\n\u0026#34;, \u0026#39;A\u0026#39;); // lA r  // 8 位显示浮点数（包括小数点） 用 0 填充 小数位精确到 2 位  printf(\u0026#34;l%08.2fr\\n\u0026#34;, -20.405); // l-0020.41r  cout \u0026lt;\u0026lt; strlen(\u0026#34;abc\u0026#34;) \u0026lt;\u0026lt; endl; // 3  cout \u0026lt;\u0026lt; sizeof(\u0026#34;abc\u0026#34;) \u0026lt;\u0026lt; endl; // 4  string s = \u0026#34;abc\u0026#34;s; cout \u0026lt;\u0026lt; s.length() \u0026lt;\u0026lt; endl; // 3  cout \u0026lt;\u0026lt; sizeof(s) \u0026lt;\u0026lt; endl; // x86 28  // x64 32(Linux) 指针为 8 字节，32 位的为 4 字节  etn = 4; layout(); // test.cpp etn=4  return 0; } ","permalink":"https://874656645.github.io/posts/221-c++-%E6%9D%82%E8%AE%B0/","summary":"应用程序内存空间（局部内存堆），程序进程结束时，会被统一都回收释放 公共内存区（全局内存堆）（写设备驱动程序时会使用），使用不当会造成内存泄漏 extern 不能修饰其他模块的静态变量 函数内用 extern 修饰的变量要么来自全局变量，要么来自本身模块的静态变量 extern 只能修饰外部变量（就近原则），不能修饰局部变量  test.cpp：\n#include \u0026lt;iostream\u0026gt; int etn = 3;\t// 全局变量 static int s_m;\t// 模块静态变量  void layout() { std::cout \u0026lt;\u0026lt; \u0026#34;test.cpp\\tetn=\u0026#34; \u0026lt;\u0026lt; etn \u0026lt;\u0026lt; std::endl; } another.cpp：\nstatic int etn = 4; // 模块静态变量 void myFunc(){ int etn = 5; // 局部自动变量 \t{ extern int etn; int x = etn;// x 是 4 而不是 5 \t} } charTest.","title":"C++ 杂记"},{"content":"0. 编译的版本  ffmpeg-4.4 nasm-2.14.02 yasm-1.3.0 H.264 H.265 fdk-aac-2.0.0  1. Get the Dependencies   需要 superuser 或者 root 用户\n# yum install autoconf automake bzip2 bzip2-devel cmake freetype-devel gcc gcc-c++ git libtool make pkgconfig zlib-devel\n  新建 ffmpeg_sources 文件夹，把需要的源代码都放到这个文件夹中\nmkdir ~/ffmpeg_sources\n  新建 ffmpeg_build 文件夹，把构建的项目文件都放到这个文件夹中\nmkdir ~/ffmpeg_build\n  新建 bin 文件夹，把编译生成的文件都放到这个文件夹中\nmkdir ~/bin\n  2. Install NASM assembler 一些库使用的汇编程序。强烈建议这样做，否则构建可能会非常缓慢。\ncd ~/ffmpeg_sources curl -O -L https://www.nasm.us/pub/nasm/releasebuilds/2.14.02/nasm-2.14.02.tar.bz2 tar xjvf nasm-2.14.02.tar.bz2 cd nasm-2.14.02 ./autogen.sh ./configure --prefix=\u0026#34;$HOME/ffmpeg_build\u0026#34; --bindir=\u0026#34;$HOME/bin\u0026#34; make make install 3. Install Yasm assembler 一些库使用的汇编程序。强烈建议这样做，否则构建可能会非常缓慢。\ncd ~/ffmpeg_sources curl -O -L https://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz tar xzvf yasm-1.3.0.tar.gz cd yasm-1.3.0 ./configure --prefix=\u0026#34;$HOME/ffmpeg_build\u0026#34; --bindir=\u0026#34;$HOME/bin\u0026#34; make make install 4. Install libx264 Requires ffmpeg to be configured with --enable-gpl --enable-libx264.\ncd ~/ffmpeg_sources git clone --branch stable --depth 1 https://code.videolan.org/videolan/x264.git cd x264 PKG_CONFIG_PATH=\u0026#34;$HOME/ffmpeg_build/lib/pkgconfig\u0026#34; ./configure --prefix=\u0026#34;$HOME/ffmpeg_build\u0026#34; --bindir=\u0026#34;$HOME/bin\u0026#34; --enable-static make make install Warning: If you get Found no assembler. Minimum version is nasm-2.13 or similar after running ./configure then the outdated nasm package from the repo is installed. Run yum remove nasm \u0026amp;\u0026amp; hash -d nasm or export PATH=$HOME/bin:$PATH and x264 will then use your newly compiled nasm instead. Ensure environment is able to resolve path to nasm binary.\n5. Install libx265 Requires ffmpeg to be configured with --enable-gpl --enable-libx265.\ncd ~/ffmpeg_sources git clone --branch stable --depth 2 https://bitbucket.org/multicoreware/x265_git cd ~/ffmpeg_sources/x265_git/build/linux PKG_CONFIG_PATH=\u0026#34;$HOME/ffmpeg_build/lib/pkgconfig\u0026#34; cmake -G \u0026#34;Unix Makefiles\u0026#34; -DCMAKE_INSTALL_PREFIX=\u0026#34;$HOME/ffmpeg_build\u0026#34; -DENABLE_SHARED:bool=off ../../source make make install 6. Install libfdk_aac Requires ffmpeg to be configured with --enable-libfdk_aac (and --enable-nonfree if you also included --enable-gpl).\ncd ~/ffmpeg_sources git clone --depth 1 https://github.com/mstorsjo/fdk-aac cd fdk-aac autoreconf -fiv ./configure --prefix=\u0026#34;$HOME/ffmpeg_build\u0026#34; --bindir=\u0026#34;$HOME/bin\u0026#34; --disable-shared make make install 7. Install FFmpeg cd ~/ffmpeg_sources curl -O -L https://ffmpeg.org/releases/ffmpeg-4.4.tar.bz2 tar xjvf ffmpeg-4.4.tar.bz2 cd ~/ffmpeg_sources/ffmpeg-4.4 PATH=\u0026#34;$HOME/bin:$PATH\u0026#34; PKG_CONFIG_PATH=\u0026#34;$HOME/ffmpeg_build/lib/pkgconfig\u0026#34; ./configure \\ --prefix=\u0026#34;$HOME/ffmpeg_build\u0026#34; \\ --pkg-config-flags=\u0026#34;--static\u0026#34; \\ --extra-cflags=\u0026#34;-I$HOME/ffmpeg_build/include\u0026#34; \\ --extra-ldflags=\u0026#34;-L$HOME/ffmpeg_build/lib\u0026#34; \\ --extra-libs=-lpthread \\ --extra-libs=-lm \\ --bindir=\u0026#34;$HOME/bin\u0026#34; \\ --enable-gpl \\ --enable-libfdk_aac \\ --enable-libx264 \\ --enable-libx265 \\ --enable-nonfree make make install hash -d ffmpeg 问题   按照官方文档编译 libx265 后，在安装 ffmpeg4 --enable-libx265 出现 ERROR: x265 not found using pkg-config 的问题，解决办法参考这里。\n 在执行 cmake 命令前，指定 x265.pc 文件的生成路径：PKG_CONFIG_PATH=\u0026quot;$HOME/ffmpeg_build/lib/pkgconfig\u0026quot; cmake -G \u0026quot;Unix Makefiles\u0026quot; -DCMAKE_INSTALL_PREFIX=\u0026quot;$HOME/ffmpeg_build\u0026quot; -DENABLE_SHARED:bool=off ../../source 或者将 x265.pc 文件的生成路径添加到环境变量 PKG_CONFIG_PATH 中：export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig 在编译 ffmpeg 时添加 --extra-libs=-lpthread 配置    经过测试，4.3.x 的 ffmpeg 版本编译会有问题，解决办法参考这里，在libavcodec/asvdec.c文件开头加上 ==\u0026gt; #include “libavutil/reverse.c”，其他同理。\n  注意添加 PATH 环境变量：export PATH=$HOME/bin:$PATH。\n  查看环境变量：env。\n  ","permalink":"https://874656645.github.io/posts/220-compile-ffmpeg-on-centos/","summary":"0. 编译的版本  ffmpeg-4.4 nasm-2.14.02 yasm-1.3.0 H.264 H.265 fdk-aac-2.0.0  1. Get the Dependencies   需要 superuser 或者 root 用户\n# yum install autoconf automake bzip2 bzip2-devel cmake freetype-devel gcc gcc-c++ git libtool make pkgconfig zlib-devel\n  新建 ffmpeg_sources 文件夹，把需要的源代码都放到这个文件夹中\nmkdir ~/ffmpeg_sources\n  新建 ffmpeg_build 文件夹，把构建的项目文件都放到这个文件夹中\nmkdir ~/ffmpeg_build\n  新建 bin 文件夹，把编译生成的文件都放到这个文件夹中\nmkdir ~/bin\n  2. Install NASM assembler 一些库使用的汇编程序。强烈建议这样做，否则构建可能会非常缓慢。\ncd ~/ffmpeg_sources curl -O -L https://www.","title":"Compile FFmpeg on CentOS"},{"content":"方法一：   可以通过 获取资产注册表（Get Asset Registry） + 按路径获取资产（Get Asset by Path） 获取路径下的所有类型资产；\n  通过 获取完整名称（GetFullName） + 包含（Contains） 筛选需要的资产；\n  通过 获取资产（GetAsset） 获取资产对象\n  资产对象的属性：\n  方法二：   可以通过 获取资产注册表（Get Asset Registry） + 按对象路径获取资产（Get Asset by Object Path） 直接获取想要的资产对象；\n  再通过 获取资产（GetAsset） + cast 将资产对象转换为需要的对象类型；\n  注意：资产路径的格式：\n map : World'/Game/Maps/NewWorld.NewWorld' 蓝图类 : 要加 _C 例如 Blueprint'/Game/Blueprints/MySpringArmPawn.MySpringArmPawn_C'  参考：\n UE4 | BP | 使用蓝图获取Uasset资源 关于UE4动态资源加载(蓝图类)  ","permalink":"https://874656645.github.io/posts/219-unreal-%E4%BD%BF%E7%94%A8%E8%93%9D%E5%9B%BE%E8%8E%B7%E5%8F%96-uasset-%E8%B5%84%E6%BA%90/","summary":"方法一：   可以通过 获取资产注册表（Get Asset Registry） + 按路径获取资产（Get Asset by Path） 获取路径下的所有类型资产；\n  通过 获取完整名称（GetFullName） + 包含（Contains） 筛选需要的资产；\n  通过 获取资产（GetAsset） 获取资产对象\n  资产对象的属性：\n  方法二：   可以通过 获取资产注册表（Get Asset Registry） + 按对象路径获取资产（Get Asset by Object Path） 直接获取想要的资产对象；\n  再通过 获取资产（GetAsset） + cast 将资产对象转换为需要的对象类型；\n  注意：资产路径的格式：\n map : World'/Game/Maps/NewWorld.NewWorld' 蓝图类 : 要加 _C 例如 Blueprint'/Game/Blueprints/MySpringArmPawn.MySpringArmPawn_C'  参考：\n UE4 | BP | 使用蓝图获取Uasset资源 关于UE4动态资源加载(蓝图类)  ","title":"Unreal——使用蓝图获取 uasset 资源"},{"content":"  蓝图接口（Blueprint Interface） 是一个或多个函数的集合——只有名称，没有实现。\n  由于接口函数没有实现，作为设计人员，所能做的就是指定一系列类型化输入和输出。\n  蓝图接口也有一定的局限性：\n 不能包含变量 不能编辑图表 不能添加组件    其他蓝图类 Actor 实现蓝图接口：\n在 类设置 中添加接口\n  参考：\n 蓝图接口 【教程】UE4中接口的使用\u0026ndash;蓝图篇（一）  ","permalink":"https://874656645.github.io/posts/218-unreal-%E8%93%9D%E5%9B%BE%E6%8E%A5%E5%8F%A3/","summary":"  蓝图接口（Blueprint Interface） 是一个或多个函数的集合——只有名称，没有实现。\n  由于接口函数没有实现，作为设计人员，所能做的就是指定一系列类型化输入和输出。\n  蓝图接口也有一定的局限性：\n 不能包含变量 不能编辑图表 不能添加组件    其他蓝图类 Actor 实现蓝图接口：\n在 类设置 中添加接口\n  参考：\n 蓝图接口 【教程】UE4中接口的使用\u0026ndash;蓝图篇（一）  ","title":"Unreal——蓝图接口"},{"content":"  所有可以放入关卡的对象都是 Actor，比如摄像机、静态网格体、玩家起始位置。\n  Actor支持三维变换，例如平移、旋转和缩放。\n  可以通过游戏逻辑代码（C++或蓝图）创建（在蓝图中使用 从类生成Actor 节点）或 销毁Actor。\n  每一个 Actor 均有一个 DefaultSceneRoot 组件，它是默认情况下的场景组件（SceneComponent），该组件不支持可视化，在场景中是看不到的，也不可分配网格，只是 Actor 的默认场景根。\n  Actor 必须有一个默认场景根。可以使用其他的组件替换默认场景根，但是只要删除所有的其他组件，场景默认根（DefaultSceneRoot）就会自动显示，这个变量名是系统保留，不能用来命名他组件。\n  当设置Actor的位置、旋转、缩放时，同时也在设置默认场景根的位置、旋转、缩放。\n  注意：\n Actor 不直接保存变换（位置、旋转和缩放）数据，只是一个可以挂载Component的类而已 在某种意义上，Actor 可被视为包含特殊类型 对象（称作组件 Component）的容器 如果 Actor 的根组件存在，则使用它的变换数据    参考：\n Actors UE4-Actor  ","permalink":"https://874656645.github.io/posts/217-unreal-actor-%E8%93%9D%E5%9B%BE%E7%B1%BB/","summary":"  所有可以放入关卡的对象都是 Actor，比如摄像机、静态网格体、玩家起始位置。\n  Actor支持三维变换，例如平移、旋转和缩放。\n  可以通过游戏逻辑代码（C++或蓝图）创建（在蓝图中使用 从类生成Actor 节点）或 销毁Actor。\n  每一个 Actor 均有一个 DefaultSceneRoot 组件，它是默认情况下的场景组件（SceneComponent），该组件不支持可视化，在场景中是看不到的，也不可分配网格，只是 Actor 的默认场景根。\n  Actor 必须有一个默认场景根。可以使用其他的组件替换默认场景根，但是只要删除所有的其他组件，场景默认根（DefaultSceneRoot）就会自动显示，这个变量名是系统保留，不能用来命名他组件。\n  当设置Actor的位置、旋转、缩放时，同时也在设置默认场景根的位置、旋转、缩放。\n  注意：\n Actor 不直接保存变换（位置、旋转和缩放）数据，只是一个可以挂载Component的类而已 在某种意义上，Actor 可被视为包含特殊类型 对象（称作组件 Component）的容器 如果 Actor 的根组件存在，则使用它的变换数据    参考：\n Actors UE4-Actor  ","title":"Unreal——Actor 蓝图类"},{"content":"  Actor\n  Actor 是可以放到关卡中的任何对象，例如摄像机、静态网格体或玩家出生点位置\n  Actor 支持 3D 变换，例如转换、旋转和缩放\n  Actor 在 UE 中是只是一个可以挂载 Component的类而已。所以，需要挂载组件的时候，才应该继承自 Actor 类。很多时候，写一个 Manager 或者一个 Data 又或者只是解析一个Config，只需要写一个 C++ 类就可以了\n  可以通过 gameplay 代码（C++ 或蓝图）创建（生成）或销毁 Actor，在蓝图中使用 从类生成Actor 节点，生成后就自动添加到场景中并能在场景中看到\n    Pawn\nPawn 是 Actor 的子类，作为游戏内的形象或人像（例如游戏中的角色）。玩家或游戏的 AI 可以控制 Pawn，将其作为非玩家角色（NPC），可以理解为在游戏中的肉体。\n  Character\n 角色（Character） 是计划用作玩家角色的 Pawn Actor 的子类。角色子类包括碰撞设置、双足运动的输入绑定以及用于玩家控制动作的其他代码 相比于 Pawn 类，Character 类提供了一个Movement 组件，这个组件提供了角色移动基本逻辑功能，包括角色的移动和跳跃，还可以依据需求扩展出不同的移动状态，比如爬行、蹲伏 当对象逻辑简单、不需要过多的逻辑动作（比如方块、飞船）那么可以选择继承 Pawn 而不是继承 Character 类    Controller\n玩家控制器（Player Controller） 获取玩家输入，并将其转换到游戏内的互动中。每个游戏内部都至少具有一个玩家控制器。玩家控制器通常操控一个 Pawn 或角色作为玩家在游戏中的呈现方式。\n以下引用自大象无形的描述：\n Controller 是漂浮在 Pawn/Character 之上的灵魂。它操纵着 Pawn 和 Character 的行为。Controller可以是 AI，AIController 类，你可以在这个类中使用虚幻引擎优秀的行为树/EQS 环境查询系统。同样也可以是玩家，Player Controller 类。你可以在这个类中绑定输入，然后转化为对 Pawn 的指令。我希望阐述的是，为何虚幻引擎采用这样的设计。Epic 给出的理由非常简单：“不同的怪物也许会共享同样的 Controller，从而获得类似的行为”。其实，Controller 抽象掉了“怪物行为”，也就是扮演了有神论者眼中“灵魂”的角色。既然是灵魂，那么肉体就不唯一，因此灵魂可以通过 Possess/UnPossess 来控制一个肉体，或者从一个肉体上离开。肉体拥有的只是简单的前进、转向、跳跃、开火等函数。而 Controller 则是能调用这些函数。从某种意义上来说，MVC 中的 Controller 与虚幻引擎这套系统有着某种类似。虚幻引擎的 Controller 对应着 MVC 的 Controller，Pawn 就是 Model，而 Pawn挂载的动态网格组件（骨架网格或者静态网格），对应着 MVC 的 View。虽然这种比喻不是非常恰当，但是能方便理解。\n  ————大象无形：虚幻引擎程序设计浅析\n   Game Model Base\n 游戏模式（Game Mode） 设置要运行的游戏的规则 针对不同的关卡重载游戏模式。无论你选择以何种方式实施，每个关卡都只能有一个游戏模式    GameInstance\n这是一个全局的单例，这个单例会在游戏项目开始运行时创建，直到游戏结束时销毁，记录游戏中的状态值。\n  Actor Compoment、Scene Compoment 组件\n 场景中看到的所有对象皆是 Actor，而 Actor 复杂的功能是由许多不同的 Component 共同实现的 UActorComponent 提供最一般的功能 USceneComponent 提供三维的空间变换以及嵌套功能 UPrimitiveComponent 提供了可视化的功能    参考：\n 虚幻引擎术语 UE4中Actor、Pawn、Character等各种类的详细了解 常见的基类（二） Actor、Pawn、Character、Controller  ","permalink":"https://874656645.github.io/posts/216-unreal-%E9%80%9A%E7%94%A8%E5%9F%BA%E7%B1%BBactorpawncharacter%E7%AD%89/","summary":"Actor\n  Actor 是可以放到关卡中的任何对象，例如摄像机、静态网格体或玩家出生点位置\n  Actor 支持 3D 变换，例如转换、旋转和缩放\n  Actor 在 UE 中是只是一个可以挂载 Component的类而已。所以，需要挂载组件的时候，才应该继承自 Actor 类。很多时候，写一个 Manager 或者一个 Data 又或者只是解析一个Config，只需要写一个 C++ 类就可以了\n  可以通过 gameplay 代码（C++ 或蓝图）创建（生成）或销毁 Actor，在蓝图中使用 从类生成Actor 节点，生成后就自动添加到场景中并能在场景中看到\n    Pawn\nPawn 是 Actor 的子类，作为游戏内的形象或人像（例如游戏中的角色）。玩家或游戏的 AI 可以控制 Pawn，将其作为非玩家角色（NPC），可以理解为在游戏中的肉体。\n  Character\n 角色（Character） 是计划用作玩家角色的 Pawn Actor 的子类。角色子类包括碰撞设置、双足运动的输入绑定以及用于玩家控制动作的其他代码 相比于 Pawn 类，Character 类提供了一个Movement 组件，这个组件提供了角色移动基本逻辑功能，包括角色的移动和跳跃，还可以依据需求扩展出不同的移动状态，比如爬行、蹲伏 当对象逻辑简单、不需要过多的逻辑动作（比如方块、飞船）那么可以选择继承 Pawn 而不是继承 Character 类    Controller","title":"Unreal——通用基类（Actor、Pawn、Character等）"},{"content":"  函数调用会等待函数执行结果，事件调用只是触发但不会等待\n事件是异步执行，触发后，会在新的线程中执行，所以可以使用 Delay，函数和宏的调用是同步执行，是单线程的，所以在函数中不能使用 Timeline、Delay 和 Http 请求 等操作。\n  事件没有返回值，函数和宏可以有返回值\n  函数和事件可以跨蓝图类访问，而宏只可以在定义的蓝图类内访问（宏库可以跨蓝图类访问）\n  函数可以用局部变量，事件没有局部变量\n  因为函数执行顺序有保证，所以优先使用函数\n  函数可以被继承，而宏不可以被继承，子类无法使用父类的宏\n  没有返回值的函数，在被子类 Overide 时，会变成事件\n  参考：\n UE4蓝图之函数、事件、宏的区别 【UE4笔记】Event\u0026amp;Function事件和函数的区别 [UE4]函数和事件的区别  ","permalink":"https://874656645.github.io/posts/215-unreal-%E8%93%9D%E5%9B%BE%E5%87%BD%E6%95%B0%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%AE%8F/","summary":"  函数调用会等待函数执行结果，事件调用只是触发但不会等待\n事件是异步执行，触发后，会在新的线程中执行，所以可以使用 Delay，函数和宏的调用是同步执行，是单线程的，所以在函数中不能使用 Timeline、Delay 和 Http 请求 等操作。\n  事件没有返回值，函数和宏可以有返回值\n  函数和事件可以跨蓝图类访问，而宏只可以在定义的蓝图类内访问（宏库可以跨蓝图类访问）\n  函数可以用局部变量，事件没有局部变量\n  因为函数执行顺序有保证，所以优先使用函数\n  函数可以被继承，而宏不可以被继承，子类无法使用父类的宏\n  没有返回值的函数，在被子类 Overide 时，会变成事件\n  参考：\n UE4蓝图之函数、事件、宏的区别 【UE4笔记】Event\u0026amp;Function事件和函数的区别 [UE4]函数和事件的区别  ","title":"Unreal——蓝图函数、事件和宏"},{"content":"注意： UE5 默认使用的是 DX12，有可能会在渲染方面出现奇怪的问题，需要特别注意。\nRHI 是 Render Hardware Interface 的缩写，虚幻引擎通过 RHI 把各个平台的图形 API 包装成统一接口，供上层渲染来使用，让业务不用过多的关注 API 细节（实际还得关注RHI 细节）。从代码结构上来看，RHI 封装的比较贴合于现代的图形 API(vulkan, metal, DX12)，也支持 opengl/opengles。这个接口是广义上的概念，不仅指 C++ 的纯虚基类，也包括一些全局变量，全局函数等。\n参考：\n UE4/UE5的RHI(Vulkan为例)  ","permalink":"https://874656645.github.io/posts/214-unreal-defaultgraphicsrhi/","summary":"注意： UE5 默认使用的是 DX12，有可能会在渲染方面出现奇怪的问题，需要特别注意。\nRHI 是 Render Hardware Interface 的缩写，虚幻引擎通过 RHI 把各个平台的图形 API 包装成统一接口，供上层渲染来使用，让业务不用过多的关注 API 细节（实际还得关注RHI 细节）。从代码结构上来看，RHI 封装的比较贴合于现代的图形 API(vulkan, metal, DX12)，也支持 opengl/opengles。这个接口是广义上的概念，不仅指 C++ 的纯虚基类，也包括一些全局变量，全局函数等。\n参考：\n UE4/UE5的RHI(Vulkan为例)  ","title":"Unreal——DefaultGraphicsRHI"},{"content":"  射线法：不需考虑精度误差和多边形点给出的顺序。\n  转角法：要求多边形是有顺序的，按照多边形顶点逆时针顺序，从 P 点到顶点 Vi 分别做连线，其中 αi 为 Vi 和 Vi+1 之间的夹角。其中 α 角度逆时针为正，顺时针为负，这样所有到顶点做连线之间夹角和为(环绕数)0，这点P在多边形外部，否则在内部。\n  射线法改进：针对有方向的多边形，通过判断射线穿过的边和点的位置（比如点在线的左侧为正，右侧为负），和为 0 则点在外部。\n  叉积法：适用凸多边形，如果一个点在多边形所有有向边的左边，那么这个点一定在多边形内部。\n  面积法：类似叉积法，适用凸多边形。如果点在多边形内部或者边上，那么点与多边形所有边组成的三角形面积和等于多边形面积。\n  参考：\n 详谈判断点在多边形内的七种方法（最全面） hdu1756 hrbust1429 为例  ","permalink":"https://874656645.github.io/posts/213-%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8/","summary":"  射线法：不需考虑精度误差和多边形点给出的顺序。\n  转角法：要求多边形是有顺序的，按照多边形顶点逆时针顺序，从 P 点到顶点 Vi 分别做连线，其中 αi 为 Vi 和 Vi+1 之间的夹角。其中 α 角度逆时针为正，顺时针为负，这样所有到顶点做连线之间夹角和为(环绕数)0，这点P在多边形外部，否则在内部。\n  射线法改进：针对有方向的多边形，通过判断射线穿过的边和点的位置（比如点在线的左侧为正，右侧为负），和为 0 则点在外部。\n  叉积法：适用凸多边形，如果一个点在多边形所有有向边的左边，那么这个点一定在多边形内部。\n  面积法：类似叉积法，适用凸多边形。如果点在多边形内部或者边上，那么点与多边形所有边组成的三角形面积和等于多边形面积。\n  参考：\n 详谈判断点在多边形内的七种方法（最全面） hdu1756 hrbust1429 为例  ","title":"判断点是否在多边形内部"},{"content":"一、注意事项：  线程处理类继承于 QObject 线程处理类对象不能有父对象 处理完成后向外发信号 即使 QThread 线程内部的处理对象运行结束了，QThread 线程对象也不会自动释放，需要手动 quit() + wait() 线程处理类对象创建成功后，需要通过 moveToThread() 函数移动到 QThread 对象中 需要通过其他线程发信号来启动另外线程中的处理类对象的处理函数 子线程中不要操作图形界面  二、connect 第五个参数的作用 指定信号和槽的连接方式：自动连接、直接连接、队列连接，多线程时才有意义，默认为 Qt::AutoConnection。\n Qt::AutoConnection（自动连接）：多线程时是 Qt::QueuedConnection（队列连接），单线程时是 Qt::DirectConnection（直接连接） Qt::QueuedConnection（队列连接）：槽函数所在线程和信号接收者所在线程相同 Qt::DirectConnection（直接连接）：槽函数所在线程和信号发送者所在线程相同  三、代码示例   线程处理类\nclass MyThreadPro : public QObject { Q_OBJECT public: explicit MyThreadPro(QObject *parent = nullptr); // 后台处理函数  void startProcessing(); // 是否结束标识位  void setFlag(bool b = false); signals: // 向其他线程发送信号  void myTimeout(); private: bool stopRunning; };   主窗口类\nThreadProWidget::ThreadProWidget(QWidget *parent) : QWidget(parent), ui(new Ui::ThreadProWidget) { ui-\u0026gt;setupUi(this); // 新建子线程处理对象，不能指定父对象  myThread = new MyThreadPro(); // 创建子线程  thread = new QThread(this); // 将处理类对象移动到子线程中  myThread-\u0026gt;moveToThread(thread); // 绑定子线程处理结束信号  connect(myThread, \u0026amp;MyThreadPro::myTimeout, this, \u0026amp;ThreadProWidget::on_myTimeout); // 通过主线程发送信号启动子线程中的处理函数  connect(this, \u0026amp;ThreadProWidget::startMyThread, myThread, \u0026amp;MyThreadPro::startProcessing); qDebug() \u0026lt;\u0026lt; \u0026#34;主线程：\u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); }   ","permalink":"https://874656645.github.io/posts/212-qt-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","summary":"一、注意事项：  线程处理类继承于 QObject 线程处理类对象不能有父对象 处理完成后向外发信号 即使 QThread 线程内部的处理对象运行结束了，QThread 线程对象也不会自动释放，需要手动 quit() + wait() 线程处理类对象创建成功后，需要通过 moveToThread() 函数移动到 QThread 对象中 需要通过其他线程发信号来启动另外线程中的处理类对象的处理函数 子线程中不要操作图形界面  二、connect 第五个参数的作用 指定信号和槽的连接方式：自动连接、直接连接、队列连接，多线程时才有意义，默认为 Qt::AutoConnection。\n Qt::AutoConnection（自动连接）：多线程时是 Qt::QueuedConnection（队列连接），单线程时是 Qt::DirectConnection（直接连接） Qt::QueuedConnection（队列连接）：槽函数所在线程和信号接收者所在线程相同 Qt::DirectConnection（直接连接）：槽函数所在线程和信号发送者所在线程相同  三、代码示例   线程处理类\nclass MyThreadPro : public QObject { Q_OBJECT public: explicit MyThreadPro(QObject *parent = nullptr); // 后台处理函数  void startProcessing(); // 是否结束标识位  void setFlag(bool b = false); signals: // 向其他线程发送信号  void myTimeout(); private: bool stopRunning; };   主窗口类","title":"Qt 多线程"},{"content":"参考：\n 视差贴图（Parallax Mapping）学习笔记 视差映射（Parallax Mapping） Learn about Parallax(视差贴图)  ","permalink":"https://874656645.github.io/posts/211-opengl-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BEparallax-mapping/","summary":"参考：\n 视差贴图（Parallax Mapping）学习笔记 视差映射（Parallax Mapping） Learn about Parallax(视差贴图)  ","title":"OpenGL 视差贴图（Parallax Mapping）"},{"content":" sRGBA 和 RGBA  ","permalink":"https://874656645.github.io/posts/210-opengl-gamma-%E6%A0%A1%E6%AD%A3%E5%92%8C%E7%BA%BF%E6%80%A7%E5%B7%A5%E4%BD%9C%E6%B5%81/","summary":" sRGBA 和 RGBA  ","title":"OpenGL Gamma 校正和线性工作流"},{"content":"一、总结  UDP 就像写信，可能会丢包 Linux UDP 通信过程  Qt UDP 通信过程  支持多路组播：D 类地址\n 局域网广播 IP： 255.255.255.255  二、每个实例都可以是服务端  只需要一个套接字，绑定到端口号即可  setWindowTitle(QString(\u0026#34;服务器端口为：%1\u0026#34;).arg(port)); udpSocket = new QUdpSocket(this); // 只需要绑定端口号，不用开启监听  udpSocket-\u0026gt;bind(port); connect(udpSocket, \u0026amp;QUdpSocket::readyRead,[=](){ char buf[1024] = {0}; QHostAddress clientAddr; // 发送方 IP  quint16 clientPort; // 发送方 Port  qint64 len = udpSocket-\u0026gt;readDatagram(buf, sizeof (buf), \u0026amp;clientAddr, \u0026amp;clientPort); qDebug() \u0026lt;\u0026lt; \u0026#34;接收到\u0026#34; \u0026lt;\u0026lt; len; if(len \u0026gt; 0){ QString str = QString(\u0026#34;[%1:%2] %3\u0026#34;).arg(clientAddr.toString()).arg(clientPort).arg(buf); ui-\u0026gt;textEditRead-\u0026gt;append(str); } });  发送消息  QString ip = ui-\u0026gt;lineEditIP-\u0026gt;text(); int port = ui-\u0026gt;lineEditPort-\u0026gt;text().toInt(); QString str = ui-\u0026gt;textEditWrite-\u0026gt;toPlainText(); // 注意：使用 QByteArray 传递，通过.data()转为char*后中文乱码  udpSocket-\u0026gt;writeDatagram(str.toUtf8(), QHostAddress(ip), port);  关闭连接  udpSocket-\u0026gt;disconnect(); udpSocket-\u0026gt;close(); ","permalink":"https://874656645.github.io/posts/209-qt-udp/","summary":"一、总结  UDP 就像写信，可能会丢包 Linux UDP 通信过程  Qt UDP 通信过程  支持多路组播：D 类地址\n 局域网广播 IP： 255.255.255.255  二、每个实例都可以是服务端  只需要一个套接字，绑定到端口号即可  setWindowTitle(QString(\u0026#34;服务器端口为：%1\u0026#34;).arg(port)); udpSocket = new QUdpSocket(this); // 只需要绑定端口号，不用开启监听  udpSocket-\u0026gt;bind(port); connect(udpSocket, \u0026amp;QUdpSocket::readyRead,[=](){ char buf[1024] = {0}; QHostAddress clientAddr; // 发送方 IP  quint16 clientPort; // 发送方 Port  qint64 len = udpSocket-\u0026gt;readDatagram(buf, sizeof (buf), \u0026amp;clientAddr, \u0026amp;clientPort); qDebug() \u0026lt;\u0026lt; \u0026#34;接收到\u0026#34; \u0026lt;\u0026lt; len; if(len \u0026gt; 0){ QString str = QString(\u0026#34;[%1:%2] %3\u0026#34;).","title":"Qt UDP"},{"content":"一、总结  TCP 就像打电话，安全，不会丢包 Linux TCP 通信  Qt TCP 通信   二、服务器端  TCP 服务器端有两个套接字，一个是监听套接字，一个是通信套接字  tcpServer = nullptr; // 服务监听套接字  tcpSocket = nullptr; // 通信套接字  // 创建tcp服务监听套接字  tcpServer = new QTcpServer(this); // tcp服务开启监听（bind端口号并开启监听）  tcpServer-\u0026gt;listen(QHostAddress::Any, 8008); // 绑定连接成功信号  connect(tcpServer, \u0026amp;QTcpServer::newConnection,[=](){ // 获取通信套接字  tcpSocket = tcpServer-\u0026gt;nextPendingConnection(); // 获取客户端 IP 和 端口  QString ip = tcpSocket-\u0026gt;peerAddress().toString(); quint16 port = tcpSocket-\u0026gt;peerPort(); QString msg = QString(\u0026#34;[%1:%2] 连接成功\u0026#34;).arg(ip).arg(port); ui-\u0026gt;textEditRead-\u0026gt;append(msg); // 绑定通信套接字读取信息  connect(tcpSocket, \u0026amp;QTcpSocket::readyRead, [=](){ QByteArray msg = tcpSocket-\u0026gt;readAll(); ui-\u0026gt;textEditRead-\u0026gt;append(msg); }); });  发送信息  if(nullptr == tcpSocket){ return; } QString msg = ui-\u0026gt;textEditWrite-\u0026gt;toPlainText(); tcpSocket-\u0026gt;write(msg.toUtf8());  关闭连接  if(nullptr == tcpSocket){ return; } // 主动断开客户端连接  tcpSocket-\u0026gt;disconnectFromHost(); // 关闭通信套接字  tcpSocket-\u0026gt;close(); delete tcpSocket; tcpSocket = nullptr; 三、客户端  客户端只有一个通信套接字  tcpSocket = new QTcpSocket(this); // 与服务器连接成功后  connect(tcpSocket, \u0026amp;QTcpSocket::connected,[=](){ ui-\u0026gt;textEditRead-\u0026gt;setText(QString(\u0026#34;和服务器连接成功\u0026#34;)); }); // 接收服务器端的消息  connect(tcpSocket, \u0026amp;QTcpSocket::readyRead, [=](){ QByteArray str = tcpSocket-\u0026gt;readAll(); ui-\u0026gt;textEditRead-\u0026gt;append(str); });  客户端连接服务器  // 主动和服务器建立连接  QString ip = ui-\u0026gt;lineEditIP-\u0026gt;text(); int port = ui-\u0026gt;lineEditPort-\u0026gt;text().toInt(); tcpSocket-\u0026gt;connectToHost(QHostAddress(ip), port);  向服务器发送消息  if(false == tcpSocket-\u0026gt;isOpen()){ return; } QString str = ui-\u0026gt;textEditWrite-\u0026gt;toPlainText(); tcpSocket-\u0026gt;write(str.toUtf8());  关闭连接  tcpSocket-\u0026gt;disconnectFromHost(); tcpSocket-\u0026gt;close(); ","permalink":"https://874656645.github.io/posts/208-qt-tcp/","summary":"一、总结  TCP 就像打电话，安全，不会丢包 Linux TCP 通信  Qt TCP 通信   二、服务器端  TCP 服务器端有两个套接字，一个是监听套接字，一个是通信套接字  tcpServer = nullptr; // 服务监听套接字  tcpSocket = nullptr; // 通信套接字  // 创建tcp服务监听套接字  tcpServer = new QTcpServer(this); // tcp服务开启监听（bind端口号并开启监听）  tcpServer-\u0026gt;listen(QHostAddress::Any, 8008); // 绑定连接成功信号  connect(tcpServer, \u0026amp;QTcpServer::newConnection,[=](){ // 获取通信套接字  tcpSocket = tcpServer-\u0026gt;nextPendingConnection(); // 获取客户端 IP 和 端口  QString ip = tcpSocket-\u0026gt;peerAddress().toString(); quint16 port = tcpSocket-\u0026gt;peerPort(); QString msg = QString(\u0026#34;[%1:%2] 连接成功\u0026#34;).","title":"Qt TCP"},{"content":"cmake_minimum_required(VERSION 3.5)project(07_TCP LANGUAGES CXX)# 将编译目录包含到Include目录 set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTORCC ON)# 根据 Qt 版本的环境变量，设置使用的 Qt 版本 set(CMAKE_PREFIX_PATH $ENV{QTDIR5141_64})set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)# QtCreator supports the following variables for Android, which are identical to qmake Android variables. # Check http://doc.qt.io/qt-5/deployment-android.html for more information. # They need to be set before the find_package(Qt5 ...) call. #if(ANDROID) # set(ANDROID_PACKAGE_SOURCE_DIR \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/android\u0026#34;) # if (ANDROID_ABI STREQUAL \u0026#34;armeabi-v7a\u0026#34;) # set(ANDROID_EXTRA_LIBS # ${CMAKE_CURRENT_SOURCE_DIR}/path/to/libcrypto.so # ${CMAKE_CURRENT_SOURCE_DIR}/path/to/libssl.so) # endif() #endif() # 工程中会用到的Qt模块 find_package(Qt5 COMPONENTS Widgets Network REQUIRED)if(ANDROID) add_library(07_TCP SHARED main.cpp serverwidget.cpp serverwidget.h serverwidget.ui )else()# 添加了新的类和ui后要把文件添加到这里  add_executable(07_TCP main.cpp serverwidget.cpp serverwidget.h serverwidget.ui clientwidget.cpp clientwidget.h clientwidget.ui )endif()# 把用到的Qt库连接到项目上 target_link_libraries(${PROJECT_NAME} PRIVATE Qt5::Widgets Qt5::Network)参考：\n CMake中添加Qt模块的合理方法  ","permalink":"https://874656645.github.io/posts/207-qt-cmake/","summary":"cmake_minimum_required(VERSION 3.5)project(07_TCP LANGUAGES CXX)# 将编译目录包含到Include目录 set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTORCC ON)# 根据 Qt 版本的环境变量，设置使用的 Qt 版本 set(CMAKE_PREFIX_PATH $ENV{QTDIR5141_64})set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)# QtCreator supports the following variables for Android, which are identical to qmake Android variables. # Check http://doc.qt.io/qt-5/deployment-android.html for more information. # They need to be set before the find_package(Qt5 ...) call. #if(ANDROID) # set(ANDROID_PACKAGE_SOURCE_DIR \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/android\u0026#34;) # if (ANDROID_ABI STREQUAL \u0026#34;armeabi-v7a\u0026#34;) # set(ANDROID_EXTRA_LIBS # ${CMAKE_CURRENT_SOURCE_DIR}/path/to/libcrypto.so # ${CMAKE_CURRENT_SOURCE_DIR}/path/to/libssl.so) # endif() #endif() # 工程中会用到的Qt模块 find_package(Qt5 COMPONENTS Widgets Network REQUIRED)if(ANDROID) add_library(07_TCP SHARED main.","title":"Qt CMake"},{"content":"","permalink":"https://874656645.github.io/posts/206-opengl-shading-frequencies/","summary":"","title":"OpenGL Shading Frequencies"},{"content":"  有两个不同的概念：像素（Pixel）和纹素（Texel）\n  在纹理上查询纹素有两种方式：\n 点查（Point Query）：小纹理，而要对纹理放大 范围查（Range Query）：动态生成 Mipmap    小纹理：低分辨率纹理应用到高分辨率设备，会产生马赛克问题\n Nearest：邻近点\n Bilinear：双线性插值\n Bicubic：     大纹理：高分辨率纹理应用到低分辨率设备，会有 锯齿（Jaggies） 和 摩尔纹（Moire） 等 走样（Aliasing） 的问题\n 多重采样（supersampling）    面采样求平均值\n  Mipmap：图像金字塔\n 具有速度快、只是近似值且只能是方形范围的特点 会额外占用 1/3 的原始纹理显存空间，总共 4/3 的显存占用    三线性插值（Trilinear interpolation）:\n 先在相邻两层 Mipmap 中分别进行 Bilinear 插值，再在结果之上进行线性插值 局限性：会存在 overblur 的问题    各项异性过滤（Anisotropic Filtering）（Ripmap）：\n 对于平行于坐标轴的矩形区域查询有较好的表现，但是对于非矩形区域仍是效果不佳 会额外占用 3 倍的显存空间   纹理映射的不规则区域    EWA Filtering:\n将不规则区域划分为椭圆形查询区域，进行多次查询\n  参考：\n GAMES101-现代计算机图形学入门-闫令琪 Bicubic interpolation 走样 各向异性过滤 EWA滤波  ","permalink":"https://874656645.github.io/posts/205-opengl-%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7/","summary":"有两个不同的概念：像素（Pixel）和纹素（Texel）\n  在纹理上查询纹素有两种方式：\n 点查（Point Query）：小纹理，而要对纹理放大 范围查（Range Query）：动态生成 Mipmap    小纹理：低分辨率纹理应用到高分辨率设备，会产生马赛克问题\n Nearest：邻近点\n Bilinear：双线性插值\n Bicubic：     大纹理：高分辨率纹理应用到低分辨率设备，会有 锯齿（Jaggies） 和 摩尔纹（Moire） 等 走样（Aliasing） 的问题\n 多重采样（supersampling）    面采样求平均值\n  Mipmap：图像金字塔\n 具有速度快、只是近似值且只能是方形范围的特点 会额外占用 1/3 的原始纹理显存空间，总共 4/3 的显存占用    三线性插值（Trilinear interpolation）:\n 先在相邻两层 Mipmap 中分别进行 Bilinear 插值，再在结果之上进行线性插值 局限性：会存在 overblur 的问题    各项异性过滤（Anisotropic Filtering）（Ripmap）：\n 对于平行于坐标轴的矩形区域查询有较好的表现，但是对于非矩形区域仍是效果不佳 会额外占用 3 倍的显存空间   纹理映射的不规则区域    EWA Filtering:","title":"OpenGL 纹理采样"},{"content":" 重心坐标在投影下不是不变的，所以如果要获取光栅化后三角形内部像素点的深度，不能使用光栅化后三角形的重心坐标进行插值，而是要先找到像素点中心位置对应的三维世界的三维坐标，在三维世界中进行深度插值计算。  参考：\n 利用重心坐标平滑插值三角形顶点的任何属性 GAMES101-现代计算机图形学入门-闫令琪  ","permalink":"https://874656645.github.io/posts/204-opengl-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87%E4%B8%8E%E6%8F%92%E5%80%BC/","summary":" 重心坐标在投影下不是不变的，所以如果要获取光栅化后三角形内部像素点的深度，不能使用光栅化后三角形的重心坐标进行插值，而是要先找到像素点中心位置对应的三维世界的三维坐标，在三维世界中进行深度插值计算。  参考：\n 利用重心坐标平滑插值三角形顶点的任何属性 GAMES101-现代计算机图形学入门-闫令琪  ","title":"OpenGL 重心坐标与插值"},{"content":"一、HTML 页面  必须包含 webRtcPlayer.js 脚本文件，该文件处理浏览器和虚幻引擎应用间的通信，接受并显示来自服务器的媒体流。在非必要的情况下，请勿修改此JavaScript文件。\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;scripts/webRtcPlayer.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 建议包含 app.js 脚本文件，此文件将设置处理键盘、鼠标和触摸事件的事件监听器，其还包含数个可在播放器页面使用的函数。\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;scripts/app.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 页面必须含有一个 ID 为 player 的 div 元素。该元素可被流送自 UE4 应用的视频帧所替换。\n\u0026lt;div id=\u0026quot;player\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 页面加载时必须调用 app.js 文件提供的 load 函数。  二、访问像素流送蓝图 API 在虚幻引擎中运行的像素流送插件会公开一个蓝图API，可在 gameplay 逻辑中使用该 API 处理播放器 HTML 页面发送的自定义 UI 事件，并将事件从虚幻引擎发送到播放器页面，实现网页客户端与 UE 运行程序之间的交互通信。\n推荐将 像素流送插件（Pixel Streaming Input） 组件添加到 PlayerController 中。\n三、从播放器页面到 UE 的通信 app.js 文件提供两个可在 HTML 播放器页面进行调用的 JavaScript 函数，以便用户从浏览器向虚幻引擎程序发送事件和命令：emitCommand 和 emitUIInteraction 函数。\n  js 代码：\n// 从播放器页面到UE4的通信  let testButton = document.getElementById(\u0026#39;test-button\u0026#39;); if (testButton !== null) { testButton.onclick = function (event) { // emitCommand 执行控制台命令  // ConsoleCommand - 使用此键可在远程虚幻引擎程序上执行控制台命令。  // 此键的值应为字符串，其中包含要运行的命令及其所需的参数  let consoleDescriptor = { ConsoleCommand: \u0026#39;Stat FPS\u0026#39; }; emitCommand(consoleDescriptor); // emitUIInteraction  // 可向其传递单个字符串或JavaScript对象  let descriptor = { Command: \u0026#34;MyCustomCommand\u0026#34;, LoadLevel: \u0026#34;/Game/Maps/Level_2\u0026#34;, PlayerCharacter: { Name: \u0026#34;Shinbi\u0026#34;, Skin: \u0026#34;Dynasty\u0026#34; } } emitUIInteraction(descriptor); }; }   蓝图：\n在程序的 gameplay 逻辑中，使用 Bind Event to OnPixelStreamingInputEvent 节点绑定自定义事件来处理此类输入\n  四、从 UE 到播放器页面的通信 虚幻引擎程序可向所有连接的播放器HTML页面发射自定义事件，用户可在播放器的 JavaScript 环境中响应此类事件，可根据 gameplay 事件更改网络页面 UI。\n  在蓝图中使用 Pixel Streaming \u0026gt; Send Pixel Streaming Response 节点向播放器页面发送事件。\n  在播放器页面的 JavaScript 中编写自定义事件处理器函数\nfunction myHandleResponseFunction(data) { console.warn(\u0026#34;Response received!\u0026#34;); console.log(data); switch (data) { case \u0026#34;MyCustomEvent\u0026#34;: // handle one type of event  case \u0026#34;AnotherEvent\u0026#34;: // handle another event  } }   调用 app.js 提供的 addResponseEventListener 函数来注册监听器函数。为事件监听器和函数向此函数传递一个独特命名。\naddResponseEventListener('test', myHandleResponseFunction);\n  如需移除事件监听器，可调用 removeResponseEventListener 并传递相同命名。\nremoveResponseEventListener('test');\n  参考：\n 自定义播放器网页  ","permalink":"https://874656645.github.io/posts/203-unreal-%E5%83%8F%E7%B4%A0%E6%B5%81%E9%80%81%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B5%E9%9D%A2%E4%B8%8E-ue-%E9%80%9A%E4%BF%A1/","summary":"一、HTML 页面  必须包含 webRtcPlayer.js 脚本文件，该文件处理浏览器和虚幻引擎应用间的通信，接受并显示来自服务器的媒体流。在非必要的情况下，请勿修改此JavaScript文件。\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;scripts/webRtcPlayer.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 建议包含 app.js 脚本文件，此文件将设置处理键盘、鼠标和触摸事件的事件监听器，其还包含数个可在播放器页面使用的函数。\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;scripts/app.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 页面必须含有一个 ID 为 player 的 div 元素。该元素可被流送自 UE4 应用的视频帧所替换。\n\u0026lt;div id=\u0026quot;player\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 页面加载时必须调用 app.js 文件提供的 load 函数。  二、访问像素流送蓝图 API 在虚幻引擎中运行的像素流送插件会公开一个蓝图API，可在 gameplay 逻辑中使用该 API 处理播放器 HTML 页面发送的自定义 UI 事件，并将事件从虚幻引擎发送到播放器页面，实现网页客户端与 UE 运行程序之间的交互通信。\n推荐将 像素流送插件（Pixel Streaming Input） 组件添加到 PlayerController 中。\n三、从播放器页面到 UE 的通信 app.js 文件提供两个可在 HTML 播放器页面进行调用的 JavaScript 函数，以便用户从浏览器向虚幻引擎程序发送事件和命令：emitCommand 和 emitUIInteraction 函数。\n  js 代码：\n// 从播放器页面到UE4的通信  let testButton = document.","title":"Unreal——像素流送播放器页面与 UE 通信"},{"content":" 有两种方式启动三维渲染服务器  一、方式一：使用 UE Editor 作为渲染服务器  启用像素流送插件\n【Pixel Streaming】 启用触控设备输入（可选）\n【编辑（Edit）】 \u0026gt; 【项目设置（Project Settings）】 \u0026gt; 【引擎（Engine）】 \u0026gt; 【输入（Input category）】 下启用 【固定显示触控界面（Always Show Touch Interface）】 设置 设置额外启动参数\n【编辑（Edit）】 \u0026gt; 【编辑器偏好（Editor Preferences\u0026hellip;）】 \u0026gt; 【关卡编辑器（Level Editor）】 \u0026gt; 【播放（Play）】 \u0026gt; 【额外启动参数（Additional Launch Parameters）】中添加参数 -AudioMixer -PixelStreamingIP=localhost -PixelStreamingPort=8888 -AllowPixelStreamingCommands 启动游戏\n通过独立进程游戏的模式启动游戏\n  二、方式二：通过打包的程序  打包前对 UE Editor 进行配置，参照方式一的前两步 启动【打包项目】\n 设置启动程序的命令行标签  按住 Alt 键并拖动 .exe 文件即可在相同文件夹中（或在其他任意处）新建一个快捷方式 右键点击快捷方式并从上下文菜单中选择 属性（Properties） 在 快捷方式属性（Shortcut Properties） 窗口的 快捷方式（Shortcut） 选项卡中，在 目标（Target） 域的末尾附加文本 -AudioMixer -PixelStreamingIP=localhost -PixelStreamingPort=8888 -RenderOffScreen 并点击 确认    三、启动服务器 启动一个服务，在虚幻引擎应用程序和客户端浏览器间建立点对点的连接（WebRTC）\n 打开信令服务器路径\n在虚幻引擎安装文件或打包的文件中，在 Samples / PixelStreaming / WebServers / SignallingWebServer 中找到信令服务器的路径 准备信令服务器\n以管理员身份打开 PowerShell 并运行 SignallingWebServer \\ platform_scripts \\ cmd \\ setup.ps1 安装所有需要的依赖项 开启信令服务器\n运行 SignallingWebServer\\platform_scripts\\cmd\\Start_SignallingServer.ps1 开启信令服务器，启动成功如下截图\n 启动虚幻引擎应用程序\n运行 MyPixelStreamingApplication.exe -PixelStreamingIP=127.0.0.1 -PixelStreamingPort=8888 -RenderOffScreen 或双击上面创建的快捷方式 虚幻应用程序连接到信令服务器\n在 Power Shell 窗口看到以下输出表示连接成功 Streamer connected: ::ffff:127.0.0.1  四、浏览器访问  本机：在 Web 浏览器地址导航栏输入 http://127.0.0.1 其他电脑：输入运行虚幻应用程序电脑的 IP 地址  五、每个连接的客户端从虚幻引擎的单独实例流送内容 上面的方式是启动一个像素流送实例，如果有多个浏览器客户端访问同一个流送实例的话，看到的是相同的场景；有时需要所有用户能拥有各自的交互体验，而非将每个用户都连接到同一流送中。要进行此操作，通过配对服务器管理和分配信令Web服务器，可为每个用户单独运行他们的像素流送组件的堆栈，并为每个用户单独指定信令Web服务器，以便开始连接。\n 设置配对服务器  在 Samples/PixelStreaming/WebServers/Matchmaker 文件夹下有一个参考的配对服务器实现，启动信令Web服务器前，运行配对服务器的 run.bat 文件以启动该服务器，也可以在启动命令中设置端口号 run.bat --httpPort 88 --matchmakerPort 9988，前者是 HTTP 连接（浏览器访问配对服务器）所用的端口，后者是配对服务器聆听传入状态消息（来自信令和Web服务器）所用的端口。\n配置参考实例：\n```json\r{\r\u0026quot;HttpPort\u0026quot;: 90,\r\u0026quot;UseHTTPS\u0026quot;: false,\r\u0026quot;MatchmakerPort\u0026quot;: 9999,\r\u0026quot;LogToFile\u0026quot;: true\r}\r```\r 修改每个信令web服务器配置   注意：如希望在同一电脑上使用像素流送来运行多个虚幻引擎实例，须注意 NVIDIA GeForce 系列等诸多应用级显卡一次最多只能运行 3 个编码器。Quadro 和 Tesla 等专业级显卡则无此类限制。     参数 描述     UseMatchmaker 将此参数设为 true，以便信令和Web服务器向配对服务器发送自身当前状态。   matchmakerAddress 将与该信令和Web服务器连接的配对服务器IP地址。   matchmakerPort 该信令和网络服务器需要向配对服务器发送消息时所用的端口。请确保此数值与配对服务器所设的 \u0026ndash;matchmakerPort 值相匹配。   publicIp 信令和Web服务器的公开可见IP地址。配对服务器将用户重新指定到该信令和Web服务器时，其会把它们发送到该IP地址。因此，其必须对连接浏览器可见。   httpPort 信令和Web服务器聆听HTTP连接所用的端口。配对服务器将用户重新指定到该信令和Web服务器时，其会把它们发送到该端口。    配置参考实例：\n  注意：在同一电脑上使用像素流送运行多个虚幻引擎实例时，要注意 StreamerPort 要使用两个不同的端口号\n  信令web服务一：\n{ \u0026#34;UseFrontend\u0026#34;: false, \u0026#34;UseMatchmaker\u0026#34;: true, \u0026#34;UseHTTPS\u0026#34;: false, \u0026#34;UseAuthentication\u0026#34;: false, \u0026#34;LogToFile\u0026#34;: true, \u0026#34;LogVerbose\u0026#34;: true, \u0026#34;HomepageFile\u0026#34;: \u0026#34;/Public/player.html\u0026#34;, \u0026#34;AdditionalRoutes\u0026#34;: {}, \u0026#34;EnableWebserver\u0026#34;: true, \u0026#34;MatchmakerAddress\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;MatchmakerPort\u0026#34;: \u0026#34;9999\u0026#34;, \u0026#34;PublicIp\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;HttpPort\u0026#34;: 81, \u0026#34;HttpsPort\u0026#34;: 443, \u0026#34;StreamerPort\u0026#34;: 8888, \u0026#34;SFUPort\u0026#34;: 8889 }   信令web服务二：\n{ \u0026#34;UseFrontend\u0026#34;: false, \u0026#34;UseMatchmaker\u0026#34;: true, \u0026#34;UseHTTPS\u0026#34;: false, \u0026#34;UseAuthentication\u0026#34;: false, \u0026#34;LogToFile\u0026#34;: true, \u0026#34;LogVerbose\u0026#34;: true, \u0026#34;HomepageFile\u0026#34;: \u0026#34;/Public/player.html\u0026#34;, \u0026#34;AdditionalRoutes\u0026#34;: {}, \u0026#34;EnableWebserver\u0026#34;: true, \u0026#34;MatchmakerAddress\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;MatchmakerPort\u0026#34;: \u0026#34;9999\u0026#34;, \u0026#34;PublicIp\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;HttpPort\u0026#34;: 81, \u0026#34;HttpsPort\u0026#34;: 443, \u0026#34;StreamerPort\u0026#34;: 8878, \u0026#34;SFUPort\u0026#34;: 8879 }   运行多个虚幻引擎应用程序  对应配置的每个信令web服务的 StreamerPort 端口号，启动两个应用程序实例\nMyPixelStreamingApplication.exe -PixelStreamingIP=127.0.0.1 -PixelStreamingPort=8888 -RenderOffScreen MyPixelStreamingApplication.exe -PixelStreamingIP=127.0.0.1 -PixelStreamingPort=8878 -RenderOffScreen 参考：\n 虚幻引擎像素流送入门 创建主机和网络连接指南  ","permalink":"https://874656645.github.io/posts/202-unreal-%E5%83%8F%E7%B4%A0%E6%B5%81%E9%80%81/","summary":"有两种方式启动三维渲染服务器  一、方式一：使用 UE Editor 作为渲染服务器  启用像素流送插件\n【Pixel Streaming】 启用触控设备输入（可选）\n【编辑（Edit）】 \u0026gt; 【项目设置（Project Settings）】 \u0026gt; 【引擎（Engine）】 \u0026gt; 【输入（Input category）】 下启用 【固定显示触控界面（Always Show Touch Interface）】 设置 设置额外启动参数\n【编辑（Edit）】 \u0026gt; 【编辑器偏好（Editor Preferences\u0026hellip;）】 \u0026gt; 【关卡编辑器（Level Editor）】 \u0026gt; 【播放（Play）】 \u0026gt; 【额外启动参数（Additional Launch Parameters）】中添加参数 -AudioMixer -PixelStreamingIP=localhost -PixelStreamingPort=8888 -AllowPixelStreamingCommands 启动游戏\n通过独立进程游戏的模式启动游戏\n  二、方式二：通过打包的程序  打包前对 UE Editor 进行配置，参照方式一的前两步 启动【打包项目】\n 设置启动程序的命令行标签  按住 Alt 键并拖动 .exe 文件即可在相同文件夹中（或在其他任意处）新建一个快捷方式 右键点击快捷方式并从上下文菜单中选择 属性（Properties） 在 快捷方式属性（Shortcut Properties） 窗口的 快捷方式（Shortcut） 选项卡中，在 目标（Target） 域的末尾附加文本 -AudioMixer -PixelStreamingIP=localhost -PixelStreamingPort=8888 -RenderOffScreen 并点击 确认    三、启动服务器 启动一个服务，在虚幻引擎应用程序和客户端浏览器间建立点对点的连接（WebRTC）","title":"Unreal——像素流送"},{"content":"UE5 打包：\n如果平台前面有感叹号表示缺少 SDK 环境\n 注意： 安装完 SDK 后要重启电脑   Windows SDK 18362 or Newer .NET Core 3.1  ","permalink":"https://874656645.github.io/posts/201-unreal-engine-5-%E6%89%93%E5%8C%85/","summary":"UE5 打包：\n如果平台前面有感叹号表示缺少 SDK 环境\n 注意： 安装完 SDK 后要重启电脑   Windows SDK 18362 or Newer .NET Core 3.1  ","title":"Unreal Engine 5 打包"},{"content":" 参考asdfasdfabout_Execution_Policies    get-executionpolicy 命令查看\n Restricted 执行策略不允许任何脚本运行 RemoteSigned    执行策略修改\n以管理员身份打开 PowerShell， 输入 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 修改执行策略\n  ","permalink":"https://874656645.github.io/posts/200-powershell-%E4%BF%AE%E6%94%B9%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5/","summary":" 参考asdfasdfabout_Execution_Policies    get-executionpolicy 命令查看\n Restricted 执行策略不允许任何脚本运行 RemoteSigned    执行策略修改\n以管理员身份打开 PowerShell， 输入 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 修改执行策略\n  ","title":"PowerShell 修改脚本执行策略"},{"content":"一、项目目录 —— 内容\n—— Maps\n—— UMG\n—— Mesh\n—— 材质\n—— 蓝图\n—— 贴图\n—— 团队人员\n—— 产品经理\n—— 平面\n—— UE 美术 —— UE 技术美术 —— 模型师\n—— UE 程序\n学习网址  可视化展示系列教程 基础  高级UE开发工程师 岗位职责：\n 负责 UE 客户端功能的设计、开发实现； 负责与产品对接功能需求，以及其他开发人员讨论需求，合作完成产品开发； 配合美术，策划完成各种效果的实现，与团队成员沟通协调，完成内容制作与优化； 保证代码质量与运行效率，持续进行项目功能优化、迭代、代码调试及 bug 修复；  任职要求：\n 本科或以上学历，2年以上 UE 工作经验，至少参与过两个商业项目； 可以撰写 UE 引擎技术文档，并与美术配合将项目资源导入引擎； 熟悉 UE 开发流程和步骤，熟练使用 UE 蓝图编程及插件技术，熟悉 UE C++ 与蓝图的交互机制； 熟悉 UMG 的 GUI 开发等； 有较强的学习能力和解决问题能力，勇于承担责任，具有良好的团队交流和协作能力；  ","permalink":"https://874656645.github.io/posts/199-unreal-%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","summary":"一、项目目录 —— 内容\n—— Maps\n—— UMG\n—— Mesh\n—— 材质\n—— 蓝图\n—— 贴图\n—— 团队人员\n—— 产品经理\n—— 平面\n—— UE 美术 —— UE 技术美术 —— 模型师\n—— UE 程序\n学习网址  可视化展示系列教程 基础  高级UE开发工程师 岗位职责：\n 负责 UE 客户端功能的设计、开发实现； 负责与产品对接功能需求，以及其他开发人员讨论需求，合作完成产品开发； 配合美术，策划完成各种效果的实现，与团队成员沟通协调，完成内容制作与优化； 保证代码质量与运行效率，持续进行项目功能优化、迭代、代码调试及 bug 修复；  任职要求：\n 本科或以上学历，2年以上 UE 工作经验，至少参与过两个商业项目； 可以撰写 UE 引擎技术文档，并与美术配合将项目资源导入引擎； 熟悉 UE 开发流程和步骤，熟练使用 UE 蓝图编程及插件技术，熟悉 UE C++ 与蓝图的交互机制； 熟悉 UMG 的 GUI 开发等； 有较强的学习能力和解决问题能力，勇于承担责任，具有良好的团队交流和协作能力；  ","title":"Unreal——智慧城市项目搭建"},{"content":"软件和插件：\n Blender 和 BlenderGis 插件 C4D CityEngine Unreal Engine `Cesium for Unreal Engine' `CityEngine VR Experience for Unreal Engine' datasmith for Unreal Engine CesiumLab 地编素材库（city park environment collection） HDRI 插件和 HDRI 素材 ArchViz Explorer 项目，场景 Pawn 操作 Factory Environment Collection json读取插件：json assets、json library、jsonxmlhelper、varest 网页插件：web ui 视频流：web camera Water 插件 基于精确地理的太阳定位工具  蓝图开发：\n 通过鼠标左键、右键和滚轮控制相机移动、缩放和旋转 Cesium 场景搭建 3DTiles 模型加载 3DMax 场景导入 UI界面搭建（用户界面、控件蓝图、商城UI插件Custom UI） 天气切换 控制器切换（自由、人行、驾驶） 长度测量（射线——由通道检测线条，缆索Actor） 面积测量 添加POI  三维效果：\n 材质 PBR 粒子效果（magic_circle_creator） 光影效果 天气模拟（天气插件 Ultra Dynamic Sky） 后处理：环境光遮蔽、MSAA、景深与镜头效果、屏幕空间反射、扫描线、泛光 自发光材质  数据：\n 场数据 DEM DOM DGN 矢量切片 3DMax 3DTiles 白模 倾斜摄影 精细模型 点云 BIM  行业动态：\n 免费混合现实3D地理空间可视化示例项目：Project Anywhere XR  几何压缩 meshopt\n服务：\n WMS WMTS WFS OGC  三维分析:\n Nanite 虚拟微多边形 Lumen 动态全局光照 VSM 虚拟贴图  rule processor 基于规则动态生成模型\n飞渡技术交流\n 支持的二三维数据格式？ 这些数据是怎么融合的？ 数据存储在本地还是服务器？如果存放在服务器，又是如何请求拉取的？ 地理坐标系统是什么？地形、倾斜摄影等具有空间信息的模型与手工模型（3d Max、SketchUp等）又是如何配准融合的？ MicroStation、 Revit、PKPM、IFC等BIM数据是如何导入构建的？模型是参数化构建的吗？BIM模型的信息是如何存储呢？支持HLOD层次加载吗？这些BIM模型如何与地形、倾斜摄影等地理信息模型融合呢？ 千万构件在场景中是如何组织、加载和调度的？怎么保证渲染端的流畅性？ 不同样式的风格是怎么切换的？可以自己设置风格参数吗？还是在预设的样式中选择？ 矢量体块是二维图（包括道路、楼房、地块、草地等信息）拉伸起来的吗？ 二三维一体化以及切换是如何实现的呢？ 楼宇拆解是在数据模型方面做了组织实现的吗？ 分层分户信息查询功能，导入的shp属性数据格式是如何与户模型挂接的？是把楼中的每一户模型都分离了吗还是处理成了大概的包围盒呢？ 城市级车辆是如何同屏实时运行的？车流的路径是如何做的？车流与模型支持物理碰撞吗？ 整个城市中的路灯、垃圾桶、或者马路上的栏杆是如何添加、组织和渲染的？ 阴影是如何计算的？抗锯齿用的是什么技术？反射是如何实现的？ 渲染引擎是什么？  ","permalink":"https://874656645.github.io/posts/198-unreal-%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%92%8C%E8%BD%AF%E4%BB%B6/","summary":"软件和插件：\n Blender 和 BlenderGis 插件 C4D CityEngine Unreal Engine `Cesium for Unreal Engine' `CityEngine VR Experience for Unreal Engine' datasmith for Unreal Engine CesiumLab 地编素材库（city park environment collection） HDRI 插件和 HDRI 素材 ArchViz Explorer 项目，场景 Pawn 操作 Factory Environment Collection json读取插件：json assets、json library、jsonxmlhelper、varest 网页插件：web ui 视频流：web camera Water 插件 基于精确地理的太阳定位工具  蓝图开发：\n 通过鼠标左键、右键和滚轮控制相机移动、缩放和旋转 Cesium 场景搭建 3DTiles 模型加载 3DMax 场景导入 UI界面搭建（用户界面、控件蓝图、商城UI插件Custom UI） 天气切换 控制器切换（自由、人行、驾驶） 长度测量（射线——由通道检测线条，缆索Actor） 面积测量 添加POI  三维效果：","title":"Unreal——智慧城市项目技术路线和软件"},{"content":" 原理：   相机的运动实际上是对世界坐标系中的物体进行反向运动变换 相机的运动矩阵与其他物体的变换矩阵类似  先缩放变换，再进行旋转，最后进行平移   所以 glm::lookAt 函数返回的是相机变换矩阵的逆矩阵  先对相机的平移矩阵求逆，然后乘以旋转矩阵的逆矩阵（参考计算矩阵乘积的逆矩阵公式）    注意事项：   相机矩阵的 Z轴 与相机的照射方向相反 glm 中的矩阵是列向量优先 正交矩阵的逆矩阵等于它的转置  刚体运动中变换矩阵的逆矩阵求解：   刚体运动变换矩阵： $$\\begin{equation} T = \\begin{bmatrix*}[c] R \u0026amp; t \\newline 0^T \u0026amp; 1 \\end{bmatrix*} \\end{equation}$$ 分块矩阵求逆公式 $$\\begin{equation} M = \\begin{bmatrix*}[c] A \u0026amp; B \\newline 0 \u0026amp; D \\end{bmatrix*} \\space\\space\\space\\space M^{-1} = \\begin{bmatrix*}[c] A^{-1} \u0026amp; -A^{-1}BD^{-1} \\newline 0 \u0026amp; D^{-1} \\end{bmatrix*} \\end{equation}$$ 刚体运动变换矩阵的逆矩阵： $$\\begin{equation} T^{-1} = \\begin{bmatrix*}[c] R^{-1} \u0026amp; -R^{-1}t \\newline 0^T \u0026amp; 1 \\end{bmatrix*} = \\begin{bmatrix*}[c] R^T \u0026amp; -R^Tt \\newline 0^T \u0026amp; 1 \\end{bmatrix*} \\end{equation}$$  方法一：  glm::mat4 Camera::calculateLookAtMatrix() { // 1. 计算方向 \tglm::vec3 zAxis = glm::normalize(camPos - target); // 2. 计算相机右轴 \tglm::vec3 xAxis = glm::normalize(glm::cross(camUp, zAxis)); // 3. 计算相机向上的向量 \tglm::vec3 yAxis = glm::normalize(glm::cross(zAxis, xAxis)); // 创建位移和旋转矩阵 \t// glm 中采用 [col][row] 方式存储 \tglm::mat4 trans = glm::mat4(1.f); trans[3][0] = -camPos.x; trans[3][1] = -camPos.y; trans[3][2] = -camPos.z; glm::mat4 rotation = glm::mat4(1.f); rotation[0][0] = xAxis.x; rotation[1][0] = xAxis.y; rotation[2][0] = xAxis.z; rotation[0][1] = yAxis.x; rotation[1][1] = yAxis.y; rotation[2][1] = yAxis.z; rotation[0][2] = zAxis.x; rotation[1][2] = zAxis.y; rotation[2][2] = zAxis.z; // 先平移再旋转 \treturn rotation * trans; } 方法二：  先构建相机的变换矩阵，然后对矩阵求逆\nglm::mat4 Camera::calculateLookAtMatrix() { // 相机位移矩阵 \tglm::mat4 camTrans = glm::mat4(1.f); camTrans = glm::translate(camTrans, camPos); // 相机旋转矩阵 \tglm::vec3 zAxis = glm::normalize(-camFront);\t// 相机的Z轴是从目标点指向相机点，与相机照射的方向相反 \tglm::vec3 xAxis = glm::normalize(glm::cross(camUp, zAxis)); glm::vec3 yAxis = glm::normalize(glm::cross(zAxis, xAxis)); // 用相机的 X Y Z 轴单位向量构建旋转矩阵（列向量优先） \tglm::mat4 camRotate = glm::mat4(glm::vec4(xAxis, 0.f), glm::vec4(yAxis, 0.f) , glm::vec4(zAxis, 0.f), glm::vec4(0.f, 0.f, 0.f, 1.f)); glm::mat4 camMat = camTrans * camRotate; return glm::inverse(camMat); } 参考：\n 刚体运动中变换矩阵的逆 计算机图形学OpenGL：7.1、摄像机LookAt矩阵 OpenGL，Qt实现：1入门篇(已更完) OpenGL渲染引擎-从理论到实践 OpenGL shader 最好的OpenGL教程之一  ","permalink":"https://874656645.github.io/posts/197-opengl-%E7%9B%B8%E6%9C%BA-lookat-%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/","summary":"原理：   相机的运动实际上是对世界坐标系中的物体进行反向运动变换 相机的运动矩阵与其他物体的变换矩阵类似  先缩放变换，再进行旋转，最后进行平移   所以 glm::lookAt 函数返回的是相机变换矩阵的逆矩阵  先对相机的平移矩阵求逆，然后乘以旋转矩阵的逆矩阵（参考计算矩阵乘积的逆矩阵公式）    注意事项：   相机矩阵的 Z轴 与相机的照射方向相反 glm 中的矩阵是列向量优先 正交矩阵的逆矩阵等于它的转置  刚体运动中变换矩阵的逆矩阵求解：   刚体运动变换矩阵： $$\\begin{equation} T = \\begin{bmatrix*}[c] R \u0026amp; t \\newline 0^T \u0026amp; 1 \\end{bmatrix*} \\end{equation}$$ 分块矩阵求逆公式 $$\\begin{equation} M = \\begin{bmatrix*}[c] A \u0026amp; B \\newline 0 \u0026amp; D \\end{bmatrix*} \\space\\space\\space\\space M^{-1} = \\begin{bmatrix*}[c] A^{-1} \u0026amp; -A^{-1}BD^{-1} \\newline 0 \u0026amp; D^{-1} \\end{bmatrix*} \\end{equation}$$ 刚体运动变换矩阵的逆矩阵： $$\\begin{equation} T^{-1} = \\begin{bmatrix*}[c] R^{-1} \u0026amp; -R^{-1}t \\newline 0^T \u0026amp; 1 \\end{bmatrix*} = \\begin{bmatrix*}[c] R^T \u0026amp; -R^Tt \\newline 0^T \u0026amp; 1 \\end{bmatrix*} \\end{equation}$$  方法一：  glm::mat4 Camera::calculateLookAtMatrix() { // 1.","title":"OpenGL 相机 LookAt 矩阵计算"},{"content":"红宝书第九版，OpenGL Version 4.5\nGames101 闫令琪\n顶点数据-\u0026gt;顶点着色器（MVP 矩阵变换，NDC 标准化设备坐标）-\u0026gt;细分控制着色器-\u0026gt;细分计算着色器-\u0026gt;几何着色器-\u0026gt;图元装配-\u0026gt;裁剪和剔除-\u0026gt;光栅化-\u0026gt;片元着色器\n片元着色器后，可能还有混色、测试等流程，最后将渲染结果输入到 Frame Buffer 中\n  顶点着色器： 将传入的顶点坐标进行 MVP 矩阵变换，经过顶点着色器，它们就该是标准化设备坐标。\n  细分着色： 细分着色包括细分控制着色器和细分计算着色器，细分控制着色器和细分计算着色器是相互依存的，要么都不要，要么都要。细分着色的作用就是通过面片（patch）来描述一个物体的形状。顶点着色器只能处理每个顶点关联的数据，而细分着色能通过面片的形式分割更多的数据点（比如曲面细分）  细分控制着色器：细分控制着色器的一个常见应用就是将输入面片顶点（控制点）传递给细分计算着色器和通过设置细分层次因素，告诉 OpenGL 怎么生成顶点，每个顶点的标注化二维坐标（细分坐标）以二维向量（也就是说只有其 x 和 y 分量是有效的）的方式保存在变量 gl_TessCorrd 内，该变量会被传递到细分计算着色器中（注：gl_TessCorrd 保存的是一个线段的因子，如一个线段的 0.5 横坐标处，那么 gl_TessCorrd.x=0.5）； 细分计算着色器：细分控制着色器完成后，细分计算着色器就通过控制点和细分坐标生成一系列顶点坐标，输出跟顶点着色器是一样的。 更多细节：可以看文章OpenGL 图元处理    几何着色器： 几何着色器提供了一种更加灵活的图元生成方法，它能够将（这一组）顶点变换为完全不同的图元，并且还能生成比原来更多的顶点。原理上来说，几何着色器通过一些手段也可以完成细分着色器的任务，但是为什么需要细分着色器呢？这是因为在某些图元生成上，细分着色器可以更加精确或者方便，比如生成三角形网格顶点，更多介绍参见几何着色器。可以看到，顶点着色器，细分着色器和几何着色器本质上都是对顶点进行处理。\n  图元装配： 前面的着色阶段都对顶点进行操作，关于这些顶点如何被组织成几何图元的信息并传到到 OpenGL 的下个阶段。图元组装阶段将顶点组织成它们相关的几何图形，为裁剪和光栅化做准备。\n  裁剪和剔除： 偶尔，顶点会在视口之外（窗口的区域），并对与顶点相关的图元进行修改，使其像素都不在视口之外。这个操作被称为裁剪，并由 OpenGL 自动处理。\n  光栅化： 经过以上步骤，基本上一个图形就形成了，但是这个图形的坐标还是在自己的坐标系中，光栅化就是将图形的坐标转化为屏幕像素坐标，最终将图元的数学描述转化为用于显示在屏幕上的片段，然后通过帧缓存就可以在电脑上看到一个个美丽的图形。\n  片元着色器： 片元着色器是opengl渲染的最后一个流程，它的主要作用就是赋予我们图形最终的颜色，纹理渲染也在这个阶段\n  参考：\n 顶点着色器到片元着色器的过程，varying变量 opengl基本流程 OpenGL学习脚印: 投影矩阵和视口变换矩阵(math-projection and viewport matrix) OpenGL入门（五）\u0026ndash; OpenGL渲染流程图解析 Opengl复习笔记（一）——顶点着色器、片段着色器（内含代码） GPU是如何工作的？Shader图形编程入门 GAMES101-现代计算机图形学入门-闫令琪 20分钟让你了解OpenGL——OpenGL全流程详细解读 OpenGL学习：Per-fragment operation(1)-模板测试(stencil test)  ","permalink":"https://874656645.github.io/posts/196-opengl-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/","summary":"红宝书第九版，OpenGL Version 4.5\nGames101 闫令琪\n顶点数据-\u0026gt;顶点着色器（MVP 矩阵变换，NDC 标准化设备坐标）-\u0026gt;细分控制着色器-\u0026gt;细分计算着色器-\u0026gt;几何着色器-\u0026gt;图元装配-\u0026gt;裁剪和剔除-\u0026gt;光栅化-\u0026gt;片元着色器\n片元着色器后，可能还有混色、测试等流程，最后将渲染结果输入到 Frame Buffer 中\n  顶点着色器： 将传入的顶点坐标进行 MVP 矩阵变换，经过顶点着色器，它们就该是标准化设备坐标。\n  细分着色： 细分着色包括细分控制着色器和细分计算着色器，细分控制着色器和细分计算着色器是相互依存的，要么都不要，要么都要。细分着色的作用就是通过面片（patch）来描述一个物体的形状。顶点着色器只能处理每个顶点关联的数据，而细分着色能通过面片的形式分割更多的数据点（比如曲面细分）  细分控制着色器：细分控制着色器的一个常见应用就是将输入面片顶点（控制点）传递给细分计算着色器和通过设置细分层次因素，告诉 OpenGL 怎么生成顶点，每个顶点的标注化二维坐标（细分坐标）以二维向量（也就是说只有其 x 和 y 分量是有效的）的方式保存在变量 gl_TessCorrd 内，该变量会被传递到细分计算着色器中（注：gl_TessCorrd 保存的是一个线段的因子，如一个线段的 0.5 横坐标处，那么 gl_TessCorrd.x=0.5）； 细分计算着色器：细分控制着色器完成后，细分计算着色器就通过控制点和细分坐标生成一系列顶点坐标，输出跟顶点着色器是一样的。 更多细节：可以看文章OpenGL 图元处理    几何着色器： 几何着色器提供了一种更加灵活的图元生成方法，它能够将（这一组）顶点变换为完全不同的图元，并且还能生成比原来更多的顶点。原理上来说，几何着色器通过一些手段也可以完成细分着色器的任务，但是为什么需要细分着色器呢？这是因为在某些图元生成上，细分着色器可以更加精确或者方便，比如生成三角形网格顶点，更多介绍参见几何着色器。可以看到，顶点着色器，细分着色器和几何着色器本质上都是对顶点进行处理。\n  图元装配： 前面的着色阶段都对顶点进行操作，关于这些顶点如何被组织成几何图元的信息并传到到 OpenGL 的下个阶段。图元组装阶段将顶点组织成它们相关的几何图形，为裁剪和光栅化做准备。\n  裁剪和剔除： 偶尔，顶点会在视口之外（窗口的区域），并对与顶点相关的图元进行修改，使其像素都不在视口之外。这个操作被称为裁剪，并由 OpenGL 自动处理。\n  光栅化： 经过以上步骤，基本上一个图形就形成了，但是这个图形的坐标还是在自己的坐标系中，光栅化就是将图形的坐标转化为屏幕像素坐标，最终将图元的数学描述转化为用于显示在屏幕上的片段，然后通过帧缓存就可以在电脑上看到一个个美丽的图形。\n  片元着色器： 片元着色器是opengl渲染的最后一个流程，它的主要作用就是赋予我们图形最终的颜色，纹理渲染也在这个阶段\n  参考：\n 顶点着色器到片元着色器的过程，varying变量 opengl基本流程 OpenGL学习脚印: 投影矩阵和视口变换矩阵(math-projection and viewport matrix) OpenGL入门（五）\u0026ndash; OpenGL渲染流程图解析 Opengl复习笔记（一）——顶点着色器、片段着色器（内含代码） GPU是如何工作的？Shader图形编程入门 GAMES101-现代计算机图形学入门-闫令琪 20分钟让你了解OpenGL——OpenGL全流程详细解读 OpenGL学习：Per-fragment operation(1)-模板测试(stencil test)  ","title":"OpenGL 渲染管线"},{"content":" 信号函数没有返回值，且只是一个函数声明，必须有 signals: 声明 槽函数的函数标签必须和信号函数相同（相同的返回值类型和形参列表） Qt5 后成员函数也可作为 slots，可以不用 slots: 声明 slots: 声明前要添加访问权限修饰符 信号函数和槽函数其实都可以被重载  // signal 和 slots 都可以重载  // Qt5的方式  void(subWindow::*pFun1)() = \u0026amp;subWindow::showMainWindow; void(MainWindow::*pSlot1)() = \u0026amp;MainWindow::onShowMainWindow; connect(\u0026amp;sw, pFun1, this, pSlot1); void(subWindow::*pFun2)(int,QString) = \u0026amp;subWindow::showMainWindow; void(MainWindow::*pSlot2)(int,QString) = \u0026amp;MainWindow::onShowMainWindow; connect(\u0026amp;sw, pFun2, this, pSlot2); // Qt4的方式  // 1. SIGNAL、SLOT宏会把信号和槽转成字符串，所以就不能进行编译期错误检查  // 2. 槽函数前面必须有 slots 标签，否则无法识别为槽函数  connect(\u0026amp;sw, SIGNAL(showMainWindow()), this, SLOT(onShowMainWindow())); connect(\u0026amp;sw, SIGNAL(showMainWindow(int,QString)) , this, SLOT(onShowMainWindow(int,QString))); // Lambda 表达式  void(subWindow::*pFun1)() = \u0026amp;subWindow::showMainWindow; connect(\u0026amp;sw, pFun1, [](){ qDebug()\u0026lt;\u0026lt;\u0026#34;没有参数的信号\u0026#34;; } ); void(subWindow::*pFun2)(int,QString) = \u0026amp;subWindow::showMainWindow; connect(\u0026amp;sw, pFun2, [](int a, QString msg){ qDebug()\u0026lt;\u0026lt;a\u0026lt;\u0026lt;msg; } ); // Lambda 表达式使用注意事项  // 如果b3是局部变量或者成员变量，lambda不要使用引用传值  QPushButton *b3 = new QPushButton(this); b3-\u0026gt;setText(\u0026#34;Lambda\u0026#34;); int a = 10, b = 100; connect(\u0026amp;b2/*b3*/, \u0026amp;QPushButton::clicked, [=](){ // 此处使用 \u0026amp; 传值会有问题  qDebug()\u0026lt;\u0026lt;a\u0026lt;\u0026lt;b; } ); ","permalink":"https://874656645.github.io/posts/193-qt-%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/","summary":" 信号函数没有返回值，且只是一个函数声明，必须有 signals: 声明 槽函数的函数标签必须和信号函数相同（相同的返回值类型和形参列表） Qt5 后成员函数也可作为 slots，可以不用 slots: 声明 slots: 声明前要添加访问权限修饰符 信号函数和槽函数其实都可以被重载  // signal 和 slots 都可以重载  // Qt5的方式  void(subWindow::*pFun1)() = \u0026amp;subWindow::showMainWindow; void(MainWindow::*pSlot1)() = \u0026amp;MainWindow::onShowMainWindow; connect(\u0026amp;sw, pFun1, this, pSlot1); void(subWindow::*pFun2)(int,QString) = \u0026amp;subWindow::showMainWindow; void(MainWindow::*pSlot2)(int,QString) = \u0026amp;MainWindow::onShowMainWindow; connect(\u0026amp;sw, pFun2, this, pSlot2); // Qt4的方式  // 1. SIGNAL、SLOT宏会把信号和槽转成字符串，所以就不能进行编译期错误检查  // 2. 槽函数前面必须有 slots 标签，否则无法识别为槽函数  connect(\u0026amp;sw, SIGNAL(showMainWindow()), this, SLOT(onShowMainWindow())); connect(\u0026amp;sw, SIGNAL(showMainWindow(int,QString)) , this, SLOT(onShowMainWindow(int,QString))); // Lambda 表达式  void(subWindow::*pFun1)() = \u0026amp;subWindow::showMainWindow; connect(\u0026amp;sw, pFun1, [](){ qDebug()\u0026lt;\u0026lt;\u0026#34;没有参数的信号\u0026#34;; } ); void(subWindow::*pFun2)(int,QString) = \u0026amp;subWindow::showMainWindow; connect(\u0026amp;sw, pFun2, [](int a, QString msg){ qDebug()\u0026lt;\u0026lt;a\u0026lt;\u0026lt;msg; } ); // Lambda 表达式使用注意事项  // 如果b3是局部变量或者成员变量，lambda不要使用引用传值  QPushButton *b3 = new QPushButton(this); b3-\u0026gt;setText(\u0026#34;Lambda\u0026#34;); int a = 10, b = 100; connect(\u0026amp;b2/*b3*/, \u0026amp;QPushButton::clicked, [=](){ // 此处使用 \u0026amp; 传值会有问题  qDebug()\u0026lt;\u0026lt;a\u0026lt;\u0026lt;b; } ); ","title":"Qt 信号和槽"},{"content":"一、通用引用  类型声明形式为 type\u0026amp;\u0026amp; 其中 type 类型是要进行推导的，如果类型推导没有发生，那么 type\u0026amp;\u0026amp; 代表一个右值引用 如果一个对象被声明为 auto\u0026amp;\u0026amp;，这个形参或者对象就是一个通用引用 通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用 如果在一个类模板里面看见了一个函数形参类型为 T\u0026amp;\u0026amp;，也不一定就是通用引用，可能并没有发生类型推导  void f(Widget\u0026amp;\u0026amp; param); //右值引用 Widget\u0026amp;\u0026amp; var1 = Widget(); //右值引用 auto\u0026amp;\u0026amp; var2 = var1; //通用引用（不是右值引用）  template\u0026lt;typename T\u0026gt; void f(std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026amp; param); //右值引用  template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); //通用引用（不是右值引用）  template \u0026lt;typename T\u0026gt; void f(const T\u0026amp;\u0026amp; param); //param是一个右值引用，因为添加了 const 限定符  // 函数模板 一般可能是通用引用 template \u0026lt;typename T\u0026gt; void print_reference_type(T \u0026amp;\u0026amp;i) { // T\u0026amp;\u0026amp; 或是 auto\u0026amp;\u0026amp;  if (std::is_lvalue_reference\u0026lt;decltype(i)\u0026gt;::value) { std::cout \u0026lt;\u0026lt; \u0026#34;lvalue: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } else if (std::is_rvalue_reference\u0026lt;decltype(i)\u0026gt;::value) { std::cout \u0026lt;\u0026lt; \u0026#34;rvalue: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;unknown value: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } } // 因为 push_back 在有一个特定的 vector 实例之前不可能存在， // 而实例化 vector 时的类型已经决定了 push_back 的声明 // 所以在这里并没有发生类型推导 template\u0026lt;class T, class Allocator = allocator\u0026lt;T\u0026gt;\u0026gt; //来自C++标准 class vector { public: void push_back(T\u0026amp;\u0026amp; x); … } 一个记录任意函数调用的时间开销的函数模板\nauto timeFuncInvocation = [](auto\u0026amp;\u0026amp; func, auto\u0026amp;\u0026amp;... params) // C++14  // auto\u0026amp;\u0026amp;椒一个通用引用  // params是0个或者多个通用引用  //（即它是个通用引用parameter pack），  //它可以绑定到任意数目、任意类型的对象上  { start timer; std::forward\u0026lt;decltype(func)\u0026gt;(func)( //对params调用func  std::forward\u0026lt;delctype(params)\u0026gt;(params)... ); stop timer and record elapsed time; }; 二、右值引用和移动操作  右值引用也是引用，所以和左值引用一样，不能返回局部变量  class B { friend std::ostream\u0026amp; operator \u0026lt;\u0026lt;(std::ostream\u0026amp; os, B\u0026amp; b); public: B() :s(10), ptr(new int[s]) { std::cout \u0026lt;\u0026lt; \u0026#34;default constructor\u0026#34; \u0026lt;\u0026lt; std::endl; for (int i = 0; i \u0026lt; s; i++) { ptr[i] = i; } } B(const B\u0026amp; b) :s(b.s) { std::cout \u0026lt;\u0026lt; \u0026#34;B\u0026amp;b\u0026#34; \u0026lt;\u0026lt; std::endl; ptr = new int[s]; for (int i = 0; i \u0026lt; s; i++) ptr[i] = b.ptr[i]; } B(B\u0026amp;\u0026amp; b) :s(b.s), ptr(b.ptr) { std::cout \u0026lt;\u0026lt; \u0026#34;B\u0026amp;\u0026amp; b\u0026#34; \u0026lt;\u0026lt; std::endl; b.ptr = nullptr; } ~B() { std::cout \u0026lt;\u0026lt; \u0026#34;~B()\u0026#34; \u0026lt;\u0026lt; std::endl; if (ptr) delete[] ptr; } private: int s; int* ptr{nullptr}; }; std::ostream\u0026amp; operator \u0026lt;\u0026lt;(std::ostream\u0026amp; os,B\u0026amp; b) { os \u0026lt;\u0026lt; \u0026#34;[ \u0026#34;; for (int i = 0; i \u0026lt; b.s; i++) os \u0026lt;\u0026lt; b.ptr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; os \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; std::endl; return os; } #if 0B\u0026amp;\u0026amp; f() // 警告，返回了局部变量的引用 { B tmp; return std::move(tmp); } B\u0026amp; f2() // 同上 { B t; return t; } #endif B f() // 调用移动构造 { B tmp; return std::move(tmp); } B f2() // 编译器会做优化 { B t; return t; } int main() { B b0 = f2(); // default constructor  // ~B()  // 这里编译器做了优化，减少了对象的拷贝  B b1(f()); // default constructor  // B\u0026amp;\u0026amp; b  // ~B()  // ~B()  // 这里调用了移动构造，所以直接返回局部对象的方式不一定比返回右值引用的方式慢  return 0 ; } ","permalink":"https://874656645.github.io/posts/192-c++11-%E5%85%B3%E4%BA%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E9%80%9A%E7%94%A8%E5%BC%95%E7%94%A8%E7%9A%84%E6%80%9D%E8%80%83/","summary":"一、通用引用  类型声明形式为 type\u0026amp;\u0026amp; 其中 type 类型是要进行推导的，如果类型推导没有发生，那么 type\u0026amp;\u0026amp; 代表一个右值引用 如果一个对象被声明为 auto\u0026amp;\u0026amp;，这个形参或者对象就是一个通用引用 通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用 如果在一个类模板里面看见了一个函数形参类型为 T\u0026amp;\u0026amp;，也不一定就是通用引用，可能并没有发生类型推导  void f(Widget\u0026amp;\u0026amp; param); //右值引用 Widget\u0026amp;\u0026amp; var1 = Widget(); //右值引用 auto\u0026amp;\u0026amp; var2 = var1; //通用引用（不是右值引用）  template\u0026lt;typename T\u0026gt; void f(std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026amp; param); //右值引用  template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); //通用引用（不是右值引用）  template \u0026lt;typename T\u0026gt; void f(const T\u0026amp;\u0026amp; param); //param是一个右值引用，因为添加了 const 限定符  // 函数模板 一般可能是通用引用 template \u0026lt;typename T\u0026gt; void print_reference_type(T \u0026amp;\u0026amp;i) { // T\u0026amp;\u0026amp; 或是 auto\u0026amp;\u0026amp;  if (std::is_lvalue_reference\u0026lt;decltype(i)\u0026gt;::value) { std::cout \u0026lt;\u0026lt; \u0026#34;lvalue: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } else if (std::is_rvalue_reference\u0026lt;decltype(i)\u0026gt;::value) { std::cout \u0026lt;\u0026lt; \u0026#34;rvalue: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;unknown value: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } } // 因为 push_back 在有一个特定的 vector 实例之前不可能存在， // 而实例化 vector 时的类型已经决定了 push_back 的声明 // 所以在这里并没有发生类型推导 template\u0026lt;class T, class Allocator = allocator\u0026lt;T\u0026gt;\u0026gt; //来自C++标准 class vector { public: void push_back(T\u0026amp;\u0026amp; x); … } 一个记录任意函数调用的时间开销的函数模板","title":"C++11 关于右值引用、左值引用和通用引用的思考"},{"content":"C中的继承和多态\n","permalink":"https://874656645.github.io/posts/195-c-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/","summary":"C中的继承和多态","title":"C 实现继承和多态"},{"content":"注：ArcMap 版本为 10.6.1\n一、将 shape 字段处理为 WKT 文本\n 在属性表中添加一个 Text 类型的字段，大小尽量大一些； 使用字段计算功能 shape file 的字符串类型字段的大小有限制（254）  二、\ndef MySub(feat): partnum = 0 # Count the number of points in the current multipart feature partcount = feat.partCount pntcount = 0 str = \u0026#39;\u0026#39; # Enter while loop for each part in the feature (if a singlepart  # feature, this will occur only once) while partnum \u0026lt; partcount: part = feat.getPart(partnum) pnt = part.next() # Enter while loop for each vertex while pnt: pntcount += 1 // str = str + \u0026#39;%f\u0026#39; %pnt.X + \u0026#39;,\u0026#39; + \u0026#39;%f\u0026#39; %pnt.Y + \u0026#39;_\u0026#39; pnt = part.next() # If pnt is null, either the part is finished or there  # is an interior ring if not pnt: str = str + \u0026#39;%f\u0026#39; %pnt.X + \u0026#39;\u0026#39; + \u0026#39;%f\u0026#39; %pnt.Y pnt = part.next() else: str = str + \u0026#39;%f\u0026#39; %pnt.X + \u0026#39;\u0026#39; + \u0026#39;%f\u0026#39; %pnt.Y + \u0026#39;_\u0026#39; partnum += 1 return str[0:len(str)-1] ","permalink":"https://874656645.github.io/posts/194-arcgis-%E5%A4%84%E7%90%86-shape-%E5%AD%97%E6%AE%B5/","summary":"注：ArcMap 版本为 10.6.1\n一、将 shape 字段处理为 WKT 文本\n 在属性表中添加一个 Text 类型的字段，大小尽量大一些； 使用字段计算功能 shape file 的字符串类型字段的大小有限制（254）  二、\ndef MySub(feat): partnum = 0 # Count the number of points in the current multipart feature partcount = feat.partCount pntcount = 0 str = \u0026#39;\u0026#39; # Enter while loop for each part in the feature (if a singlepart  # feature, this will occur only once) while partnum \u0026lt; partcount: part = feat.","title":"ArcGIS 处理 Shape 字段"},{"content":"一、设置 Linux 环境 1. 确保已安装用于 Visual Studio 的 Linux 开发工作负荷 2. Linux 所需环境 sudo apt-get install openssh-server g++ gdb make ninja-build rsync zip\n确保 ssh 服务在 Linux 计算机上运行\nsudo service ssh start\n参考官方文档\n二、连接到远程 Linux 打开【工具】\u0026gt;【选项】\u0026gt;【跨平台】\u0026gt;【连接管理器】进行添加设置\n也可以连接到 WSL，参考官方文档\n三、创建 Linux MSBuild 项目 四、配置 Linux MSBuild 项目 大部分的默认配置都不需要修改，只需关注几个地方\n调试设置\n包含目录是 Linux 上项目的路径\n库目录可使用相对路径\n如果依赖的是动态库，需要在 Linux 端设置 LD_LIBRARY_PATH\n最后在 Linux 环境中生成的项目目录如下\n还可以在【调试】中打开【Linux控制台】\n参考官方文档\n","permalink":"https://874656645.github.io/posts/191-%E4%BD%BF%E7%94%A8-vs2022-%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95-linux-msbuild-%E9%A1%B9%E7%9B%AE/","summary":"一、设置 Linux 环境 1. 确保已安装用于 Visual Studio 的 Linux 开发工作负荷 2. Linux 所需环境 sudo apt-get install openssh-server g++ gdb make ninja-build rsync zip\n确保 ssh 服务在 Linux 计算机上运行\nsudo service ssh start\n参考官方文档\n二、连接到远程 Linux 打开【工具】\u0026gt;【选项】\u0026gt;【跨平台】\u0026gt;【连接管理器】进行添加设置\n也可以连接到 WSL，参考官方文档\n三、创建 Linux MSBuild 项目 四、配置 Linux MSBuild 项目 大部分的默认配置都不需要修改，只需关注几个地方\n调试设置\n包含目录是 Linux 上项目的路径\n库目录可使用相对路径\n如果依赖的是动态库，需要在 Linux 端设置 LD_LIBRARY_PATH\n最后在 Linux 环境中生成的项目目录如下\n还可以在【调试】中打开【Linux控制台】\n参考官方文档","title":"使用 VS2022 部署、运行和调试 Linux MSBuild 项目"},{"content":" 通过 using 可以方便的使用父类的构造函数和其他函数； 优先使用子类的构造和函数，如果没有找到匹配的才会调用基类的； 可在子类的初始化列表中调用父类的构造函数，并对子类的成员进行列表初始化；  class BS { int q; double w; public: BS() : q(0), w(0) {} BS(int k) : q(k), w(100) {} BS(double x) : q(-1), w(x) {} BS(int k, double x) : q(k), w(x) {} void Show() const { std::cout \u0026lt;\u0026lt; q \u0026lt;\u0026lt;\u0026#34;, \u0026#34; \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int fn(int j) { cout \u0026lt;\u0026lt; \u0026#34;BS::fn(int)\\n\u0026#34;; return 0; } double fn(double w) { cout \u0026lt;\u0026lt; \u0026#34;BS::fn(double)\\n\u0026#34;; return 0; } void fn(const char * s) { cout \u0026lt;\u0026lt; \u0026#34;BS::fn(const char *)\\n\u0026#34;; } }; class DR : public BS { short j; public: using BS::BS; DR() : j(-100) {} // DR needs its own default constructor  DR(double x) : BS(2*x), j(int(x)) {} DR(int i) : j(-2), BS(i, 0.5* i) {} void Show() const { std::cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; BS::Show(); } using BS::fn; // 如果不用 using，父类的 fn 会被隐藏  double fn(double w) { cout \u0026lt;\u0026lt; \u0026#34;DR::fn(double)\\n\u0026#34;; return 0; }; }; int main() { DR o1; // use DR()  o1.Show(); // -100, 0, 0  DR o2(18.81); // use DR(double) instead of BS(double)  o2.Show(); // 18, -1, 37.62  DR o3(10, 1.8); // use BS(int, double)  o3.Show(); // 随机值, 10, 1.8  o3.fn(1); // use BS::fn  o3.fn(1.1); // use DR::fn  o3.fn(\u0026#34;Uh\u0026#34;); // use BS::fn } 输出：\n-100, 0, 0 18, -1, 37.62 24016, 10, 1.8 BS::fn(int) DR::fn(double) BS::fn(const char *) ","permalink":"https://874656645.github.io/posts/190-c++11-%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0/","summary":"通过 using 可以方便的使用父类的构造函数和其他函数； 优先使用子类的构造和函数，如果没有找到匹配的才会调用基类的； 可在子类的初始化列表中调用父类的构造函数，并对子类的成员进行列表初始化；  class BS { int q; double w; public: BS() : q(0), w(0) {} BS(int k) : q(k), w(100) {} BS(double x) : q(-1), w(x) {} BS(int k, double x) : q(k), w(x) {} void Show() const { std::cout \u0026lt;\u0026lt; q \u0026lt;\u0026lt;\u0026#34;, \u0026#34; \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int fn(int j) { cout \u0026lt;\u0026lt; \u0026#34;BS::fn(int)\\n\u0026#34;; return 0; } double fn(double w) { cout \u0026lt;\u0026lt; \u0026#34;BS::fn(double)\\n\u0026#34;; return 0; } void fn(const char * s) { cout \u0026lt;\u0026lt; \u0026#34;BS::fn(const char *)\\n\u0026#34;; } }; class DR : public BS { short j; public: using BS::BS; DR() : j(-100) {} // DR needs its own default constructor  DR(double x) : BS(2*x), j(int(x)) {} DR(int i) : j(-2), BS(i, 0.","title":"C++11 继承构造"},{"content":"委托构造的使用方法类似成员列表初始化的变种；\n注意：\n 如果在一个构造函数中使用了本类的委托构造，就不能再对成员使用列表初始化了； 会先执行委托构造函数的函数体，然后再执行本身的函数体； 虽然可以在构造函数中调用其他的构造函数，但已经被初始化的成员变量还会被当前的构造函数进行重置，有可能导致又变为原来的未初始化状态；  class Test{ public: Test():Test(0, 0.1){ s = \u0026#34;Ah\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Test()\\n\u0026#34;; } Test(int ii):Test(ii, 0.1, \u0026#34;Hi\u0026#34;){ cout \u0026lt;\u0026lt; \u0026#34;Test(int)\\n\u0026#34;; } Test(int ii, double dd):Test(ii, dd, \u0026#34;Hi\u0026#34;){ cout \u0026lt;\u0026lt; \u0026#34;Test(int, double)\\n\u0026#34;; } Test(int ii, double dd, string ss):i(ii), d(dd), s(ss){ cout \u0026lt;\u0026lt; \u0026#34;Test(int, double, string)\\n\u0026#34;; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;\\td = \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;\\ts = \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } private: int i; double d; string s; }; int main() { Test t(10); t.print(); return 0; } 输出：\nTest(int, double, string) Test(int) i = 10\td = 0.1\ts = Hi 不可在构造函数中调用其他的构造函数：\n... Test(int ii){ Test(ii, 0.1, \u0026#34;Hi\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;Test(int)\\n\u0026#34;; } ... 输出：\nTest(int, double, string) Test(int) i = 111602336\td = 4.64376e-310\ts = ","permalink":"https://874656645.github.io/posts/189-c++11-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0/","summary":"委托构造的使用方法类似成员列表初始化的变种；\n注意：\n 如果在一个构造函数中使用了本类的委托构造，就不能再对成员使用列表初始化了； 会先执行委托构造函数的函数体，然后再执行本身的函数体； 虽然可以在构造函数中调用其他的构造函数，但已经被初始化的成员变量还会被当前的构造函数进行重置，有可能导致又变为原来的未初始化状态；  class Test{ public: Test():Test(0, 0.1){ s = \u0026#34;Ah\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Test()\\n\u0026#34;; } Test(int ii):Test(ii, 0.1, \u0026#34;Hi\u0026#34;){ cout \u0026lt;\u0026lt; \u0026#34;Test(int)\\n\u0026#34;; } Test(int ii, double dd):Test(ii, dd, \u0026#34;Hi\u0026#34;){ cout \u0026lt;\u0026lt; \u0026#34;Test(int, double)\\n\u0026#34;; } Test(int ii, double dd, string ss):i(ii), d(dd), s(ss){ cout \u0026lt;\u0026lt; \u0026#34;Test(int, double, string)\\n\u0026#34;; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;\\td = \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;\\ts = \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } private: int i; double d; string s; }; int main() { Test t(10); t.","title":"C++11 委托构造"},{"content":" 静态变量在 main 函数前执行初始化 on_exit 注册的函数在 main 执行后再执行  void f(int state, void* msg){ cout \u0026lt;\u0026lt; \u0026#34;after main exit.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;state: \u0026#34; \u0026lt;\u0026lt; state \u0026lt;\u0026lt; \u0026#34;\\tmessage: \u0026#34; \u0026lt;\u0026lt; (char*)msg \u0026lt;\u0026lt; endl; } int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World\\n\u0026#34;; on_exit(f, (char*)\u0026#34;this is message\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;end of main.\\n\u0026#34;; return 0; } 输出：\nHello World end of main. after main exit. state: 0\tmessage: this is message ","permalink":"https://874656645.github.io/posts/188-main-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%90%8E%E6%89%80%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81/","summary":" 静态变量在 main 函数前执行初始化 on_exit 注册的函数在 main 执行后再执行  void f(int state, void* msg){ cout \u0026lt;\u0026lt; \u0026#34;after main exit.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;state: \u0026#34; \u0026lt;\u0026lt; state \u0026lt;\u0026lt; \u0026#34;\\tmessage: \u0026#34; \u0026lt;\u0026lt; (char*)msg \u0026lt;\u0026lt; endl; } int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World\\n\u0026#34;; on_exit(f, (char*)\u0026#34;this is message\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;end of main.\\n\u0026#34;; return 0; } 输出：\nHello World end of main. after main exit. state: 0\tmessage: this is message ","title":"main 函数执行完后所执行的代码"},{"content":"一、概念   计算机系统中内存是以字节为单位进行编址的，每个地址单元都唯一的对应着 1 个字节（8 bit）\n  有些类型的长度是超过 1 个字节的，比如 C/C++ 中，short 类型一般是 2 个字节，int 类型一般 4 个字节等。因此这里就存在如何安排多字节数据中，各字节存放顺序的问题。正是因为不同的安排顺序导致了大端存储模式和小端存储模式的存在。\n 大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中（高低低高） 小端模式：是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中（高高低低）    假如有一个 4 字节的数据为 0x12345678（十进制：305419896，0x12 为高字节，0x78 为低字节），若将其存放于地址 0x4000 8000 中，则有：\n            内存地址 0x4000 8000（低地址） 0x4000 8001 0x4000 8002 0x4000 8003（高地址）   大端模式 0x12 0x34 0x56 0x78   小端模式 0x78 0x56 0x34 0x12      现状：\n Intel 的 80×86 系列芯片使用小端存储模式 ARM 芯片默认采用小端，但可以切换为大端 MIPS 芯片采用大端，但可以在大小端之间切换 在网络上传输的数据普遍采用的都是大端    二、判断字节序  不同的 CPU 有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，也叫做主机序 内存的读写永远从低地址开始读/写（起始地址），从低到高 对一个对象取地址，这个指针是对象使用的最低字节地址（对象的起始地址） 大端模式（Big endian）：将高序字节存储在起始地址 小端模式（Little endian）：将低序字节存储在起始地址    通过将多字节数据强制类型转换成单字节数据，再通过判断起始存储位置是数据高字节还是低字节进行检测\nint i = 1; char *p = (char*)\u0026amp;i; // 读取 int 的第一个字节（起始地址） if(*p == 1){ printf(\u0026#34;Little Endian\u0026#34;); } else{ printf(\u0026#34;Big Endian\u0026#34;); }   利用联合体 union 的存放顺序是所有成员都从低地址开始存放这一特性进行检测\nbool isBigEndian() { union uendian { int nNum; char cLowAddressValue; }; uendian u; u.nNum = 0x12345678; if ( u.cLowAddressValue == 0x12 ) return true; return false; }   Linux 操作系统中相关的源代码\nstatic union { char c[4]; unsigned long mylong; } endian_test = {{ \u0026#39;l\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;b\u0026#39; } }; #define ENDIANNESS ((char)endian_test.mylong)   测试\n  void show_bytes(unsigned char* start, size_t len){ for(size_t i = 0; i \u0026lt; len; ++i){ printf(\u0026#34; %.2x\u0026#34;, start[i]); } printf(\u0026#34;\\n\u0026#34;); } void show_int(int x){ show_bytes((unsigned char*)\u0026amp;x, sizeof(int)); } void show_float(float x){ show_bytes((unsigned char*)\u0026amp;x, sizeof(float)); } void show_pointer(void* x){ show_bytes((unsigned char*)\u0026amp;x, sizeof(void*)); } void test_show_bytes(int val){ int ival = val; float fval = (float)ival; int* pval = \u0026amp;ival; cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; ival \u0026lt;\u0026lt; endl; show_int(ival); cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; fval \u0026lt;\u0026lt; endl; show_float(fval); cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; pval \u0026lt;\u0026lt; endl; show_pointer(pval); } int main() { int i = 12345; test_show_bytes(i); return 0; } 输出：\n3039\r39 30 00 00\r12345\r00 e4 40 46\r0x7fffbf791af8\rf8 1a 79 bf ff 7f 00 00\r参考：\n 关于高位字节与低位字节简洁明了的说明，以及高低字节序转换函数 大端模式、小端模式、高字节序、低字节序、MSB、LSB 大端和小端（Big endian and Little endian） 大端小端。。。 二进制、16进制、大端小端  ","permalink":"https://874656645.github.io/posts/187-%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F/","summary":"一、概念   计算机系统中内存是以字节为单位进行编址的，每个地址单元都唯一的对应着 1 个字节（8 bit）\n  有些类型的长度是超过 1 个字节的，比如 C/C++ 中，short 类型一般是 2 个字节，int 类型一般 4 个字节等。因此这里就存在如何安排多字节数据中，各字节存放顺序的问题。正是因为不同的安排顺序导致了大端存储模式和小端存储模式的存在。\n 大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中（高低低高） 小端模式：是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中（高高低低）    假如有一个 4 字节的数据为 0x12345678（十进制：305419896，0x12 为高字节，0x78 为低字节），若将其存放于地址 0x4000 8000 中，则有：\n            内存地址 0x4000 8000（低地址） 0x4000 8001 0x4000 8002 0x4000 8003（高地址）   大端模式 0x12 0x34 0x56 0x78   小端模式 0x78 0x56 0x34 0x12      现状：","title":"大端、小端字节序"},{"content":"alignof( type-id ) 查询类型的对齐要求，以字节为单位\nstruct Storage { char a; int b; double c; long long d; }; // struct alignas(alignof(long double)) AlignasStorage { // struct alignas(long double) AlignasStorage { struct alignas(std::max_align_t) AlignasStorage { // max_align_t 相当于 alignof(long double) 内存对齐为 16 字节  // 这三种写法都可以  char a; int b; double c; long long d; }; struct Empty {}; struct alignas(64) Empty64 {}; int main() { std::cout \u0026lt;\u0026lt; alignof(Storage) \u0026lt;\u0026lt; std::endl; // 8  std::cout \u0026lt;\u0026lt; sizeof(Storage) \u0026lt;\u0026lt; std::endl; // 24 内存对齐为 8 字节，所以大小为 8 的整数倍  std::cout \u0026lt;\u0026lt; alignof(AlignasStorage) \u0026lt;\u0026lt; std::endl; // 16  std::cout \u0026lt;\u0026lt; sizeof(AlignasStorage) \u0026lt;\u0026lt; std::endl; // 32 内存对齐为 16 字节，所以大小为 16 的整数倍  int a = 10; int \u0026amp;b = a; std::cout \u0026lt;\u0026lt; alignof(b) \u0026lt;\u0026lt; std::endl; // 4 引用类型返回引用类型的对齐要求  int x[10]; std::cout \u0026lt;\u0026lt; alignof(x) \u0026lt;\u0026lt; std::endl; // 4 数组类型返回元素类型的对齐要求  std::cout \u0026lt;\u0026lt; \u0026#34;Alignment of\u0026#34; \u0026#34;\\n\u0026#34; \u0026#34;- char : \u0026#34; \u0026lt;\u0026lt; alignof(char) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; // 1  \u0026#34;- pointer : \u0026#34; \u0026lt;\u0026lt; alignof(int*) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; // 8  \u0026#34;- int : \u0026#34; \u0026lt;\u0026lt; alignof(int) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; // 4  \u0026#34;- long long : \u0026#34; \u0026lt;\u0026lt; alignof(long long) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; // 8  \u0026#34;- empty class : \u0026#34; \u0026lt;\u0026lt; alignof(Empty) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; // 1  \u0026#34;- alignas(64) Empty: \u0026#34; \u0026lt;\u0026lt; alignof(Empty64) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 64  return 0; } ","permalink":"https://874656645.github.io/posts/186-c++11-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-alignof-alignas-max_align_t/","summary":"alignof( type-id ) 查询类型的对齐要求，以字节为单位\nstruct Storage { char a; int b; double c; long long d; }; // struct alignas(alignof(long double)) AlignasStorage { // struct alignas(long double) AlignasStorage { struct alignas(std::max_align_t) AlignasStorage { // max_align_t 相当于 alignof(long double) 内存对齐为 16 字节  // 这三种写法都可以  char a; int b; double c; long long d; }; struct Empty {}; struct alignas(64) Empty64 {}; int main() { std::cout \u0026lt;\u0026lt; alignof(Storage) \u0026lt;\u0026lt; std::endl; // 8  std::cout \u0026lt;\u0026lt; sizeof(Storage) \u0026lt;\u0026lt; std::endl; // 24 内存对齐为 8 字节，所以大小为 8 的整数倍  std::cout \u0026lt;\u0026lt; alignof(AlignasStorage) \u0026lt;\u0026lt; std::endl; // 16  std::cout \u0026lt;\u0026lt; sizeof(AlignasStorage) \u0026lt;\u0026lt; std::endl; // 32 内存对齐为 16 字节，所以大小为 16 的整数倍  int a = 10; int \u0026amp;b = a; std::cout \u0026lt;\u0026lt; alignof(b) \u0026lt;\u0026lt; std::endl; // 4 引用类型返回引用类型的对齐要求  int x[10]; std::cout \u0026lt;\u0026lt; alignof(x) \u0026lt;\u0026lt; std::endl; // 4 数组类型返回元素类型的对齐要求  std::cout \u0026lt;\u0026lt; \u0026#34;Alignment of\u0026#34; \u0026#34;\\n\u0026#34; \u0026#34;- char : \u0026#34; \u0026lt;\u0026lt; alignof(char) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; // 1  \u0026#34;- pointer : \u0026#34; \u0026lt;\u0026lt; alignof(int*) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; // 8  \u0026#34;- int : \u0026#34; \u0026lt;\u0026lt; alignof(int) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; // 4  \u0026#34;- long long : \u0026#34; \u0026lt;\u0026lt; alignof(long long) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; // 8  \u0026#34;- empty class : \u0026#34; \u0026lt;\u0026lt; alignof(Empty) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; // 1  \u0026#34;- alignas(64) Empty: \u0026#34; \u0026lt;\u0026lt; alignof(Empty64) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 64  return 0; } ","title":"C++11 内存对齐 alignof alignas max_align_t"},{"content":"Cesium for Unreal 插件的材质被设计成模块化的，所以可以被很容易地添加和删除。\n目标  浏览和理解现有的 Cesium for Unreal 3D Tileset 的材质 基于包含在 Cesium for Unreal 插件内的材质实例文件创建自定义材质 修改 tileset 的材质 了解 tileset mesh 的材质限制  Material Instances Cesium for Unreal 通过使用 Material Instances 实现最大的灵活度，每个材质实例通过使用更多的材质图层来应用图像叠加，水，或其他材质效果。\n![MaterialInstances](./img/MaterialInstances.jpg)\r  图层资产：包含将显示在给定层上的材质图层节点 混合资产：包含一个节点，该节点确定该材质图层将如何与下面的图层混合 每个材质图层和材质图层混合都可以像其他材质对象一样在材质编辑器中编辑  创建应用到整个 tileset 的材质   在插件目录找到 MI_CesiumThreeOverlaysAndClipping 材质实例文件，并把它拷贝到项目的内容文件夹中，将其改名为 MI_GroundTint。\n  在【内容】面板右击，创建一个【材质图层】资产，并将其命名为 ML_GroundTint。\n  双击 ML_GroundTint，打开材质编辑窗口，点击【SetMaterialAttributes】节点，在【细节】面板中的【属性设置类型】数组中添加两个元素，第一个元素设置为默认值【BaseColor】，第二个元素设置为【Opacity】。\n  添加一个【Constant3Vector】节点，并右击节点，将其【转换为参数】，并命名为 Color。\n  添加一个【Constant】节点，，将其【转换为参数】，并命名为 Opacity。\n  右击 Color 节点，在【细节】面板设置默认颜色，比如红色，设置 Opacity 的默认值为 0.5。\n  将 Color 节点连接到【SetMaterialAttributes】节点的【基础颜色】，将 Opacity 节点连接到【不透明度】，如下图所示：\n  保存并关闭材质图层编辑窗口，打开 MI_GroundTint 材质实例编辑窗口，将 Overlay2 修改为 GroundTint，然后设置【图层资产】为上面的 ML_GroundTint。\n  选中关卡中的【Cesium World Terrain】actor，在【细节】面板中找到 Material 并将其设置为 ML_GroundTint，效果如下：\n  使用带有材质的 Cartographic Polygons   在插件目录找到 MI_CesiumThreeOverlaysAndClipping 材质实例文件，并把它拷贝到项目的内容文件夹中，将其改名为 MI_AreaTint。\n  在【内容】面板右击，创建一个【材质图层混合】资产，并将其命名为 MLB_AreaTint。\n  打开 MLB_AreaTint，该资产将在 Bottom Layer（使用了该 Blend Asset 的图层下面的所有材质图层）和 Top Layer（使用了该 Blend Asset 的图层）之间混合。使用 Cartographic Polygons 时，不仅仅是希望将两种材料属性均匀混合在一起。CesiumPolygonRasterOverlay 不像图像叠加一样运行。相反，我们需要设置自定义逻辑以将 Cartographic Polygon Mask 用作 Alpha 混合。\n  删除 BlendMaterialAttributes 节点并添加两个 GetMaterialAttributes 节点，再添加一个 SetMaterialAttributes 节点，最终将所有节点连接如下图所示：\n  在新建的三个节点中分别添加【属性获取类型】 BaseColor（基础颜色）。\n  添加 Color（Constant3Vector）参数节点和 Opacity（Constant）参数节点，并分别设置默认值。\n  添加 LinearInterpolate (Lerp) 节点，将 Bottom Layer 的基础颜色与我们设置的颜色参数进行线性插值混合。\n  通过 Top Layer 的 GetMaterialAttributes 节点计算 Lerp 节点的 Alpha 值，添加 BreakOutFloat3Components 节点，将 Top Layer 的基础颜色分为 RGB 3通道的值，添加 Multiply 节点，将 R 通道与 Opacity 参数相乘，并把输出结果连接到 Lerp 节点的 Alpha。最终连接效果图如下所示：\n  保存并关闭 MLB_AreaTint。\n  打开 MI_AreaTint 材质实例，找到最上面的材质图层，并将 Key 从 Clipping 修改为 Tint，并将它的【混合资产】设置为 MLB_AreaTint。\n  关闭并保存材质实例。\n 在场景中添加 Cesium Cartographic Polygon。\n  将 Cesium World Terrain 的 Material 设置为 MI_AreaTint。\n  在 Cesium World Terrain tileset actor 添加组件 Cesium Polygon Raster Overlay\n 在 Polygons 添加y一个元素并关联到我们添加的 Cesium Cartographic Polygon 取消选中 Exclude Tiles Inside 将 Material Layer Key 设置为 Tint    在添加的多边形内部的 tileset 会与我们设置的材质图层进行混色，效果如下图所示：   ","permalink":"https://874656645.github.io/posts/185-cesium-unreal-editing-tileset-materials/","summary":"Cesium for Unreal 插件的材质被设计成模块化的，所以可以被很容易地添加和删除。\n目标  浏览和理解现有的 Cesium for Unreal 3D Tileset 的材质 基于包含在 Cesium for Unreal 插件内的材质实例文件创建自定义材质 修改 tileset 的材质 了解 tileset mesh 的材质限制  Material Instances Cesium for Unreal 通过使用 Material Instances 实现最大的灵活度，每个材质实例通过使用更多的材质图层来应用图像叠加，水，或其他材质效果。\n![MaterialInstances](./img/MaterialInstances.jpg)\r  图层资产：包含将显示在给定层上的材质图层节点 混合资产：包含一个节点，该节点确定该材质图层将如何与下面的图层混合 每个材质图层和材质图层混合都可以像其他材质对象一样在材质编辑器中编辑  创建应用到整个 tileset 的材质   在插件目录找到 MI_CesiumThreeOverlaysAndClipping 材质实例文件，并把它拷贝到项目的内容文件夹中，将其改名为 MI_GroundTint。\n  在【内容】面板右击，创建一个【材质图层】资产，并将其命名为 ML_GroundTint。\n  双击 ML_GroundTint，打开材质编辑窗口，点击【SetMaterialAttributes】节点，在【细节】面板中的【属性设置类型】数组中添加两个元素，第一个元素设置为默认值【BaseColor】，第二个元素设置为【Opacity】。\n  添加一个【Constant3Vector】节点，并右击节点，将其【转换为参数】，并命名为 Color。\n  添加一个【Constant】节点，，将其【转换为参数】，并命名为 Opacity。\n  右击 Color 节点，在【细节】面板设置默认颜色，比如红色，设置 Opacity 的默认值为 0.","title":"Cesium4Unreal——Editing Tileset Materials"},{"content":"使用 CesiumCartographicPolygon actor，可以定义一个 tileset 的隐藏区域，或应用其他材质效果。CesiumCartographicPolygon 可以通过 Cesium PolygonRasterOverlay 组件添加到一个或多个 tilesets。\n在这里，一个 CesiumCartographicPolygon 被用来隐藏 Cesium World Terrain 和 Cesium OSM Buildings，它们与 Aerometrex Denver Photogrammetry 重叠。\n注意：虽然 CesiumCartographicPolygon 有助于基于材质的改变，如 clipping，但它们不影响物理。你仍然可以与 tileset 的隐藏部分发生碰撞。\n第一步：添加 CesiumCartographicPolygon actor 可以修改多边形的节点（增加、删除、拖拽节点），修改线的颜色，以及地理位置\n第二步：将 CesiumCartographicPolygon 连接到 tileset 数据 选择要将 CesiumCartographicPolygon 应用到的 tileset，比如 Cesium World Terrain，添加组件 CesiumPolygonRasterOverlay\n关连 CesiumCartographicPolygon\n可以手动刷新 tileset （Refresh Tileset）观看效果\n Exclude Tiles Inside： 是专为 clipping 使用。如果这个设置被启用，任何完全位于多边形内部的 tiles 都不会被加载，这可以提高性能。如果你使用这个多边形不是为了 clipping，要禁用这个设置。否则，多边形内的 tiles 将不会被渲染。 Material Layer Key： 将多边形与特定部分的 tileset 的材质连接起来。如果你把这个键换成别的东西，它不会起作用，直到你创建一个使用新键的材质，并将该材质应用到 tileset。  ","permalink":"https://874656645.github.io/posts/184-cesium-unreal-hide-parts-tilesets/","summary":"使用 CesiumCartographicPolygon actor，可以定义一个 tileset 的隐藏区域，或应用其他材质效果。CesiumCartographicPolygon 可以通过 Cesium PolygonRasterOverlay 组件添加到一个或多个 tilesets。\n在这里，一个 CesiumCartographicPolygon 被用来隐藏 Cesium World Terrain 和 Cesium OSM Buildings，它们与 Aerometrex Denver Photogrammetry 重叠。\n注意：虽然 CesiumCartographicPolygon 有助于基于材质的改变，如 clipping，但它们不影响物理。你仍然可以与 tileset 的隐藏部分发生碰撞。\n第一步：添加 CesiumCartographicPolygon actor 可以修改多边形的节点（增加、删除、拖拽节点），修改线的颜色，以及地理位置\n第二步：将 CesiumCartographicPolygon 连接到 tileset 数据 选择要将 CesiumCartographicPolygon 应用到的 tileset，比如 Cesium World Terrain，添加组件 CesiumPolygonRasterOverlay\n关连 CesiumCartographicPolygon\n可以手动刷新 tileset （Refresh Tileset）观看效果\n Exclude Tiles Inside： 是专为 clipping 使用。如果这个设置被启用，任何完全位于多边形内部的 tiles 都不会被加载，这可以提高性能。如果你使用这个多边形不是为了 clipping，要禁用这个设置。否则，多边形内的 tiles 将不会被渲染。 Material Layer Key： 将多边形与特定部分的 tileset 的材质连接起来。如果你把这个键换成别的东西，它不会起作用，直到你创建一个使用新键的材质，并将该材质应用到 tileset。  ","title":"Cesium4Unreal——Hide Parts Tilesets"},{"content":"目标 此步骤将学习如何设置控制器，而不是使用 Cesium 的 DynamicPawn。\n第一步：添加摄影测量数据 为了防止地形和摄影测量数据交叉，将 Aerometrex Denver Photogrammetry 的 actor 的位置的 Z 值设置为 600。\n第二步：定位到摄影测量数据  方式一：如果有经纬度坐标和高程数据，直接设置 CesiumGeoreference 的数据  Origin Latitude = 39.752827\nOrigin Longitude = -104.999689\nOrigin Height = 1570.879421\n方式二：在【世界大纲视图】中双击 Aerometrex Denver Photogrammetry，使用场景视图导航到想要放置世界原点的位置，并点击【Place Georeference origin Here】按钮  第三步：导入第三人称角色 可以添加 UE 自带的【Third Person】资源，也可以添加自己做的角色。添加自带的小白人资源有两种方式：\n 方式一：通过【添加/导入】中的【添加功能或内容包】  方式二：从其他有【第三人称游戏模板】的项目中，将 ThirdPersonCharacter 迁移到本项目中。  第四步：将 ThirdPersonCharacter 放入到场景中 找到 ThirdPersonCharacter 并将其拖拽到场景里，并调整合适的朝向\n效果如下：\n设置【自动控制玩家】为【玩家0】，这样在点击【运行】的时候就可以看到小白人了\n注意：如果你现在试着玩这个关卡，你会注意到你的演员可能会在丹佛摄影测量完全加载之前开始下降。继续阅读，看看如何解决这个问题。出于这个原因，还建议禁用当前未与之交互的任何物理对象的物理功能。\n第五步：设置一个安全的起始位置 在小白人的脚下放置一个立方体，防止开始游戏时，由于 3DTiles 数据在加载过程中，小白人由于受重力影响而掉下去。\n第六步：在场景中添加一个车辆控制器 第七步：设置关卡蓝图 通过 C 和 V 切换小白人和车辆控制器的控制权。\n为了防止当控制权切换到小白人后，车辆控制器受物理特性影响，要关闭物理模拟\n","permalink":"https://874656645.github.io/posts/183-cesium-unreal-using-custom-controllers/","summary":"目标 此步骤将学习如何设置控制器，而不是使用 Cesium 的 DynamicPawn。\n第一步：添加摄影测量数据 为了防止地形和摄影测量数据交叉，将 Aerometrex Denver Photogrammetry 的 actor 的位置的 Z 值设置为 600。\n第二步：定位到摄影测量数据  方式一：如果有经纬度坐标和高程数据，直接设置 CesiumGeoreference 的数据  Origin Latitude = 39.752827\nOrigin Longitude = -104.999689\nOrigin Height = 1570.879421\n方式二：在【世界大纲视图】中双击 Aerometrex Denver Photogrammetry，使用场景视图导航到想要放置世界原点的位置，并点击【Place Georeference origin Here】按钮  第三步：导入第三人称角色 可以添加 UE 自带的【Third Person】资源，也可以添加自己做的角色。添加自带的小白人资源有两种方式：\n 方式一：通过【添加/导入】中的【添加功能或内容包】  方式二：从其他有【第三人称游戏模板】的项目中，将 ThirdPersonCharacter 迁移到本项目中。  第四步：将 ThirdPersonCharacter 放入到场景中 找到 ThirdPersonCharacter 并将其拖拽到场景里，并调整合适的朝向\n效果如下：\n设置【自动控制玩家】为【玩家0】，这样在点击【运行】的时候就可以看到小白人了\n注意：如果你现在试着玩这个关卡，你会注意到你的演员可能会在丹佛摄影测量完全加载之前开始下降。继续阅读，看看如何解决这个问题。出于这个原因，还建议禁用当前未与之交互的任何物理对象的物理功能。\n第五步：设置一个安全的起始位置 在小白人的脚下放置一个立方体，防止开始游戏时，由于 3DTiles 数据在加载过程中，小白人由于受重力影响而掉下去。\n第六步：在场景中添加一个车辆控制器 第七步：设置关卡蓝图 通过 C 和 V 切换小白人和车辆控制器的控制权。","title":"Cesium4Unreal——Using Custom Controllers"},{"content":"目标 学习使用虚幻引擎的蓝图系统编程，实现在地球上的两个位置之间平稳飞行。\n 在虚幻引擎中使用地图坐标 在感兴趣的位置创建 viewpoints 创建一个蓝图，使位置的切换变得平滑  第一步：创建一个关卡 参考前面的步骤创关卡，并定位到澳大利亚悉尼\nOrigin Latitude = -33.871799 Origin Longitude = 151.206696 Origin Height = 3000.0\n第二步：添加 DynamicPawn actor 第三步：在蓝图中设置转换   打开关卡蓝图\n  蓝图联接图\n  创建墨尔本经纬度向量\nlongitude = 144.9631\nlatitude = -37.8136\nheight = 2000\n第四步：自定义飞行过渡 设置飞行曲线：\n Fly To Altitude Profile Curve Fly to Maximum Altitude Curve Fly to Progress Curve  添加 Fly To Curves actor，这是一个UCurveFloat，这个函数用来控制计算从源头到目的地的路径插值。\n  在【内容】面板右击，选择【其他】【曲线】，选择【CurveFloat】，并命名\n  双击刚才创建的 Curve 对象，打开曲线编辑器。右击曲线，添加三个关键帧，效果如下：\n  全选三个关键帧结点，在上方的工具条中选择【三次插值】和【加权切线】\n  拖动加权切线\n  添加 【Fly to Maximum Altitude Curve】和【Fly to Progress Curve】\n Fly to Maximum Altitude Curve shape and curve options   Fly to Progress Curve shape and curve options    调整三个曲线，一旦对曲线的形状感到满意，就可以将它们分配给 DynamicPawn 角色的【细节】面板中相应的变量\n  第五步：飞行到地理标记 输入起始和结束的 WGS84 坐标来指定飞行并不总是很方便。在某些情况下，可以通过放置地理标记来避免这种情况。这些标记可以直接作为在球上的目标位置（这些地理标记都是有地理参考的网格体）。\n  在场景中放置一个静态网格体，例如立方体，这个就可以做为我们的地理标记，然后在 UE 编辑器中调整需要的场景视角，右击放入的静态网格体，选择【将对象对齐到视图】，将地理标记准确的放置在 UE 编辑器当前摄像机所在位置，并对齐摄像机朝向。（注意：如果当前项目有【子关卡】，要将地理标记放到【持久关卡】中）。\n  将放置的静态网格体设置为可移动的。\n  添加 Cesium Globe Anchor 组件\n  在【关卡蓝图】中添加键盘事件。\n  将 DynamicPawn 拖入到蓝图中，添加 【Inaccurate Fly to Location ECEF】函数。\n  将放置的静态网格体和 CesiumGeoreference 拖入到蓝图中。添加 CesiumGeoreference 对象的【Inaccurate Transform Ue to Ecef】函数，将输出结果连接到【Inaccurate Fly to Location ECEF】，然后添加获取静态网格体位置【GetActorLocation】的函数，将输出结果连接到【Inaccurate Transform Ue to Ecef】，效果如下图：\n  还可以在【Inaccurate Fly to Location ECEF】函数中修改最终点的 Yaw 和 Pitch 参数，调整相机的最终朝向\n  ","permalink":"https://874656645.github.io/posts/182-cesium-unreal-transition-between-locations/","summary":"目标 学习使用虚幻引擎的蓝图系统编程，实现在地球上的两个位置之间平稳飞行。\n 在虚幻引擎中使用地图坐标 在感兴趣的位置创建 viewpoints 创建一个蓝图，使位置的切换变得平滑  第一步：创建一个关卡 参考前面的步骤创关卡，并定位到澳大利亚悉尼\nOrigin Latitude = -33.871799 Origin Longitude = 151.206696 Origin Height = 3000.0\n第二步：添加 DynamicPawn actor 第三步：在蓝图中设置转换   打开关卡蓝图\n  蓝图联接图\n  创建墨尔本经纬度向量\nlongitude = 144.9631\nlatitude = -37.8136\nheight = 2000\n第四步：自定义飞行过渡 设置飞行曲线：\n Fly To Altitude Profile Curve Fly to Maximum Altitude Curve Fly to Progress Curve  添加 Fly To Curves actor，这是一个UCurveFloat，这个函数用来控制计算从源头到目的地的路径插值。\n  在【内容】面板右击，选择【其他】【曲线】，选择【CurveFloat】，并命名","title":"Cesium4Unreal——Transition Between Locations"},{"content":"目标  Create a persistent global level Put several local sublevels within the persistent level Fill each sublevel with assets and game-logic using your typical Unreal workflow Seamlessly fly between sublevels as well as explore the persistent level Stay aware of pitfalls along the way  第一步：新建由项目组成的世界场景   新建一个空白的项目\n参考快速入门，删除【世界大纲试图】中的所有默认的 actors\n  创建持久关卡(Persistent Level)\n在内容浏览器新建 World 文件夹，把当前的空关卡命名为 Globe 并保存到此文件夹中。\n这个关卡就是 Persistent Level，它代表了整个地球。\n  世界场景设置\n打开【世界场景设置】面板，勾选【启用场景合成】\n禁用【启用场景边界检查】，在全球尺度的世界中，物体可以移动非常远的距离，禁用此设置 Unreal 就不会删除远离原点的物体\n  打开【关卡设置】面板\n  点击【调用世界场景构成】，打开【世界场景构成】面板\n  在【世界场景构成】面板中新建图层，命名 CesiumLayer，并禁用【流送距离】\n  第二步：设置持久关卡 Globe 参考添加数据\n  添加 Cesium World Terrain With Bing Aerial Imagery 地形和影像数据。\n  添加照明 CesiumSunSky，如果看不到影像等数据，去【项目设置】中启用【扩展自动曝光设置中的默认亮度范围】\n  为了建立一些详细的，真实世界的地点并开始构建子关卡，添加 Aerometrex Denver Photogrammetry 和 Nearmap Boston Photogrammetry 的 3D Tilesets 数据。\n  为了绕地球飞行而不迷失方向，添加 DynamicPawn，这个 Actor 在环绕地球飞行时会调整自己的方向，从而能始终保持适当的向上方向。\n  第三步：设置有地理参考的子关卡   将编辑器的世界场景定位到感兴趣的区域，比如 Aerometrex Denver Photogrammetry，然后将编辑器的相机飞行到想要创建子关卡的特定位置，然后将原点放置到这里。\n  然后打开【关卡】面板，创建一个新的 sublevel ，保存到 World 文件夹的 Sublevels 文件夹中\n  在【关卡】面板，双击刚才创建的子关卡，或者右击子关卡，选择【加载】，然后将子关卡指定到创建的 CesiumLayer 图层\n  此时，子关卡被创建，子关卡的中心位置被正确地设置在 CesiumGeoreference actor 上。To georeference the sublevel (i.e., to lock the current alignment of the sublevel with the globe)，勾选【Enabled】\n  现在应该看到一个蓝色的线框球体。球体以子关卡的中心位置为中心(即 georeference )，其半径由数组中子关卡入口的【Load Radius】属性决定。这个球体指定玩家摄像机为了加载关卡必须进入的区域。您可以根据用例的需要自由地扩展或缩小【Load Radius】。\n  第四步：创建多个子关卡 按 Ctrl + Shift + S 保存当前子关卡和持久关卡的所有内容，或者点击【保存所有】。右键单击【关卡】面板中的【子关卡】并选择【卸载】。\n当在 UE 编辑器中工作时，一次只能加载一个 georeferenced 的子关卡。如果具有不同 georeferenced 的多个子关卡同时加载并可见，它们将在编辑器中彼此重叠出现。但是在【运行】的时候没问题。\n然后重复第三步创建子关卡的流程\n注意：如果想编辑某个子关卡，一定要将其设置为当前\n","permalink":"https://874656645.github.io/posts/181-cesium-unreal-georeferenced-sublevels/","summary":"目标  Create a persistent global level Put several local sublevels within the persistent level Fill each sublevel with assets and game-logic using your typical Unreal workflow Seamlessly fly between sublevels as well as explore the persistent level Stay aware of pitfalls along the way  第一步：新建由项目组成的世界场景   新建一个空白的项目\n参考快速入门，删除【世界大纲试图】中的所有默认的 actors\n  创建持久关卡(Persistent Level)\n在内容浏览器新建 World 文件夹，把当前的空关卡命名为 Globe 并保存到此文件夹中。\n这个关卡就是 Persistent Level，它代表了整个地球。\n  世界场景设置\n打开【世界场景设置】面板，勾选【启用场景合成】\n禁用【启用场景边界检查】，在全球尺度的世界中，物体可以移动非常远的距离，禁用此设置 Unreal 就不会删除远离原点的物体","title":"Cesium4Unreal——Building Global Scenes with Georeferenced Sublevels"},{"content":"一、添加静态风格体（static meshes） 二、真实世界椭球与游戏世界坐标系 由于地球曲率的影响，距离 CesiumGeoreference 原点越远，铅垂线的方向误差越大，每一公里方向偏差大概 0.01 度。当我们从地球的一端到对面的一端时，重力的方向就转了 180 度。\n可以从以下几方面解决（由易到难）：\n 待在一个相对较小的区域内，大概100公里左右； 在地球的每个部分设置独立的子关卡，每个子关卡都有自己的 CesiumGeoreference； 使用 CesiumGlobeAnchor 为 actor 添加有限的真实世界信息参考(参见下面的“我们可以将动态对象转换为地理引用对象”); 手动扩展你的游戏对象，以充分考虑真实椭圆地球影响。  三、一般的虚幻引擎对象的位置问题 一般的虚幻引擎对象是固定在游戏世界，而不固定在真实世界的位置\n当 CesiumGeoreference 原点改变时，整个虚幻引擎世界将移动到地球上的一个新位置，包括其中的所有对象\n开始放置的地方：\n修改 CesiumGeoreference 原点后：\n四、将动态对象转换为具有地理坐标参考的对象 1. 修改对象为可移动的 2. 添加 Cesium Globe Anchor 组件 通过添加 Cesium Globe Anchor 组件，就将这个 actor 对象转换为具有地理位置参考的对象了。\n现在，我们可以更改 Cesium Globe Anchor 的原点，那么该物体将完全保持在地球上的位置。我们还可以直接指定 Longitude / Latitude / Height 或者 Earth-Centered, Earth-Fixed 的坐标，以将物体与精确的数值坐标放置在一起。\n需要注意两点：\n 只能将 Cesium Globe Anchor 组件添加到可移动的 actor 上； 并不能解决所有的问题，尤其是重力方向的问题；  ","permalink":"https://874656645.github.io/posts/180-cesium-unreal-placeobjectonglobe/","summary":"一、添加静态风格体（static meshes） 二、真实世界椭球与游戏世界坐标系 由于地球曲率的影响，距离 CesiumGeoreference 原点越远，铅垂线的方向误差越大，每一公里方向偏差大概 0.01 度。当我们从地球的一端到对面的一端时，重力的方向就转了 180 度。\n可以从以下几方面解决（由易到难）：\n 待在一个相对较小的区域内，大概100公里左右； 在地球的每个部分设置独立的子关卡，每个子关卡都有自己的 CesiumGeoreference； 使用 CesiumGlobeAnchor 为 actor 添加有限的真实世界信息参考(参见下面的“我们可以将动态对象转换为地理引用对象”); 手动扩展你的游戏对象，以充分考虑真实椭圆地球影响。  三、一般的虚幻引擎对象的位置问题 一般的虚幻引擎对象是固定在游戏世界，而不固定在真实世界的位置\n当 CesiumGeoreference 原点改变时，整个虚幻引擎世界将移动到地球上的一个新位置，包括其中的所有对象\n开始放置的地方：\n修改 CesiumGeoreference 原点后：\n四、将动态对象转换为具有地理坐标参考的对象 1. 修改对象为可移动的 2. 添加 Cesium Globe Anchor 组件 通过添加 Cesium Globe Anchor 组件，就将这个 actor 对象转换为具有地理位置参考的对象了。\n现在，我们可以更改 Cesium Globe Anchor 的原点，那么该物体将完全保持在地球上的位置。我们还可以直接指定 Longitude / Latitude / Height 或者 Earth-Centered, Earth-Fixed 的坐标，以将物体与精确的数值坐标放置在一起。\n需要注意两点：\n 只能将 Cesium Globe Anchor 组件添加到可移动的 actor 上； 并不能解决所有的问题，尤其是重力方向的问题；  ","title":"Cesium4Unreal——Place Objects On Globe"},{"content":"第一步：新建空白关卡 第二步：添加倾斜摄影数据 去网站将数据资产添加到自己的账户\n第三步：以倾斜摄影数据为中心 看起来怪怪的是因为球心坐标系与游戏的坐标系统有所不同， 虚幻编辑器的摄像机 Z 方向是向上的。在地球上（与大多数游戏不同）以地球为中心的坐标系统的向上方向取决于你在世界的位置。\n通过点击 CesiumGeoreference 的 Place Georeference Origin Here 按钮快速设置场景坐标原点到当前相机位置\n此按钮将重新定位虚幻引擎当前关卡的坐标系统，使其中心点(0,0,0)准确地位于摄像机之前的位置，并对齐虚幻引擎的坐标轴，使+X指向东方，+Y指向南方，+Z指向上方\n第四步：添加光照 CesiumSunSky 添加照明并调整时区和时间\n第五步：添加地球影像地形 修改摄影测量数据的位置\n第六步：从本地目录添加 3D Tileset 1. 在场景中添加了一个新的空白 Cesium3DTileset Actor 2. 设置本地 Tileset 文件路径 定位到添加的 tileset actor，场景和数据朝向很可能是错误的\n这是因为 CesiumGeoreference actor 的原点距离 LocalTileset actor 很远。\n3. 重新设置原点 修改 3D Tileset 数据的 Z 值\n影像地形数据 可以通过在本场发布数据服务的方式，类似这种 http://localhost:portNumber/terrainAsset\n经度和时区 摘自知乎\n经度与纬度组成了一个坐标系统，称为地理坐标系统。通过经纬度表示地球上的任何一个位置。\n国际上规定以通过英国伦敦近郊的格林尼治天文台旧址的经线作为计算经度的起点，即经度零度零分零秒，也称“本初子午线”。在它东面的为东经，共180度；在它西面的为西经，共180度。因为地球是圆的，所以东经180度和西经180度的经线是同一条经线。各国公定180度经线为“国际日期变更线”。为了避免同一地区使用两个不同的日期，国际日期变线在遇陆地时略有偏离。\n地球自西向东转，东边时间就要比西边早。规定将全球分为24时区，东西各12时区，每个时区跨经度15度，以英国格林尼治天文台旧址为零时区，两个相邻时区之间相差1小时。\n不同时区的时间按照同减异加、东加西减的原则计算。比如，北京位于东8区，纽约在西5区，北京时间要比纽约早13个小时。\n","permalink":"https://874656645.github.io/posts/179-cesium-unreal-photogrammetry/","summary":"第一步：新建空白关卡 第二步：添加倾斜摄影数据 去网站将数据资产添加到自己的账户\n第三步：以倾斜摄影数据为中心 看起来怪怪的是因为球心坐标系与游戏的坐标系统有所不同， 虚幻编辑器的摄像机 Z 方向是向上的。在地球上（与大多数游戏不同）以地球为中心的坐标系统的向上方向取决于你在世界的位置。\n通过点击 CesiumGeoreference 的 Place Georeference Origin Here 按钮快速设置场景坐标原点到当前相机位置\n此按钮将重新定位虚幻引擎当前关卡的坐标系统，使其中心点(0,0,0)准确地位于摄像机之前的位置，并对齐虚幻引擎的坐标轴，使+X指向东方，+Y指向南方，+Z指向上方\n第四步：添加光照 CesiumSunSky 添加照明并调整时区和时间\n第五步：添加地球影像地形 修改摄影测量数据的位置\n第六步：从本地目录添加 3D Tileset 1. 在场景中添加了一个新的空白 Cesium3DTileset Actor 2. 设置本地 Tileset 文件路径 定位到添加的 tileset actor，场景和数据朝向很可能是错误的\n这是因为 CesiumGeoreference actor 的原点距离 LocalTileset actor 很远。\n3. 重新设置原点 修改 3D Tileset 数据的 Z 值\n影像地形数据 可以通过在本场发布数据服务的方式，类似这种 http://localhost:portNumber/terrainAsset\n经度和时区 摘自知乎\n经度与纬度组成了一个坐标系统，称为地理坐标系统。通过经纬度表示地球上的任何一个位置。\n国际上规定以通过英国伦敦近郊的格林尼治天文台旧址的经线作为计算经度的起点，即经度零度零分零秒，也称“本初子午线”。在它东面的为东经，共180度；在它西面的为西经，共180度。因为地球是圆的，所以东经180度和西经180度的经线是同一条经线。各国公定180度经线为“国际日期变更线”。为了避免同一地区使用两个不同的日期，国际日期变线在遇陆地时略有偏离。\n地球自西向东转，东边时间就要比西边早。规定将全球分为24时区，东西各12时区，每个时区跨经度15度，以英国格林尼治天文台旧址为零时区，两个相邻时区之间相差1小时。\n不同时区的时间按照同减异加、东加西减的原则计算。比如，北京位于东8区，纽约在西5区，北京时间要比纽约早13个小时。","title":"Cesium4Unreal——Photogrammetry 倾斜摄影"},{"content":" Ureal Engin 版本 4.27  第一步：安装 Cesium 插件 Cesium for Unreal 插件地址\n启动 Epic Games Launcher，搜索 Cesium for Unreal\n第二步：新建项目关卡 1. 项目类型——\u0026gt;游戏，模板——\u0026gt;空白，选择不带初学者内容包 2. 激活 Cesium for Unreal 插件 3. 删除【世界大纲视图】中的所有内容，这样就有了一个空的关卡 保存当前关卡\n将你上面保存的关卡设置为编辑器开始地图和游戏默认地图\n第三步：Connect to Cesium ion 第四步：在场景中添加球 开始会有创建 token 的对话框，完成后，在世界大纲视图中会添加下面几个 Actor 对象\n第五步：使用 CesiumSunSky 添加照明 启用【项目设置】【扩展自动曝光设置中的默认亮度范围】\n第六步：添加 DynamicPawn  确保 DynamicPawn 自动控制玩家属性为玩家0 设置相对位置变换为 (0, 0, 0)  第七步：通过 CesiumGeoreference 修改场景的初始位置 第八步：通过 CesiumSunSky 设置光照 ","permalink":"https://874656645.github.io/posts/178-cesium-unreal-project/","summary":" Ureal Engin 版本 4.27  第一步：安装 Cesium 插件 Cesium for Unreal 插件地址\n启动 Epic Games Launcher，搜索 Cesium for Unreal\n第二步：新建项目关卡 1. 项目类型——\u0026gt;游戏，模板——\u0026gt;空白，选择不带初学者内容包 2. 激活 Cesium for Unreal 插件 3. 删除【世界大纲视图】中的所有内容，这样就有了一个空的关卡 保存当前关卡\n将你上面保存的关卡设置为编辑器开始地图和游戏默认地图\n第三步：Connect to Cesium ion 第四步：在场景中添加球 开始会有创建 token 的对话框，完成后，在世界大纲视图中会添加下面几个 Actor 对象\n第五步：使用 CesiumSunSky 添加照明 启用【项目设置】【扩展自动曝光设置中的默认亮度范围】\n第六步：添加 DynamicPawn  确保 DynamicPawn 自动控制玩家属性为玩家0 设置相对位置变换为 (0, 0, 0)  第七步：通过 CesiumGeoreference 修改场景的初始位置 第八步：通过 CesiumSunSky 设置光照 ","title":"Cesium4Unreal——Hello Cesium for UE"},{"content":"  一元折叠表达式\n ( pack op ... ) : 一元右折叠  (E op ...) 展开后： (E1 op (... op (EN-1 op EN)))   ( ... op pack ) ：一元左折叠  (... op E) 展开后： (((E1 op E2) op ...) op EN)      二元折叠表达式\n ( pack op ... op init ) ：二元右折叠  (E op ... op I) 展开后： (E1 op (... op (EN−1 op (EN op I))))   ( init op ... op pack ) ：二元左折叠  (I op ... op E) 展开后： ((((I op E1) op E2) op ...) op EN)      折叠表达式 op 支持如下二元操作符： + - * / % ^ \u0026amp; | = \u0026lt; \u0026gt; \u0026lt;\u0026lt; \u0026gt;\u0026gt; += -= *= /= %= ^= \u0026amp;= |= \u0026lt;\u0026lt;= \u0026gt;\u0026gt;= == != \u0026lt;= \u0026gt;= \u0026amp;\u0026amp; || , .* -\u0026gt;*\n  当一元折叠表达式的元素个数为 0 （空包）时，只能使用下列运算符：\n 逻辑与（\u0026amp;\u0026amp;），空包的默认值为 true 逻辑或（||），空包的默认值为 false 逗号运算符（,），空包的默认值为 void()    当二元折叠表达式中的 init 的运算符优先级高于 op 运算符时，要用 () 把 init 表达式括起来\ntemplate\u0026lt;typename ...Args\u0026gt; int sum(Args\u0026amp;\u0026amp;... args) { // return (args + ... + 1 * 2); // Error: operator with precedence below cast  return (args + ... + (1 * 2)); // OK }   一些示例：\ntemplate\u0026lt;typename ... Ts\u0026gt; auto sum(Ts ... ts){ // 右折叠（ ... 在操作符右侧）1+(2+(3+(4+5)))  // return (ts + ...);  // 左折叠（... 在操作符左侧） (((1+2)+3)+4)+5  return (... + ts); } // 匹配范围内的单个元素 template \u0026lt;typename T, typename ... Ts\u0026gt; auto matches(const T\u0026amp; range, Ts ... ts) { return (std::count(std::begin(range), std::end(range), ts) + ...); } // 检查集合中的多个插入操作是否成功 template \u0026lt;typename T, typename ... Ts\u0026gt; bool insert_all(T\u0026amp; set, Ts ... ts) { return (set.insert(ts).second \u0026amp;\u0026amp; ...); } // 检查所有参数是否在范围内 template \u0026lt;typename T, typename ... Ts\u0026gt; bool within(T min, T max, Ts ...ts) { return ((min \u0026lt;= ts \u0026amp;\u0026amp; ts \u0026lt;= max) \u0026amp;\u0026amp; ...); } // 将多个元素插入vector中 template \u0026lt;typename T, typename ... Ts\u0026gt; void insert_all(std::vector\u0026lt;T\u0026gt; \u0026amp;vec, Ts ... ts){ (vec.push_back(ts), ...); } // 打印 template\u0026lt;typename... Ts\u0026gt; void my_printf(Ts ... ts) { ((std::cout \u0026lt;\u0026lt; ts \u0026lt;\u0026lt; std::endl), ...); } int main() { int x = sum(1,2,3,4,5); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; string y = sum(string(\u0026#34;abc\u0026#34;),string(\u0026#34;def\u0026#34;),string(\u0026#34;gh\u0026#34;)); cout \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; auto z = sum(1, 2.2f, 3.3, \u0026#39;a\u0026#39;); cout \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; std::vector\u0026lt;int\u0026gt; v{1, 2, 3, 4, 5}; int c = 0; c = matches(v, 2, 5); // return 2  cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; c = matches(v, 100, 200); // return 0  cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; c = matches(\u0026#34;abcdefg\u0026#34;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;); // return 0  cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; c = matches(\u0026#34;abcdefg\u0026#34;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;f\u0026#39;); // return 3  cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; std::set\u0026lt;int\u0026gt; my_set{1, 2, 3}; insert_all(my_set, 4, 5, 6); // Returns true  for_each(my_set.begin(), my_set.end(), [](const auto \u0026amp;t){cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34; \u0026#34;;}); cout \u0026lt;\u0026lt; endl; insert_all(my_set, 7, 2, 8); // Returns false, because the 2 collides  // 由于短路，8并没有被插入  for_each(my_set.begin(), my_set.end(), [](const auto \u0026amp;t){cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34; \u0026#34;;}); cout \u0026lt;\u0026lt; endl; bool b = false; b = within(10, 20, 1, 15, 30); // --\u0026gt; false  cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; b = within(10, 20, 11, 12, 13); // --\u0026gt; true  cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; b = within(5.0, 5.5, 5.1, 5.2, 5.3); // --\u0026gt; true  cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; std::string aaa {\u0026#34;aaa\u0026#34;}; std::string bcd {\u0026#34;bcd\u0026#34;}; std::string def {\u0026#34;def\u0026#34;}; std::string zzz {\u0026#34;zzz\u0026#34;}; b = within(aaa, zzz, bcd, def); // --\u0026gt; true  cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; b = within(aaa, def, bcd, zzz); // --\u0026gt; false  cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; std::vector\u0026lt;int\u0026gt; my_vec{1, 2, 3}; insert_all(my_vec, 4, 5, 6); for_each(my_vec.begin(), my_vec.end(), [](const auto \u0026amp;t){cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34; \u0026#34;;}); cout \u0026lt;\u0026lt; endl; return 0; } 输出：\n15 abcdefgh 103.5 2 0 0 3 1 2 3 4 5 6 1 2 3 4 5 6 7 false true true true false 1 2 3 4 5 6   参考：\nfold expression\n","permalink":"https://874656645.github.io/posts/177-c++17-%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"一元折叠表达式\n ( pack op ... ) : 一元右折叠  (E op ...) 展开后： (E1 op (... op (EN-1 op EN)))   ( ... op pack ) ：一元左折叠  (... op E) 展开后： (((E1 op E2) op ...) op EN)      二元折叠表达式\n ( pack op ... op init ) ：二元右折叠  (E op ... op I) 展开后： (E1 op (... op (EN−1 op (EN op I))))   ( init op .","title":"C++17 折叠表达式"},{"content":"  任意个数、任意类别的模板参数\ntemplate\u0026lt;typename... Ts\u0026gt; class Magic; // 计算参数的个数 template\u0026lt;typename... Ts\u0026gt; void magic(Ts... args) { std::cout \u0026lt;\u0026lt; sizeof...(args) \u0026lt;\u0026lt; std::endl; }   递归解包：\n C++17 之前  template\u0026lt;typename T0\u0026gt; void my_printf(T0 value) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } template\u0026lt;typename T, typename... Ts\u0026gt; void my_printf(T value, Ts... args) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; my_printf(args...); } int main() { my_printf(1, 2.2, \u0026#34;abc\u0026#34;, \u0026#39;a\u0026#39;); return 0; }  C++17 变参模板展开：  template\u0026lt;typename T, typename... Ts\u0026gt; void my_printf(T t, Ts... ts) { std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; std::endl; if constexpr (sizeof...(ts) \u0026gt; 0) my_printf(ts...); } int main() { my_printf(1, 1.2f, 3.4, \u0026#39;a\u0026#39;); }   C++17 之前初始化列表展开：\ntemplate \u0026lt;typename... Ts\u0026gt; void my_printf1(Ts... msg) { // 利用数组初始化  using var = int[]; (void)var{0, (std::cout \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl, 0)...}; } template \u0026lt;typename... Ts\u0026gt; void my_printf2(Ts... msg) { // 利用 initializer_list  (void)initializer_list\u0026lt;int\u0026gt;{(std::cout \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl, 0)...}; }   C++17 折叠表达式：\ntemplate\u0026lt;typename... Ts\u0026gt; void my_printf(Ts ... ts) { ((std::cout \u0026lt;\u0026lt; ts \u0026lt;\u0026lt; std::endl), ...); }   ","permalink":"https://874656645.github.io/posts/176-c++17-%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/","summary":"任意个数、任意类别的模板参数\ntemplate\u0026lt;typename... Ts\u0026gt; class Magic; // 计算参数的个数 template\u0026lt;typename... Ts\u0026gt; void magic(Ts... args) { std::cout \u0026lt;\u0026lt; sizeof...(args) \u0026lt;\u0026lt; std::endl; }   递归解包：\n C++17 之前  template\u0026lt;typename T0\u0026gt; void my_printf(T0 value) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } template\u0026lt;typename T, typename... Ts\u0026gt; void my_printf(T value, Ts... args) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; my_printf(args...); } int main() { my_printf(1, 2.2, \u0026#34;abc\u0026#34;, \u0026#39;a\u0026#39;); return 0; }  C++17 变参模板展开：  template\u0026lt;typename T, typename.","title":"C++17 变长参数模板"},{"content":"注意：使用结构化绑定时，就不能再使用 std::tie 创建虚拟变量了，所以我们不得不绑定所有值到命名过的变量上。对部分成员进行绑定的做法是高效的，因为编译器可以很容易的对未绑定的变量进行优化\nstd::pair\u0026lt;int,int\u0026gt; divide_remainder(int dividend, int divisor){ int f = dividend / divisor; int s = dividend % divisor; return {f, s}; } int main() { auto [dividend, remainder] = divide_remainder(16, 3); std::cout \u0026lt;\u0026lt; \u0026#34;16 / 3 is \u0026#34; \u0026lt;\u0026lt; dividend \u0026lt;\u0026lt; \u0026#34; with a remainder of \u0026#34; \u0026lt;\u0026lt; remainder \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 之前的写法  int remainder1; std::tie(std::ignore, remainder1) = divide_remainder(16, 5); std::cout \u0026lt;\u0026lt; \u0026#34;16 % 5 is \u0026#34; \u0026lt;\u0026lt; remainder1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","permalink":"https://874656645.github.io/posts/175-c++17-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E6%9D%A5%E8%A7%A3%E5%8C%85%E7%BB%91%E5%AE%9A%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/","summary":"注意：使用结构化绑定时，就不能再使用 std::tie 创建虚拟变量了，所以我们不得不绑定所有值到命名过的变量上。对部分成员进行绑定的做法是高效的，因为编译器可以很容易的对未绑定的变量进行优化\nstd::pair\u0026lt;int,int\u0026gt; divide_remainder(int dividend, int divisor){ int f = dividend / divisor; int s = dividend % divisor; return {f, s}; } int main() { auto [dividend, remainder] = divide_remainder(16, 3); std::cout \u0026lt;\u0026lt; \u0026#34;16 / 3 is \u0026#34; \u0026lt;\u0026lt; dividend \u0026lt;\u0026lt; \u0026#34; with a remainder of \u0026#34; \u0026lt;\u0026lt; remainder \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 之前的写法  int remainder1; std::tie(std::ignore, remainder1) = divide_remainder(16, 5); std::cout \u0026lt;\u0026lt; \u0026#34;16 % 5 is \u0026#34; \u0026lt;\u0026lt; remainder1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","title":"C++17 使用结构化绑定来解包绑定的返回值"},{"content":" ( expression-list )：优先调用非聚合初始化，且会存在隐式转换 = expression： { initializer-list }：如果有聚合初始化（initializer_list\u0026lt;\u0026gt;），就调用聚合初始化，没有的话就调用符合条件的非聚合初始化 = { initializer-list }：同上 使用 auto 声明的变量括号初始化，只允许一个参数的情况 {} 与 () 调用构造函数初始化的方式，不同点在于 {} 没有类型的隐式转换，比如 int x(1.2); 和 int x = 1.2; 通过隐式的对浮点值进行向下取整，然后将其转换为整型，从而将 x 的值初始化为 1。相反的， int x{1.2}; 将会遇到编译错误，初始化列表中的初始值，需要与变量声明的类型完全匹配。  测试代码一：\n// #define AGGREGATE_INIT class Test{ public: Test(int a, float b, char* c){ cout \u0026lt;\u0026lt; \u0026#34;int float char* initialize...\u0026#34; \u0026lt;\u0026lt; endl; } Test(int a, int b, int c){ cout \u0026lt;\u0026lt; \u0026#34;int int int initialize...\u0026#34; \u0026lt;\u0026lt; endl; } Test(int a, double b, float c){ cout \u0026lt;\u0026lt; \u0026#34;int double float initialize...\u0026#34; \u0026lt;\u0026lt; endl; } #ifdef AGGREGATE_INIT  Test(initializer_list\u0026lt;int\u0026gt; ls){ cout \u0026lt;\u0026lt; \u0026#34;initializer_list initialize...\u0026#34; \u0026lt;\u0026lt; endl; } #endif }; int main() { char cc[] = \u0026#34;abc\u0026#34;; Test t1{10, 1.2, cc}; // int float char* initialize...  Test t2{1, 2, 3}; // initializer_list initialize...  t2 = {4, 5, 6}; // initializer_list initialize...  // 如果存在聚合初始化构造会报错，此时只会匹配聚合初始化  // t2 = {4, 4.4, 4.f}; // error: narrowing conversion of ‘4.4000000000000004e+0’ from ‘double’ to ‘int’ inside { } [-Wnarrowing]  // Test t3{4, 4.4, 4.f}; // error: narrowing conversion of ‘4.4000000000000004e+0’ from ‘double’ to ‘int’ inside { } [-Wnarrowing]  // 如果不存在聚合初始化，会找匹配的非聚合初始化  t2 = {4, 4.4, 4.f}; // int double float initialize...  Test t3{4, 4.4, 4.f}; // int double float initialize...  Test t4(4, 4.4, 4.f); // int double float initialize...  t4 = {1, 2, cc}; // int float char* initialize...  return 0; } 测试代码二：\ntemplate \u0026lt;typename T1, typename T2, typename T3\u0026gt; class my_wrapper { T1 t1; T2 t2; T3 t3; public: explicit my_wrapper(T1 t1_, T2 t2_, T3 t3_) : t1{t1_}, t2{t2_}, t3{t3_} { cout \u0026lt;\u0026lt; t1_ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; t2_ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; t3_ \u0026lt;\u0026lt; endl; } }; // 工厂函数 template \u0026lt;typename T1, typename T2, typename T3\u0026gt; my_wrapper\u0026lt;T1, T2, T3\u0026gt; make_wrapper(T1 t1, T2 t2, T3 t3) { return my_wrapper{t1, t2, t3}; } int main() { my_wrapper wrapper {123, 1.23, \u0026#34;abc\u0026#34;}; // my_wrapper\u0026lt;int, double, const char *\u0026gt; wrapper {123, 1.23, \u0026#34;abc\u0026#34;}; // 之前的写法  auto wrapper = make_wrapper(123, 1.23, \u0026#34;abc\u0026#34;); // auto wrapper = make_wrapper\u0026lt;int, double, const char *\u0026gt;(123, 1.23, \u0026#34;abc\u0026#34;); // 之前的写法  auto x{3}; // auto y{1,2}; // error: direct-list-initialization of ‘auto’ requires exactly one element [-fpermissive]  auto z = {1,2}; return 0; } 参考：\nInitialization\n","permalink":"https://874656645.github.io/posts/174-c++17-%E5%A4%A7%E6%8B%AC%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%8C%96/","summary":"( expression-list )：优先调用非聚合初始化，且会存在隐式转换 = expression： { initializer-list }：如果有聚合初始化（initializer_list\u0026lt;\u0026gt;），就调用聚合初始化，没有的话就调用符合条件的非聚合初始化 = { initializer-list }：同上 使用 auto 声明的变量括号初始化，只允许一个参数的情况 {} 与 () 调用构造函数初始化的方式，不同点在于 {} 没有类型的隐式转换，比如 int x(1.2); 和 int x = 1.2; 通过隐式的对浮点值进行向下取整，然后将其转换为整型，从而将 x 的值初始化为 1。相反的， int x{1.2}; 将会遇到编译错误，初始化列表中的初始值，需要与变量声明的类型完全匹配。  测试代码一：\n// #define AGGREGATE_INIT class Test{ public: Test(int a, float b, char* c){ cout \u0026lt;\u0026lt; \u0026#34;int float char* initialize...\u0026#34; \u0026lt;\u0026lt; endl; } Test(int a, int b, int c){ cout \u0026lt;\u0026lt; \u0026#34;int int int initialize.","title":"C++17 大括号初始化"},{"content":"它能处理不同模板类型的特化，因为它可以在完全不同的代码中，选取相应的片段，依据这些片段的类型对模板进行特化\n比如我们有一个简单的类，它的成员函数 add ，支持对 U 类型值与 T 类型值的加法\ntemplate \u0026lt;typename T\u0026gt; class addable { T val; public: addable(T v) : val{v} {} template \u0026lt;typename U\u0026gt; T add(U x) const { return val + x; } }; 假设类型 T 是 std::vector\u0026lt;something\u0026gt; ，而类型 U 是 int。这里就有问题了，为整个 vector 添加整数是为 了什么呢？应该是对 vector 中的每个元素加上一个整型数。实现这个功能就需要在循环中进行\ntemplate \u0026lt;typename U\u0026gt; T add(U x) { auto copy (val); // Get a copy of the vector member  for (auto \u0026amp;n : copy) { n += x; } return copy; } 把两种情况结合在一起：\ntemplate \u0026lt;typename U\u0026gt; T add(U x) const{ if constexpr(std::is_same\u0026lt;T, std::vector\u0026lt;U\u0026gt;\u0026gt;::value){ auto copy(val); for (auto \u0026amp;n : copy){ n += x; } return copy; } else { return val + x; } } 使用 constexpr-if 的代码在编译完成后，程序的这一部分其实就不会有分支存在。有种方式类似于 constexpr-if，那就是 #if-#else 的预编译方式进行宏替换，不过这种方式在代码的构成方面不是那么优雅。\n在一个 constexpr-if-else 代码块中，可以有多个条件(注意：a 和 b 也可以依赖于模板参数，并不需要其为编译时常量)：\nif constexpr(a){ // do something } else if constexpr(b){ // do something else } else { // do something completely different } 之前的写法：\ntemplate \u0026lt;typename T\u0026gt; class addable{ T val; public: addable(T v):val{v}{} template \u0026lt;typename U\u0026gt; std::enable_if_t\u0026lt;!std::is_same\u0026lt;T, std::vector\u0026lt;U\u0026gt;\u0026gt;::value, T\u0026gt; add(U x) const { return val + x; } template \u0026lt;typename U\u0026gt; std::enable_if_t\u0026lt;std::is_same\u0026lt;T, std::vector\u0026lt;U\u0026gt;\u0026gt;::value, std::vector\u0026lt;U\u0026gt;\u0026gt; add (U x) const{ auto copy(val); for (auto \u0026amp;n: copy){ n += x; } return copy; } }; 当编译器看到具有相同名称的不同模板函数并不得不选择其中一个时，一个重要的原则就起作用了：替换失败不是错误(SFINAE, Substitution Failure is not An Error)。这个例子中，就意味着如果函数的返回值来源一个错误的模板表示，无法推断得出，这时编译器不会将这种情况视为错误(和 std::enable_if 中的条件为 false 时的状态一样)。这样编译器就会去找函数的另外的实现。\n测试：\nint main() { auto t1 = addable\u0026lt;int\u0026gt; {1}.add(2); // is 3  cout \u0026lt;\u0026lt; t1 \u0026lt;\u0026lt; endl; auto t2 = addable\u0026lt;float\u0026gt; {1.f}.add(2); // is 3.0  cout \u0026lt;\u0026lt; t2 \u0026lt;\u0026lt; endl; auto t3 = addable\u0026lt;std::string\u0026gt; {\u0026#34;aa\u0026#34;}.add(\u0026#34;bb\u0026#34;); // is \u0026#34;aabb\u0026#34;  cout \u0026lt;\u0026lt; t3 \u0026lt;\u0026lt; endl; std::vector\u0026lt;int\u0026gt; v{1, 2, 3}; auto t4 = addable\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; {v}.add(10); // is std::vector\u0026lt;int\u0026gt; {11, 12, 13}  for_each(t4.begin(), t4.end(), [](const auto \u0026amp;i){cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;;}); cout \u0026lt;\u0026lt; endl; std::vector\u0026lt;std::string\u0026gt; sv{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; auto t5 = addable\u0026lt;std::vector\u0026lt;std::string\u0026gt;\u0026gt; {sv}.add(std::string{\u0026#34;z\u0026#34;}); // is {\u0026#34;az\u0026#34;, \u0026#34;bz\u0026#34;, \u0026#34;cz\u0026#34;}  for_each(t5.begin(), t5.end(), [](const auto \u0026amp;i){cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;;}); cout \u0026lt;\u0026lt; endl; return 0; } 输出：\n3 3 aabb 11 12 13 az bz cz ","permalink":"https://874656645.github.io/posts/173-c++17-constexpr-if-%E7%AE%80%E5%8C%96%E7%BC%96%E8%AF%91/","summary":"它能处理不同模板类型的特化，因为它可以在完全不同的代码中，选取相应的片段，依据这些片段的类型对模板进行特化\n比如我们有一个简单的类，它的成员函数 add ，支持对 U 类型值与 T 类型值的加法\ntemplate \u0026lt;typename T\u0026gt; class addable { T val; public: addable(T v) : val{v} {} template \u0026lt;typename U\u0026gt; T add(U x) const { return val + x; } }; 假设类型 T 是 std::vector\u0026lt;something\u0026gt; ，而类型 U 是 int。这里就有问题了，为整个 vector 添加整数是为 了什么呢？应该是对 vector 中的每个元素加上一个整型数。实现这个功能就需要在循环中进行\ntemplate \u0026lt;typename U\u0026gt; T add(U x) { auto copy (val); // Get a copy of the vector member  for (auto \u0026amp;n : copy) { n += x; } return copy; } 把两种情况结合在一起：","title":"C++17 constexpr-if 简化编译"},{"content":" 函数指针和成员函数指针无法用于 const_cast const_cast 使得指向非 const 类型的 const 引用或指针能够被修改 通过 const_cast 修改 const 对象是未定义的行为  struct type { int i; type(): i(3) {} void f(int v) const { // this-\u0026gt;i = v; // compile error: this is a pointer to const  const_cast\u0026lt;type*\u0026gt;(this)-\u0026gt;i = v; // OK as long as the type object isn\u0026#39;t const  } }; int main() { int i = 3; // i is not declared const  const int\u0026amp; rci = i; // const reference  const_cast\u0026lt;int\u0026amp;\u0026gt;(rci) = 4; // OK: modifies i  std::cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; const int* pci = \u0026amp;i; // *pci = 5; // error: assignment of read-only location ‘* pci’  *const_cast\u0026lt;int*\u0026gt;(pci) = 5; // OK: modifies i  std::cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; type t; // if this was const type t, then t.f(4) would be undefined behavior  t.f(4); std::cout \u0026lt;\u0026lt; \u0026#34;type::i = \u0026#34; \u0026lt;\u0026lt; t.i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; const int j = 3; // j is declared const  int* pj = const_cast\u0026lt;int*\u0026gt;(\u0026amp;j); // *pj = 4; // undefined behavior  const int\u0026amp; r2 = j; // 绑定到 const 对象的 const 引用  const_cast\u0026lt;int\u0026amp;\u0026gt;(r2) = 2; // 未定义行为：试图修改 const 对象 j  void (type::*pmf)(int) const = \u0026amp;type::f; // pointer to member function  // const_cast\u0026lt;void(type::*)(int)\u0026gt;(pmf); // compile error: const_cast does  // not work on function pointers  (t.*pmf)(40); } 输出：\ni = 4 i = 5 type::i = 4 type::i = 40 参考：\nconst_cast conversion\n","permalink":"https://874656645.github.io/posts/172-const_cast/","summary":"函数指针和成员函数指针无法用于 const_cast const_cast 使得指向非 const 类型的 const 引用或指针能够被修改 通过 const_cast 修改 const 对象是未定义的行为  struct type { int i; type(): i(3) {} void f(int v) const { // this-\u0026gt;i = v; // compile error: this is a pointer to const  const_cast\u0026lt;type*\u0026gt;(this)-\u0026gt;i = v; // OK as long as the type object isn\u0026#39;t const  } }; int main() { int i = 3; // i is not declared const  const int\u0026amp; rci = i; // const reference  const_cast\u0026lt;int\u0026amp;\u0026gt;(rci) = 4; // OK: modifies i  std::cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; const int* pci = \u0026amp;i; // *pci = 5; // error: assignment of read-only location ‘* pci’  *const_cast\u0026lt;int*\u0026gt;(pci) = 5; // OK: modifies i  std::cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; type t; // if this was const type t, then t.","title":"const_cast"},{"content":"一、转换函数 Conversion Functions(operators) 在 C++ 中，使用类作为具体类型，对现实世界对象进行抽象。有时，需要隐式地将一种具体类型转换为另一种具体类型或 C++ 内建数据类型。转换函数在这种情况下发挥着重要作用。它类似于类中的运算符重载函数。\n转换函数写法：operator typeName();\n 转换函数必须是类的成员函数 转换函数不能指定返回值类型 转换函数不能有形参  例如下面的类：\nclass Fraction { public: Fraction(int numerator, int denominator = 1) :m_numerator(numerator), m_denominator(denominator) { } //转换函数  operator double() const { return (double)m_numerator / m_denominator; } private: int m_numerator; //分子  int m_denominator; //分母 }; int main() { Fraction f(8,5); double d = 4 + f; cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; return 0; } 输出：\n5.6 注意： 编译器将在基于类型调用适当的功能时具有更多控制，而不是我们所期望的。所以使用类或对象的特定成员函数来执行此类转换才是良好的习惯。\n二、构造函数隐式转换 non-explicit-one-argument constructor class Fraction { public: Fraction(int numerator, int denominator = 1) :m_numerator(numerator), m_denominator(denominator) { } Fraction operator + (const Fraction\u0026amp; f) { return Fraction(m_numerator * f.m_denominator + f.m_numerator * m_denominator, m_denominator * f.m_denominator); } //转换函数  operator string() const { return to_string(m_numerator) + \u0026#34;/\u0026#34; + to_string(m_denominator); } private: int m_numerator; //分子  int m_denominator; //分母 }; int main() { Fraction f(8,5); Fraction ff = f + 4; // 调用构造函数，将 4 转换成 Fraction(4, 1)，然后再调用 operator +  cout \u0026lt;\u0026lt; (string)ff \u0026lt;\u0026lt; endl; return 0; } 输出：\n28/5 三、转换函数与构造函数隐式转换（ambiguous） class Fraction { public: Fraction(int numerator, int denominator = 1) :m_numerator(numerator), m_denominator(denominator) { } Fraction operator + (const Fraction\u0026amp; f) { return Fraction(m_numerator * f.m_denominator + f.m_numerator * m_denominator, m_denominator * f.m_denominator); } //转换函数  operator double() const { return (double)m_numerator / m_denominator; } operator string() const { return to_string(m_numerator) + \u0026#34;/\u0026#34; + to_string(m_denominator); } private: int m_numerator; //分子  int m_denominator; //分母 }; int main() { Fraction f(8,5); Fraction ff = f + 4; // error: ambiguous overload for ‘operator+’ (operand types are ‘Fraction’ and ‘int’)  cout \u0026lt;\u0026lt; ff \u0026lt;\u0026lt; endl; return 0; } 输出：\nmain.cpp:54:21: error: ambiguous overload for ‘operator+’ (operand types are ‘Fraction’ and ‘int’) 54 | Fraction ff = f + 4; | ~ ^ ~ | | | | | int | Fraction main.cpp:54:21: note: candidate: ‘operator+(double, int)’ 54 | Fraction ff = f + 4; | ~~^~~ main.cpp:21:14: note: candidate: ‘Fraction Fraction::operator+(const Fraction\u0026amp;)’ 21 | Fraction operator + (const Fraction\u0026amp; f) { | ^~~~~~~~  可以将 4 隐式的转换为 Fraction 对象，然后调用 + 操作符重载 也可以将 f 转换为 double，再与 4 相加，最后再将 double 隐式转换为 Fraction 对象  四、禁止构造函数隐式转换 class Fraction { public: explicit Fraction(int numerator, int denominator = 1) :m_numerator(numerator), m_denominator(denominator) { } Fraction operator + (const Fraction\u0026amp; f) { return Fraction(m_numerator * f.m_denominator + f.m_numerator * m_denominator, m_denominator * f.m_denominator); } //转换函数  operator string() const { return to_string(m_numerator) + \u0026#34;/\u0026#34; + to_string(m_denominator); } operator double() const { return (double)m_numerator / m_denominator; } private: int m_numerator; //分子  int m_denominator; //分母 }; int main() { Fraction f(8,5); // Fraction ff = f + 4; // error: conversion from ‘double’ to non-scalar type ‘Fraction’ requested  double ff = f + 4; // OK\t5.6  cout \u0026lt;\u0026lt; ff \u0026lt;\u0026lt; endl; return 0; }  由于在构造函数前面增加了 explicit 关键字，所以不能将 4 转换成 Fraction 类型； 也不能先将 f 转换成 double 类型，与 4 相加，再将 double 隐式转换成 Fraction 类型，所以会报错。  参考：\n C++转换函数 （conversion function）与 C++中explicit关键字 C++转换函数 Conversion Operators in C++  ","permalink":"https://874656645.github.io/posts/171-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/","summary":"一、转换函数 Conversion Functions(operators) 在 C++ 中，使用类作为具体类型，对现实世界对象进行抽象。有时，需要隐式地将一种具体类型转换为另一种具体类型或 C++ 内建数据类型。转换函数在这种情况下发挥着重要作用。它类似于类中的运算符重载函数。\n转换函数写法：operator typeName();\n 转换函数必须是类的成员函数 转换函数不能指定返回值类型 转换函数不能有形参  例如下面的类：\nclass Fraction { public: Fraction(int numerator, int denominator = 1) :m_numerator(numerator), m_denominator(denominator) { } //转换函数  operator double() const { return (double)m_numerator / m_denominator; } private: int m_numerator; //分子  int m_denominator; //分母 }; int main() { Fraction f(8,5); double d = 4 + f; cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"类型转换函数"},{"content":" 在编译过程中就已经把值计算出来，会做类型检查； define 是在预编译过程中进行简单的文本替换，不会做类型检查； 在对象声明时或非静态成员函数中使用 constexpr 关键字(C++ 14)暗示这个对象或非静态成员函数是 const 的； 在函数或静态数据成员(C++ 17)声明中使用的 constexpr 关键字意味着内联； C++11 中 constexpr 函数可以使用递归，?: 三目运算符，从 C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句； constexpr 修饰的是函数参数，而不是函数返回值，函数返回值是可以被改变的    constexpr 修饰变量必须满足以下要求：\n 它的类型必须是一个LiteralType 它必须立即初始化 其初始化的完整表达式，包括所有隐式转换、构造函数调用等，必须是 constexpr 它必须有 constexpr 析构    constexpr 修饰函数必须满足以下要求：\n 它不能是 virtual 修饰的(直到 C++20) 它不能是 coroutine 协程(直到 C++20) 它的返回类型（如果有的话）必须是 LiteralType 所有参数必须是 LiteralType    class Test{ public: int x = 10; }; int main() { constexpr Test t; // const  cout \u0026lt;\u0026lt; typeid(t.x).name() \u0026lt;\u0026lt; endl; // i  t.x = 100; // error: assignment of member ‘Test::x’ in read-only object  return 0; } static int x = 20; constexpr int\u0026amp; f(int\u0026amp; x) { x = x * x; // 此时 x 是 400 \treturn x; } int main() { f(x) = 10; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; // 10  return 0; } ","permalink":"https://874656645.github.io/posts/170-c++11-constexpr/","summary":"在编译过程中就已经把值计算出来，会做类型检查； define 是在预编译过程中进行简单的文本替换，不会做类型检查； 在对象声明时或非静态成员函数中使用 constexpr 关键字(C++ 14)暗示这个对象或非静态成员函数是 const 的； 在函数或静态数据成员(C++ 17)声明中使用的 constexpr 关键字意味着内联； C++11 中 constexpr 函数可以使用递归，?: 三目运算符，从 C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句； constexpr 修饰的是函数参数，而不是函数返回值，函数返回值是可以被改变的    constexpr 修饰变量必须满足以下要求：\n 它的类型必须是一个LiteralType 它必须立即初始化 其初始化的完整表达式，包括所有隐式转换、构造函数调用等，必须是 constexpr 它必须有 constexpr 析构    constexpr 修饰函数必须满足以下要求：\n 它不能是 virtual 修饰的(直到 C++20) 它不能是 coroutine 协程(直到 C++20) 它的返回类型（如果有的话）必须是 LiteralType 所有参数必须是 LiteralType    class Test{ public: int x = 10; }; int main() { constexpr Test t; // const  cout \u0026lt;\u0026lt; typeid(t.","title":"C++11 constexpr"},{"content":" 包装指定调用标签（如 double(double) 返回值类型为 double，参数也是 double 类型）的函数； 替代以前的函数指针、函数对象和 lambda 表达式； 类模板 std::function 是一个通用的多态函数包装器。 function 的实例可以存储、复制和调用任何 CopyConstructible Callable 目标：  函数 lambda 表达式 std::bind 表达式 函数对象 指向成员函数的指针 指向成员属性的指针   可以减少生成的模板函数实例化代码的数量，缩小可执行文件的大小；  参考：\nstd::function\n","permalink":"https://874656645.github.io/posts/169-c++11-function/","summary":"包装指定调用标签（如 double(double) 返回值类型为 double，参数也是 double 类型）的函数； 替代以前的函数指针、函数对象和 lambda 表达式； 类模板 std::function 是一个通用的多态函数包装器。 function 的实例可以存储、复制和调用任何 CopyConstructible Callable 目标：  函数 lambda 表达式 std::bind 表达式 函数对象 指向成员函数的指针 指向成员属性的指针   可以减少生成的模板函数实例化代码的数量，缩小可执行文件的大小；  参考：\nstd::function","title":"C++11 std::function"},{"content":"","permalink":"https://874656645.github.io/posts/168-c++11-mem_fn/","summary":"","title":"C++11 std::mem_fn"},{"content":"  创建一个对象或函数的引用，对象必须是 可复制(CopyConstructible)、可赋值(CopyAssignable) 的。\n  它经常被用作在标准容器(如 std::vector )中存储引用的机制，而标准容器通常不能保存引用。\n  辅助函数 std::ref 与 std::cref 常用于生成 std::reference_wrapper 对象。\n  std::reference_wrapper 也用于按引用传递参数给 std::bind 或 std::thread 的构造函数。\n  能隐式转换成 T\u0026amp;。\n    在 vector 中存储引用类型：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;list\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;random\u0026gt;#include \u0026lt;functional\u0026gt;#include \u0026lt;algorithm\u0026gt; int main() { std::list\u0026lt;int\u0026gt; l(10); std::iota(l.begin(), l.end(), -4); // 从 -4 开始，逐个 +1  std::vector\u0026lt;std::reference_wrapper\u0026lt;int\u0026gt;\u0026gt; v(l.begin(), l.end()); // 不能在 list 上用 shuffle （要求随机访问），但能在 vector 上使用它  std::shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()}); std::cout \u0026lt;\u0026lt; \u0026#34;Contents of the list: \u0026#34;; for (int n : l) { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Contents of the list, as seen through a shuffled vector: \u0026#34;; for (int i : v) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Doubling the values in the initial list...\\n\u0026#34;; for (int\u0026amp; i : l) { i *= 2; } std::cout \u0026lt;\u0026lt; \u0026#34;Contents of the list, after doubling: \u0026#34;; for (int i : l) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Contents of the list, as seen through a shuffled vector: \u0026#34;; for (int i : v) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 输出：\nContents of the list: -4 -3 -2 -1 0 1 2 3 4 5 Contents of the list, as seen through a shuffled vector: -3 2 0 3 -1 4 -4 1 5 -2 Doubling the values in the initial list... Contents of the list, after doubling: -8 -6 -4 -2 0 2 4 6 8 10 Contents of the list, as seen through a shuffled vector: -6 4 0 6 -2 8 -8 2 10 -4   声明引用类型的数组\nint main() { int x = 5, y = 7, z = 8; std::reference_wrapper\u0026lt;int\u0026gt; arr[] {x, y, z}; // int\u0026amp; arr[]{x,y,z}; // error: declaration of ‘arr’ as array of references  for (auto a: arr) std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; std::cout \u0026lt;\u0026lt; std::endl; x = 50; std::cout \u0026lt;\u0026lt; \u0026#34;-----------\\n\u0026#34;; for (auto a: arr) std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 输出：\n5 7 8 ----------- 50 7 8   与 T\u0026amp; 和 T 隐式转换\nvoid func(int\u0026amp; a, int b){ cout \u0026lt;\u0026lt; \u0026#34;in func: a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; a++; b++; } int main() { int a = 10, b = 20; cout \u0026lt;\u0026lt; \u0026#34;in main: a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; func(ref(a), ref(b)); // 虽然传递的是 b 的引用，但函数形参不是引用类型  // ，所以函数内的 b 是一个拷贝  cout \u0026lt;\u0026lt; \u0026#34;in main: a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 输出：\nin main: a = 10, b = 20 in func: a = 10, b = 20 in main: a = 11, b = 20   T\u0026amp; 与 reference_wrapper 区别\nint main() { cout \u0026lt;\u0026lt; boolalpha; int x = 5, y = 7; reference_wrapper\u0026lt;int\u0026gt; r = x; // or auto r = ref(x);  cout \u0026lt;\u0026lt; is_same\u0026lt;int\u0026amp;, decltype(r.get())\u0026gt;::value \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // true  cout \u0026lt;\u0026lt; is_same\u0026lt;int\u0026amp;, decltype(r)\u0026gt;::value \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // false  cout \u0026lt;\u0026lt; (\u0026amp;x == \u0026amp;r.get()) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // true  r = y; cout \u0026lt;\u0026lt; (\u0026amp;y == \u0026amp;r.get()) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // true  r.get()=70; cout \u0026lt;\u0026lt; y; // 70  return 0; }   包裹函数指针\n个人感觉，可以替代 函数指针 了，类似 std::function\nvoid func(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt;\u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } void func1(int i) { cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } void func2(const reference_wrapper\u0026lt;void(int,int)\u0026gt;\u0026amp; f){ cout \u0026lt;\u0026lt; \u0026#34;in func2 invoke f:\u0026#34; \u0026lt;\u0026lt; endl; f(10, 20); } int main() { // 包裹函数指针  int x = 5, y = 7; reference_wrapper\u0026lt;void(int,int)\u0026gt; f0 = func; f0(x, y); // a = 5,b = 7  func2(f0); // in func2 invoke f:  // a = 10,b = 20  auto f1 = std::ref(func); f1(5,7); // a = 5,b = 7  using Examp = reference_wrapper\u0026lt;void(int)\u0026gt;; Examp f = func1; f(10); // i = 10  using ExampFc = function\u0026lt;void(int)\u0026gt;; ExampFc ff = func1; ff(20); // i = 20  return 0; }   参考：\n std::reference_wrapper C++ Difference between std::ref(T) and T\u0026amp;? C++11中std::reference_wrapper的理解  ","permalink":"https://874656645.github.io/posts/167-c++11-reference_wrapper/","summary":"创建一个对象或函数的引用，对象必须是 可复制(CopyConstructible)、可赋值(CopyAssignable) 的。\n  它经常被用作在标准容器(如 std::vector )中存储引用的机制，而标准容器通常不能保存引用。\n  辅助函数 std::ref 与 std::cref 常用于生成 std::reference_wrapper 对象。\n  std::reference_wrapper 也用于按引用传递参数给 std::bind 或 std::thread 的构造函数。\n  能隐式转换成 T\u0026amp;。\n    在 vector 中存储引用类型：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;list\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;random\u0026gt;#include \u0026lt;functional\u0026gt;#include \u0026lt;algorithm\u0026gt; int main() { std::list\u0026lt;int\u0026gt; l(10); std::iota(l.begin(), l.end(), -4); // 从 -4 开始，逐个 +1  std::vector\u0026lt;std::reference_wrapper\u0026lt;int\u0026gt;\u0026gt; v(l.begin(), l.end()); // 不能在 list 上用 shuffle （要求随机访问），但能在 vector 上使用它  std::shuffle(v.","title":"C++11 std::reference_wrapper"},{"content":"函数模板 ref 与 cref 是生成 std::reference_wrapper 类型对象的帮助函数，主要是与 std::bind 一起使用，默认情况下，std::bind 无法使用变量引用传递，即使原来的函数形参是引用类型的\nvoid f(int\u0026amp; n1, int\u0026amp; n2, const int\u0026amp; n3) { std::cout \u0026lt;\u0026lt; \u0026#34;In function: \u0026#34; \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n3 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; ++n1; // 增加存储于函数对象的 n1 副本  ++n2; // 增加 main() 的 n2  // ++n3; // 编译错误 error: increment of read-only reference ‘n3’ } int main() { int n1 = 1, n2 = 2, n3 = 3; // 函数对象 bound_f  // 默认会将此时变量值的副本做为函数对象的参数（函数参数特例化）  std::function\u0026lt;void()\u0026gt; bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3)); n1 = 10; n2 = 11; n3 = 12; std::cout \u0026lt;\u0026lt; \u0026#34;Before function: \u0026#34; \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n3 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; bound_f(); std::cout \u0026lt;\u0026lt; \u0026#34;After function: \u0026#34; \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n3 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 输出：\nBefore function: 10 11 12 In function: 1 11 12 After function: 10 12 12 参考：\n std::bind C++ std::bind  ","permalink":"https://874656645.github.io/posts/166-c++11-refcref-%E4%B8%8E-bind/","summary":"函数模板 ref 与 cref 是生成 std::reference_wrapper 类型对象的帮助函数，主要是与 std::bind 一起使用，默认情况下，std::bind 无法使用变量引用传递，即使原来的函数形参是引用类型的\nvoid f(int\u0026amp; n1, int\u0026amp; n2, const int\u0026amp; n3) { std::cout \u0026lt;\u0026lt; \u0026#34;In function: \u0026#34; \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n3 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; ++n1; // 增加存储于函数对象的 n1 副本  ++n2; // 增加 main() 的 n2  // ++n3; // 编译错误 error: increment of read-only reference ‘n3’ } int main() { int n1 = 1, n2 = 2, n3 = 3; // 函数对象 bound_f  // 默认会将此时变量值的副本做为函数对象的参数（函数参数特例化）  std::function\u0026lt;void()\u0026gt; bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3)); n1 = 10; n2 = 11; n3 = 12; std::cout \u0026lt;\u0026lt; \u0026#34;Before function: \u0026#34; \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n3 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; bound_f(); std::cout \u0026lt;\u0026lt; \u0026#34;After function: \u0026#34; \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n3 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 输出：","title":"C++11 std::ref, std::cref 与 std::bind"},{"content":"一、队列的应用   只要满足先来先服务特性的应用均可采用队列作为其数据组织方式或中间数据结构\n 调度或缓冲  消息缓冲器 邮件缓冲器 计算机硬设备之间的通信也需要队列作为数据缓冲 操作系统的资源管理   宽度优先搜索    广度优先搜索：搜索该步的所有可能状态，再进一步考虑后面的各种情况；（队列应用）\n 树的层次遍历    深度优先搜索：沿某一状态走下去，不行再回头。（栈应用）\n 树的先序、中序、后续遍历    二、农夫过河问题   问题抽象：\n “人狼羊菜”乘船过河 只有人能撑船，船只有两个位置（包括人） 狼羊、羊菜不能在没有人时共处    数据抽象：\n 对每个角色的位置进行描述，农夫、狼、羊和菜，四个目标依次各用一位，目标在起始岸位置：0，目标岸：1。如 0110 表示农夫、白菜在起始岸，而狼、羊在目标岸（此状态为不安全状态） 用整数 status 表示上述四位二进制描述的状态，如整数 0x08 表示的状态 1000，整数 0x0F 表示的状态 1111 如何从上述状态中得到每个角色所在位置？  bool farmer(int status){ return ((status \u0026amp; 0x08) != 0); } bool wolf(int status){ return ((status \u0026amp; 0x04) != 0); } bool goat(int status){ return ((status \u0026amp; 0x02) != 0); } bool cabbage(int status){ return ((status \u0026amp; 0x01) != 0); }  安全状态判断  bool safe(int status) // 返回 true:安全，false:不安全 { if ((goat(status) == cabbage(status)) \u0026amp;\u0026amp; (goat(status) != farmer(status))) return(false); // 羊吃白菜  if ((goat(status) == wolf(status)) \u0026amp;\u0026amp; (goat(status) != farmer(status))) return(false); // 狼吃羊  return(true); // 其它状态为安全 }   问题求解：试探法\n  算法抽象：问题变为从状态 0000（整数0）出发，寻找全部由安全状态构成的状态序列，以状态 1111（整数15）为最终目标。\n 状态序列中每个状态都可以从前一状态通过农夫（可以带一样东西）划船过河的动作到达。 序列中不能出现 重复 状态    算法设计\n 定义一个整数队列 moveTo，它的每个元素表示一个可以安全到达的中间状态 还需要定义一个数据结构 记录已被访问过的各个状态，以及已被发现的能够到达当前这个状态的路径  用顺序表 route 的第 i 个元素记录状态 i 是否已被访问过 若 route[i] 已被访问过，则在这个顺序表元素中记入前驱状态值；-1 表示未被访问 route 的大小（长度）为 16      算法实现\nvoid solve() { int movers, i, location, newlocation; vector\u0026lt;int\u0026gt; route(END+1, -1); // 记录已考虑的状态路径  queue\u0026lt;int\u0026gt; moveTo; // 准备初值  moveTo.push(0x00); route[0]=0; while (!moveTo.empty() \u0026amp;\u0026amp; route[15] == -1) { // 得到现在的状态  int status = moveTo.front(); moveTo.pop(); for (movers = 1; movers \u0026lt;= 8; movers \u0026lt;\u0026lt;= 1) { // 农夫总是在移动，随农夫移动的也只能是在农夫同侧的东西  if (farmer(status) == (bool)(status \u0026amp; movers)) { // 随农夫移动以后的状态  int newstatus = status ^ (0x08 | movers); // 安全的，并且未考虑过的走法  // 确保状态不能重复，重复状态没有意义，还有可能造成死循环  if (safe(newstatus) \u0026amp;\u0026amp; (route[newstatus] == -1)) { route[newstatus] = status; moveTo.push(newstatus); } } } } // 反向打印出路径  if (route[15] != -1) { cout \u0026lt;\u0026lt; \u0026#34;The reverse path is : \u0026#34; \u0026lt;\u0026lt; endl; for (int status = 15; status \u0026gt;= 0; status = route[status]) { cout \u0026lt;\u0026lt; \u0026#34;The status is : \u0026#34; \u0026lt;\u0026lt; bitset\u0026lt;4\u0026gt;(status) \u0026lt;\u0026lt; endl; if (status == 0) break; } } else{ cout \u0026lt;\u0026lt; \u0026#34;No solution.\u0026#34; \u0026lt;\u0026lt; endl; } } 输出：\nThe reverse path is : The status is : 1111 The status is : 0101 The status is : 1101 The status is : 0001 The status is : 1011 The status is : 0010 The status is : 1010 The status is : 0000   总结：这个算法只能输出其中的一种解，这个问题还有另一种路径\n  三、另一个思考题 五人提灯过独木桥：\n 有一盏灯能使用 30 秒，要在灯灭前过这座独木桥 一家五口人，每人过桥的速度不同：哥哥 1 秒，弟弟 3 秒，爸爸 6 秒，妈妈 8 秒，奶奶 12 秒 每次只能过 2 个人，而且天黑，过桥时必须有灯照明  ","permalink":"https://874656645.github.io/posts/165-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/","summary":"一、队列的应用   只要满足先来先服务特性的应用均可采用队列作为其数据组织方式或中间数据结构\n 调度或缓冲  消息缓冲器 邮件缓冲器 计算机硬设备之间的通信也需要队列作为数据缓冲 操作系统的资源管理   宽度优先搜索    广度优先搜索：搜索该步的所有可能状态，再进一步考虑后面的各种情况；（队列应用）\n 树的层次遍历    深度优先搜索：沿某一状态走下去，不行再回头。（栈应用）\n 树的先序、中序、后续遍历    二、农夫过河问题   问题抽象：\n “人狼羊菜”乘船过河 只有人能撑船，船只有两个位置（包括人） 狼羊、羊菜不能在没有人时共处    数据抽象：\n 对每个角色的位置进行描述，农夫、狼、羊和菜，四个目标依次各用一位，目标在起始岸位置：0，目标岸：1。如 0110 表示农夫、白菜在起始岸，而狼、羊在目标岸（此状态为不安全状态） 用整数 status 表示上述四位二进制描述的状态，如整数 0x08 表示的状态 1000，整数 0x0F 表示的状态 1111 如何从上述状态中得到每个角色所在位置？  bool farmer(int status){ return ((status \u0026amp; 0x08) != 0); } bool wolf(int status){ return ((status \u0026amp; 0x04) !","title":"数据结构与算法——队列的应用"},{"content":"栈的物理实现有 顺序队列 和 链式队列\n一、顺序队列 用向量存储队列元素，用两个变量分别指向队列的前端(front)和尾端(rear)\n 关键是如何防止假溢出    队列溢出\n 上溢 下溢 假溢出：当 rear = mSize-1 时，再作插入运算就会产生溢出，如果这时队列的前端还有许多空位置，这种现象称为假溢出    循环队列\n 为了解决假溢出的问题，需要采用循环队列的方式： % mSize 另外一个问题就是如何区分空队列还是满队列？空一个队列空间，空队列状态时，令 front = rear，若 (rear + 1) % mSize == front，我们认为此时队列已满，但实际上 rear 指向的空间并没有被利用    循环队列类定义\n  template \u0026lt;class T\u0026gt; class arrQueue: public Queue\u0026lt;T\u0026gt; { private: int mSize; // 存放队列的数组的大小  int front; // 表示队头所在位置的下标  int rear; // 表示待入队元素所在位置的下标  T *qu; // 存放类型为T的队列元素的数组 public: // 队列的运算集  arrQueue(int size) { // 创建队列的实例  mSize = size + 1; // 浪费一个存储空间，以区别队列空和队列满  qu = new T[mSize]; front = rear = 0; } ~arrQueue() { // 消除该实例，并释放其空间  delete[] qu; } } // 入队操作 template\u0026lt;class T\u0026gt; bool arrQueue\u0026lt;T\u0026gt; :: enQueue(const T item) { // item入队，插入队尾  if (((rear + 1 ) % mSize) == front) { cout \u0026lt;\u0026lt; \u0026#34;队列已满，溢出\u0026#34; \u0026lt;\u0026lt; endl; return false; } qu[rear] = item; rear = (rear + 1) % mSize; // 循环后继  return true; } // 出队操作 bool arrQueue\u0026lt;T\u0026gt; :: deQueue(T\u0026amp; item) { // 返回队头元素并从队列中删除  if ( front == rear) { cout \u0026lt;\u0026lt; \u0026#34;队列为空\u0026#34; \u0026lt;\u0026lt; endl; return false; } item = qu[front]; front = (front + 1) % mSize; // 这里并没有真的删除队列空间的元素，而是把头指针循环后移  return true; } 二、链式队列   用单链表方式存储，队列中每个元素对于链表中的一个结点\n 单链表队列 链接指针的方向是从队列的前端向尾端链接    链式队列类定义\n  template \u0026lt;class T\u0026gt; class lnkQueue: public Queue\u0026lt;T\u0026gt; { private: int size; // 队列中当前元素的个数  Link\u0026lt;T\u0026gt;* front; // 表示队头的指针  Link\u0026lt;T\u0026gt;* rear; // 表示队尾的指针 public: // 队列的运算集  lnkQueue(int size); // 创建队列的实例  ~lnkQueue(); // 消除该实例，并释放其空间 } // 入队操作 template \u0026lt;class T\u0026gt; bool enQueue(const T item) { // item入队，插入队尾  if (rear == nullptr) { // 空队列  front = rear = new Link\u0026lt;T\u0026gt;(item, nullptr); } else { // 添加新的元素  rear-\u0026gt;next = new Link\u0026lt;T\u0026gt;(item, nullptr); rear = rear-\u0026gt;next; // 向后移动尾指针  } size++; // 队列大小加一  return true; } // 出队操作 template \u0026lt;class T\u0026gt; bool deQueue(T* item) { // 返回队头元素并从队列中删除  Link\u0026lt;T\u0026gt;* tmp; if (size == 0) { // 队列为空，没有元素可出队  cout \u0026lt;\u0026lt; \u0026#34;队列为空\u0026#34; \u0026lt;\u0026lt; endl; return false; } *item = front-\u0026gt;data; tmp = front; front = front-\u0026gt;next; // 向后移动头指针  delete tmp; // 删除原来的头结点空间  if (front == nullptr) rear = nullptr; size--; return true; } 三、顺序队列与链式队列的比较  顺序队列有固定的存储空间 链式队列可以满足大小无法估计的情况 它们都不允许访问队列内部的元素  ","permalink":"https://874656645.github.io/posts/164-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","summary":"栈的物理实现有 顺序队列 和 链式队列\n一、顺序队列 用向量存储队列元素，用两个变量分别指向队列的前端(front)和尾端(rear)\n 关键是如何防止假溢出    队列溢出\n 上溢 下溢 假溢出：当 rear = mSize-1 时，再作插入运算就会产生溢出，如果这时队列的前端还有许多空位置，这种现象称为假溢出    循环队列\n 为了解决假溢出的问题，需要采用循环队列的方式： % mSize 另外一个问题就是如何区分空队列还是满队列？空一个队列空间，空队列状态时，令 front = rear，若 (rear + 1) % mSize == front，我们认为此时队列已满，但实际上 rear 指向的空间并没有被利用    循环队列类定义\n  template \u0026lt;class T\u0026gt; class arrQueue: public Queue\u0026lt;T\u0026gt; { private: int mSize; // 存放队列的数组的大小  int front; // 表示队头所在位置的下标  int rear; // 表示待入队元素所在位置的下标  T *qu; // 存放类型为T的队列元素的数组 public: // 队列的运算集  arrQueue(int size) { // 创建队列的实例  mSize = size + 1; // 浪费一个存储空间，以区别队列空和队列满  qu = new T[mSize]; front = rear = 0; } ~arrQueue() { // 消除该实例，并释放其空间  delete[] qu; } } // 入队操作 template\u0026lt;class T\u0026gt; bool arrQueue\u0026lt;T\u0026gt; :: enQueue(const T item) { // item入队，插入队尾  if (((rear + 1 ) % mSize) == front) { cout \u0026lt;\u0026lt; \u0026#34;队列已满，溢出\u0026#34; \u0026lt;\u0026lt; endl; return false; } qu[rear] = item; rear = (rear + 1) % mSize; // 循环后继  return true; } // 出队操作 bool arrQueue\u0026lt;T\u0026gt; :: deQueue(T\u0026amp; item) { // 返回队头元素并从队列中删除  if ( front == rear) { cout \u0026lt;\u0026lt; \u0026#34;队列为空\u0026#34; \u0026lt;\u0026lt; endl; return false; } item = qu[front]; front = (front + 1) % mSize; // 这里并没有真的删除队列空间的元素，而是把头指针循环后移  return true; } 二、链式队列   用单链表方式存储，队列中每个元素对于链表中的一个结点","title":"数据结构与算法——队列的实现方式"},{"content":"一、队列   队列特点\n 访问受限的线性表 先进先出 插入在一端进行，删除在另一端进行    主要元素\n 队头 队尾    主要操作\n 入队列 出队列 取队首元素 判断队列是否为空    二、队列的抽象数据类型 template \u0026lt;class T\u0026gt; class Queue { // 队列的运算集 public: // 变为空队列  void clear(); // 将item插入队尾，成功则返回真，否则返回假  bool enQueue(const T item); // 返回队头元素并将其从队列中删除，成功则返回真  bool deQueue(T \u0026amp; item); // 返回队头元素，但不删除，成功则返回真  bool getFront(T \u0026amp; item); // 返回真，若队列已空  bool isEmpty(); // 返回真，若队列已满  bool isFull(); }; 三、队列的实现方式 队列的物理实现又分为顺序队列和链式队列\n","permalink":"https://874656645.github.io/posts/163-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/","summary":"一、队列   队列特点\n 访问受限的线性表 先进先出 插入在一端进行，删除在另一端进行    主要元素\n 队头 队尾    主要操作\n 入队列 出队列 取队首元素 判断队列是否为空    二、队列的抽象数据类型 template \u0026lt;class T\u0026gt; class Queue { // 队列的运算集 public: // 变为空队列  void clear(); // 将item插入队尾，成功则返回真，否则返回假  bool enQueue(const T item); // 返回队头元素并将其从队列中删除，成功则返回真  bool deQueue(T \u0026amp; item); // 返回队头元素，但不删除，成功则返回真  bool getFront(T \u0026amp; item); // 返回真，若队列已空  bool isEmpty(); // 返回真，若队列已满  bool isFull(); }; 三、队列的实现方式 队列的物理实现又分为顺序队列和链式队列","title":"数据结构与算法——队列"},{"content":"  栈的特点是后进先出，所以常用来处理具有递归结构的数据\n 深度优先搜索 表达式求值 子程序 / 函数调用的管理 消除递归    表达式的递归定义\n 基本符号集：${0，1，…，9，+，-，*，/，（，）}$ 语法成分集：{\u0026lt;表达式\u0026gt; , \u0026lt;项\u0026gt; , \u0026lt;因子\u0026gt; , \u0026lt;常数\u0026gt;, \u0026lt;数字\u0026gt; } 中缀表达式：$23\\ +\\ (34\\ *\\ 45)\\ /\\ (5\\ +\\ 6\\ +\\ 7)$  后缀表达式：$23\\ 34\\ 45\\ *\\ 5\\ 6\\ +\\ 7\\ +\\ /\\ +$\n    中缀表达式\n 运算符在中间 需要括号改变优先级  例如：$4\\ *\\ x\\ *\\ (2\\ *\\ x\\ +\\ a)\\ –\\ c$\n  后缀表达式\n 运算符在后面 完全不需要括号  例如：$4\\ x\\ *\\ 2\\ x\\ *\\ a\\ +\\ *\\ c\\ –$\n  后缀表达式求值思路\n循环：依次顺序读入表达式的符号序列（假设以 ＝ 作为输入序列的结束），并根据读入的元素符号逐一分析\n 当遇到的是一个操作数，则压入栈顶 当遇到的是一个运算符, 就从栈中两次取出栈顶（注意两个操作数在符号两侧的顺序，第一个是右操作数，第二个是左操作数），按照运算符对这两个操作数进行计算。然后将计算结果压入栈顶  如此继续，直到遇到符号 ＝，这时栈顶的值就是输入表达式的值\n  部分代码：\n// 计算器类定义 template \u0026lt;class T\u0026gt; class Calculator { private: stack\u0026lt;T\u0026gt; s; // 这个栈用于压入保存操作数  // 从栈顶弹出两个操作数 opd1 和 opd2  bool GetTwoOperands(T\u0026amp; opd1,T\u0026amp; opd2); // 取两个操作数，并按 op 对两个操作数进行计算  void Compute(char op); public: Calculator(void){} ; // 创建计算器实例，开辟一个空栈  void Run(void); // 读入后缀表达式，遇 “=” 符号结束  void Clear(void); // 清除计算器，为下一次计算做准备 }; template \u0026lt;class T\u0026gt; bool Calculator\u0026lt;T\u0026gt;::GetTwoOperands(T\u0026amp; opnd1, T\u0026amp; opnd2) { if (s.empty()) { cerr \u0026lt;\u0026lt; \u0026#34;Missing operand!\u0026#34; \u0026lt;\u0026lt;endl; return false; } opnd1 = s.top(); // 右操作数  s.pop(); if (s.empty()) { cerr \u0026lt;\u0026lt; \u0026#34;Missing operand!\u0026#34; \u0026lt;\u0026lt;endl; return false; } opnd2 = s.top(); // 左操作数  s.pop(); return true; } template \u0026lt;class T\u0026gt; void Calculator\u0026lt;T\u0026gt;::Compute(char op) { T operand1, operand2; bool result = GetTwoOperands(operand1, operand2); if (result == true) { switch(op) { case \u0026#39;+\u0026#39; : s.push(operand2 + operand1); break; case \u0026#39;-\u0026#39; : s.push(operand2 - operand1); break; case \u0026#39;*\u0026#39; : s.push(operand2 * operand1); break; case \u0026#39;/\u0026#39; : if (operand1 == 0.0) { cerr \u0026lt;\u0026lt; \u0026#34;Divide by 0!\u0026#34; \u0026lt;\u0026lt; endl; stack\u0026lt;T\u0026gt;().swap(s); } else { s.push(operand2 / operand1); break; } } }else{ stack\u0026lt;T\u0026gt;().swap(s); } } template \u0026lt;class T\u0026gt; void Calculator\u0026lt;T\u0026gt;::Run(void) { char c; T newoperand; while (cin \u0026gt;\u0026gt; c, c != \u0026#39;=\u0026#39;) { switch(c) { case \u0026#39;+\u0026#39;: case \u0026#39;-\u0026#39;: case \u0026#39;*\u0026#39;: case \u0026#39;/\u0026#39;: Compute(c); break; default: cin.putback(c); cin \u0026gt;\u0026gt; newoperand; s.push(newoperand); break; } } if (!s.empty()) cout \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; // 印出求值的最后结果 }   将中缀表达式转换为后缀表达式\n思路：利用栈来记录表达式中的运算符\n  当输入是操作数，直接输出到后缀表达式序列\n  当输入的是左括号时，也把它压栈\n  当输入的是运算符时：\nwhile (以下循环)\nif（栈非空 and 栈顶不是左括号 and 输入运算符的优先级 ≤ 栈顶运算符的优先级）\n将当前栈顶元素弹栈，放到后缀表达式序列中（此步反复循环，直到上述 if 条件不 成立,将输入的运算符压入栈中）；\nelse\n把输入的运算符压栈（\u0026gt; 当前栈顶运算符才压栈！）\n  当输入的是右括号时，先判断栈是否为空\n 若为空（括号不匹配），异常处理，清栈退出； 若非空，则把栈中的元素依次弹出  遇到第一个左括号为止，将弹出的元素输出到后缀表达式的序列中（弹出的 开括号不放到序列中） 若没有遇到开括号，说明括号也不匹配，做异常处理，清栈退出      最后，当中缀表达式的符号序列全部读入时，若栈内仍有元素，把它们全部依次弹 出，都放到后缀表达式序列尾部。\n  若弹出的元素遇到开括号时，则说明括号不匹配，做错误异常处理，清栈退出\n    ","permalink":"https://874656645.github.io/posts/162-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/","summary":"栈的特点是后进先出，所以常用来处理具有递归结构的数据\n 深度优先搜索 表达式求值 子程序 / 函数调用的管理 消除递归    表达式的递归定义\n 基本符号集：${0，1，…，9，+，-，*，/，（，）}$ 语法成分集：{\u0026lt;表达式\u0026gt; , \u0026lt;项\u0026gt; , \u0026lt;因子\u0026gt; , \u0026lt;常数\u0026gt;, \u0026lt;数字\u0026gt; } 中缀表达式：$23\\ +\\ (34\\ *\\ 45)\\ /\\ (5\\ +\\ 6\\ +\\ 7)$  后缀表达式：$23\\ 34\\ 45\\ *\\ 5\\ 6\\ +\\ 7\\ +\\ /\\ +$\n    中缀表达式\n 运算符在中间 需要括号改变优先级  例如：$4\\ *\\ x\\ *\\ (2\\ *\\ x\\ +\\ a)\\ –\\ c$\n  后缀表达式","title":"数据结构与算法——栈的应用"},{"content":"栈的物理实现有 顺序栈 和 链式栈\n一、顺序栈（Array-based Stack）  使用向量实现，本质上是顺序表的简化版  栈有固定大小   关键是确定哪一端作为栈顶 注意上溢、下溢问题  类定义：\ntemplate \u0026lt;class T\u0026gt; class arrStack : public Stack \u0026lt;T\u0026gt; { private: // 栈的顺序存储  int mSize; // 栈中最多可存放的元素个数  int top; // 栈顶位置，应小于mSize  T *st; // 存放栈元素的数组 public: // 栈的运算的顺序实现  arrStack(int size) { // 创建一个给定长度的顺序栈实例  mSize = size; top = -1; st = new T[mSize]; } arrStack() { // 创建一个顺序栈的实例  top = -1; } ~arrStack() { delete [] st; } void clear() { top = -1; } // 清空栈 }; bool arrStack\u0026lt;T\u0026gt;::push(const T item) { // 入栈  if (top == mSize-1) { // 栈已满  cout \u0026lt;\u0026lt; \u0026#34;栈满溢出\u0026#34; \u0026lt;\u0026lt; endl; return false; } else { // 新元素入栈并修改栈顶指针  st[++top] = item; return true; } } bool arrStack\u0026lt;T\u0026gt;::pop(T\u0026amp; item) { // 出栈  if (top == -1) { // 栈为空  cout \u0026lt;\u0026lt; \u0026#34;栈为空，不能执行出栈操作\u0026#34;\u0026lt;\u0026lt; endl; return false; } else { item = st[top--]; // 返回栈顶，并缩减1  return true; } } 二、链式栈（Linked Stack）  用单链表方式存储，其中指针的方向是从栈顶向下链接 理论上没有大小限制  类定义：\ntemplate \u0026lt;class T\u0026gt; class Link{ private: T data; Link* next{nullptr}; public: Link(T info, Link* nextValue); }; template \u0026lt;class T\u0026gt; class lnkStack : public Stack \u0026lt;T\u0026gt; { private: // 栈的链式存储  Link\u0026lt;T\u0026gt;* top; // 指向栈顶的指针  int size; // 存放元素的个数 public: // 栈运算的链式实现  lnkStack(int defSize) { // 构造函数  top = nullptr; size = 0; } ~lnkStack() { // 析构函数  clear(); } }; // 具有两个参数的Link构造函数 Link(const T info, Link* nextValue) { data = info; next = nextValue; } // 入栈操作的链式实现 bool lnkStack\u0026lt;T\u0026gt;:: push(const T item) { Link\u0026lt;T\u0026gt;* tmp = new Link\u0026lt;T\u0026gt;(item, top); top = tmp; size++; return true; } // 出栈操作的链式实现 bool lnkStack\u0026lt;T\u0026gt;:: pop(T\u0026amp; item) { Link \u0026lt;T\u0026gt; *tmp; if (size == 0) { cout \u0026lt;\u0026lt; \u0026#34;栈为空，不能执行出栈操作\u0026#34;\u0026lt;\u0026lt; endl; return false; } item = top-\u0026gt;data; tmp = top-\u0026gt;next; delete top; top = tmp; size--; return true; } 三、顺序栈与链式栈的比较   时间效率\n顺序栈和链式栈都是 $\\mathcal{O}(1)$ 的时间复杂度\n  空间效率\n 顺序栈须说明一个固定的长度 链式栈的长度可变，但增加了结构性开销（增加了一个指针变量）    实际应用中，顺序栈比链式栈用得更广泛，尤其在能预测栈中最大数据量的情况下，一般是用顺序栈来实现\n  ","permalink":"https://874656645.github.io/posts/161-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","summary":"栈的物理实现有 顺序栈 和 链式栈\n一、顺序栈（Array-based Stack）  使用向量实现，本质上是顺序表的简化版  栈有固定大小   关键是确定哪一端作为栈顶 注意上溢、下溢问题  类定义：\ntemplate \u0026lt;class T\u0026gt; class arrStack : public Stack \u0026lt;T\u0026gt; { private: // 栈的顺序存储  int mSize; // 栈中最多可存放的元素个数  int top; // 栈顶位置，应小于mSize  T *st; // 存放栈元素的数组 public: // 栈的运算的顺序实现  arrStack(int size) { // 创建一个给定长度的顺序栈实例  mSize = size; top = -1; st = new T[mSize]; } arrStack() { // 创建一个顺序栈的实例  top = -1; } ~arrStack() { delete [] st; } void clear() { top = -1; } // 清空栈 }; bool arrStack\u0026lt;T\u0026gt;::push(const T item) { // 入栈  if (top == mSize-1) { // 栈已满  cout \u0026lt;\u0026lt; \u0026#34;栈满溢出\u0026#34; \u0026lt;\u0026lt; endl; return false; } else { // 新元素入栈并修改栈顶指针  st[++top] = item; return true; } } bool arrStack\u0026lt;T\u0026gt;::pop(T\u0026amp; item) { // 出栈  if (top == -1) { // 栈为空  cout \u0026lt;\u0026lt; \u0026#34;栈为空，不能执行出栈操作\u0026#34;\u0026lt;\u0026lt; endl; return false; } else { item = st[top--]; // 返回栈顶，并缩减1  return true; } } 二、链式栈（Linked Stack）  用单链表方式存储，其中指针的方向是从栈顶向下链接 理论上没有大小限制  类定义：","title":"数据结构与算法——栈的实现方式"},{"content":"一、栈  后进先出  是一种限制访问端口的线性表   主要操作  进栈（push） 出栈（pop）   应用  表达式求值（中缀表达式、后缀表达式） 消除递归 深度优先搜索（树、图）    二、栈的抽象数据类型 template \u0026lt;class T\u0026gt; class Stack { public: // 栈的运算集  void clear(); // 变为空栈  bool push(const T item); // item入栈，成功返回真，否则假  bool pop(T\u0026amp; item); // 返回栈顶内容并弹出，成功返回真，否则假  bool top(T\u0026amp; item); // 返回栈顶但不弹出，成功返回真，否则假  bool isEmpty(); // 若栈已空返回真  bool isFull(); // 若栈已满返回真 }; 三、思考题   若入栈顺序为 1,2,3,4 的话，则出栈的顺序可以有哪些?\n 1234 1243 1324 1342 1423 错误 1432 2134 2143  引理：设 k 是最后一个出栈的，那么 k 把序列一分为二；在 k 之前入栈的元素，一定比在 k 之后入栈的元素，要提前出栈\n  从初始输入序列 $1,2,\u0026hellip;,n$，希望利用一个栈得到输出序列 $p_1,p_2,\u0026hellip;,p_n$（它们是 $1,2,\u0026hellip;,n$的一种排列）。若存在下标 $i,j,k$，满足 $i\u0026lt;j\u0026lt;k$ 同时 $p_j\u0026lt;p_i\u0026lt;p_k$，则输出序列是否合法？\n  给定一个入栈序列，和一个出栈序列，请你写出一个程序，判定出栈序列是否合法？\n可以根据上面的引理写一个 减而治之 的算法\n  给定一个入栈序列，序列长度为 N，请计算有多少种出栈序列？\n$$ \\begin{aligned} f(n) \u0026amp;= \\sum_{x=0}^{n-1} f(x) \\times f(N-1-x)\\newline \u0026amp;= \\frac{1}{N+1} \\times C_{2N}^{N} \\end{aligned} $$\nCatalan 数\n  汉诺塔问题\n  ","permalink":"https://874656645.github.io/posts/160-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88/","summary":"一、栈  后进先出  是一种限制访问端口的线性表   主要操作  进栈（push） 出栈（pop）   应用  表达式求值（中缀表达式、后缀表达式） 消除递归 深度优先搜索（树、图）    二、栈的抽象数据类型 template \u0026lt;class T\u0026gt; class Stack { public: // 栈的运算集  void clear(); // 变为空栈  bool push(const T item); // item入栈，成功返回真，否则假  bool pop(T\u0026amp; item); // 返回栈顶内容并弹出，成功返回真，否则假  bool top(T\u0026amp; item); // 返回栈顶但不弹出，成功返回真，否则假  bool isEmpty(); // 若栈已空返回真  bool isFull(); // 若栈已满返回真 }; 三、思考题   若入栈顺序为 1,2,3,4 的话，则出栈的顺序可以有哪些?","title":"数据结构与算法——栈"},{"content":"WebIDL Binder 提供一种简单、轻量级的方法来绑定 C++ 代码。\nWebIDL Binder 使用 WebIDL 定义了一种 接口语言 来把 C++ 和 JavaScript 粘合在一起。\n该绑定器支持可以用 WebIDL 表达的 c++ 类型的子集。这个子集对于大多数情况来说已经足够了。\n接下来，通过一个简单的例子来看一下绑定的流程，使用 WebIDL Binder 进行绑定的过程分为三个阶段：\n 创建一个 WebIDL 文件，用来描述 C++ 接口； 使用绑定器生成 C++ 和 JavaScript 的胶水代码； 使用 EMScripten 编译此胶水代码；  第一步：创建 WebIDL 接口文件 创建一个描述将要绑定的 C++ 类型的 WebIDL 接口文件。该文件将复制 C++ 头文件中的一些信息。比如，我们想绑定下面的 C++ 类（my_classes.h）：\nclass Foo { public: int getVal(); void setVal(int v); private: int m_val{0}; }; class Bar { public: Bar(long val); ~Bar(); void doSomething(); private: int m_val; }; IDL 接口文件就可以写成下面的形式（my_classes.idl）：\ninterface Foo { void Foo(); long getVal(); void setVal(long v); }; interface Bar { void Bar(long val); void doSomething(); }; 从 IDL 接口文件到 C++ 代码的映射要注意：\n IDL类定义包括了一个与接口同名的且返回值是 void 的函数。这个构造函数允许我们从 JavaScript 中创建对象，并且必须在 IDL 中定义，即使 C++ 中使用的是默认构造函数； WebIDL 中的类型名与 C++ 中的不一样，比如 int 被映射成了 long，具体的类型对应关系参考 WebIDL types struct 与 class 一样，也是使用 interface 关键字  第二步：生成胶水代码 执行命令 webidl_binder my_classes.idl glue，会在同级目录产生 glue.cpp 和 glue.js 两个胶水代码文件\n第三步：编译项目 在项目编译过程中使用胶水代码文件（glue.cpp 和 glue.js）\n  在 emcc 命令中添加 --post-js glue.js。post-js 选项将胶水代码（glue.js）添加到编译后的 js 输出文件的末尾；\n  创建一个包装器文件，比如：my_glue_wrapper.cpp，用来 #include 要绑定的类的头文件和 glue.cpp，比如：\n#include \u0026#34;my_classes.h\u0026#34;#include \u0026lt;cstddef\u0026gt; // size_t#include \u0026#34;glue.cpp\u0026#34;  将 my_glue_wrapper.cpp 一起添加到 emcc 编译命令中，最后的 emcc 命令包含 C++ 和 JavaScript 的胶水代码，它们是为了协同工作而构建的\nemcc my_classes.cpp my_glue_wrapper.cpp --post-js glue.js -o output.js\n现在 output.js 文件中就包含通过 JavaScript 使用 C++ 类所需的所有内容了。\n使用方式：\n一旦编译完成，C++ 对象就可以像普通的 JavaScript 对象一样在 JavaScript 中创建和使用了。将 output.js 和 output.wasm 添加到网站中，然后通过以下代码创建 Foo 和 Bar 对象，并调用他们的方法：\nvar f = new Module.Foo(); f.setVal(200); alert(f.getVal()); var b = new Module.Bar(123); b.doSomething(); 注意：\n 总是通过 Module 对象访问对象； 虽然在默认情况下，全局命名空间中的对象也是可用的，但在某些情况下它们是不可用的(例如，如果使用闭包编译器来最小化代码，或将编译后的代码包装在函数中，以避免污染全局命名空间)。当然，也可以通过将模块赋值给一个新变量：var MyModuleName = module;； 只能在 js 调用 WASM 代码是安全的情况下（所需文件都加载完成后），使用上面的代码；  当没有更多的引用时，JavaScript 将自动对任何包装好的 C++ 对象进行垃圾回收。如果 C++ 对象不需要特定的清理（即它没有析构函数），那么不需要采取其他操作。\n如果一个 C++ 对象确实需要清理，就必须显式地调用 Module.destroy(obj) 来调用它的析构函数，然后删除对该对象的所有引用，以便它可以被垃圾收集。例如，如果 Bar 需要清理分配的内存：\nvar b = new Module.Bar(123); b.doSomething(); Module.destroy(b); // If the C++ object requires clean up   模块化输出\n使用 \u0026lsquo;WebIDL Binder\u0026rsquo; 时，通常是创建一个库。在这种情况下，就要使用 MODULARIZE 选项。它将整个 JavaScript 输出包装在一个函数中，并返回一个解析为已初始化的 Module 实例的 Promise\nemcc my_classes.cpp my_glue_wrapper.cpp -s MODULARIZE --post-js glue.js -o output.js\n使用方式：\nvar instance; Module().then(module =\u0026gt; { instance = module; var f = new module.Foo(); f.setVal(200); alert(f.getVal()); var b = new module.Bar(123); b.doSomething(); module.destroy(b); }); 当它可以安全运行已编译的代码时，也就是说它已经被下载并实例化之后，promise 才会被解析。promise 是在调用 onRuntimeInitialized 回调函数的同时被解析的，所以在使用 MODULARIZE 时不需要使用 onRuntimeInitialized 回调。\nonRuntimeInitialized 回调：\n\u0026lt;script type=\u0026#39;text/javascript\u0026#39;\u0026gt; var Module = { onRuntimeInitialized: function(){ alert(\u0026#34;I am ready!\u0026#34;); } } \u0026lt;/script\u0026gt; \u0026lt;script src = \u0026#34;hello.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 我们还可以使用 EXPORT_NAME 选项将 Module 更改为其他内容。对于库来说，这是一种很好的实践方式，因为这样它们就不会在全局作用域中包含不必要的内容，而且在某些情况下，我们希望创建多个库。编译命令可参考下面这种：\nemcc my_classes.cpp my_glue_wrapper.cpp -s MODULARIZE -s 'EXPORT_NAME=\u0026quot;createMyModule\u0026quot;' --post-js glue.js -o output.js\n我们可以这样使用：\ncreateMyModule(/* optional default settings */).then(function(MyModule) { // this is reached when everything is ready, and you can call methods on Module  var f = new MyModule.Foo(); f.setVal(200); alert(f.getVal()); var b = new MyModule.Bar(123); b.doSomething(); MyModule.destroy(b); }); 注意：在 MODULARIZE 模式中，我们不会寻找一个全局的 Module 对象来获取默认值。默认值必须作为参数传递给工厂函数。(详情见 settings.js)\n  WebIDL Types    C++ IDL     bool boolean   float float   double double   char byte   char* DOMString (represents a JavaScript string)   unsigned char octet   int long   long long   unsigned short unsigned short   unsigned long unsigned long   long long long long   void void   void* any or VoidPtr    参考：\n WebIDL Binder  ","permalink":"https://874656645.github.io/posts/159-emscripten-%E4%BD%BF%E7%94%A8-webidl-binder-%E7%BB%91%E5%AE%9A-c++-%E4%BB%A3%E7%A0%81/","summary":"WebIDL Binder 提供一种简单、轻量级的方法来绑定 C++ 代码。\nWebIDL Binder 使用 WebIDL 定义了一种 接口语言 来把 C++ 和 JavaScript 粘合在一起。\n该绑定器支持可以用 WebIDL 表达的 c++ 类型的子集。这个子集对于大多数情况来说已经足够了。\n接下来，通过一个简单的例子来看一下绑定的流程，使用 WebIDL Binder 进行绑定的过程分为三个阶段：\n 创建一个 WebIDL 文件，用来描述 C++ 接口； 使用绑定器生成 C++ 和 JavaScript 的胶水代码； 使用 EMScripten 编译此胶水代码；  第一步：创建 WebIDL 接口文件 创建一个描述将要绑定的 C++ 类型的 WebIDL 接口文件。该文件将复制 C++ 头文件中的一些信息。比如，我们想绑定下面的 C++ 类（my_classes.h）：\nclass Foo { public: int getVal(); void setVal(int v); private: int m_val{0}; }; class Bar { public: Bar(long val); ~Bar(); void doSomething(); private: int m_val; }; IDL 接口文件就可以写成下面的形式（my_classes.","title":"Emscripten——使用 WebIDL Binder 绑定 C++ 代码"},{"content":"WASM 调用 js 代码 Emscripten 提供了两种方式，用于从 C/C++ 调用 JavaScript 的方法：\n 使用 emscripten_run_script() 运行脚本 编写 inline JavaScript。    最直接但稍微慢的方式是使用 emscripten_run_script()。这有效地使用 eval() 在 C/C++ 中运行指定的 JavaScript 代码。例如，调用浏览器的 alert() 函数，例如下面的代码：\nint EMSCRIPTEN_KEEPALIVE runScript(){ emscripten_run_script(\u0026#34;alert(\u0026#39;hi\u0026#39;)\u0026#34;); emscripten_run_script(\u0026#34;console.log(\u0026#39;hello world!\u0026#39;)\u0026#34;); return 0; }   从 C 中调用 JavaScript 接口的一种更快的方法是编写 inline JavaScript，使用 EM_JS() 或 EM_ASM() (以及其它相关的宏)。\n  EM_JS 是在 C 文件中声明一个 JavaScript 函数，使用方法参考这里。\n#include \u0026lt;emscripten.h\u0026gt; EM_JS(void, myAlert, (), { alert(\u0026#39;hello world!\u0026#39;); throw \u0026#39;all done\u0026#39;; // exception }); EM_JS(void, take_args, (int x, float y), { console.log(\u0026#39;I received: \u0026#39; + [x, y]); }); EM_JS(void, say_hello, (const char* cstr), { console.log(\u0026#39;Hello, \u0026#39;, UTF8ToString(cstr)); }); EM_JS(int, add_forty_two, (int n), { return n + 42; }); EM_JS(int, get_memory_size, (), { return HEAP8.length; }); int main() { myAlert(); take_args(10, 20.4f); say_hello(\u0026#34;C++\u0026#34;); int x = add_forty_two(100); int y = get_memory_size(); cout \u0026lt;\u0026lt; \u0026#34;return value of add_forty_two is \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;HEAP8 memory size is \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; return 0; }   EM_ASM 的使用方式与 inline assembly 代码类似\n#include \u0026lt;emscripten.h\u0026gt; int main() { EM_ASM( alert(\u0026#39;hello world!\u0026#39;); throw \u0026#39;all done\u0026#39;; ); // pass params from C to javascript  EM_ASM({ console.log(\u0026#39;I received: \u0026#39; + $0); }, 100); // return value back  int x = EM_ASM_INT({ console.log(\u0026#39;I received: \u0026#39; + $0); return $0 + 1; }, 100); printf(\u0026#34;%d\\n\u0026#34;, x); return 0; }   注意：\n 您需要使用适当的宏 EM_ASM_INT 或 EM_ASM_DOUBLE 来指定返回值是 int 还是 double; 输入参数使用 $0，$1 等; return 被用来提供从 JavaScript 发送回 c 的值; 使用 { 和 } 来封装代码，以便将代码与稍后传递的参数区分开来，后面是输入参数； 当使用 EM_ASM 宏时，请确保只使用单引号，双引号将导致编译器无法检测到的语法错误    js 回调 目标： 在 WebAssembly 端接收并解析 JSON 字符串后，做一些逻辑处理，然后返回修改后的 JSON 字符串\nC++ 代码：\n#include \u0026lt;emscripten.h\u0026gt;int jsonParse(const char *jsonStr) { auto j = nlohmann::json::parse(jsonStr); if (j.find(\u0026#34;data\u0026#34;) != j.end()) { j[\u0026#34;data\u0026#34;] = \u0026#34;Hi there!\u0026#34;; string res = j.dump(); EM_ASM({ if (typeof window.onRspHandler == \u0026#39;function\u0026#39;) { window.onRspHandler(UTF8ToString($0)) } }, res.c_str()); } return 0; } 使用 EM_ASM 调用外部 js 的 window.onRspHandler 回调方法。EM_ASM 大括号内可以书写任意的 JavaScript 代码，并且可以对其进行传参操作。在本例中，我们将 result 传递给 EM_ASM 方法，其 $0 为传参的等价替换，若还有更多参数则可以写为 $1、$2 等。\njs 代码：\n// js 回调函数 window.onRspHandler = (result) =\u0026gt; { console.log(result); // 在控制台输出: {\u0026#34;data\u0026#34;:\u0026#34;Hi there!\u0026#34;} }; const jsonstr = JSON.stringify({data:\u0026#34;Hello Json!\u0026#34;}); const ptr = allocateUTF8(jsonstr); Module._jsonParse(ptr); _free(ptr); 参考：\n Interacting with code  ","permalink":"https://874656645.github.io/posts/158-emscripten-c++-%E8%B0%83%E7%94%A8-js-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","summary":"WASM 调用 js 代码 Emscripten 提供了两种方式，用于从 C/C++ 调用 JavaScript 的方法：\n 使用 emscripten_run_script() 运行脚本 编写 inline JavaScript。    最直接但稍微慢的方式是使用 emscripten_run_script()。这有效地使用 eval() 在 C/C++ 中运行指定的 JavaScript 代码。例如，调用浏览器的 alert() 函数，例如下面的代码：\nint EMSCRIPTEN_KEEPALIVE runScript(){ emscripten_run_script(\u0026#34;alert(\u0026#39;hi\u0026#39;)\u0026#34;); emscripten_run_script(\u0026#34;console.log(\u0026#39;hello world!\u0026#39;)\u0026#34;); return 0; }   从 C 中调用 JavaScript 接口的一种更快的方法是编写 inline JavaScript，使用 EM_JS() 或 EM_ASM() (以及其它相关的宏)。\n  EM_JS 是在 C 文件中声明一个 JavaScript 函数，使用方法参考这里。\n#include \u0026lt;emscripten.h\u0026gt; EM_JS(void, myAlert, (), { alert(\u0026#39;hello world!\u0026#39;); throw \u0026#39;all done\u0026#39;; // exception }); EM_JS(void, take_args, (int x, float y), { console.","title":"Emscripten——C++ 调用 Js 回调函数"},{"content":"Emscripten 提供了许多方法来在 JavaScript 和编译后的 C 或 c++ 之间连接和交互，我们先来看看 js 调用 WASM 的情况。\n一、使用 ccall 或 cwrap callall() 调用带有指定参数的编译过的 C 函数 并返回结果，而 cwrap() 封装了编译过的 C 函数并返回一个可以正常调用的 JavaScript 函数。因此，如果计划多次调用一个编译后的函数，cwrap() 会更有用。\n例如下面的 C main.cpp 文件：\n#include \u0026lt;math.h\u0026gt; extern \u0026#34;C\u0026#34; { int int_sqrt(int x) { return sqrt(x); } } 使用下面的命令进行编译：\nemcc main.cpp -o function.html -s EXPORTED_FUNCTIONS=_int_sqrt -s EXPORTED_RUNTIME_METHODS=ccall,cwrap\nEXPORTED_FUNCTIONS 告诉编译器哪些函数我们想要导出（不指定的函数会被删掉），EXPORTED_RUNTIME_METHODS 告诉编译器我们需要用到的运行时方法 ccall 和 cwrap，否则这些方法也会被优化掉\n编译后就可以在 js 中通过 cwrap 使用了：\nint_sqrt = Module.cwrap(\u0026#39;int_sqrt\u0026#39;, \u0026#39;number\u0026#39;, [\u0026#39;number\u0026#39;]) int_sqrt(12) // return 3 int_sqrt(28) // return 5 第一个参数是被 wrap 的 C 函数的名字（没有下划线），第二个参数是函数返回值在类型（如果没有返回值，使用 JavaScript 的 null 类型），第三个参数是一个参数数组（如果没有参数，可以省略）。\nJavaScript 的 number 类型对应于 C 语言的 int、float 或 pointer类型\nJavaScript 的 string 类型对应于 C 语言的字符串类型 char*\nJavaScript 的 array 或类型化数组对应于 C 语言的数组类型；对于类型化数组，它必须是 Uint8Array 或 Int8Array\n在 JavaScript 中使用 ccall 调用：\n// Call C from JavaScript var result = Module.ccall(\u0026#39;int_sqrt\u0026#39;, // name of C function  \u0026#39;number\u0026#39;, // return type  [\u0026#39;number\u0026#39;], // argument types  [28]); // arguments  // result is 5 如果要 导出 JS 库函数（例如 SRC/Library*.js 文件中的某些内容），那么除了 EXPORTED_FUNCTIONS 之外，还需要将其添加到 DEFAULT_LIBRARY_FUNCS_TO_INCLUDE 编译参数中，因为后者将强制添加的方法被包含在构建中。\n二、js 直接调用导出的接口 直接调用编译成的 js 接口函数（在 C 或 C++ 接口函数名的前面添加 _ ）的方式比使用 ccall、cwrap 的调用方式运行更快。\n传递给函数和从函数接收的参数必须是基本的数据类型：\n 整数和浮点数可以直接进行传递 指针也可以直接传递 JavaScript 字符串类型 someString 可以通过使用 ptr = allocateUTF8(someString) 转换为 char *，注意： 向指针的转换会分配内存，之后需要通过调用 free(ptr) 来释放内存（在JavaScript 中调用 _free(ptr)） 从 C/C++ 接收的 char* 可以使用 UTF8ToString(ptr) 转换为 JavaScript 字符串。  案例一： 从 js 中传入 string 类型的参数\nC++ 接口代码：\n// 接收 js 的 json 字符串，解析 data 项，并将内容打印到控制台 int EMSCRIPTEN_KEEPALIVE jsonParse(const char *jsonStr) { // string str = R\u0026#34;({\u0026#34;data\u0026#34;: \u0026#34;test json\u0026#34;})\u0026#34;;  auto j = nlohmann::json::parse(jsonStr); if (j.find(\u0026#34;data\u0026#34;) != j.end()) { auto v = j[\u0026#34;data\u0026#34;].get\u0026lt;string\u0026gt;(); cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; } return 0; } js 端代码：\nlet jsonstr = JSON.stringify({data:\u0026#34;Hello World!\u0026#34;}); const ptr = allocateUTF8(jsonstr); Module._jsonParse(ptr); _free(ptr); 案例二： 在 js 中接收返回的 char* 类型\nC++ 接口代码：\nchar* EMSCRIPTEN_KEEPALIVE outString(char* p){ char s[] = \u0026#34;, Hi there!\u0026#34;; strcat(p, s); return p; } js 端代码：\nconst ptr1 = allocateUTF8(\u0026#34;zhang3\u0026#34;); var retPtr = Module._outString(ptr1); var resValue = UTF8ToString(retPtr); console.log(resValue); _free(retPtr); 案例三： 在 js 中开辟内存，调用 C++ 接口并为内存赋值\nC++ 接口代码：\nint EMSCRIPTEN_KEEPALIVE outString2(char* p){ char s[] = \u0026#34;Hi there!\u0026#34;; strcpy(p, s); return 0; } js 端代码：\nvar ptr = _malloc(512); Module._outString2(ptr); var str = UTF8ToString(ptr); console.log(str); _free(ptr); 参考：\n Interacting with code  ","permalink":"https://874656645.github.io/posts/157-emscripten-js-%E8%B0%83%E7%94%A8-c++-%E6%8E%A5%E5%8F%A3/","summary":"Emscripten 提供了许多方法来在 JavaScript 和编译后的 C 或 c++ 之间连接和交互，我们先来看看 js 调用 WASM 的情况。\n一、使用 ccall 或 cwrap callall() 调用带有指定参数的编译过的 C 函数 并返回结果，而 cwrap() 封装了编译过的 C 函数并返回一个可以正常调用的 JavaScript 函数。因此，如果计划多次调用一个编译后的函数，cwrap() 会更有用。\n例如下面的 C main.cpp 文件：\n#include \u0026lt;math.h\u0026gt; extern \u0026#34;C\u0026#34; { int int_sqrt(int x) { return sqrt(x); } } 使用下面的命令进行编译：\nemcc main.cpp -o function.html -s EXPORTED_FUNCTIONS=_int_sqrt -s EXPORTED_RUNTIME_METHODS=ccall,cwrap\nEXPORTED_FUNCTIONS 告诉编译器哪些函数我们想要导出（不指定的函数会被删掉），EXPORTED_RUNTIME_METHODS 告诉编译器我们需要用到的运行时方法 ccall 和 cwrap，否则这些方法也会被优化掉\n编译后就可以在 js 中通过 cwrap 使用了：\nint_sqrt = Module.cwrap(\u0026#39;int_sqrt\u0026#39;, \u0026#39;number\u0026#39;, [\u0026#39;number\u0026#39;]) int_sqrt(12) // return 3 int_sqrt(28) // return 5 第一个参数是被 wrap 的 C 函数的名字（没有下划线），第二个参数是函数返回值在类型（如果没有返回值，使用 JavaScript 的 null 类型），第三个参数是一个参数数组（如果没有参数，可以省略）。","title":"Emscripten——js 调用 C++ 接口"},{"content":"使用 CMake 构建   在源文件目录添加 CMakeList.txt 文件\n# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 set(MyTarget hello)project(${MyTarget} VERSION 1.0)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 编译生成.html文件 set(CMAKE_EXECUTABLE_SUFFIX \u0026#34;.html\u0026#34;)# 添加源码文件和生成的目标文件的名称 # file(GLOB_RECURSE SRC_MAIN ./*.cpp) aux_source_directory(./ SRC_MAIN)aux_source_directory(./thirdParty/ SRC_MAIN)add_executable(${MyTarget} ${SRC_MAIN})# add_executable(${MyTarget} main.cpp) # 设置Emscripten的编译链接参数 set_target_properties(${MyTarget} PROPERTIES LINK_FLAGS \u0026#34; \\ -s EXIT_RUNTIME=0 \\ -gsource-map \\ -s EXPORTED_FUNCTIONS=_main,_sayHello1,_jsonParse,_jsonParse1 \\ -s EXPORTED_RUNTIME_METHODS=ccall,cwrap,addFunction \\ -s NO_DISABLE_EXCEPTION_CATCHING \\ \u0026#34;)# 添加第三方库路径 # target_link_directories(${MyTarget} # PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # ) # 将第三方库与主程序进行链接 # set(LIBS cjson) # target_link_libraries(sample ${LIBS}) # 添加头文件查找路径 target_include_directories(${MyTarget} PUBLIC \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}\u0026#34; )  创建 build 文件夹，并在 build 文件夹内执行命令 emcmake cmake .. -DCMAKE_BUILD_TYPE=Debug 进行项目构建\n  使用 make 编译  构建完成后，执行命令 emmake make 进行编译  ","permalink":"https://874656645.github.io/posts/156-emscripten-%E4%BD%BF%E7%94%A8-cmake-%E6%9E%84%E5%BB%BA%E5%B9%B6%E7%94%A8-make-%E7%BC%96%E8%AF%91/","summary":"使用 CMake 构建   在源文件目录添加 CMakeList.txt 文件\n# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 set(MyTarget hello)project(${MyTarget} VERSION 1.0)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 编译生成.html文件 set(CMAKE_EXECUTABLE_SUFFIX \u0026#34;.html\u0026#34;)# 添加源码文件和生成的目标文件的名称 # file(GLOB_RECURSE SRC_MAIN ./*.cpp) aux_source_directory(./ SRC_MAIN)aux_source_directory(./thirdParty/ SRC_MAIN)add_executable(${MyTarget} ${SRC_MAIN})# add_executable(${MyTarget} main.cpp) # 设置Emscripten的编译链接参数 set_target_properties(${MyTarget} PROPERTIES LINK_FLAGS \u0026#34; \\ -s EXIT_RUNTIME=0 \\ -gsource-map \\ -s EXPORTED_FUNCTIONS=_main,_sayHello1,_jsonParse,_jsonParse1 \\ -s EXPORTED_RUNTIME_METHODS=ccall,cwrap,addFunction \\ -s NO_DISABLE_EXCEPTION_CATCHING \\ \u0026#34;)# 添加第三方库路径 # target_link_directories(${MyTarget} # PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # ) # 将第三方库与主程序进行链接 # set(LIBS cjson) # target_link_libraries(sample ${LIBS}) # 添加头文件查找路径 target_include_directories(${MyTarget} PUBLIC \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}\u0026#34; )  创建 build 文件夹，并在 build 文件夹内执行命令 emcmake cmake .","title":"Emscripten——使用 CMake 构建并用 Make 编译"},{"content":"导出 C++ 函数到 js 有多种方式：\n  方式一：在编译的时候指定\n在编译命令中添加 -sEXPORTED_FUNCTIONS 参数，例如：-s EXPORTED_FUNCTIONS=_myFunction,_sayHello1\n  方式二：修改 C++ 函数\n在 C++ 代码中需要导出的函数声明前添加 EMSCRIPTEN_KEEPALIVE 宏定义\n#include \u0026lt;emscripten.h\u0026gt; extern \u0026#34;C\u0026#34; int EMSCRIPTEN_KEEPALIVE myFunction(int argc, char ** argv) { printf(\u0026#34;我的函数已被调用\\n\u0026#34;); return 0; } #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif  int EMSCRIPTEN_KEEPALIVE sayHello(){ cout \u0026lt;\u0026lt; \u0026#34;hello from sayHello!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } int sayHello1() { Person p; cout \u0026lt;\u0026lt; p.printInfo() \u0026lt;\u0026lt; endl; return 0; } #ifdef __cplusplus } #endif   方式三：WebIDL Binder\n  WebIDL Binder 提供了一种简单且轻量级的方法来绑定 c++ 代码，这样编译后的代码就可以像正常的 JavaScript 库一样在 JavaScript 中被使用了。\n方式四：Embind  ","permalink":"https://874656645.github.io/posts/155-emscripten-c++-%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA/","summary":"导出 C++ 函数到 js 有多种方式：\n  方式一：在编译的时候指定\n在编译命令中添加 -sEXPORTED_FUNCTIONS 参数，例如：-s EXPORTED_FUNCTIONS=_myFunction,_sayHello1\n  方式二：修改 C++ 函数\n在 C++ 代码中需要导出的函数声明前添加 EMSCRIPTEN_KEEPALIVE 宏定义\n#include \u0026lt;emscripten.h\u0026gt; extern \u0026#34;C\u0026#34; int EMSCRIPTEN_KEEPALIVE myFunction(int argc, char ** argv) { printf(\u0026#34;我的函数已被调用\\n\u0026#34;); return 0; } #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif  int EMSCRIPTEN_KEEPALIVE sayHello(){ cout \u0026lt;\u0026lt; \u0026#34;hello from sayHello!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } int sayHello1() { Person p; cout \u0026lt;\u0026lt; p.printInfo() \u0026lt;\u0026lt; endl; return 0; } #ifdef __cplusplus } #endif   方式三：WebIDL Binder","title":"Emscripten——C++ 函数导出"},{"content":"编译   新建 main.cpp 文件\n#include \u0026lt;iostream\u0026gt;using namespace std; int main(){ cout \u0026lt;\u0026lt; \u0026#34;hello world!\u0026#34; \u0026lt;\u0026lt; endl; return 0; }   使用 emcc 或 em++ 编译 C++ 文件\n执行命令 em++ main.cpp，会在同级目录下生成 a.out.js 和 a.out.wasm 两个文件。\n  使用 node 测试\n测试命令 node a.out.js，会在控制台输出 cout 的内容\n  使用 html 页面 测试\n执行命令 em++ main.cpp -o hello.html，会在同级目录下生成三个文件：\n hello.html：测试网页 hello.js：相关的胶水代码，包括加载 WASM 文件并执行调用等相关逻辑 hello.wasm：编译得到的核心 WebAssembly执行文件\n在本地启动一个静态网站服务器，就可以在浏览器中访问生成的网页了    编译带有 调试 信息的测试页面\n执行命令 em++ main.cpp -o hello.html -gsource-map，会在同级目录下生成四个文件：\n hello.html hello.js hello.wasm testHello.wasm.map：带有调试信息的 wasm 文件映射，在浏览器的调试窗口就可以看到 cpp 文件并进行调试了    静态网页服务器 这里使用的是 http-server\n 安装 node.js 安装 http-server: npm install http-server -g 启动服务器：http-server . -p 8000  WASM 调试  在编译命令中添加 -gsource-map 参数 确保网站根目录下有 C++ 或 C 源文件 如果使用 cmake 编译，在编译命令中还需要添加 -DCMAKE_BUILD_TYPE=Debug 参数  ","permalink":"https://874656645.github.io/posts/154-emscripten-hello-world/","summary":"编译   新建 main.cpp 文件\n#include \u0026lt;iostream\u0026gt;using namespace std; int main(){ cout \u0026lt;\u0026lt; \u0026#34;hello world!\u0026#34; \u0026lt;\u0026lt; endl; return 0; }   使用 emcc 或 em++ 编译 C++ 文件\n执行命令 em++ main.cpp，会在同级目录下生成 a.out.js 和 a.out.wasm 两个文件。\n  使用 node 测试\n测试命令 node a.out.js，会在控制台输出 cout 的内容\n  使用 html 页面 测试\n执行命令 em++ main.cpp -o hello.html，会在同级目录下生成三个文件：\n hello.html：测试网页 hello.js：相关的胶水代码，包括加载 WASM 文件并执行调用等相关逻辑 hello.wasm：编译得到的核心 WebAssembly执行文件\n在本地启动一个静态网站服务器，就可以在浏览器中访问生成的网页了    编译带有 调试 信息的测试页面","title":"Emscripten——Hello World"},{"content":"启用 Linux 环境 这里使用的是 WSL（Windows Subsystem Linux）环境，环境配置参考这里\nLinux 安装 Emscripten Download and install\n  安装 python3\nsudo apt install python3\n  安装 git\nsudo apt install git\n  创建目录并 clone emsdk\nsudo git clone https://github.com/emscripten-core/emsdk.git\n  更新 emsdk 并激活\ncd emsdk git pull # Download and install the latest SDK tools. ./emsdk install latest # Make the \u0026#34;latest\u0026#34; SDK \u0026#34;active\u0026#34; for the current user. (writes .emscripten file) ./emsdk activate latest # Activate PATH and other environment variables in the current terminal source ./emsdk_env.sh  注：如果更改了 SDK 的位置（例如，拷贝到另一台计算机上），重新运行 ./emsdk activate latest 和 source ./emsdk_env.sh 命令 注：可以把所需的路径添加到 PATH 中，否则终端重启后要先运行 source ./emsdk_env.sh 命令    测试环境\nWindows: emcc --check\nLinux: ./emcc --check\nemcc -v\n  如果使用 CMake 编译，还需要安装 CMake sudu apt install cmake\n  ","permalink":"https://874656645.github.io/posts/153-emscripten-%E5%AE%89%E8%A3%85/","summary":"启用 Linux 环境 这里使用的是 WSL（Windows Subsystem Linux）环境，环境配置参考这里\nLinux 安装 Emscripten Download and install\n  安装 python3\nsudo apt install python3\n  安装 git\nsudo apt install git\n  创建目录并 clone emsdk\nsudo git clone https://github.com/emscripten-core/emsdk.git\n  更新 emsdk 并激活\ncd emsdk git pull # Download and install the latest SDK tools. ./emsdk install latest # Make the \u0026#34;latest\u0026#34; SDK \u0026#34;active\u0026#34; for the current user. (writes .emscripten file) .","title":"Emscripten——安装"},{"content":"一、暴力算法 $\\mathcal{O}(n^3)$ 遍历数组的所有子数组集合，并对其求和，筛选出和的最大值\nint maxSumOfSub1(int* array, int length){ int maxSum = 0; int startIndex = 0, endIndex = 0; for(int i = 0; i \u0026lt; length; i++){ for(int j = i; j \u0026lt; length; j++){ int sum = 0; for(int k = i; k \u0026lt;= j; k++) sum += array[k]; if(maxSum \u0026lt; sum){ maxSum = sum; startIndex = i; endIndex = j; } } } cout \u0026lt;\u0026lt; \u0026#34;Begin:\u0026#34; \u0026lt;\u0026lt; startIndex \u0026lt;\u0026lt; \u0026#34; End:\u0026#34; \u0026lt;\u0026lt; endIndex \u0026lt;\u0026lt; \u0026#34; Num:\u0026#34; \u0026lt;\u0026lt; maxSum \u0026lt;\u0026lt; endl; return maxSum; } 二、前缀和 $\\mathcal{O}(n^2)$ 先把数组的前 i 项和求出来并将其保存到数组中，然后计算所有子数组集合的和，筛选其中最大的\nint maxSumOfSub2(int* array, int length){ int maxSum = 0; int sumLen = length + 1; int sum[sumLen] = {0}; int startIndex = 0, endIndex = 0; for(int i = 1; i \u0026lt;= length; ++i){ sum[i] = sum[i-1] + array[i-1]; } // for_each(sum, sum + sumLen, [](int ele){ cout \u0026lt;\u0026lt; ele \u0026lt;\u0026lt; \u0026#34; \u0026#34;;});  // cout \u0026lt;\u0026lt; endl;  for(int i = 0; i \u0026lt; length; i++){ for(int j = i + 1; j \u0026lt;= length; j++){ int res = sum[j] - sum[i]; if(maxSum \u0026lt; res){ maxSum = res; startIndex = i; endIndex = j-1; } } } cout \u0026lt;\u0026lt; \u0026#34;Begin:\u0026#34; \u0026lt;\u0026lt; startIndex \u0026lt;\u0026lt; \u0026#34; End:\u0026#34; \u0026lt;\u0026lt; endIndex \u0026lt;\u0026lt; \u0026#34; Num:\u0026#34; \u0026lt;\u0026lt; maxSum \u0026lt;\u0026lt; endl; return maxSum; } 三、分治法 $\\mathcal{O}(n\\log_2{}n)$ 先将数组分为两个子数组 a, b；\n分别求出两个子数组 a，b 的连续子数组中和的最大值 ma, mb；\n还有一种情况：有可能最大和的子数组跨越两个数组 mc；\n在计算 mc 时，注意：mc必定包含总区间的中间元素，因此求 mc 等价于从中间元素开始往左累加的最大值 + 从中间元素开始往右累加的最大值。\n最后比较 ma, mb, mc，取最大的。\nint maxSumOfSub3(int* array, int l, int r){ if(l == r){ return array[l]; } int mid = (l + r) / 2; //计算Ma,Mb的情况  int maxa = maxSumOfSub3(array, l, mid); int maxb = maxSumOfSub3(array, mid + 1, r); //计算子数组跨越两个子数组（Mc）的情况  int maxc = 0, lmax = 0, rmax = 0, sum = 0; for(int i = mid; i \u0026gt;= l; i--){//从中间元素开始往左累加的最大值  sum += array[i]; lmax = max(lmax, sum); } sum = 0; for(int i = mid + 1; i \u0026lt;= r; i++){//从中间元素开始往右累加的最大值  sum += array[i]; rmax = max(rmax, sum); } maxc = lmax + rmax; return max(maxc, max(maxa, maxb)); } 四、动态规划法 $\\mathcal{O}(n)$  dp[i] 表示以下标 i 指向的元素结尾的所有子数组的和的最大值 状态转移方程：dp[i] = max(dp[i-1] + array[i], array[i]) 最后的子数组最大和：ans = max(dp[i], ans) 需要比较三个值，筛选出三者中的最大值：前最大子数组和（索引 i-1 之前）、当前项 array[i] 的值、边界最大子数组和（索引 i 之前）  int maxSumOfSub4( int* array, int length) { int dp[length] = {array[0]}; int maxSum = array[0]; for( int i = 1; i \u0026lt; length; ++i ) { dp[i] = max(dp[i-1] + array[i], array[i]); maxSum = max(maxSum, dp[i]); } return maxSum; } 改进一：省去保存历史状态值的数组空间\nint maxSumOfSub5( int* array, int length) { int boundry = array[0]; int maxSum = array[0]; for( int i = 1; i \u0026lt; length; ++i ) { boundry = max(boundry + array[i], array[i]); maxSum = max(maxSum, boundry); } return maxSum; } 改进二：记录最大子数组区间\nint maxSumOfSub6( int* array, int length) { int dp[length] = {array[0]}; int maxSum = array[0]; int endIndex = 0; int startIndex = 0; int tmpBeginIndex = 0; for( int i = 1; i \u0026lt; length; ++i ) { // dp[i] = max(dp[i-1] + array[i], array[i]);  // maxSum = max(maxSum, dp[i]);  if(dp[i-1] + array[i] \u0026lt; array[i]){ dp[i] = array[i]; tmpBeginIndex = i; } else{ dp[i] = dp[i-1] + array[i]; } if(maxSum \u0026lt; dp[i]){ maxSum = dp[i]; startIndex = tmpBeginIndex; endIndex = i; } } cout \u0026lt;\u0026lt; \u0026#34;Begin:\u0026#34; \u0026lt;\u0026lt; startIndex \u0026lt;\u0026lt; \u0026#34; End:\u0026#34; \u0026lt;\u0026lt; endIndex \u0026lt;\u0026lt; \u0026#34; Num:\u0026#34; \u0026lt;\u0026lt; maxSum \u0026lt;\u0026lt; endl; return maxSum; } 改进三：省去保存历史状态值的数组空间，并且记录大子数组区间\nint maxSumOfSub7( int* array, int length) { int boundry = array[0]; int maxSum = array[0]; int endIndex = 0; int startIndex = 0; int tmpBeginIndex = 0; for( int i = 1; i \u0026lt; length; ++i ) { // boundry = max(boundry + array[i], array[i]);  // maxSum = max(maxSum, boundry);  if(boundry + array[i] \u0026lt; array[i]){ boundry = array[i]; tmpBeginIndex = i; } else{ boundry += array[i]; } if(maxSum \u0026lt; boundry){ maxSum = boundry; startIndex = tmpBeginIndex; endIndex = i; } } cout \u0026lt;\u0026lt; \u0026#34;Begin:\u0026#34; \u0026lt;\u0026lt; startIndex \u0026lt;\u0026lt; \u0026#34; End:\u0026#34; \u0026lt;\u0026lt; endIndex \u0026lt;\u0026lt; \u0026#34; Num:\u0026#34; \u0026lt;\u0026lt; maxSum \u0026lt;\u0026lt; endl; return maxSum; } 五、扫描法 $\\mathcal{O}(n)$ 当加上一个正数时，和会增加；当加上一个负数时，和会减少。如果当前得到的和是个负数，那么这个和在接下来的累加中应该抛弃并重新清零，不然的话这个负数将会减少接下来的和。（与动态规划算法很像似）\nint maxSumOfSub8( int* array, int length) { int boundry = array[0]; int maxSum = array[0]; int endIndex = 0; int startIndex = 0; int tmpBeginIndex = 0; for( int i = 1; i \u0026lt; length; ++i ) { if(boundry \u0026lt; 0){ boundry = array[i]; tmpBeginIndex = i; } else{ boundry += array[i]; } if( maxSum \u0026lt; boundry ) { maxSum = boundry; startIndex = tmpBeginIndex; endIndex = i; } } cout \u0026lt;\u0026lt; \u0026#34;Begin:\u0026#34; \u0026lt;\u0026lt; startIndex \u0026lt;\u0026lt; \u0026#34; End:\u0026#34; \u0026lt;\u0026lt; endIndex \u0026lt;\u0026lt; \u0026#34; Num:\u0026#34; \u0026lt;\u0026lt; maxSum \u0026lt;\u0026lt; endl; return maxSum; } 测试 int main() { int a[] = {1,-2,3,10,-4,7,2,-48}; // int a[] = {3,-1,-1,-1,-1,-1,-1,-1};  // int a[] = {-1,-1,-1,-1,-1,-1,-1,3};  // int a[] = {5,-2,-3,-1,-1,-1,-1,-3};  int num = sizeof(a)/sizeof(a[0]); // int result = maxSumOfSub5(a, num);  int result = 0; result = maxSumOfSub1(a, num); result = maxSumOfSub2(a, num); result = maxSumOfSub3(a, 0, num-1); cout \u0026lt;\u0026lt; \u0026#34;Num:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; result = maxSumOfSub4(a, num); cout \u0026lt;\u0026lt; \u0026#34;Num:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; result = maxSumOfSub5(a, num); cout \u0026lt;\u0026lt; \u0026#34;Num:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; result = maxSumOfSub6(a, num); result = maxSumOfSub7(a, num); result = maxSumOfSub8(a, num); cout \u0026lt;\u0026lt; \u0026#34;-----------------------------\u0026#34; \u0026lt;\u0026lt; endl; int b[] = {3,-1,5,-1,9,-20,21,-20,20,21}; num = sizeof(b)/sizeof(b[0]); result = maxSumOfSub1(b, num); result = maxSumOfSub2(b, num); result = maxSumOfSub3(b, 0, num-1); cout \u0026lt;\u0026lt; \u0026#34;Num:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; result = maxSumOfSub4(b, num); cout \u0026lt;\u0026lt; \u0026#34;Num:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; result = maxSumOfSub5(b, num); cout \u0026lt;\u0026lt; \u0026#34;Num:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; result = maxSumOfSub6(b, num); result = maxSumOfSub7(b, num); result = maxSumOfSub8(b, num); return 0; } 输出：\nBegin:2 End:6 Num:18 Begin:2 End:6 Num:18 Num:18 Num:18 Num:18 Begin:2 End:6 Num:18 Begin:2 End:6 Num:18 Begin:2 End:6 Num:18 ----------------------------- Begin:6 End:9 Num:42 Begin:6 End:9 Num:42 Num:42 Num:42 Num:42 Begin:6 End:9 Num:42 Begin:6 End:9 Num:42 Begin:6 End:9 Num:42 ","permalink":"https://874656645.github.io/posts/152-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/","summary":"一、暴力算法 $\\mathcal{O}(n^3)$ 遍历数组的所有子数组集合，并对其求和，筛选出和的最大值\nint maxSumOfSub1(int* array, int length){ int maxSum = 0; int startIndex = 0, endIndex = 0; for(int i = 0; i \u0026lt; length; i++){ for(int j = i; j \u0026lt; length; j++){ int sum = 0; for(int k = i; k \u0026lt;= j; k++) sum += array[k]; if(maxSum \u0026lt; sum){ maxSum = sum; startIndex = i; endIndex = j; } } } cout \u0026lt;\u0026lt; \u0026#34;Begin:\u0026#34; \u0026lt;\u0026lt; startIndex \u0026lt;\u0026lt; \u0026#34; End:\u0026#34; \u0026lt;\u0026lt; endIndex \u0026lt;\u0026lt; \u0026#34; Num:\u0026#34; \u0026lt;\u0026lt; maxSum \u0026lt;\u0026lt; endl; return maxSum; } 二、前缀和 $\\mathcal{O}(n^2)$ 先把数组的前 i 项和求出来并将其保存到数组中，然后计算所有子数组集合的和，筛选其中最大的","title":"数据结构与算法——连续子数组最大和"},{"content":"线性结构  二元组 B = (K, R) , K = {a0, a1, …, an-1 }, R = {r}，其中 r 为前驱后继关系，具有反对称性和传递性 唯一的开始结点（表头）：没有前驱，只有一个唯一的后继 唯一的终止结点（表尾）：没有后继，只有一个唯一的前驱 内部结点：一个唯一的前驱和一个唯一的后继  线性表 线性表简称表，是零个或多个元素的有穷序列\n 表目：线性表中的元素 文件：含有大量记录的线性表又称为文件 索引（下标） 表的长度 空表：长度为零的线性表(n=0)  线性表分类   按访问方式划分：\n 直接访问型 顺序访问型 目录索引型    按存储方式：\n 顺序表（数组） 链表    按操作：\n 线性表：不限操作 栈：在同一端操作，在深度优先搜索、递归等算法中有很好的应用 队列：在两端操作，在宽度优先搜索、层次化处理中有很好的应用    顺序表  顺序表俗称向量，是用数组实现的（固定长度的一维数组） 按索引值从小到大存放在一片相邻的连续区域 结构紧凑，存储密度为1（存储密度 = 数据本身所占存储 / 整个数据结构所占存储） 物理存储关系就能表示逻辑关联关系  链表  链表需要指针表示逻辑关联关系，存储效率不如顺序表 有头链表和无头链表 在一些边界处理的时候，要注意头结点（head）和尾结点（tail）的特殊处理  讨论   线性表的分类方法有哪些？各种线性表名称中，哪些跟存储结构相关？哪些跟运算相关？\n 线性表可按访问方式分为直接访问型、顺序访问型和目录索引型；按存储方式分为顺序存储（数组，向量）和链接存储（单链表、双链表、循环链表）；按操分为普通线性表、栈（单口进出）、队列（一端进，另一端出）； 顺序表（数组）、链表（单链表、双链表、循环链表）跟存储结构相关，分别是顺序存储和链接存储； 栈、队列跟运算相关，栈是单口操作，后进先出，队列是先进先出，两者都可以用顺序存储实现，也可以用链表（链接存储）实现；    顺序表的操作和优缺点？在顺序表中插入和删除操作各需要考虑哪些问题？顺序表有哪些优缺点？\n 首先要检查顺序表是否上溢或下溢，其次要检查插入或删除的位置是否合法，最后为保证顺序存储的特性，要对插入或删除位置后的元素进行移位，并更新表的长度属性； 优点：结构紧凑，存储密度高，支持在 $\\mathcal{O}(1)$ 时间内随机访问； 缺点：插入和删除元素需要频繁移位，效率较低，是 $\\mathcal{O}(n)$ 时间复杂度。    顺序表和链表的特点以及在应用场景中的选择？线性表的顺序和链接两种实现方法的特点，其的插入、删除、查找等操作的代价？顺序表和链表分别适用于什么样的应用场景？\n  求数组最大子数组之和，数组 [1, -2, 3, 10, -4, 7, 2, -5]，和最大的子数组为 [3, 10, -4, 7, 2]，输出该子数组的和18，请分别思考分治法、动态规划法及其效率。\n连续子数组最大和\n动态规划法和线性扫描法相似，时间复杂度是 $\\mathcal{O}(n)$，不过动态规划法有 $\\mathcal{O}(n)$ 的空间占用；分治递归法如何记录最大子数组的区间下标呢？暴力算法时间复杂度是 $\\mathcal{O}(n^3)$，前缀和算法时间复杂度 $\\mathcal{O}(n^2)$，但是有 $\\mathcal{O}(n)$ 的空间占用；\n  如何判断单链表中是否有回路？提示，可以多想几种方法，允许改变链表结构。\n ​在链表中添加一个标识，未被访问过为 false，访问过就改为 true。初始状态都设为 false，如果遍历的时候遇到标识为 true 的，说明有环路 可以使用Floyd判圈法(快慢指针问题)，使用 slow 和 fast 双指针，起始位置都在链表开头，fast 每次前进 2 步，slow 前进 1步，如果 fast==slow 说明有环路，此时将 fast 移动到链表开头，先判断两个指针是否相同（有在环路开始地方重合的可能性），让双指针每次都前进 1 步，最终相遇的地方就是环路的开始节点    ","permalink":"https://874656645.github.io/posts/151-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E8%A1%A8/","summary":"线性结构  二元组 B = (K, R) , K = {a0, a1, …, an-1 }, R = {r}，其中 r 为前驱后继关系，具有反对称性和传递性 唯一的开始结点（表头）：没有前驱，只有一个唯一的后继 唯一的终止结点（表尾）：没有后继，只有一个唯一的前驱 内部结点：一个唯一的前驱和一个唯一的后继  线性表 线性表简称表，是零个或多个元素的有穷序列\n 表目：线性表中的元素 文件：含有大量记录的线性表又称为文件 索引（下标） 表的长度 空表：长度为零的线性表(n=0)  线性表分类   按访问方式划分：\n 直接访问型 顺序访问型 目录索引型    按存储方式：\n 顺序表（数组） 链表    按操作：\n 线性表：不限操作 栈：在同一端操作，在深度优先搜索、递归等算法中有很好的应用 队列：在两端操作，在宽度优先搜索、层次化处理中有很好的应用    顺序表  顺序表俗称向量，是用数组实现的（固定长度的一维数组） 按索引值从小到大存放在一片相邻的连续区域 结构紧凑，存储密度为1（存储密度 = 数据本身所占存储 / 整个数据结构所占存储） 物理存储关系就能表示逻辑关联关系  链表  链表需要指针表示逻辑关联关系，存储效率不如顺序表 有头链表和无头链表 在一些边界处理的时候，要注意头结点（head）和尾结点（tail）的特殊处理  讨论   线性表的分类方法有哪些？各种线性表名称中，哪些跟存储结构相关？哪些跟运算相关？","title":"数据结构与算法——线性表"},{"content":"算法的时间和空间性能非常重要\n一、算法的渐近分析 当 n 增大到一定值后，其他的常数项和低幂次项都可以忽略，只需确定是在什么量级（线性、n 方、指数级等）\n1. 大 $\\mathcal{O}$ 表式法 函数增长率上限\n2. 大 $\\Omega$ 表式法 函数增值率的下限\n3. 大 $\\Theta$ 表示法 当上、下限相同时则可用 $\\Theta$ 表示法\n二、增长率曲线 三、数据结构和算法的选择  仔细分析所要解决的问题  特别是求解问题所涉及的数据类型和数据间逻辑关系（问题抽象、数据抽象） 数据结构的初步设计往往先于算法设计   注意数据结构的可扩展性  考虑当输入数据的规模发生改变时，数据结构是否能够适应求解问题的演变和扩展    三、思考题   数据结构的三个要素任何一个发生改变，都是不同的数据结构，请举例讨论\n 双向链表和二叉树的存储结构其实是一样的，他们的不同在于逻辑结构。 数组和向量都是线性表，其存储形式不同，成为不同的数据结构。    算法设计目标是什么？\n 时间和空间的权衡 易读 易编码 易调试 易维护 易扩展    算法选择的过程？\n  要求在时间复杂度 $\\mathcal{O}(n)$、空间复杂度 $\\mathcal{O}(1)$，使数组元素循环向右移动 K 位\n  ","permalink":"https://874656645.github.io/posts/150-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E4%B8%8E%E5%BA%A6%E9%87%8F/","summary":"算法的时间和空间性能非常重要\n一、算法的渐近分析 当 n 增大到一定值后，其他的常数项和低幂次项都可以忽略，只需确定是在什么量级（线性、n 方、指数级等）\n1. 大 $\\mathcal{O}$ 表式法 函数增长率上限\n2. 大 $\\Omega$ 表式法 函数增值率的下限\n3. 大 $\\Theta$ 表示法 当上、下限相同时则可用 $\\Theta$ 表示法\n二、增长率曲线 三、数据结构和算法的选择  仔细分析所要解决的问题  特别是求解问题所涉及的数据类型和数据间逻辑关系（问题抽象、数据抽象） 数据结构的初步设计往往先于算法设计   注意数据结构的可扩展性  考虑当输入数据的规模发生改变时，数据结构是否能够适应求解问题的演变和扩展    三、思考题   数据结构的三个要素任何一个发生改变，都是不同的数据结构，请举例讨论\n 双向链表和二叉树的存储结构其实是一样的，他们的不同在于逻辑结构。 数组和向量都是线性表，其存储形式不同，成为不同的数据结构。    算法设计目标是什么？\n 时间和空间的权衡 易读 易编码 易调试 易维护 易扩展    算法选择的过程？\n  要求在时间复杂度 $\\mathcal{O}(n)$、空间复杂度 $\\mathcal{O}(1)$，使数组元素循环向右移动 K 位\n  ","title":"数据结构与算法——算法效率与度量"},{"content":"一、问题——算法——程序  问题：一个函数，从输入到输出在一种映射 算法：对特定问题求解过程的描述，是指令的有限序列 程序：算法在计算机程序设计语言中的具体实现  二、算法的特性  通用性：参数化的，能对一类问题进行参数化输入并问题求解 有效性：有限条有效指令组成的指令序列，保证计算结果的正确性 确定性：算法的下一步执行步骤必须明确 有穷性：执行必须在有限步内结束，不能有死循环  三、基本算法分类  穷举法：\n遍历每一个元素，比较低效，但是是一种万能的算法；对于一个问题，如果一时想不出好的算法的话，可对小规模数据采用穷举法剖析问题的特性和数据的特性，进而寻求更高效的算法 回溯、搜索：\n能进则进，不能进则换，不能换则退，如树和图的遍历 递归分治：\n二分查找，以及快速排序、归并排序，都是经典的分治算法思想 贪心法：\n其数据具有贪心性质，每次求解的时候都采用当前的最佳解，最终得到最优解，如 Huffman 编码树、最短路径 Dijkstra 算法、最小生成树 Prim 算法 动态规划：\n得到小规模问题的最优解，然后在更大规模的时候去组合这些最优解，最后得到全局的最优解，如图的两两结点之间最短路 Floyd 算法。要求具有最优子结构性质以及无后效性，动态规划的子结构有重叠，而递归分治子结构不重叠。  四、“监视哨”顺序检索 设置“监视哨”后，在查找过程中不用判断 i 是否越界，少一次判断，算法的运行效率会更高\n","permalink":"https://874656645.github.io/posts/149-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7%E5%8F%8A%E5%88%86%E7%B1%BB/","summary":"一、问题——算法——程序  问题：一个函数，从输入到输出在一种映射 算法：对特定问题求解过程的描述，是指令的有限序列 程序：算法在计算机程序设计语言中的具体实现  二、算法的特性  通用性：参数化的，能对一类问题进行参数化输入并问题求解 有效性：有限条有效指令组成的指令序列，保证计算结果的正确性 确定性：算法的下一步执行步骤必须明确 有穷性：执行必须在有限步内结束，不能有死循环  三、基本算法分类  穷举法：\n遍历每一个元素，比较低效，但是是一种万能的算法；对于一个问题，如果一时想不出好的算法的话，可对小规模数据采用穷举法剖析问题的特性和数据的特性，进而寻求更高效的算法 回溯、搜索：\n能进则进，不能进则换，不能换则退，如树和图的遍历 递归分治：\n二分查找，以及快速排序、归并排序，都是经典的分治算法思想 贪心法：\n其数据具有贪心性质，每次求解的时候都采用当前的最佳解，最终得到最优解，如 Huffman 编码树、最短路径 Dijkstra 算法、最小生成树 Prim 算法 动态规划：\n得到小规模问题的最优解，然后在更大规模的时候去组合这些最优解，最后得到全局的最优解，如图的两两结点之间最短路 Floyd 算法。要求具有最优子结构性质以及无后效性，动态规划的子结构有重叠，而递归分治子结构不重叠。  四、“监视哨”顺序检索 设置“监视哨”后，在查找过程中不用判断 i 是否越界，少一次判断，算法的运行效率会更高","title":"数据结构与算法——算法特性及分类"},{"content":"一、什么是数据结构   结构：实体 + 关系，比如分子结构，关系图等\n  数据结构：按照逻辑关系组织起来的一批数据，按一定的存储方法所把它存储在计算机中，并在这些数据上定义了一个运算的集合\n  二、数据的逻辑结构  线性结构\n线性表（表、栈、队列、串等） 非线性结构\n树（二叉树、Huffman树、二叉检索树等）\n图（有向图、无向图等） 图 ⊇ 树 ⊇ 二叉树 ⊇ 线性表  三、数据的存储结构   将逻辑结构的结点映射到内存中，每一个结点都对应一个唯一的连续存储区域\n  内存可以看作从低地址到高地址的一个编码的线性结构，可以根据地址立即访问想要访问的内存单元，不需要搜索\n  存储结构主要有顺序、链接、索引和散列四种形式\n 顺序存储对应于数组 链接存储对应于链表 索引是对数据建立一个索引表，通过这个表有效的找到相应数据的存储地址 散列是一种特殊的索引结构，本身也是一种存储结构，通过关键码的映射关系，在整个散列表中用单位时间快速地找到其存储地址    四、抽象数据类型 ADT（Abstract Data Type）  定义了一组运算的数学模型 与物理存储结构无关 使软件系统建立在数据之上(面向对象)  五、定义抽象数据类型 抽象数据类型就是在逻辑结构上的运算，可以理解为抽象数据结构二元组 \u0026lt;数据对象D, 数据操作P\u0026gt;\n先定义逻辑结构，再定义运算\n 逻辑结构：数据对象及其关系 运算：数据操作  就像面向对象语言中所定义的类（特别是抽象类），封装了数据成员和函数成员\n","permalink":"https://874656645.github.io/posts/148-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89/","summary":"一、什么是数据结构   结构：实体 + 关系，比如分子结构，关系图等\n  数据结构：按照逻辑关系组织起来的一批数据，按一定的存储方法所把它存储在计算机中，并在这些数据上定义了一个运算的集合\n  二、数据的逻辑结构  线性结构\n线性表（表、栈、队列、串等） 非线性结构\n树（二叉树、Huffman树、二叉检索树等）\n图（有向图、无向图等） 图 ⊇ 树 ⊇ 二叉树 ⊇ 线性表  三、数据的存储结构   将逻辑结构的结点映射到内存中，每一个结点都对应一个唯一的连续存储区域\n  内存可以看作从低地址到高地址的一个编码的线性结构，可以根据地址立即访问想要访问的内存单元，不需要搜索\n  存储结构主要有顺序、链接、索引和散列四种形式\n 顺序存储对应于数组 链接存储对应于链表 索引是对数据建立一个索引表，通过这个表有效的找到相应数据的存储地址 散列是一种特殊的索引结构，本身也是一种存储结构，通过关键码的映射关系，在整个散列表中用单位时间快速地找到其存储地址    四、抽象数据类型 ADT（Abstract Data Type）  定义了一组运算的数学模型 与物理存储结构无关 使软件系统建立在数据之上(面向对象)  五、定义抽象数据类型 抽象数据类型就是在逻辑结构上的运算，可以理解为抽象数据结构二元组 \u0026lt;数据对象D, 数据操作P\u0026gt;\n先定义逻辑结构，再定义运算\n 逻辑结构：数据对象及其关系 运算：数据操作  就像面向对象语言中所定义的类（特别是抽象类），封装了数据成员和函数成员","title":"数据结构与算法——数据结构定义"},{"content":"算法 + 数据结构 = 程序   数据结构与算法是程序的灵魂，以问题求解为导向，进行问题抽象、数据抽象、算法抽象，通过有效地组织数据、设计高效的算法、完成高质量的程序，从而解决实际应用的问题。\n  流程：问题 =\u0026gt; 数据 =\u0026gt; 算法\n  理论（离散数学、概率统计、图论等） =\u0026gt; 抽象（问题抽象、数据抽象、算法抽象等面向对象思想） =\u0026gt; 设计（实现的某种具体编程语言）\n  逻辑抽象 + 运算抽象 =\u0026gt; ADT\n  运算 + 存储 =\u0026gt; 算法分析（时间和空间复杂度）\n  问题抽象：分析和抽象任务需求，建立问题模型\n  数据抽象：确定恰当的数据结构表示数学模型\n  算法抽象：在数据模型的基础上设计合适的算法\n  ","permalink":"https://874656645.github.io/posts/147-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%80%E4%BB%8B/","summary":"算法 + 数据结构 = 程序   数据结构与算法是程序的灵魂，以问题求解为导向，进行问题抽象、数据抽象、算法抽象，通过有效地组织数据、设计高效的算法、完成高质量的程序，从而解决实际应用的问题。\n  流程：问题 =\u0026gt; 数据 =\u0026gt; 算法\n  理论（离散数学、概率统计、图论等） =\u0026gt; 抽象（问题抽象、数据抽象、算法抽象等面向对象思想） =\u0026gt; 设计（实现的某种具体编程语言）\n  逻辑抽象 + 运算抽象 =\u0026gt; ADT\n  运算 + 存储 =\u0026gt; 算法分析（时间和空间复杂度）\n  问题抽象：分析和抽象任务需求，建立问题模型\n  数据抽象：确定恰当的数据结构表示数学模型\n  算法抽象：在数据模型的基础上设计合适的算法\n  ","title":"数据结构与算法——简介"},{"content":"注意：这个对于单配置生成器是有效的，对于多配置生成器(例如Visual Studio)是无效的。因此在 Windows 平台，通过 MSYS 环境进行演示。\n默认情况下（Linux平台），CMake 的一个构建目录(build dir)只包含一个配置，可以是 Debug、Release、MinSizeRel 或 RelWithDebInfo。但是，可以通过设置 CPack 来绑定多个构建目录，并构造一个包含同一项目的多个配置的发行包。\n首先，我们希望确保 Debug 和 Release 构建对将要安装的可执行文件和库使用不同的名称。让我们使用 d 作为 Debug 可执行文件和库的后缀。在顶层 CMakeLists.txt 的开始部分添加 CMAKE_DEBUG_POSTFIX\n# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 设置 CMAKE_DEBUG_POSTFIX，指定后缀为 d set(CMAKE_DEBUG_POSTFIX d)然后在 Tutorial 可执行文件上添加属性 DEBUG_POSTFIX：\n# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# And the DEBUG_POSTFIX property on the tutorial executable set_target_properties(Tutorial PROPERTIES DEBUG_POSTFIX ${CMAKE_DEBUG_POSTFIX})为 MathFunctions 库添加版本号信息，在 Mathfunctions/CMakelists.txt 中，设置 VERSION 和 SOVERSION 属性：\n# add the library that runs add_library(MathFunctions MathFunctions.cxx)# 添加 版本信息 set_property(TARGET MathFunctions PROPERTY VERSION \u0026#34;1.0.0\u0026#34;)set_property(TARGET MathFunctions PROPERTY SOVERSION \u0026#34;1\u0026#34;)接下来分别对 Debug 和 Release 分别进行构建，在 build 时使用 CMAKE_BUILD_TYPE 参数设置配置类型：\nmkdir debug mkdir release cd debug cmake -G \u0026#34;MinGW Makefiles\u0026#34; -DCMAKE_BUILD_TYPE=Debug .. cmake --build . cd ../release cmake -G \u0026#34;MinGW Makefiles\u0026#34; -DCMAKE_BUILD_TYPE=Release .. cmake --build . 现在我们可以使用一个自定义的配置文件将两个构建包打包到一个单独的发行包中。在顶层目录创建 MultiCPackConfig.cmake 文件，首先包含由 cmake 创建的默认配置文件，接下来，使用 CPACK_INSTALL_CMAKE_PROJECTS 变量来指定要安装的项目。在本例中，我们希望同时安装 debug 和 release。\ninclude(\u0026#34;release/CPackConfig.cmake\u0026#34;)set(CPACK_INSTALL_CMAKE_PROJECTS \u0026#34;debug;Tutorial;ALL;/\u0026#34; \u0026#34;release;Tutorial;ALL;/\u0026#34; )最后在顶层目录中，运行 cpack，使用 config 选项指定我们的自定义配置文件：\ncpack --config MultiCPackConfig.cmake 注：可能会需要安装 nsis 包\npacman -S mingw-w64-ucrt-x86_64-nsis 在顶层目录会生成一个可安装发行包：\n安装后的目录结构：\n","permalink":"https://874656645.github.io/posts/146-cmake-%E6%89%93%E5%8C%85-debug-%E5%92%8C-release/","summary":"注意：这个对于单配置生成器是有效的，对于多配置生成器(例如Visual Studio)是无效的。因此在 Windows 平台，通过 MSYS 环境进行演示。\n默认情况下（Linux平台），CMake 的一个构建目录(build dir)只包含一个配置，可以是 Debug、Release、MinSizeRel 或 RelWithDebInfo。但是，可以通过设置 CPack 来绑定多个构建目录，并构造一个包含同一项目的多个配置的发行包。\n首先，我们希望确保 Debug 和 Release 构建对将要安装的可执行文件和库使用不同的名称。让我们使用 d 作为 Debug 可执行文件和库的后缀。在顶层 CMakeLists.txt 的开始部分添加 CMAKE_DEBUG_POSTFIX\n# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 设置 CMAKE_DEBUG_POSTFIX，指定后缀为 d set(CMAKE_DEBUG_POSTFIX d)然后在 Tutorial 可执行文件上添加属性 DEBUG_POSTFIX：\n# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# And the DEBUG_POSTFIX property on the tutorial executable set_target_properties(Tutorial PROPERTIES DEBUG_POSTFIX ${CMAKE_DEBUG_POSTFIX})为 MathFunctions 库添加版本号信息，在 Mathfunctions/CMakelists.txt 中，设置 VERSION 和 SOVERSION 属性：\n# add the library that runs add_library(MathFunctions MathFunctions.","title":"CMake 打包 Debug 和 Release"},{"content":"在安装和测试过程中，我们增加了 CMake 安装库文件和项目依赖的头文件(bin、lib、include)的能力。在打包可安装程序的过程中，我们增加了打包这些信息的能力，这样它就可以分发给其他人使用\n接下来是如何添加必要的信息，以便其他 CMake 项目可以使用我们的项目，无论是在构建目录、本地安装还是打包的时候\n第一步是更新我们的 install(TARGETS) 命令，不仅指定 DESTINATION，还指定 EXPORT。EXPORT 关键字生成一个 CMake 文件，其中包含从安装树导入安装命令中列出的所有目标的代码。\n修改 MathFunctions/CMakeLists.txt 文件代码：\n# install rules set(installable_libs MathFunctions tutorial_compiler_flags)if(TARGET SqrtLibrary) list(APPEND installable_libs SqrtLibrary)endif()install(TARGETS ${installable_libs} EXPORT MathFunctionsTargets DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)第二步我们还需要显式地安装生成的 MathFunctionsTargets.cmake 文件。在顶层的 CMakeLists.txt 文件底部添加如下代码：\ninstall(EXPORT MathFunctionsTargets FILE MathFunctionsTargets.cmake DESTINATION lib/cmake/MathFunctions )此时构建会有下面的错误：\n这是因为在生成导出信息期间，它将导出内在绑定到当前计算机项目的路径，在其他计算机上路径无效。\n第三步更新 MathFunctions/CMakeLists.txt 中的 target_include_directories() 用来设置在 build 时和在 install/package 时需要使用不同的 INTERFACE locations。\n# 将当前二进制目录添加到包含目录列表中 target_include_directories(MathFunctions # INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}  INTERFACE $\u0026lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}\u0026gt; $\u0026lt;INSTALL_INTERFACE:include\u0026gt; )第四步我们还需要生成一个 MathFunctionsConfig.cmake，这样 CMake 的 find_package() 命令就可以找到我们的项目。在顶层的项目目录添加 Config.cmake.in 配置文件，内容如下：\n@PACKAGE_INIT@ include ( \u0026#34;${CMAKE_CURRENT_LIST_DIR}/MathFunctionsTargets.cmake\u0026#34; )为了正确地配置和安装该文件，将以下内容添加到顶层 CMakeLists.txt 文件的底部\ninclude(CMakePackageConfigHelpers)然后，执行 configure_package_config_file() 命令，此命令会将 Config.cmake.in 配置文件中的 @PACKAGE_INIT@ 变量替换为一个代码块，该代码块将设置的值转换为相对路径\ninclude(CMakePackageConfigHelpers)# generate the config file that is includes the exports configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake\u0026#34; INSTALL_DESTINATION \u0026#34;lib/cmake/example\u0026#34; NO_SET_AND_CHECK_MACRO NO_CHECK_REQUIRED_COMPONENTS_MACRO )MathFunctionsConfig.cmake 文件内容：\n####### Expanded from @PACKAGE_INIT@ by configure_package_config_file() ####### ####### Any changes to this file will be overwritten by the next CMake run #### ####### The input file was Config.cmake.in ######## get_filename_component(PACKAGE_PREFIX_DIR \u0026#34;${CMAKE_CURRENT_LIST_DIR}/../../../\u0026#34; ABSOLUTE)#################################################################################### include ( \u0026#34;${CMAKE_CURRENT_LIST_DIR}/MathFunctionsTargets.cmake\u0026#34; )第五步生成 MathFunctionsConfigVersion.cmake 文件，该文件被 find_package 所使用，用于记录所需库安装包的版本和兼容性。通过添加 write_basic_package_version_file() 命令生成此文件\nwrite_basic_package_version_file( \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake\u0026#34; # 版本  VERSION \u0026#34;${Tutorial_VERSION_MAJOR}.${Tutorial_VERSION_MINOR}\u0026#34; # 指示此版本或任何更高版本与请求的版本兼容  COMPATIBILITY AnyNewerVersion )最后安装生成的配置文件：\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake ${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake DESTINATION lib/cmake/MathFunctions )如果我们希望我们的项目也从构建目录中使用，我们只需要在顶层 CMakeLists.txt 的底部添加以下内容\nexport(EXPORT MathFunctionsTargets FILE \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsTargets.cmake\u0026#34; )顶层 CMakeLists.txt 完整代码如下：\n# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.15)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 # set(CMAKE_CXX_STANDARD 11) # set(CMAKE_CXX_STANDARD_REQUIRED True) add_library(tutorial_compiler_flags INTERFACE)target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)# add compiler warning flags just when building this project via # the BUILD_INTERFACE genex set(gcc_like_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC\u0026gt;\u0026#34;)set(msvc_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,MSVC\u0026gt;\u0026#34;)target_compile_options(tutorial_compiler_flags INTERFACE \u0026#34;$\u0026lt;${gcc_like_cxx}:$\u0026lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused\u0026gt;\u0026gt;\u0026#34; \u0026#34;$\u0026lt;${msvc_cxx}:$\u0026lt;BUILD_INTERFACE:-W3\u0026gt;\u0026gt;\u0026#34; )# control where the static and shared libraries are built so that on windows # we don\u0026#39;t need to tinker with the path to run the executable # 指定静态库和动态库的生成路径 set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)# 生成共享库选项 option(BUILD_SHARED_LIBS \u0026#34;Build using shared libraries\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加编译子模块 MathFunctions library add_subdirectory(MathFunctions)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# 依赖共享库 MathFunctions target_link_libraries(Tutorial PUBLIC MathFunctions)# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )# enable dashboard scripting include(CTest)# does the application run add_test(NAME Runs COMMAND Tutorial 25)# does the usage message work? add_test(NAME Usage COMMAND Tutorial)set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION \u0026#34;Usage:.*number\u0026#34; )# define a function to simplify adding tests function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction()# do a bunch of result based tests do_test(Tutorial 4 \u0026#34;4 is 2\u0026#34;)do_test(Tutorial 9 \u0026#34;9 is 3\u0026#34;)do_test(Tutorial 5 \u0026#34;5 is 2.236\u0026#34;)do_test(Tutorial 7 \u0026#34;7 is 2.645\u0026#34;)do_test(Tutorial 25 \u0026#34;25 is 5\u0026#34;)do_test(Tutorial -25 \u0026#34;-25 is (-nan|nan|0)\u0026#34;)do_test(Tutorial 0.0001 \u0026#34;0.0001 is 0.01\u0026#34;)## Packaging an Installer # 此模块将打包项目当前平台所需的任何运行时库 include(InstallRequiredSystemLibraries)set(CPACK_RESOURCE_FILE_LICENSE \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/License.txt\u0026#34;)set(CPACK_PACKAGE_VERSION_MAJOR \u0026#34;${Tutorial_VERSION_MAJOR}\u0026#34;)set(CPACK_PACKAGE_VERSION_MINOR \u0026#34;${Tutorial_VERSION_MINOR}\u0026#34;)set(CPACK_SOURCE_GENERATOR \u0026#34;TGZ\u0026#34;)include(CPack)## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026#34; DESTINATION include )install(EXPORT MathFunctionsTargets FILE MathFunctionsTargets.cmake DESTINATION lib/cmake/MathFunctions )include(CMakePackageConfigHelpers)# generate the config file that is includes the exports # 生成 cmake 配置文件 configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake\u0026#34; INSTALL_DESTINATION \u0026#34;lib/cmake/example\u0026#34; NO_SET_AND_CHECK_MACRO NO_CHECK_REQUIRED_COMPONENTS_MACRO )write_basic_package_version_file( \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake\u0026#34; # 版本  VERSION \u0026#34;${Tutorial_VERSION_MAJOR}.${Tutorial_VERSION_MINOR}\u0026#34; # 指示此版本或任何更高版本与请求的版本兼容  COMPATIBILITY AnyNewerVersion )install(FILES ${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake ${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake DESTINATION lib/cmake/MathFunctions )# If we want our project to also be used from a build directory export(EXPORT MathFunctionsTargets FILE \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsTargets.cmake\u0026#34; )MathFunctions/CMakeLists.txt 完整代码：\n# add the library that runs add_library(MathFunctions MathFunctions.cxx)# 生成导出库的宏定义文件 # include(GenerateExportHeader) # generate_export_header(MathFunctions) # 将当前二进制目录添加到包含目录列表中 target_include_directories(MathFunctions # INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}  INTERFACE $\u0026lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}\u0026gt; $\u0026lt;INSTALL_INTERFACE:include\u0026gt; )# 通过 tutorial_compiler_flags 指定 MathFunctions 动态库的编译参数设置 target_link_libraries(MathFunctions PUBLIC tutorial_compiler_flags)# should we use our own math functions # 是否使用 USE_MYMATH 选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)if(USE_MYMATH) # 设置程序中使用到的宏定义  target_compile_definitions(MathFunctions PRIVATE \u0026#34;USE_MYMATH\u0026#34;) # first we add the executable that generates the table  add_executable(MakeTable MakeTable.cxx) # 通过 tutorial_compiler_flags 指定 MakeTable 可执行程序的编译参数设置  target_link_libraries(MakeTable PRIVATE tutorial_compiler_flags) # add the command to generate the source code  add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable ) # 添加静态库  # library that just does sqrt  add_library(SqrtLibrary STATIC mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h ) # state that we depend on our binary dir to find Table.h  target_include_directories(SqrtLibrary PRIVATE ${CMAKE_CURRENT_BINARY_DIR} )  # state that SqrtLibrary need PIC(position independent code) when the default is shared libraries  # 如果将一个没有位置独立代码(position independent code)的静态库与一个有位置独立代码的库组合在一起使用，  # 就要显示设置目标的属性，否则会有链接错误  set_target_properties(SqrtLibrary PROPERTIES POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS} )  # 通过 tutorial_compiler_flags 指定 SqrtLibrary 静态库的编译参数设置  target_link_libraries(SqrtLibrary PRIVATE tutorial_compiler_flags) target_link_libraries(MathFunctions PRIVATE SqrtLibrary)endif()# define the symbol stating we are using the declspec(dllexport) when # building on windows # 声明dll导出宏定义 target_compile_definitions(MathFunctions PRIVATE \u0026#34;EXPORTING_MYMATH\u0026#34;)# install rules set(installable_libs MathFunctions tutorial_compiler_flags)if(TARGET SqrtLibrary) list(APPEND installable_libs SqrtLibrary)endif()install(TARGETS ${installable_libs} # generates a CMake file containing code to import all targets listed in the install command from the installation tree  EXPORT MathFunctionsTargets DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)","permalink":"https://874656645.github.io/posts/145-cmake-%E6%B7%BB%E5%8A%A0%E5%AF%BC%E5%87%BA%E9%85%8D%E7%BD%AE/","summary":"在安装和测试过程中，我们增加了 CMake 安装库文件和项目依赖的头文件(bin、lib、include)的能力。在打包可安装程序的过程中，我们增加了打包这些信息的能力，这样它就可以分发给其他人使用\n接下来是如何添加必要的信息，以便其他 CMake 项目可以使用我们的项目，无论是在构建目录、本地安装还是打包的时候\n第一步是更新我们的 install(TARGETS) 命令，不仅指定 DESTINATION，还指定 EXPORT。EXPORT 关键字生成一个 CMake 文件，其中包含从安装树导入安装命令中列出的所有目标的代码。\n修改 MathFunctions/CMakeLists.txt 文件代码：\n# install rules set(installable_libs MathFunctions tutorial_compiler_flags)if(TARGET SqrtLibrary) list(APPEND installable_libs SqrtLibrary)endif()install(TARGETS ${installable_libs} EXPORT MathFunctionsTargets DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)第二步我们还需要显式地安装生成的 MathFunctionsTargets.cmake 文件。在顶层的 CMakeLists.txt 文件底部添加如下代码：\ninstall(EXPORT MathFunctionsTargets FILE MathFunctionsTargets.cmake DESTINATION lib/cmake/MathFunctions )此时构建会有下面的错误：\n这是因为在生成导出信息期间，它将导出内在绑定到当前计算机项目的路径，在其他计算机上路径无效。\n第三步更新 MathFunctions/CMakeLists.txt 中的 target_include_directories() 用来设置在 build 时和在 install/package 时需要使用不同的 INTERFACE locations。\n# 将当前二进制目录添加到包含目录列表中 target_include_directories(MathFunctions # INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}  INTERFACE $\u0026lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}\u0026gt; $\u0026lt;INSTALL_INTERFACE:include\u0026gt; )第四步我们还需要生成一个 MathFunctionsConfig.cmake，这样 CMake 的 find_package() 命令就可以找到我们的项目。在顶层的项目目录添加 Config.","title":"CMake 添加导出配置"},{"content":" target_compile_features target_compile_options COMPILE_LANG_AND_ID BUILD_INTERFACE  生成器表达式(Generator expressions)允许在许多目标属性的上下文中使用，比如 LINK LIBRARIES、INCLUDE DIRECTORIES、COMPILE DEFINITIONS 等。当使用命令来填充这些属性时，它们也可以被使用，例如 target_link_libraries()、target_include_directories()、target_compile_definitions() 等。\n生成器表达式可以用于启用条件链接、编译时使用的条件定义、条件包含目录等。这些条件可能基于构建配置、目标属性、平台信息或任何其他可查询的信息。\n有不同类型的生成器表达式，包括逻辑表达式、信息表达式和输出表达式。\n逻辑表达式用于创建条件输出。基本的表达式是 0 和 1 表达式。\n生成器表达式的一个常见用法是有条件地添加编译器标志，比如那些用于语言级别或警告的标志。一个很好的模式是将该信息关联到一个 INTERFACE 目标，从而允许该信息传播。让我们先构造一个接口目标，并指定所需的 c++ 标准 11，而不是使用 CMAKE CXX 标准。\n# 指定 C++ 标准 # set(CMAKE_CXX_STANDARD 11) # set(CMAKE_CXX_STANDARD_REQUIRED True) # 将上面的代码替换为 add_library(tutorial_compiler_flags INTERFACE)target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)接下来，我们为项目添加所需的编译器警告标志。由于警告标志因编译器的不同而不同，我们使用 COMPILE_LANG_AND_ID 生成器表达式来控制给定语言和一组编译器 ID 要应用哪些标志（注：将要使用的生成器表达式是在 3.15 中引入的，所以要更新 cmake_minimum_required 的版本为 3.15），如下所示：\nset(gcc_like_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC\u0026gt;\u0026#34;)set(msvc_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,MSVC\u0026gt;\u0026#34;)target_compile_options(tutorial_compiler_flags INTERFACE \u0026#34;$\u0026lt;${gcc_like_cxx}:$\u0026lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused\u0026gt;\u0026gt;\u0026#34; \u0026#34;$\u0026lt;${msvc_cxx}:$\u0026lt;BUILD_INTERFACE:-W3\u0026gt;\u0026gt;\u0026#34; )我们看到警告标志被封装在一个 BUILD_INTERFACE 条件中。这样做是为了让我们已安装项目的使用者不会继承我们的警告标志。\n修改 Mathfunctions/cmakelists.txt，以便所有编译目标都有一个 target_link_libraries() 调用我们设置的编译条件标识 tutorial_compiler_flags。\n# add the library that runs add_library(MathFunctions MathFunctions.cxx)# include(GenerateExportHeader) # generate_export_header(MathFunctions) # 将当前二进制目录添加到包含目录列表中 target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} )# 通过 tutorial_compiler_flags 指定 MathFunctions 动态库的编译参数设置 target_link_libraries(MathFunctions PUBLIC tutorial_compiler_flags)# should we use our own math functions # 是否使用 USE_MYMATH 选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)if(USE_MYMATH) # 设置程序中使用到的宏定义  target_compile_definitions(MathFunctions PRIVATE \u0026#34;USE_MYMATH\u0026#34;) # first we add the executable that generates the table  add_executable(MakeTable MakeTable.cxx) # 通过 tutorial_compiler_flags 指定 MakeTable 可执行程序的编译参数设置  target_link_libraries(MakeTable PRIVATE tutorial_compiler_flags) # add the command to generate the source code  add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable ) # 添加静态库  # library that just does sqrt  add_library(SqrtLibrary STATIC mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h ) # state that we depend on our binary dir to find Table.h  target_include_directories(SqrtLibrary PRIVATE ${CMAKE_CURRENT_BINARY_DIR} )  # state that SqrtLibrary need PIC(position independent code) when the default is shared libraries  # 如果将一个没有位置独立代码(position independent code)的静态库与一个有位置独立代码的库组合在一起使用，  # 就要显示设置目标的属性，否则会有链接错误  set_target_properties(SqrtLibrary PROPERTIES POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS} )  # 通过 tutorial_compiler_flags 指定 SqrtLibrary 静态库的编译参数设置  target_link_libraries(SqrtLibrary PRIVATE tutorial_compiler_flags) target_link_libraries(MathFunctions PRIVATE SqrtLibrary)endif()# define the symbol stating we are using the declspec(dllexport) when # building on windows # 声明dll导出宏定义 target_compile_definitions(MathFunctions PRIVATE \u0026#34;EXPORTING_MYMATH\u0026#34;)# install rules set(installable_libs MathFunctions)if(TARGET SqrtLibrary) list(APPEND installable_libs SqrtLibrary)endif()install(TARGETS ${installable_libs} DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)","permalink":"https://874656645.github.io/posts/144-cmake-%E6%B7%BB%E5%8A%A0%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"target_compile_features target_compile_options COMPILE_LANG_AND_ID BUILD_INTERFACE  生成器表达式(Generator expressions)允许在许多目标属性的上下文中使用，比如 LINK LIBRARIES、INCLUDE DIRECTORIES、COMPILE DEFINITIONS 等。当使用命令来填充这些属性时，它们也可以被使用，例如 target_link_libraries()、target_include_directories()、target_compile_definitions() 等。\n生成器表达式可以用于启用条件链接、编译时使用的条件定义、条件包含目录等。这些条件可能基于构建配置、目标属性、平台信息或任何其他可查询的信息。\n有不同类型的生成器表达式，包括逻辑表达式、信息表达式和输出表达式。\n逻辑表达式用于创建条件输出。基本的表达式是 0 和 1 表达式。\n生成器表达式的一个常见用法是有条件地添加编译器标志，比如那些用于语言级别或警告的标志。一个很好的模式是将该信息关联到一个 INTERFACE 目标，从而允许该信息传播。让我们先构造一个接口目标，并指定所需的 c++ 标准 11，而不是使用 CMAKE CXX 标准。\n# 指定 C++ 标准 # set(CMAKE_CXX_STANDARD 11) # set(CMAKE_CXX_STANDARD_REQUIRED True) # 将上面的代码替换为 add_library(tutorial_compiler_flags INTERFACE)target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)接下来，我们为项目添加所需的编译器警告标志。由于警告标志因编译器的不同而不同，我们使用 COMPILE_LANG_AND_ID 生成器表达式来控制给定语言和一组编译器 ID 要应用哪些标志（注：将要使用的生成器表达式是在 3.15 中引入的，所以要更新 cmake_minimum_required 的版本为 3.15），如下所示：\nset(gcc_like_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC\u0026gt;\u0026#34;)set(msvc_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,MSVC\u0026gt;\u0026#34;)target_compile_options(tutorial_compiler_flags INTERFACE \u0026#34;$\u0026lt;${gcc_like_cxx}:$\u0026lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused\u0026gt;\u0026gt;\u0026#34; \u0026#34;$\u0026lt;${msvc_cxx}:$\u0026lt;BUILD_INTERFACE:-W3\u0026gt;\u0026gt;\u0026#34; )我们看到警告标志被封装在一个 BUILD_INTERFACE 条件中。这样做是为了让我们已安装项目的使用者不会继承我们的警告标志。\n修改 Mathfunctions/cmakelists.txt，以便所有编译目标都有一个 target_link_libraries() 调用我们设置的编译条件标识 tutorial_compiler_flags。","title":"CMake 添加生成器表达式"},{"content":" 将原来的 静态库 MathFunctions拆分为动态库 MathFunctions.dll 和静态库 SqrtLibrary.lib 两个库。MathFunctions.dll 动态库会使用 SqrtLibrary.lib 静态库。 BUILD_SHARED_LIBS  在顶层的 CMakeLists.txt 文件中添加 BUILD_SHARED_LIBS，如果这个标记存在且为真，则将导致所有库都被构建为共享库，除非该库被显式地设置为静态库。这个变量通常作为 option() 添加到项目中，以便项目的每个用户可以决定他们是要使用共享库还是静态库构建项目。\n顶层的 CMakeLists.txt 文件修改如下：\n# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.2)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# control where the static and shared libraries are built so that on windows # we don\u0026#39;t need to tinker with the path to run the executable # 指定静态库和动态库的生成路径 set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)# 生成共享库选项 option(BUILD_SHARED_LIBS \u0026#34;Build using shared libraries\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加编译子模块 MathFunctions library add_subdirectory(MathFunctions)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# 依赖共享库 MathFunctions target_link_libraries(Tutorial PUBLIC MathFunctions)# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026#34; DESTINATION include )# enable dashboard scripting include(CTest)# does the application run add_test(NAME Runs COMMAND Tutorial 25)# does the usage message work? add_test(NAME Usage COMMAND Tutorial)set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION \u0026#34;Usage:.*number\u0026#34; )# define a function to simplify adding tests function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction()# do a bunch of result based tests do_test(Tutorial 4 \u0026#34;4 is 2\u0026#34;)do_test(Tutorial 9 \u0026#34;9 is 3\u0026#34;)do_test(Tutorial 5 \u0026#34;5 is 2.236\u0026#34;)do_test(Tutorial 7 \u0026#34;7 is 2.645\u0026#34;)do_test(Tutorial 25 \u0026#34;25 is 5\u0026#34;)do_test(Tutorial -25 \u0026#34;-25 is (-nan|nan|0)\u0026#34;)do_test(Tutorial 0.0001 \u0026#34;0.0001 is 0.01\u0026#34;)## Packaging an Installer # 此模块将打包项目当前平台所需的任何运行时库 include(InstallRequiredSystemLibraries)set(CPACK_RESOURCE_FILE_LICENSE \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/License.txt\u0026#34;)set(CPACK_PACKAGE_VERSION_MAJOR \u0026#34;${Tutorial_VERSION_MAJOR}\u0026#34;)set(CPACK_PACKAGE_VERSION_MINOR \u0026#34;${Tutorial_VERSION_MINOR}\u0026#34;)set(CPACK_SOURCE_GENERATOR \u0026#34;TGZ\u0026#34;)include(CPack)在 Mathfunctions/Cmakelists.txt 中，我们需要创建一个 Sqrtlibrary，当启用 USE_MYMATH 时，将有条件地构建和安装。\n# add the library that runs add_library(MathFunctions MathFunctions.cxx)# 将当前二进制目录添加到包含目录列表中 target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} )# should we use our own math functions # 是否使用 USE_MYMATH 选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)if(USE_MYMATH) # 设置程序中使用到的宏定义  target_compile_definitions(MathFunctions PRIVATE \u0026#34;USE_MYMATH\u0026#34;) # first we add the executable that generates the table  add_executable(MakeTable MakeTable.cxx) # add the command to generate the source code  add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable ) # 添加静态库  # library that just does sqrt  add_library(SqrtLibrary STATIC mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h ) # state that we depend on our binary dir to find Table.h  target_include_directories(SqrtLibrary PRIVATE ${CMAKE_CURRENT_BINARY_DIR} )  # state that SqrtLibrary need PIC(position independent code) when the default is shared libraries  # 如果将一个没有位置独立代码(position independent code)的静态库与一个有位置独立代码的库组合在一起使用，  # 就要显示设置目标的属性，否则会有链接错误  set_target_properties(SqrtLibrary PROPERTIES POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS} ) target_link_libraries(MathFunctions PRIVATE SqrtLibrary)endif()# define the symbol stating we are using the declspec(dllexport) when # building on windows # 声明dll导出宏定义 target_compile_definitions(MathFunctions PRIVATE \u0026#34;EXPORTING_MYMATH\u0026#34;)# install rules # 安装规则 set(installable_libs MathFunctions)if(TARGET SqrtLibrary) list(APPEND installable_libs SqrtLibrary)endif()install(TARGETS ${installable_libs} DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)","permalink":"https://874656645.github.io/posts/143-cmake-%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/","summary":"将原来的 静态库 MathFunctions拆分为动态库 MathFunctions.dll 和静态库 SqrtLibrary.lib 两个库。MathFunctions.dll 动态库会使用 SqrtLibrary.lib 静态库。 BUILD_SHARED_LIBS  在顶层的 CMakeLists.txt 文件中添加 BUILD_SHARED_LIBS，如果这个标记存在且为真，则将导致所有库都被构建为共享库，除非该库被显式地设置为静态库。这个变量通常作为 option() 添加到项目中，以便项目的每个用户可以决定他们是要使用共享库还是静态库构建项目。\n顶层的 CMakeLists.txt 文件修改如下：\n# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.2)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# control where the static and shared libraries are built so that on windows # we don\u0026#39;t need to tinker with the path to run the executable # 指定静态库和动态库的生成路径 set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;)# 生成共享库选项 option(BUILD_SHARED_LIBS \u0026#34;Build using shared libraries\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.","title":"CMake 静态库和动态库混合使用"},{"content":"向仪表板提交测试结果 1. 修改最上层的 CMakeLists.txt 文件 将 enable_testing() 替换为 include(CTest)，CTest 模块会自动调用 enable_testing()\n# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026#34; DESTINATION include )# enable dashboard scripting include(CTest)# does the application run add_test(NAME Runs COMMAND Tutorial 25)# does the usage message work? add_test(NAME Usage COMMAND Tutorial)set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION \u0026#34;Usage:.*number\u0026#34; )# define a function to simplify adding tests function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction()# do a bunch of result based tests do_test(Tutorial 4 \u0026#34;4 is 2\u0026#34;)do_test(Tutorial 9 \u0026#34;9 is 3\u0026#34;)do_test(Tutorial 5 \u0026#34;5 is 2.236\u0026#34;)do_test(Tutorial 7 \u0026#34;7 is 2.645\u0026#34;)do_test(Tutorial 25 \u0026#34;25 is 5\u0026#34;)do_test(Tutorial -25 \u0026#34;-25 is (-nan|nan|0)\u0026#34;)do_test(Tutorial 0.0001 \u0026#34;0.0001 is 0.01\u0026#34;)## Packaging an Installer # 此模块将打包项目当前平台所需的任何运行时库 include(InstallRequiredSystemLibraries)set(CPACK_RESOURCE_FILE_LICENSE \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/License.txt\u0026#34;)set(CPACK_PACKAGE_VERSION_MAJOR \u0026#34;${Tutorial_VERSION_MAJOR}\u0026#34;)set(CPACK_PACKAGE_VERSION_MINOR \u0026#34;${Tutorial_VERSION_MINOR}\u0026#34;)set(CPACK_SOURCE_GENERATOR \u0026#34;TGZ\u0026#34;)include(CPack)2. 添加 CTestConfig.cmake 文件 在顶级目录中添加 CTestConfig.cmake 文件，在这个文件里为 CTest 指定关于项目的信息，CTest 可执行文件在运行时将读取这个文件\n# 项目名称 set(CTEST_PROJECT_NAME \u0026#34;CMakeTutorial\u0026#34;)# 24 小时制 set(CTEST_NIGHTLY_START_TIME \u0026#34;00:00:00 EST\u0026#34;)# 发送提交生成的文档的CDash实例的URL set(CTEST_DROP_METHOD \u0026#34;http\u0026#34;)set(CTEST_DROP_SITE \u0026#34;my.cdash.org\u0026#34;)set(CTEST_DROP_LOCATION \u0026#34;/submit.php?project=CMakeTutorial\u0026#34;)set(CTEST_DROP_SITE_CDASH TRUE)3. 执行 ctest 命令 在 build 目录下运行命令：\n ctest [-VV] -D Experimental ctest [-VV] -C Debug -D Experimental  4. 查看数据 CTest 可执行文件将构建和测试项目并将结果提交给 Kitware 的公共仪表板：https://my.cdash.org/index.php?project=cmaketutorial\n","permalink":"https://874656645.github.io/posts/142-cmake-%E6%B7%BB%E5%8A%A0%E5%AF%B9%E6%B5%8B%E8%AF%95%E4%BB%AA%E8%A1%A8%E6%9D%BF%E7%9A%84%E6%94%AF%E6%8C%81/","summary":"向仪表板提交测试结果 1. 修改最上层的 CMakeLists.txt 文件 将 enable_testing() 替换为 include(CTest)，CTest 模块会自动调用 enable_testing()\n# 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.","title":"CMake 添加对测试仪表板的支持"},{"content":" 可以在各种平台上提供二进制和源代码发行版。 InstallRequiredSystemLibraries CPack  一、需要在顶层 CMakeLists.txt 文件的底部添加几行代码 # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026#34; DESTINATION include )## 测试 enable_testing()# does the application run add_test(NAME Runs COMMAND Tutorial 25)# does the usage message work? add_test(NAME Usage COMMAND Tutorial)set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION \u0026#34;Usage:.*number\u0026#34; )# define a function to simplify adding tests function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction()# do a bunch of result based tests do_test(Tutorial 4 \u0026#34;4 is 2\u0026#34;)do_test(Tutorial 9 \u0026#34;9 is 3\u0026#34;)do_test(Tutorial 5 \u0026#34;5 is 2.236\u0026#34;)do_test(Tutorial 7 \u0026#34;7 is 2.645\u0026#34;)do_test(Tutorial 25 \u0026#34;25 is 5\u0026#34;)do_test(Tutorial -25 \u0026#34;-25 is (-nan|nan|0)\u0026#34;)do_test(Tutorial 0.0001 \u0026#34;0.0001 is 0.01\u0026#34;)## Packaging an Installer # 此模块将打包项目当前平台所需的任何运行时库 include(InstallRequiredSystemLibraries)# 设置一些 CPack 变量来存储这个项目的许可证和版本信息 set(CPACK_RESOURCE_FILE_LICENSE \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/License.txt\u0026#34;)set(CPACK_PACKAGE_VERSION_MAJOR \u0026#34;${Tutorial_VERSION_MAJOR}\u0026#34;)set(CPACK_PACKAGE_VERSION_MINOR \u0026#34;${Tutorial_VERSION_MINOR}\u0026#34;)# 为源包选择一种文件格式 # ZIP (.zip) # TGZ (.tar.gz) # TBZ2 (.tar.bz2) # 等格式 set(CPACK_SOURCE_GENERATOR \u0026#34;TGZ\u0026#34;)include(CPack)二、像往常一样 build 工程 cmake --build . --config Release\n三、执行打包命令  cpack：构建二进制发行版 cpack -G ZIP -C Debug：指定发行包的文件格式和配置类型 cpack --config CPackSourceConfig.cmake：打包带有源码的可发行包  ","permalink":"https://874656645.github.io/posts/141-cmake-%E6%89%93%E5%8C%85%E5%8F%AF%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F/","summary":"可以在各种平台上提供二进制和源代码发行版。 InstallRequiredSystemLibraries CPack  一、需要在顶层 CMakeLists.txt 文件的底部添加几行代码 # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.","title":"CMake 打包可安装程序"},{"content":" add_custom_command  MathFunctions 工程的 CMakeLists.txt # 添加可执行程序 MakeTable add_executable(MakeTable MakeTable.cxx)# 添加一个自定义命令，指定如何通过运行 MakeTable 生成 Table.h add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable )# 将生成的 Table.h 添加到库 MathFunctions 的源代码列表 add_library(MathFunctions mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h )# 将当前二进制目录添加到包含目录列表中，这样 Table.h 才能被 mysqrt.cxx 找到并包含 target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} PRIVATE ${CMAKE_CURRENT_BINARY_DIR} )install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)install(FILES ${CMAKE_CURRENT_BINARY_DIR}/Table.h DESTINATION include)生成的 Table.h 文件 double sqrtTable[] = { 0, 1, 1.41421, 1.73205, 2, 2.23607, 2.44949, 2.64575, 2.82843, 3, 0}; Tutorial.exe 运行结果 .\\Release\\Tutorial.exe 4.8 Use the table to help find an initial value Computing sqrt of 4.8 to be 2.2 Computing sqrt of 4.8 to be 2.19091 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 Computing sqrt of 4.8 to be 2.19089 The square root of 4.8 is 2.19089 ","permalink":"https://874656645.github.io/posts/140-cmake-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E5%92%8C%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/","summary":"add_custom_command  MathFunctions 工程的 CMakeLists.txt # 添加可执行程序 MakeTable add_executable(MakeTable MakeTable.cxx)# 添加一个自定义命令，指定如何通过运行 MakeTable 生成 Table.h add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable )# 将生成的 Table.h 添加到库 MathFunctions 的源代码列表 add_library(MathFunctions mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h )# 将当前二进制目录添加到包含目录列表中，这样 Table.h 才能被 mysqrt.cxx 找到并包含 target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} PRIVATE ${CMAKE_CURRENT_BINARY_DIR} )install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)install(FILES ${CMAKE_CURRENT_BINARY_DIR}/Table.h DESTINATION include)生成的 Table.h 文件 double sqrtTable[] = { 0, 1, 1.41421, 1.73205, 2, 2.23607, 2.44949, 2.64575, 2.82843, 3, 0}; Tutorial.","title":"CMake 添加自定义命令和生成文件"},{"content":" CheckSymbolExists: 考虑在项目中添加一些代码，这些代码依赖于目标平台可能没有的特性 target_compile_definitions  add_library(MathFunctions mysqrt.cxx)target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})# does this system provide the log and exp functions? include(CheckSymbolExists)check_symbol_exists(log \u0026#34;math.h\u0026#34; HAVE_LOG)check_symbol_exists(exp \u0026#34;math.h\u0026#34; HAVE_EXP)# 如果平台中没有找到 log 和 exp，我们需要链接到 m 库 if(NOT (HAVE_LOG AND HAVE_EXP)) unset(HAVE_LOG CACHE) unset(HAVE_EXP CACHE) # 设置 m 库并再次尝试  set(CMAKE_REQUIRED_LIBRARIES \u0026#34;m\u0026#34;) check_symbol_exists(log \u0026#34;math.h\u0026#34; HAVE_LOG) check_symbol_exists(exp \u0026#34;math.h\u0026#34; HAVE_EXP) if(HAVE_LOG AND HAVE_EXP) target_link_libraries(MathFunctions PRIVATE m) endif()endif()# 如果可用，使用 target_compile_definitions() 指定 HAVE LOG 和 HAVE EXP 作为私有编译定义 # 在项目配置 预处理器定义中添加 HAVE LOG 和 HAVE EXP 两个宏定义 if(HAVE_LOG AND HAVE_EXP) target_compile_definitions(MathFunctions PRIVATE \u0026#34;HAVE_LOG\u0026#34; \u0026#34;HAVE_EXP\u0026#34;)endif()# install install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)修改 mysqrt 函数：\ndouble mysqrt(double x) { if (x \u0026lt;= 0) { return 0; } #if defined(HAVE_LOG) \u0026amp;\u0026amp; defined(HAVE_EXP)  double result = exp(log(x) * 0.5); std::cout \u0026lt;\u0026lt; \u0026#34;Computing sqrt of \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; to be \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; \u0026#34; using log and exp\u0026#34; \u0026lt;\u0026lt; std::endl; #else  double result = x; // do ten iterations  for (int i = 0; i \u0026lt; 10; ++i) { if (result \u0026lt;= 0) { result = 0.1; } double delta = x - (result * result); result = result + 0.5 * delta / result; std::cout \u0026lt;\u0026lt; \u0026#34;Computing sqrt of \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; to be \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } #endif  return result; } ","permalink":"https://874656645.github.io/posts/139-cmake-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%87%AA%E6%A3%80/","summary":"CheckSymbolExists: 考虑在项目中添加一些代码，这些代码依赖于目标平台可能没有的特性 target_compile_definitions  add_library(MathFunctions mysqrt.cxx)target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})# does this system provide the log and exp functions? include(CheckSymbolExists)check_symbol_exists(log \u0026#34;math.h\u0026#34; HAVE_LOG)check_symbol_exists(exp \u0026#34;math.h\u0026#34; HAVE_EXP)# 如果平台中没有找到 log 和 exp，我们需要链接到 m 库 if(NOT (HAVE_LOG AND HAVE_EXP)) unset(HAVE_LOG CACHE) unset(HAVE_EXP CACHE) # 设置 m 库并再次尝试  set(CMAKE_REQUIRED_LIBRARIES \u0026#34;m\u0026#34;) check_symbol_exists(log \u0026#34;math.h\u0026#34; HAVE_LOG) check_symbol_exists(exp \u0026#34;math.h\u0026#34; HAVE_EXP) if(HAVE_LOG AND HAVE_EXP) target_link_libraries(MathFunctions PRIVATE m) endif()endif()# 如果可用，使用 target_compile_definitions() 指定 HAVE LOG 和 HAVE EXP 作为私有编译定义 # 在项目配置 预处理器定义中添加 HAVE LOG 和 HAVE EXP 两个宏定义 if(HAVE_LOG AND HAVE_EXP) target_compile_definitions(MathFunctions PRIVATE \u0026#34;HAVE_LOG\u0026#34; \u0026#34;HAVE_EXP\u0026#34;)endif()# install install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.","title":"CMake 添加系统自检"},{"content":"Install Rules 在库的 CMakeLists.txt 文件末尾添加 install\nadd_library(MathFunctions mysqrt.cxx)target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)在顶层 CMakeLists.txt 的末尾添加\n... ... ## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026#34; DESTINATION include )Testing Support 在顶层 CMakeLists.txt 的末尾添加\n... ... ## 测试 enable_testing()# does the application run add_test(NAME Runs COMMAND Tutorial 25)# does the usage message work? add_test(NAME Usage COMMAND Tutorial)# 设置校验信息 set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION \u0026#34;Usage:.*number\u0026#34; )# define a function to simplify adding tests function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction()# do a bunch of result based tests do_test(Tutorial 4 \u0026#34;4 is 2\u0026#34;)do_test(Tutorial 9 \u0026#34;9 is 3\u0026#34;)do_test(Tutorial 5 \u0026#34;5 is 2.236\u0026#34;)do_test(Tutorial 7 \u0026#34;7 is 2.645\u0026#34;)do_test(Tutorial 25 \u0026#34;25 is 5\u0026#34;)do_test(Tutorial -25 \u0026#34;-25 is (-nan|nan|0)\u0026#34;)do_test(Tutorial 0.0001 \u0026#34;0.0001 is 0.01\u0026#34;)","permalink":"https://874656645.github.io/posts/138-cmake-%E5%AE%89%E8%A3%85%E5%92%8C%E6%B5%8B%E8%AF%95/","summary":"Install Rules 在库的 CMakeLists.txt 文件末尾添加 install\nadd_library(MathFunctions mysqrt.cxx)target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.h DESTINATION include)在顶层 CMakeLists.txt 的末尾添加\n... ... ## 安装 install(TARGETS Tutorial DESTINATION bin)install(FILES \u0026#34;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026#34; DESTINATION include )Testing Support 在顶层 CMakeLists.txt 的末尾添加\n... ... ## 测试 enable_testing()# does the application run add_test(NAME Runs COMMAND Tutorial 25)# does the usage message work? add_test(NAME Usage COMMAND Tutorial)# 设置校验信息 set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION \u0026#34;Usage:.*number\u0026#34; )# define a function to simplify adding tests function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction()# do a bunch of result based tests do_test(Tutorial 4 \u0026#34;4 is 2\u0026#34;)do_test(Tutorial 9 \u0026#34;9 is 3\u0026#34;)do_test(Tutorial 5 \u0026#34;5 is 2.","title":"CMake 安装和测试"},{"content":"添加依赖库和使用条件 CMakeLists.txt  注意编译选项、生成配置文件和条件编译三部分的顺序  # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions) list(APPEND EXTRA_INCLUDES \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34;)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; ${EXTRA_INCLUDES} )子模块（库）的 CMakeLists.txt 文件 add_library(MathFunctions mysqrt.cxx)TutorialConfig.h.in // 版本号配置信息 #define TUTORIAL_VERSION_MAJOR @Tutorial_VERSION_MAJOR@ #define TUTORIAL_VERSION_MINOR @Tutorial_VERSION_MINOR@ // 程序中使用到的宏定义 #cmakedefine USE_MYMATH 程序中的宏定义使用 #ifdef USE_MYMATH #include \u0026#34;MathFunctions.h\u0026#34;#endif  ... ... #ifdef USE_MYMATH  const double outputValue = mysqrt(inputValue); #else  const double outputValue = sqrt(inputValue); #endif 添加库的使用需求   在子模块（库）的 CMakeLists.txt 文件末尾添加\nadd_library(MathFunctions mysqrt.cxx)target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} ) INTERFACE means things that consumers require but the producer doesn\u0026rsquo;t    在上层 CMakeLists.txt 文件中就可以不添加 EXTRA_INCLUDES 了\n... ... if(USE_MYMATH)add_subdirectory(MathFunctions)list(APPEND EXTRA_LIBS MathFunctions)# list(APPEND EXTRA_INCLUDES \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34;) endif()... ... target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; )  ","permalink":"https://874656645.github.io/posts/137-cmake-%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%BA%93%E5%92%8C%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6/","summary":"添加依赖库和使用条件 CMakeLists.txt  注意编译选项、生成配置文件和条件编译三部分的顺序  # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 3.1)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 设置编译选项 option(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON)# 生成一个头文件，传递 CMake 的一些设置到源代码 configure_file(TutorialConfig.h.in TutorialConfig.h)# 添加 MathFunctions library # add_subdirectory(MathFunctions) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions) list(APPEND EXTRA_INCLUDES \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34;)endif()# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# target_link_libraries(Tutorial PUBLIC MathFunctions) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# 添加头文件查找路径 # target_include_directories(Tutorial PUBLIC # \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; # \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; # ) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; ${EXTRA_INCLUDES} )子模块（库）的 CMakeLists.txt 文件 add_library(MathFunctions mysqrt.","title":"CMake 添加依赖库和使用条件"},{"content":"CMakeList # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 2.0)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 生成一个头文件，传递 CMake 的一些设置到源代码 configue_file(TutorialConfig.h.in TutorialConfig.h)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# 添加头文件查找路径 target_include_directories(Tutorial PUBLIC \u0026#34;$(PROJECT_BINARY_DIR)\u0026#34;)TutorialConfig.h.in // #define TUTORIAL_VERSION_MAJOR @Tutorial_VERSION_MAJOR@ #define TUTORIAL_VERSION_MINOR @Tutorial_VERSION_MINOR@ ","permalink":"https://874656645.github.io/posts/136-cmake-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92%E8%AE%BE%E7%BD%AE%E4%BF%A1%E6%81%AF/","summary":"CMakeList # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 2.0)# 指定 C++ 标准 set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 生成一个头文件，传递 CMake 的一些设置到源代码 configue_file(TutorialConfig.h.in TutorialConfig.h)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)# 添加头文件查找路径 target_include_directories(Tutorial PUBLIC \u0026#34;$(PROJECT_BINARY_DIR)\u0026#34;)TutorialConfig.h.in // #define TUTORIAL_VERSION_MAJOR @Tutorial_VERSION_MAJOR@ #define TUTORIAL_VERSION_MINOR @Tutorial_VERSION_MINOR@ ","title":"CMake 配置文件传递设置信息"},{"content":"一、CMakeLists.txt 文件示例 # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 1.0)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)二、CMake 相关命令   cmake .. 含有 CMakeLists.txt 文件的路径，根据 CMakeLists.txt 文件构建对应的工程；\n  cmake .. -DUSE_MYMATH=OFF 将 CMake 编译选项 USE_MYMATH 设置为关闭状态，并构建工程\n  cmake .. -DCMAKE_BUILD_TYPE=Release 在Linux中设定 Release 版本，可设置的类型有 Debug、MinSizeRel、Release、RelWithDebInfo\n  指定编译工具为 MSVC（不同的 CMake 版本，命令写法不同）：\ncmake -G \u0026#34;Visual Studio 14 2015 Win64\u0026#34; cmake -G \u0026#34;Visual Studio 16 2019\u0026#34; -A x64 cmake -G \u0026#34;Visual Studio 16 2019\u0026#34; -A Win32   在 Windows 中使用 MinGW\ncmake -G \u0026#34;MinGW Makefiles\u0026#34; -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ -DCMAKE_SYSROOT=D:/msys64/ucrt64/bin .. cmake -G \u0026#34;MinGW Makefiles\u0026#34; -DCMAKE_BUILD_TYPE=Debug -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ .. cmake -G \u0026#34;MinGW Makefiles\u0026#34; -DCMAKE_BUILD_TYPE=Debug ..   cmake --install . --prefix \u0026quot;E:/VSCode-Projects/CMake/Install\u0026quot; 指定安装路径，在 Windows 中，如果不指定 --prefix 参数，64位默认会安装到 C:\\Program Files\n  cpack --config CPackSourceConfig.cmake：创建完整源代码树和 build 的压缩包\n  Windows  cmake --build . 在当前目录编译成二进制文件，默认是 Debug cmake --build . --config Release 编译 Release ctest -C Release -VV 参数 -VV 输出详细信息，可不加。对于多配置生成器(例如Visual Studio)，配置类型必须用 -C \u0026lt;mode\u0026gt; 标志来指定 cpack -G ZIP -C Debug：要指定生成器，请使用 -G 选项。对于多配置构建，使用 -C 来指定配置 ctest [-VV] -C Debug -D Experimental：向仪表板提交测试结果  Linux  make 进行编译 ctest -N 和 ctest -VV 测试 cpack ctest [-VV] -D Experimental：向仪表板提交测试结果  ","permalink":"https://874656645.github.io/posts/135-cmake-%E4%BD%BF%E7%94%A8/","summary":"一、CMakeLists.txt 文件示例 # 设置CMake版本最低要求 cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本 project(Tutorial VERSION 1.0)# 添加源码文件和生成的目标文件的名称 add_executable(Tutorial main.cpp)二、CMake 相关命令   cmake .. 含有 CMakeLists.txt 文件的路径，根据 CMakeLists.txt 文件构建对应的工程；\n  cmake .. -DUSE_MYMATH=OFF 将 CMake 编译选项 USE_MYMATH 设置为关闭状态，并构建工程\n  cmake .. -DCMAKE_BUILD_TYPE=Release 在Linux中设定 Release 版本，可设置的类型有 Debug、MinSizeRel、Release、RelWithDebInfo\n  指定编译工具为 MSVC（不同的 CMake 版本，命令写法不同）：\ncmake -G \u0026#34;Visual Studio 14 2015 Win64\u0026#34; cmake -G \u0026#34;Visual Studio 16 2019\u0026#34; -A x64 cmake -G \u0026#34;Visual Studio 16 2019\u0026#34; -A Win32   在 Windows 中使用 MinGW","title":"CMake 使用"},{"content":"哈希表及处理冲突的方法\n一、哈希法与哈希表  哈希法又称散列法、杂凑法以及关键字地址计算法等，相应的表称为哈希表。 这种方法的基本思想是：首先在元素的关键字 k 和元素的存储位置 p 之间建立一个对应关系 f，使得 p = f(k)，f 称为哈希函数。 创建哈希表时，把关键字为 k 的元素直接存入地址为 f(k) 的单元；以后当查找关键字为 k 的元素时，再利用哈希函数计算出该元素的存储位置 p=f(k)，从而达到按关键字直接存取元素的目的。  二、冲突 当关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，即 k1 ≠ k2，但 f(k1) = f(k2)，这种现象称为冲突，此时称 k1 和 k2 为同义词。\n三、哈希函数构造方法 构造哈希函数的原则是：\n 函数本身便于计算； 计算出来的地址分布均匀，即对任一关键字 k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突  常用的构造方法：\n 数字分析法 平方取中法 分段叠加法 除留余数法：假设哈希表长为 m，p 为小于等于 m 的最大素数，则哈希函数为 f(k)=k % p 伪随机数法  四、冲突处理方法 1. 开放地址法（Open addressing） 这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi\n 线性探测 二次探测 伪随机探测  线性探测再散列的优点是：只要哈希表不满，就一定能找到一个不冲突的哈希地址，而二次探测再散列和伪随机探测再散列则不一定；缺点是线性探测再散列容易产生二次聚集\n2. 再哈希法 这种方法是同时构造多个不同的哈希函数，当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间\n3. 开链法（Separate chaining） 这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i 个单元中，因而查找、插入和删除主要在同义词链中进行。同义词较多时可以考虑使用红黑树替代链表。链地址法适用于经常进行插入和删除的情况\n4. 建立公共溢出区 将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表\n","permalink":"https://874656645.github.io/posts/134-%E5%93%88%E5%B8%8C%E6%B3%95%E4%B8%8E%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/","summary":"哈希表及处理冲突的方法\n一、哈希法与哈希表  哈希法又称散列法、杂凑法以及关键字地址计算法等，相应的表称为哈希表。 这种方法的基本思想是：首先在元素的关键字 k 和元素的存储位置 p 之间建立一个对应关系 f，使得 p = f(k)，f 称为哈希函数。 创建哈希表时，把关键字为 k 的元素直接存入地址为 f(k) 的单元；以后当查找关键字为 k 的元素时，再利用哈希函数计算出该元素的存储位置 p=f(k)，从而达到按关键字直接存取元素的目的。  二、冲突 当关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，即 k1 ≠ k2，但 f(k1) = f(k2)，这种现象称为冲突，此时称 k1 和 k2 为同义词。\n三、哈希函数构造方法 构造哈希函数的原则是：\n 函数本身便于计算； 计算出来的地址分布均匀，即对任一关键字 k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突  常用的构造方法：\n 数字分析法 平方取中法 分段叠加法 除留余数法：假设哈希表长为 m，p 为小于等于 m 的最大素数，则哈希函数为 f(k)=k % p 伪随机数法  四、冲突处理方法 1. 开放地址法（Open addressing） 这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi\n 线性探测 二次探测 伪随机探测  线性探测再散列的优点是：只要哈希表不满，就一定能找到一个不冲突的哈希地址，而二次探测再散列和伪随机探测再散列则不一定；缺点是线性探测再散列容易产生二次聚集\n2. 再哈希法 这种方法是同时构造多个不同的哈希函数，当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间","title":"哈希法与冲突处理"},{"content":"一、结论  C 中将数据类型分为左值和右值，在 C++11 中又将右值概念更为细致的分为将亡值（xvalue）和纯右值（prvalue）。 将亡值是 C++11 新增的跟右值引用相关的表达式，通常是将要被移动的对象（移为他用），比如返回右值引用 T\u0026amp;\u0026amp; 的函数返回值、std::move 的返回值。 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。 右值引用可以直接指向右值，也可以通过 std::move 指向左值；而左值引用只能指向左值（const左值引用也能指向右值）。 作为函数形参时，右值引用更灵活。虽然 const 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。 可移动对象在需要拷贝且被拷贝者之后不再被需要的场景，建议使用 std::move 触发移动语义，提升性能。 我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和 std::move 的语言特性。 std::move 本身只做类型转换，对性能无影响。 std::forward 同样也是做类型转换且更强大，move 只能转出来右值，forward 既可以转成右值，又可以转成左值。 函数最好不要返回函数体内局部变量的左值引用或右值引用。  二、注意事项  左值引用是具名变量值的别名 右值引用是不具名（匿名）变量的别名    引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值，但是，const左值引用是可以指向右值的\nconst int \u0026amp;ref_a = 5; int a = 5; int \u0026amp;ref_a = a; // 左值引用指向左值，编译通过 int \u0026amp;ref_a = 5; // 左值引用指向了右值，会编译失败   右值引用的标志是 \u0026amp;\u0026amp;，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值\nint\u0026amp;\u0026amp; ref_a_right = 5; // ok int a = 5; int\u0026amp;\u0026amp; ref_a_left = a; // 编译不过，右值引用不可以指向左值  ref_a_right = 6; // 右值引用的用途：可以修改右值   事实上 std::move 移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(lvalue)。 所以，单纯的 std::move(xxx) 不会有性能提升，从这个角度来讲，右值引用和左值引用的功能相似，都是原始变量的别名，至于移动后原始变量是否可用，取决于被移动的数据类型对于移动语义的具体实现。\n案例一：\nint a = 5; // a是个左值 int \u0026amp;ref_a_left = a; // 左值引用指向左值 int \u0026amp;\u0026amp;ref_a_right = std::move(a); // 通过std::move将左值转化为右值，可以被右值引用指向 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 打印结果：5 ref_a_right = 10; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 打印结果：10 ref_a_left = 20; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 打印结果：20 // 这三个变量的地址都相同 案例二：\nclass Person{ public: int m_age{20}; }; void test(Person\u0026amp;\u0026amp; p){ cout \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; \u0026amp;p \u0026lt;\u0026lt; endl; } void test1(Person\u0026amp; p){ cout \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; \u0026amp;p \u0026lt;\u0026lt; endl; } int main() { Person pp; cout \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; \u0026amp;pp \u0026lt;\u0026lt; endl; test(move(pp)); cout \u0026lt;\u0026lt; pp.m_age \u0026lt;\u0026lt; endl; test1(pp); return 0; } 输出： main 0x7ffc06f34444 test 0x7ffc06f34444 20 test1 0x7ffc06f34444   被声明出来的左、右值引用都是左值。因为被声明出的左右值引用是有地址的，也位于等号左边。\n// 形参是个右值引用 void change(int\u0026amp;\u0026amp; right_value) { right_value = 8; } int main() { int a = 5; // a是个左值  int \u0026amp;ref_a_left = a; // ref_a_left是个左值引用  int \u0026amp;\u0026amp;ref_a_right = std::move(a); // ref_a_right是个右值引用  cout \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026amp;ref_a_left \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026amp;ref_a_right; // 打印这三个左值的地址，都是一样的  // error: cannot bind rvalue reference of type ‘int\u0026amp;\u0026amp;’ to lvalue of type ‘int’  // change(a); // 编译不过，a是左值，change参数要求右值  // change(ref_a_left); // 编译不过，左值引用ref_a_left本身也是个左值  // change(ref_a_right); // 编译不过，右值引用ref_a_right本身也是个左值  change(std::move(a)); // 编译通过  change(std::move(ref_a_right)); // 编译通过  change(std::move(ref_a_left)); // 编译通过  change(5); // 当然可以直接接右值，编译通过 }   右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值。\n  三、std::forward std::forward\u0026lt;T\u0026gt;(u) 有两个参数：T 与 u\n a. 当 T 显示为左值引用类型时，u 将被转换为 T 类型的左值； b. 否则 u 将被转换为 T 类型右值  void change2(int\u0026amp;\u0026amp; ref_r) { ref_r = 1; } void change3(int\u0026amp; ref_l) { ref_l = 1; } // change的入参是右值引用 // 有名字的右值引用是 左值，因此ref_r是左值 void change(int\u0026amp;\u0026amp; ref_r) { // error: cannot bind rvalue reference of type ‘int\u0026amp;\u0026amp;’ to lvalue of type ‘int’  // change2(ref_r); // 错误，change2的入参是右值引用，需要接右值，ref_r是左值，编译失败  change2(std::move(ref_r)); // ok，std::move把左值转为右值，编译通过  change2(std::forward\u0026lt;int\u0026amp;\u0026amp;\u0026gt;(ref_r)); // ok，std::forward的T是右值引用类型(int \u0026amp;\u0026amp;)，符合条件b，因此u(ref_r)会被转换为右值，编译通过  change2(std::forward\u0026lt;int\u0026gt;(ref_r)); // ok，std::forward的T是int类型，属于条件b，因此会把ref_r转为右值  change3(ref_r); // ok，change3的入参是左值引用，需要接左值，ref_r是左值，编译通过  change3(std::forward\u0026lt;int\u0026amp;\u0026gt;(ref_r)); // ok，std::forward的T是左值引用类型(int \u0026amp;)，符合条件a，因此u(ref_r)会被转换为左值，编译通过  // 可见，forward可以把值转换为左值或者右值 } int main() { int a = 5; change(std::move(a)); } 四、自定义类支持移动语义 编译器会默认在用户自定义的 class 和 struct 中生成移动语义函数，但前提是符合用户类默认的移动构造/移动赋值的启用条件，系统默认的移动语义函数更像是一种引用（原始变量的别名）。\nif (定义了 拷贝构造函数 、 拷贝赋值运算符 或 析构函数) { 不会合成移动构造函数和移动赋值运算符。此时会使用对应 拷贝 操作来代替 移动 } else if (类的所有成员都可以移动) { 则会为类合成移动构造函数或移动赋值运算符。 } else { 合成拷贝构造函数和拷贝复制运算符。 } C++11 对于特殊成员函数处理的规则如下：\n 默认构造函数：和 C++98 规则相同。仅当类不存在用户声明的构造函数时才自动生成。 析构函数：基本上和 C++98 相同；稍微不同的是现在析构默认 noexcept。和 C++98 一样，仅当基类析构为虚函数时该类析构才为虚函数。 拷贝构造函数：和 C++98 运行时行为一样：逐成员拷贝 non-static 数据。仅当类没有用户定义的拷贝构造时才生成。如果类声明了移动操作它就是 delete 的。当用户声明了拷贝赋值或者析构，该函数自动生成已被废弃。 拷贝赋值运算符：和 C++98 运行时行为一样：逐成员拷贝赋值 non-static 数据。仅当类没有用户定义的拷贝赋值时才生成。如果类声明了移动操作它就是 delete 的。当用户声明了拷贝构造或者析构，该函数自动生成已被废弃。 移动构造函数和移动赋值运算符：都对非 static 数据执行逐成员移动。仅当类没有用户定义的拷贝操作，移动操作或析构时才自动生成。  class Person{ public: Person():m_age(new int(20)){ cout \u0026lt;\u0026lt; \u0026#34;Construct: \u0026#34; \u0026lt;\u0026lt; ++n_cstr \u0026lt;\u0026lt; endl; } ~Person(){ delete m_age; cout \u0026lt;\u0026lt; \u0026#34;Destruct: \u0026#34; \u0026lt;\u0026lt; ++n_dstr \u0026lt;\u0026lt; endl; } Person(const Person\u0026amp; p):m_age(new int(*p.m_age)){ cout \u0026lt;\u0026lt; \u0026#34;Copy construct: \u0026#34; \u0026lt;\u0026lt; ++n_cptr \u0026lt;\u0026lt; endl; } Person(Person\u0026amp;\u0026amp; p){ m_age = std::exchange(p.m_age, nullptr); cout \u0026lt;\u0026lt; \u0026#34;Move construct: \u0026#34; \u0026lt;\u0026lt; ++n_mvtr \u0026lt;\u0026lt; endl; } Person\u0026amp; operator=(const Person\u0026amp; p){ *m_age = *p.m_age; cout \u0026lt;\u0026lt; \u0026#34;operator=(const Person\u0026amp; p)...\u0026#34; \u0026lt;\u0026lt; endl; return *this; } Person\u0026amp; operator=(Person\u0026amp;\u0026amp; p){ if(m_age) delete m_age; m_age = std::exchange(p.m_age, nullptr); cout \u0026lt;\u0026lt; \u0026#34;operator=(Person\u0026amp;\u0026amp; p)...\u0026#34; \u0026lt;\u0026lt; endl; return *this; } int* m_age{nullptr}; static int n_cstr; static int n_dstr; static int n_cptr; static int n_mvtr; }; int Person::n_cstr = 0; int Person::n_dstr = 0; int Person::n_cptr = 0; int Person::n_mvtr = 0; Person GetPerson(){ Person p; cout \u0026lt;\u0026lt; *p.m_age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Resource from \u0026#34; \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; return p; } int main(int argc, const char* argv[]){ Person p = GetPerson(); cout \u0026lt;\u0026lt; *p.m_age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Resource from \u0026#34; \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; return 0; } 输出：\nConstruct: 1 20 Resource from GetPerson: 000001D5C8D85990 Move construct: 1 Destruct: 1 20 Resource from main: 000001D5C8D85990 Destruct: 2 参考：\n 认识 C++ 移动语义与右值引用 一文读懂 C++ 右值引用和 std::move  ","permalink":"https://874656645.github.io/posts/133-c++11-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/","summary":"一、结论  C 中将数据类型分为左值和右值，在 C++11 中又将右值概念更为细致的分为将亡值（xvalue）和纯右值（prvalue）。 将亡值是 C++11 新增的跟右值引用相关的表达式，通常是将要被移动的对象（移为他用），比如返回右值引用 T\u0026amp;\u0026amp; 的函数返回值、std::move 的返回值。 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。 右值引用可以直接指向右值，也可以通过 std::move 指向左值；而左值引用只能指向左值（const左值引用也能指向右值）。 作为函数形参时，右值引用更灵活。虽然 const 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。 可移动对象在需要拷贝且被拷贝者之后不再被需要的场景，建议使用 std::move 触发移动语义，提升性能。 我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和 std::move 的语言特性。 std::move 本身只做类型转换，对性能无影响。 std::forward 同样也是做类型转换且更强大，move 只能转出来右值，forward 既可以转成右值，又可以转成左值。 函数最好不要返回函数体内局部变量的左值引用或右值引用。  二、注意事项  左值引用是具名变量值的别名 右值引用是不具名（匿名）变量的别名    引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值，但是，const左值引用是可以指向右值的\nconst int \u0026amp;ref_a = 5; int a = 5; int \u0026amp;ref_a = a; // 左值引用指向左值，编译通过 int \u0026amp;ref_a = 5; // 左值引用指向了右值，会编译失败   右值引用的标志是 \u0026amp;\u0026amp;，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值\nint\u0026amp;\u0026amp; ref_a_right = 5; // ok int a = 5; int\u0026amp;\u0026amp; ref_a_left = a; // 编译不过，右值引用不可以指向左值  ref_a_right = 6; // 右值引用的用途：可以修改右值   事实上 std::move 移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(lvalue)。 所以，单纯的 std::move(xxx) 不会有性能提升，从这个角度来讲，右值引用和左值引用的功能相似，都是原始变量的别名，至于移动后原始变量是否可用，取决于被移动的数据类型对于移动语义的具体实现。","title":"C++11 左值、右值和移动语义"},{"content":"一、auto_ptr 特点  支持拷贝构造 支持赋值拷贝 支持 operator-\u0026gt;/operator* 解引用 支持指针变量重置 保证指针持有者唯一（涉及所有权转移）  二、问题一：使用数组存储 auto_ptr std::vector\u0026lt;std::auto_ptr\u0026lt;People\u0026gt;\u0026gt; peoples; // 这里实例化多个people并保存到数组中 ... std::auto_ptr\u0026lt;People\u0026gt; one = peoples[5]; ... std::cout \u0026lt;\u0026lt; peoples[5]-\u0026gt;get_name() \u0026lt;\u0026lt; std::endl; 原因在于 std::auto_ptr 支持 operator=，为了确保指针所有者唯一，这里转移了所有权，people[5] 变成了 null\n三、问题二、函数传参 auto_ptr 类型 void do_somthing(std::auto_ptr\u0026lt;People\u0026gt; people){ // 该函数内不对people变量执行各种隐式/显示的所有权转移和释放  ... } std::auto_ptr\u0026lt;People\u0026gt; people(new People(\u0026#34;jony\u0026#34;)); do_something(people); ... std::cout \u0026lt;\u0026lt; people-\u0026gt;get_name() \u0026lt;\u0026lt; std::endl; 原因在于 std::auto_ptr支持拷贝构造，为了确保指针所有者唯一，这里转移了所有权\n四、unique_ptr 在11中，可以支持右值以及移动语义了，此时可以完全匹配auto_ptr的所有权管理，新增了 std::unique_ptr。std::unique_ptr 不仅加入了移动语义的支持，同时也关闭了左值拷贝构造和左值赋值功能！杜绝了上述场景的出现！但是，此时，需要使用其他的方案了。比如场景一中，std::unique_ptr类型变量不能使用vector保存了！\n所以 std::auto_ptr 废弃了，由 std::unique_ptr 代替！\nclass Person{ public: int getAge()const{ return m_age; } void setAge(int age){ m_age = age; } private: int m_age{20}; }; unique_ptr\u0026lt;Person\u0026gt; Change(unique_ptr\u0026lt;Person\u0026gt; p){ p-\u0026gt;setAge(30); return p; } int main() { unique_ptr\u0026lt;Person\u0026gt; pP(new Person); cout \u0026lt;\u0026lt; pP-\u0026gt;getAge() \u0026lt;\u0026lt; endl; // unique_ptr\u0026lt;Person\u0026gt; pP2 = Change(pP); // error： unique_ptr 删除了拷贝构造，所以需要使用 move 关键字转移所有权  unique_ptr\u0026lt;Person\u0026gt; pP2 = Change(move(pP)); // pP = pP2; // error：unique_ptr 删除了 = 赋值构造  cout \u0026lt;\u0026lt; \u0026#34;-------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pP2-\u0026gt;getAge() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-------------\u0026#34; \u0026lt;\u0026lt; endl; if(pP == nullptr){ cout \u0026lt;\u0026lt; \u0026#34;pP 变量已失效\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输出：\n20 ------------- 30 ------------- pP 变量已失效 ","permalink":"https://874656645.github.io/posts/131-c++11-auto_ptr-%E8%A2%AB%E5%BA%9F%E5%BC%83%E4%B8%8E-unique_ptr/","summary":"一、auto_ptr 特点  支持拷贝构造 支持赋值拷贝 支持 operator-\u0026gt;/operator* 解引用 支持指针变量重置 保证指针持有者唯一（涉及所有权转移）  二、问题一：使用数组存储 auto_ptr std::vector\u0026lt;std::auto_ptr\u0026lt;People\u0026gt;\u0026gt; peoples; // 这里实例化多个people并保存到数组中 ... std::auto_ptr\u0026lt;People\u0026gt; one = peoples[5]; ... std::cout \u0026lt;\u0026lt; peoples[5]-\u0026gt;get_name() \u0026lt;\u0026lt; std::endl; 原因在于 std::auto_ptr 支持 operator=，为了确保指针所有者唯一，这里转移了所有权，people[5] 变成了 null\n三、问题二、函数传参 auto_ptr 类型 void do_somthing(std::auto_ptr\u0026lt;People\u0026gt; people){ // 该函数内不对people变量执行各种隐式/显示的所有权转移和释放  ... } std::auto_ptr\u0026lt;People\u0026gt; people(new People(\u0026#34;jony\u0026#34;)); do_something(people); ... std::cout \u0026lt;\u0026lt; people-\u0026gt;get_name() \u0026lt;\u0026lt; std::endl; 原因在于 std::auto_ptr支持拷贝构造，为了确保指针所有者唯一，这里转移了所有权\n四、unique_ptr 在11中，可以支持右值以及移动语义了，此时可以完全匹配auto_ptr的所有权管理，新增了 std::unique_ptr。std::unique_ptr 不仅加入了移动语义的支持，同时也关闭了左值拷贝构造和左值赋值功能！杜绝了上述场景的出现！但是，此时，需要使用其他的方案了。比如场景一中，std::unique_ptr类型变量不能使用vector保存了！\n所以 std::auto_ptr 废弃了，由 std::unique_ptr 代替！\nclass Person{ public: int getAge()const{ return m_age; } void setAge(int age){ m_age = age; } private: int m_age{20}; }; unique_ptr\u0026lt;Person\u0026gt; Change(unique_ptr\u0026lt;Person\u0026gt; p){ p-\u0026gt;setAge(30); return p; } int main() { unique_ptr\u0026lt;Person\u0026gt; pP(new Person); cout \u0026lt;\u0026lt; pP-\u0026gt;getAge() \u0026lt;\u0026lt; endl; // unique_ptr\u0026lt;Person\u0026gt; pP2 = Change(pP); // error： unique_ptr 删除了拷贝构造，所以需要使用 move 关键字转移所有权  unique_ptr\u0026lt;Person\u0026gt; pP2 = Change(move(pP)); // pP = pP2; // error：unique_ptr 删除了 = 赋值构造  cout \u0026lt;\u0026lt; \u0026#34;-------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pP2-\u0026gt;getAge() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-------------\u0026#34; \u0026lt;\u0026lt; endl; if(pP == nullptr){ cout \u0026lt;\u0026lt; \u0026#34;pP 变量已失效\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输出：","title":"C++11 auto_ptr 被废弃与 unique_ptr"},{"content":"一、修饰类成员变量 此关键字只能应用于类的非静态和非常量数据成员，mutable 是为了让 const 对象的某些数据成员可以被修改。static 是类的成员，不属于对象，常对象和常函数只会限制类的成员变量修改，所以类的 static 数据成员不需要 mutable 修饰，在常对象和常函数中也能被修改。\nclass Person{ public: int getAge() const{ m_count++; s_count++; return m_age; } int getCount()const{ return m_count; } private: int m_age{20}; mutable int m_count{0}; public: static int s_count; }; int Person::s_count = 0; int main() { Person p; p.getAge(); p.getAge(); p.getAge(); cout \u0026lt;\u0026lt; p.getCount() \u0026lt;\u0026lt; endl; // 3  cout \u0026lt;\u0026lt; p.s_count \u0026lt;\u0026lt; endl; // 3  return 0; } 二、修饰匿名函数 表示可以修改按值传入的变量的副本（不是值本身），类似于不带 const 关键字的形参。使用 mutable 关键字后对按值传入的变量进行的修改，不会将改变传递到 Lambda 表达式之外。如果不加 mutable 关键字，按值传入的变量是只读的，即使在 Lambda 表达式内部也不可修改\nint main () { int x = 1; int y = 1; int z; cout \u0026lt;\u0026lt; \u0026#34;x1: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty1: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; z = [=]() mutable -\u0026gt; int { ++x; ++y; cout \u0026lt;\u0026lt; \u0026#34;x2: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty2: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; return x + y; }(); cout \u0026lt;\u0026lt; \u0026#34;x3: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty3: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;z: \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; return 0; } 输出：\nx1: 1\ty1: 1 x2: 2\ty2: 2 x3: 1\ty3: 1 z: 4 ","permalink":"https://874656645.github.io/posts/132-c++11-mutable-%E5%85%B3%E9%94%AE%E5%AD%97/","summary":"一、修饰类成员变量 此关键字只能应用于类的非静态和非常量数据成员，mutable 是为了让 const 对象的某些数据成员可以被修改。static 是类的成员，不属于对象，常对象和常函数只会限制类的成员变量修改，所以类的 static 数据成员不需要 mutable 修饰，在常对象和常函数中也能被修改。\nclass Person{ public: int getAge() const{ m_count++; s_count++; return m_age; } int getCount()const{ return m_count; } private: int m_age{20}; mutable int m_count{0}; public: static int s_count; }; int Person::s_count = 0; int main() { Person p; p.getAge(); p.getAge(); p.getAge(); cout \u0026lt;\u0026lt; p.getCount() \u0026lt;\u0026lt; endl; // 3  cout \u0026lt;\u0026lt; p.s_count \u0026lt;\u0026lt; endl; // 3  return 0; } 二、修饰匿名函数 表示可以修改按值传入的变量的副本（不是值本身），类似于不带 const 关键字的形参。使用 mutable 关键字后对按值传入的变量进行的修改，不会将改变传递到 Lambda 表达式之外。如果不加 mutable 关键字，按值传入的变量是只读的，即使在 Lambda 表达式内部也不可修改","title":"C++11 mutable 关键字"},{"content":"一、进行自动类型推导  auto 的自动类型推断发生在编译期，所以使用 auto 并不会造成程序运行时效率的降低。 而是否会造成编译期的时间消耗，我认为是不会的，在未使用 auto 时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换。 auto 属于类类型推导 decltype 是包含声明修饰符的声明类型推导  int main() { int a = 10; auto val = a; cout \u0026lt;\u0026lt; typeid(val).name() \u0026lt;\u0026lt; endl; // i  return 0; } 二、在定义函数模板时，用于声明依赖模板参数的变量类型 不到编译的时候，x * y 的真正类型很难确定\ntemplate \u0026lt;class _Tx,class _Ty\u0026gt; void Multiply(_Tx x, _Ty y) { auto v = x * y; std::cout \u0026lt;\u0026lt; v; } int main() { int a = 10; double b = 1.53; Multiply(a, b); // 15.3  return 0; } 三、函数模板返回值依赖于模板参数 auto 在这里的作用也称为返回值占位，真正的返回值是后面的 decltype(x * y)。为何要将返回值后置呢？如果没有后置，则函数声明时为：decltype(x * y) multiply(_Tx x, _Ty y)，而此时 x, y 还没声明呢，编译无法通过。\ntemplate \u0026lt;class _Tx,class _Ty\u0026gt; auto Multiply(_Tx x, _Ty y) -\u0026gt; decltype(x * y) { return x * y; } int main() { int a = 10; double b = 1.53; cout \u0026lt;\u0026lt; Multiply(a, b) \u0026lt;\u0026lt; endl; return 0; } 四、与匿名函数结合使用 int main() { auto f = [](int a, int b) -\u0026gt; int { return a * b; }; decltype(f) g = f; // lambda 的类型是独有且无名的  // 也不用定义函数指针了  cout \u0026lt;\u0026lt; typeid(f).name() \u0026lt;\u0026lt; endl; auto i = f(2, 2); decltype(g(3, 3)) j = g(3, 3); cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; \u0026#34;j = \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 输出：\nZ4mainEUliiE_ i = 4, j = 9 五、auto 注意事项   auto 变量必须在声明时初始化，这类似于 const 关键字。\n  定义在一个 auto 序列的变量必须始终推导成同一类型。\nauto a4 = 10, a5 = 20, a6 = 30; //正确 auto b4 = 10, b5 = 20.0, b6 = \u0026#39;a\u0026#39;; //错误   如果初始化表达式是引用，则去除引用语义。\nint main() { int a = 10; int \u0026amp;b = a; auto c = b; // c的类型为int而非int\u0026amp;（去除引用）  auto \u0026amp;d = b; // 此时c的类型才为int\u0026amp;  c = 100; //a = 10;  cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; d = 100; //a = 100;  cout \u0026lt;\u0026lt; \u0026#34;d = \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34; a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 输出：\nc = 100 a = 10 d = 100 a = 100   如果初始化表达式为 const 或 volatile（或者两者兼有），则除去 const/volatile 语义\n  如果 auto 关键字带上 \u0026amp; 号，则不去除 const 语义\nint main() { const int a1 = 10; auto b1= a1; // b1的类型为int而非const int（去除const）  // 与指针类似，只是为新变量开辟了新的空间  int* pB1 = (int*)\u0026amp;a1; b1 = 100; // 合法  *pB1 = 1000; // 合法  cout \u0026lt;\u0026lt; \u0026#34;b1 = \u0026#34; \u0026lt;\u0026lt; b1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a1 = \u0026#34; \u0026lt;\u0026lt; a1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;*pB1 = \u0026#34; \u0026lt;\u0026lt; *pB1 \u0026lt;\u0026lt; endl; const auto c1 = a1; // 此时c1的类型为const int  // c1 = 100; // 非法  auto\u0026amp; b2 = a1; // 因为auto带上\u0026amp;，故不去除const，b2类型为const int  // b2 = 100; // 非法  return 0; } 输出：\nb1 = 100 a1 = 10 *pB1 = 1000   初始化表达式为数组时，auto 关键字推导类型为指针。\n  若表达式为数组且 auto 带上 \u0026amp;，则推导类型为数组类型。\nint main() { int a3[3] = { 1, 2, 3 }; auto b3 = a3; cout \u0026lt;\u0026lt; typeid(b3).name() \u0026lt;\u0026lt; endl; auto\u0026amp; c3 = a3; // int (\u0026amp;)[3]  cout \u0026lt;\u0026lt; typeid(c3).name() \u0026lt;\u0026lt; endl; return 0; } 输出：\nPi A3_i   函数形参或者模板参数不能被声明为 auto。\n  六、decltype 声明引用类型 struct A { double x; }; const A* a; decltype(a-\u0026gt;x) y; // y 的类型是 double（其声明类型） decltype((a-\u0026gt;x)) z = y; // z 的类型是 const double\u0026amp;（左值表达式） ","permalink":"https://874656645.github.io/posts/130-c++11-auto-%E4%B8%8E-decltype-%E5%85%B3%E9%94%AE%E5%AD%97/","summary":"一、进行自动类型推导  auto 的自动类型推断发生在编译期，所以使用 auto 并不会造成程序运行时效率的降低。 而是否会造成编译期的时间消耗，我认为是不会的，在未使用 auto 时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换。 auto 属于类类型推导 decltype 是包含声明修饰符的声明类型推导  int main() { int a = 10; auto val = a; cout \u0026lt;\u0026lt; typeid(val).name() \u0026lt;\u0026lt; endl; // i  return 0; } 二、在定义函数模板时，用于声明依赖模板参数的变量类型 不到编译的时候，x * y 的真正类型很难确定\ntemplate \u0026lt;class _Tx,class _Ty\u0026gt; void Multiply(_Tx x, _Ty y) { auto v = x * y; std::cout \u0026lt;\u0026lt; v; } int main() { int a = 10; double b = 1.","title":"C++11 auto 与 decltype 关键字"},{"content":"一、生成带有调试信息的程序 gcc main.c -o app -g\n二、启动调试  启动调试：gdb app 设置参数： set args\nset args 123 abc 456 ddd 查看代码： list 或 l  查看代码显示行数：show listsize 设置代码显示行数：set listsize 20 查看当前文件：  l l 行号 l 函数名   查看非当前文件：  l 文件名:行号 l 文件名:函数名      三、断点相关  设置断点：  break 行号 b 行号 b 函数名 b 文件名:行号 b 文件名:函数名   查看断点：info break 或 i b 删除断点：  del 断点Num d Num d Num1 Num2 d Num1-Num10   设置断点无效：dis Num 断点生效：ena Num 设置条件断点：b 行号 if i == 10  四、调试相关  启动运行：  start - s run - r   退出 gdb 调试：quit - q 打印变量的值：p 变量名 打印变量的类型：ptype 变量名 向下单步调试：  next - n step - s   跳出函数体：finish 从循环中跳出（循环体中不能有断点）：until 设置变量的值：set var 变量名 = value 继续运行到下一个断点：continue - c 监视变量：display 变量名 查看所有的监视变量的信息：info(i) display 取消变量监视：undisplay Num  ","permalink":"https://874656645.github.io/posts/127-gdb-%E8%B0%83%E8%AF%95%E4%BD%BF%E7%94%A8/","summary":"一、生成带有调试信息的程序 gcc main.c -o app -g\n二、启动调试  启动调试：gdb app 设置参数： set args\nset args 123 abc 456 ddd 查看代码： list 或 l  查看代码显示行数：show listsize 设置代码显示行数：set listsize 20 查看当前文件：  l l 行号 l 函数名   查看非当前文件：  l 文件名:行号 l 文件名:函数名      三、断点相关  设置断点：  break 行号 b 行号 b 函数名 b 文件名:行号 b 文件名:函数名   查看断点：info break 或 i b 删除断点：  del 断点Num d Num d Num1 Num2 d Num1-Num10   设置断点无效：dis Num 断点生效：ena Num 设置条件断点：b 行号 if i == 10  四、调试相关  启动运行：  start - s run - r   退出 gdb 调试：quit - q 打印变量的值：p 变量名 打印变量的类型：ptype 变量名 向下单步调试：  next - n step - s   跳出函数体：finish 从循环中跳出（循环体中不能有断点）：until 设置变量的值：set var 变量名 = value 继续运行到下一个断点：continue - c 监视变量：display 变量名 查看所有的监视变量的信息：info(i) display 取消变量监视：undisplay Num  ","title":"gdb 调试使用"},{"content":"一、make  gcc 编译器 make 是 Linux 自带的构建器  二、文件命名  makefile Makefile  三、makefile 中的规则 例如：gcc a.c b.c c.c -o app\n  规则由三部分组成：目标、依赖、命令\napp:a.c b.c c.c gcc a.c b.c c.c -o app   makefile 中可以有多条规则\n  四、makefile 优化   版本一：\napp:main.c add.c sub.c gcc main.c add.c sub.c -I ./ -o app 存在的问题： 效率低，其中一个文件修改了，剩余的其它文件都要重新编译\n  版本二：\napp:main.o add.o sub.o gcc main.o add.o sub.o -I ./ -o app main.o:main.c gcc main.c -c -I ./ add.o:add.c gcc add.c -c -I ./ sub.o:sub.c gcc sub.c -c -I ./ 存在的问题： 冗余\n  版本三：\n 自定义变量：obj=a.o b.o c.o 自定义变量取值：tmp=$(obj) makefile 自带的变量，一般都是大写的 自动变量：只能在规则的命令中使用  $@：规则中的目标 $\u0026lt;：规则中的第一个依赖 $^：规则中的所有依赖    obj = main.o add.o sub.o target = app $(target):$(obj) gcc $(obj) -o $(target) -I ./ %.o:%.c gcc -c $\u0026lt; -o $@ -I ./ obj = main.o add.o sub.o target = app $(target):$(obj) gcc $^ -o $@ -I ./ %.o:%.c gcc -c $\u0026lt; -o $@ -I ./ 存在的问题： 可移植性比较差\n  版本四：（makefile 中的函数）\n wildcard：查找指定目录下指定类型的文件 patsubst：匹配替换  src = $(wildcard ./*.c) obj = $(patsubst %.c,%.o,$(src)) target = app $(target):$(obj) gcc $^ -o $@ -I ./ %.o:%.c gcc $\u0026lt; -c -I ./ 存在的问题： 不能自动清除\n  版本五：\n make 目标名：让 make 执行非终极目标 clean:：编写一个清理项目的规则（只有目标，没有依赖项） -f：强制执行 .PHONY:clean：声明伪目标，避免同名文件干扰 -命令：忽略执行失败的命令，继续向下执行  src = $(wildcard ./*.c) obj = $(patsubst %.c,%.o,$(src)) target = app $(target):$(obj) gcc $^ -o $@ -I ./ %.o:%.c gcc $\u0026lt; -c -I ./ .PHONY:clean clean: -mkdir /abc -rm *.o $(target) -f   ","permalink":"https://874656645.github.io/posts/126-makefile-%E4%BD%BF%E7%94%A8/","summary":"一、make  gcc 编译器 make 是 Linux 自带的构建器  二、文件命名  makefile Makefile  三、makefile 中的规则 例如：gcc a.c b.c c.c -o app\n  规则由三部分组成：目标、依赖、命令\napp:a.c b.c c.c gcc a.c b.c c.c -o app   makefile 中可以有多条规则\n  四、makefile 优化   版本一：\napp:main.c add.c sub.c gcc main.c add.c sub.c -I ./ -o app 存在的问题： 效率低，其中一个文件修改了，剩余的其它文件都要重新编译\n  版本二：\napp:main.o add.o sub.o gcc main.o add.o sub.o -I ./ -o app main.","title":"Makefile 使用"},{"content":"一、库是什么 库是二进制格式的源代码（二进制加密）\n二、库的使用  头文件 制作的库文件  三、静态库的制作和使用  命名规则 libxxx.a 制作步骤  准备源代码文件 将源代码文件生成 .o 文件 gcc -c *.c 将 .o 文件打包（archive） ar rcs libxxx.a *.o 查看 lib 文件 nm libxxx.a   库的使用 gcc main.c -I./include -L ./lib -lmyCalc -o app  -L: 库的路径 -l: 库的名称（去掉 lib 前缀和 .a 后缀）    四、动态库的制作和使用  命名规则 libxxx.so 制作步骤  准备源代码文件 将源代码文件生成 .o 文件 gcc -c -fpic *.c 或者 gcc -c -fPIC *.c 将 .o 文件打包 gcc -shared -o libxxx.so *.o   库的使用  gcc main.c -I ./include -L ./lib -l mycalc -o app2   动态库无法加载（4 种方式）  使用临时环境变量设置：export LD_LIBRARY_PATH=./lib:$LD_LIBRARY_PATH 修改用户级别的配置文件：打开 ~/.bashrc文件，将 export LD_LIBRARY_PATH=~/lib （注：等号两边不要有空格）添加到文件最后，重启 bash 终端或 source ~/.bashrc 修改系统级别的配置文件：/etc/profile，重复上面的步骤 更新 /etc/ld_so_cache 文件列表  将库的绝对路径（注：必需是绝对路径，不能使用类似 ~ 代替）添加到配置文件中 etc/ld.so.conf 执行 sudo ldconfig -v 命令   拓展，使用函数调用：dlopen、dlclose、dlsym Linux动态库路径查找顺序：\n    五、其它命令  file app2\n ldd app2\n  ","permalink":"https://874656645.github.io/posts/125-linux-%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/","summary":"一、库是什么 库是二进制格式的源代码（二进制加密）\n二、库的使用  头文件 制作的库文件  三、静态库的制作和使用  命名规则 libxxx.a 制作步骤  准备源代码文件 将源代码文件生成 .o 文件 gcc -c *.c 将 .o 文件打包（archive） ar rcs libxxx.a *.o 查看 lib 文件 nm libxxx.a   库的使用 gcc main.c -I./include -L ./lib -lmyCalc -o app  -L: 库的路径 -l: 库的名称（去掉 lib 前缀和 .a 后缀）    四、动态库的制作和使用  命名规则 libxxx.so 制作步骤  准备源代码文件 将源代码文件生成 .o 文件 gcc -c -fpic *.c 或者 gcc -c -fPIC *.","title":"Linux 静态库与动态库"},{"content":"一、gcc 工作流程  预处理 —— -E  宏替换 头文件展开 去掉注释 生成 .i 文件   编译 —— -S  生成 .s 文件 汇编文件   汇编 —— -c  生成 .o 文件 二进制文件   链接  二、gcc 常用参数  -v / --version -I : 编译时指定头文件路径 -c : 生成二进制文件 .o -o : 指定生成的文件名 -g : gdb 调试，生成带有调试信息的二进制文件（Debug模式） -D : 编译时指定一个宏 -Wall : 显示警告信息 -On : 优化代码，n 是优化级别（1，2，3）  ","permalink":"https://874656645.github.io/posts/124-gcc-%E7%9B%B8%E5%85%B3/","summary":"一、gcc 工作流程  预处理 —— -E  宏替换 头文件展开 去掉注释 生成 .i 文件   编译 —— -S  生成 .s 文件 汇编文件   汇编 —— -c  生成 .o 文件 二进制文件   链接  二、gcc 常用参数  -v / --version -I : 编译时指定头文件路径 -c : 生成二进制文件 .o -o : 指定生成的文件名 -g : gdb 调试，生成带有调试信息的二进制文件（Debug模式） -D : 编译时指定一个宏 -Wall : 显示警告信息 -On : 优化代码，n 是优化级别（1，2，3）  ","title":"gcc 相关"},{"content":"  NULL，0，'\\0'，\u0026lsquo;0\u0026rsquo;\nint main() { char arr[] = {0, \u0026#39;\\0\u0026#39;, \u0026#39;0\u0026#39;, 48}; printf(\u0026#34;%c\\n\u0026#34;, arr[0]); printf(\u0026#34;%c\\n\u0026#34;, arr[1]); printf(\u0026#34;%c\\n\u0026#34;, arr[2]); printf(\u0026#34;%c\\n\u0026#34;, arr[3]); printf(\u0026#34;---------------\\n\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;, arr[0]); printf(\u0026#34;%d\\n\u0026#34;, arr[1]); printf(\u0026#34;%d\\n\u0026#34;, arr[2]); printf(\u0026#34;%d\\n\u0026#34;, arr[3]); return 0; } 输出：\n0 0 --------------- 0 0 48 48   UTF-8 向下兼容 ASCII 编码，UTF-8 编码中，一个英文字为一个字节，一个中文一般为三个字节（ASCII、Unicode、UTF-8）\n 0xxxxxxx：单字节编码形式，这和 ASCII 编码完全一样，因此 UTF-8 是兼容 ASCII 的； 110xxxxx 10xxxxxx：双字节编码形式； 1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式； 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式； UTF-8：每字 1 ~ 6 字节 Unicode（UCS-2）：每字都是 2 bytes UTF-16：每字 2 ~ 4 字节 UTF-32（UCS-4）：每字都是 4 bytes    float 单精度，浮点数在内存中是按科学计数法来存储的，小数点后6位能确定表示，float 是由 1 bit 符号位，8 bit 指数位和 23 bit 尾数位组成，精度是由尾数位决定的（2^23 = 8388608）\nbool test(float a, float b){ float t = (a + b) - a - b; cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; return t == 0; } int main() { // 第五位及以后的数字，大于等于 8 的数字就不稳定了  cout \u0026lt;\u0026lt; test(1.12348, 2.12348) \u0026lt;\u0026lt; endl; return 0; } 输出：\n-2.38419e-07 0   double 双精度是由 1 bit 符号位，11 bit 指数位和 52 bit 尾数位组成\n  IPv4 地址由 4 部分组成，每部分 8 bit，一共 32 bit，每部分用 10 进制表示，中间用 . 隔开\n  IPv6 地址由 8 部分组成，每部分 16 bit，一共 128 bit，每部分用 16 进制表示，中间用 : 隔开\n  ","permalink":"https://874656645.github.io/posts/123-2022-02-14%E6%9D%82%E8%AE%B0/","summary":"NULL，0，'\\0'，\u0026lsquo;0\u0026rsquo;\nint main() { char arr[] = {0, \u0026#39;\\0\u0026#39;, \u0026#39;0\u0026#39;, 48}; printf(\u0026#34;%c\\n\u0026#34;, arr[0]); printf(\u0026#34;%c\\n\u0026#34;, arr[1]); printf(\u0026#34;%c\\n\u0026#34;, arr[2]); printf(\u0026#34;%c\\n\u0026#34;, arr[3]); printf(\u0026#34;---------------\\n\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;, arr[0]); printf(\u0026#34;%d\\n\u0026#34;, arr[1]); printf(\u0026#34;%d\\n\u0026#34;, arr[2]); printf(\u0026#34;%d\\n\u0026#34;, arr[3]); return 0; } 输出：\n0 0 --------------- 0 0 48 48   UTF-8 向下兼容 ASCII 编码，UTF-8 编码中，一个英文字为一个字节，一个中文一般为三个字节（ASCII、Unicode、UTF-8）\n 0xxxxxxx：单字节编码形式，这和 ASCII 编码完全一样，因此 UTF-8 是兼容 ASCII 的； 110xxxxx 10xxxxxx：双字节编码形式； 1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式； 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式； UTF-8：每字 1 ~ 6 字节 Unicode（UCS-2）：每字都是 2 bytes UTF-16：每字 2 ~ 4 字节 UTF-32（UCS-4）：每字都是 4 bytes    float 单精度，浮点数在内存中是按科学计数法来存储的，小数点后6位能确定表示，float 是由 1 bit 符号位，8 bit 指数位和 23 bit 尾数位组成，精度是由尾数位决定的（2^23 = 8388608）","title":"2022-02-14 杂记"},{"content":"一、使用教程   vimtutor\n  显示行号:\nvim ~/.vimrc 在文件的最后一行输入 set number 并保存退出   二、vim 三种工作模式  命令模式 编辑模式 末行模式\n  三、命令模式下的相关操作  保存退出\nZZ 代码格式化\ngg=G 光标移动：  左下上右：H J K L 移动到行首：0 移动到行尾：$ 移动到文件首部：gg 移动到文件尾部：G 跳转到第20行：20 + G 从当前位置向下移动 n 行：n + enter   删除命令：  删除光标后的一个字符：x（小写） 删除光标前的一个字符：X（大写） 删除一个单词：dw 删除光标前的所有字符：d0 删除光标后的所有字符：d$ 或者 D 删除光标所在行：dd 删除多行：ndd 删除光标所在行以及下面 n 行 删除光标所在行到文件首部的字符：dgg 删除光标所在行到文件尾部的字符：dG   撤销与反撤销：  撤销：u 反撤销：ctrl + r   复制粘贴：  复制一行：yy 复制多行：nyy 粘贴到光标下一行：p 粘贴到光标上一行：P(大写)   字符可视模式：v  移动光标 复制：y 删除：d 粘贴：p(小写 光标之后) P(大写 光标之前)   行可视模式：V  增加缩进：\u0026gt; 减少缩进：\u0026lt;   块可视模式：ctrl + V  o：将光标在块的左上角和右下角切换 O：将光标移动到所在行的对角 nl：将光标向右移动 n 个字符 nj：将光标向下移动 n 行 I：插入，按两次 ESC 退出（例如：多行注释操作）   替换操作：  r：替换光标后的字符 R：替换光标后的多个字符   查找操作：  /xxx ?xxx # 查找光标所在的单词 n 或 N 切换到下一个   想看 man 文档  光标移动到要查的内容上，然后 章节号 + K shell 命令：man 3 printf man man    四、命令模式切换到文本编辑模式  a：在光标所覆盖的字符后面插入 A：行尾部插入 i：在光标所覆盖的字符前面插入 I：行首部插入 o：在光标所在行的下一行开始插入 O：在光标所在行的上一行开始插入 s：删除掉光标覆盖的字符并开始插入 S：删除光标所在的整行并开始插入  五、末行模式  从命令模式进入末行模式：: 保存退出：:wq 或 :x 保存：:w 退出：:q 退出不保存：:q! 跳转到第 n 行：:n 删除从 m 行到 n 行：:m,nd 末行模式下执行 shell 命令：:!ls  六、替换  替换光标所在行的字符串：:s/old/new 替换光标所在行所有的字符串：:s/old/new/g 替换光标所在行所有的字符串并提示确认：:s/old/new/gc 替换某些行范围内的字符串：:10,20s/old/new 替换某些行范围内的所有字符串：:10,20s/old/new/g 替换当前文档所有的：:%s/old/new/g  七、分屏操作  当前文件分屏：:sp 或 :vsp 两个屏幕显示不同的文件：:sp 文件名 或 :vsp 文件名 分屏关闭：:qall :wqall :q 屏幕切换：ctrl + w + w 打开的时候分屏：vi -o 多个文件名 或 vi -O 多个文件名  ","permalink":"https://874656645.github.io/posts/122-vim-%E4%BD%BF%E7%94%A8/","summary":"一、使用教程   vimtutor\n  显示行号:\nvim ~/.vimrc 在文件的最后一行输入 set number 并保存退出   二、vim 三种工作模式  命令模式 编辑模式 末行模式\n  三、命令模式下的相关操作  保存退出\nZZ 代码格式化\ngg=G 光标移动：  左下上右：H J K L 移动到行首：0 移动到行尾：$ 移动到文件首部：gg 移动到文件尾部：G 跳转到第20行：20 + G 从当前位置向下移动 n 行：n + enter   删除命令：  删除光标后的一个字符：x（小写） 删除光标前的一个字符：X（大写） 删除一个单词：dw 删除光标前的所有字符：d0 删除光标后的所有字符：d$ 或者 D 删除光标所在行：dd 删除多行：ndd 删除光标所在行以及下面 n 行 删除光标所在行到文件首部的字符：dgg 删除光标所在行到文件尾部的字符：dG   撤销与反撤销：  撤销：u 反撤销：ctrl + r   复制粘贴：  复制一行：yy 复制多行：nyy 粘贴到光标下一行：p 粘贴到光标上一行：P(大写)   字符可视模式：v  移动光标 复制：y 删除：d 粘贴：p(小写 光标之后) P(大写 光标之前)   行可视模式：V  增加缩进：\u0026gt; 减少缩进：\u0026lt;   块可视模式：ctrl + V  o：将光标在块的左上角和右下角切换 O：将光标移动到所在行的对角 nl：将光标向右移动 n 个字符 nj：将光标向下移动 n 行 I：插入，按两次 ESC 退出（例如：多行注释操作）   替换操作：  r：替换光标后的字符 R：替换光标后的多个字符   查找操作：  /xxx ?","title":"vim 使用"},{"content":"WSL 的基本命令\n一、自动安装 满足 Win10 系统版本要求的（ Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11）可以使用这种方式\n查看方式，Win + R 打开运行窗口，输入 winver 查看\n  安装 WSL\nwsl --install\n  查看可用的 Linux 发行版\nwsl -l -o\n  查看已安装的 Linux 分发版\nwsl -l -v\n  注销 Linux 发行版\nwsl --unregister Ubuntu\n  可以直接从官网下载 Linux 发行版的安装包，然后将 appx 扩展名改为 zip，解压到想要放置的目录，双击 ubuntu.exe 启动，参考手动安装\n  二、手动安装  注意：以下命令都是在以管理员权限运行的 PowerShell 中完成   启用 “适用于 Linux 的 Windows 子系统” 可选功能\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 启用 “虚拟机平台” 可选功能\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重启电脑 查看 WSL 状态信息，默认版本等\nwsl --status\n 更新 WSL\nwsl --update 下载 Ubuntu 版本，将扩展名 .appx 改为 zip，解压到文件夹，双击 ubuntu.exe 启动运行  ","permalink":"https://874656645.github.io/posts/121-windows-10-%E4%B8%AD%E7%9A%84-linux-%E5%AD%90%E7%B3%BB%E7%BB%9F/","summary":"WSL 的基本命令\n一、自动安装 满足 Win10 系统版本要求的（ Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11）可以使用这种方式\n查看方式，Win + R 打开运行窗口，输入 winver 查看\n  安装 WSL\nwsl --install\n  查看可用的 Linux 发行版\nwsl -l -o\n  查看已安装的 Linux 分发版\nwsl -l -v\n  注销 Linux 发行版\nwsl --unregister Ubuntu\n  可以直接从官网下载 Linux 发行版的安装包，然后将 appx 扩展名改为 zip，解压到想要放置的目录，双击 ubuntu.exe 启动，参考手动安装\n  二、手动安装  注意：以下命令都是在以管理员权限运行的 PowerShell 中完成   启用 “适用于 Linux 的 Windows 子系统” 可选功能","title":"Windows 10 中的 Linux 子系统"},{"content":"         bin 二进制文件，可执行文件   boot 系统开机启动项   dev device 设备（硬盘、显卡、显示器 一切皆文件）   lib 动态库   mnt 手动挂载目录   media 外设自动挂载目录   root 超级用户的家目录   usr unix system resource 头文件include、源文件src、用户安装程序/usr/local   etc 配置文件   opt 安装第三方应用程序   home Linux 所有用户的家目录（操作系统的家目录）   tmp 临时文件目录，系统重启后会被清空    ","permalink":"https://874656645.github.io/posts/120-linux-%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/","summary":"         bin 二进制文件，可执行文件   boot 系统开机启动项   dev device 设备（硬盘、显卡、显示器 一切皆文件）   lib 动态库   mnt 手动挂载目录   media 外设自动挂载目录   root 超级用户的家目录   usr unix system resource 头文件include、源文件src、用户安装程序/usr/local   etc 配置文件   opt 安装第三方应用程序   home Linux 所有用户的家目录（操作系统的家目录）   tmp 临时文件目录，系统重启后会被清空    ","title":"Linux 目录介绍"},{"content":"  逆序打印字符串\nvoid printReverseString(const char* str){ if(*str == \u0026#39;\\0\u0026#39;){ return; } printReverseString(str + 1); printf(\u0026#34;%c\u0026#34;, *str); } int main() { const char* str = \u0026#34;Hello World\u0026#34;; printReverseString(str); // dlroW olleH  return 0; }   逆序输出链表\nstruct LinkNode{ int data; struct LinkNode* next; }; void printReverseLinkNode(struct LinkNode* header){ if(header == NULL){ return; } printReverseLinkNode(header-\u0026gt;next); printf(\u0026#34;%d\\n\u0026#34;, header-\u0026gt;data); } int main() { struct LinkNode* header = malloc(sizeof(struct LinkNode)); struct LinkNode* node1 = malloc(sizeof(struct LinkNode)); node1-\u0026gt;data = 10; node1-\u0026gt;next = NULL; struct LinkNode* node2 = malloc(sizeof(struct LinkNode)); node2-\u0026gt;data = 20; node2-\u0026gt;next = NULL; struct LinkNode* node3 = malloc(sizeof(struct LinkNode)); node3-\u0026gt;data = 30; node3-\u0026gt;next = NULL; header-\u0026gt;next = node1; node1-\u0026gt;next = node2; node2-\u0026gt;next = node3; printReverseLinkNode(header-\u0026gt;next); return 0; }   递归实现给出一个数 8793，依次打印千位数 8、百位数 7、十位数 9、个位数 3\nvoid printNum(int num){ if(num == 0){ return; } int val = num / 10; printNum(val); printf(\u0026#34;%d \u0026#34;, num % 10); } int main() { int num = 8973; printNum(num); // 8 9 7 3  return 0; }   阶乘\nint factorial(int n){ if(n \u0026lt;= 1){ return 1; } else{ return n * factorial(n-1); } }   斐波那契数列\nint fibonacci(int n){ if(n == 0) return 0; if(n == 1) return 1; return fibonacci(n-1) + fibonacci(n-2); }   河内塔（递归树的中序遍历）\nvoid move(char X, char Y){ cout \u0026lt;\u0026lt; \u0026#34;move \u0026#34; \u0026lt;\u0026lt; X \u0026lt;\u0026lt; \u0026#34; to \u0026#34; \u0026lt;\u0026lt; Y \u0026lt;\u0026lt; endl; } void hanoi(int n, char X, char Y, char Z){ if(n \u0026lt;= 1){ move (X, Z); } else{ hanoi(n-1, X, Z, Y); // X 上最大的环不动，其他 n-1 个环移动到 Y  move(X, Z); // 移动最大的环到 Z，放好  hanoi(n-1, Y, X, Z); // 把 Y 上的 n-1 个环移动到 Z  } }   ","permalink":"https://874656645.github.io/posts/119-%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E5%BD%92%E6%A0%91/","summary":"逆序打印字符串\nvoid printReverseString(const char* str){ if(*str == \u0026#39;\\0\u0026#39;){ return; } printReverseString(str + 1); printf(\u0026#34;%c\u0026#34;, *str); } int main() { const char* str = \u0026#34;Hello World\u0026#34;; printReverseString(str); // dlroW olleH  return 0; }   逆序输出链表\nstruct LinkNode{ int data; struct LinkNode* next; }; void printReverseLinkNode(struct LinkNode* header){ if(header == NULL){ return; } printReverseLinkNode(header-\u0026gt;next); printf(\u0026#34;%d\\n\u0026#34;, header-\u0026gt;data); } int main() { struct LinkNode* header = malloc(sizeof(struct LinkNode)); struct LinkNode* node1 = malloc(sizeof(struct LinkNode)); node1-\u0026gt;data = 10; node1-\u0026gt;next = NULL; struct LinkNode* node2 = malloc(sizeof(struct LinkNode)); node2-\u0026gt;data = 20; node2-\u0026gt;next = NULL; struct LinkNode* node3 = malloc(sizeof(struct LinkNode)); node3-\u0026gt;data = 30; node3-\u0026gt;next = NULL; header-\u0026gt;next = node1; node1-\u0026gt;next = node2; node2-\u0026gt;next = node3; printReverseLinkNode(header-\u0026gt;next); return 0; }   递归实现给出一个数 8793，依次打印千位数 8、百位数 7、十位数 9、个位数 3","title":"递归与递归树"},{"content":"int main() { printf(\u0026#34;%s\\n\u0026#34;, __FILE__); // main.c  printf(\u0026#34;%d\\n\u0026#34;, __LINE__); // 14  printf(\u0026#34;%s\\n\u0026#34;, __DATE__); // Feb 7 2022  printf(\u0026#34;%s\\n\u0026#34;, __TIME__); // 01:59:37  return 0; } // func1.h #ifdef __cplusplus extern \u0026#34;C\u0026#34;{ #endif  void func1(); #ifdef __cplusplus } #endif  // main.h extern \u0026#34;C\u0026#34;{ include \u0026#34;func1.h\u0026#34; } extern \u0026#34;C\u0026#34;{ extern void func1(); } int main() { func1(); return 0; } ","permalink":"https://874656645.github.io/posts/118-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/","summary":"int main() { printf(\u0026#34;%s\\n\u0026#34;, __FILE__); // main.c  printf(\u0026#34;%d\\n\u0026#34;, __LINE__); // 14  printf(\u0026#34;%s\\n\u0026#34;, __DATE__); // Feb 7 2022  printf(\u0026#34;%s\\n\u0026#34;, __TIME__); // 01:59:37  return 0; } // func1.h #ifdef __cplusplus extern \u0026#34;C\u0026#34;{ #endif  void func1(); #ifdef __cplusplus } #endif  // main.h extern \u0026#34;C\u0026#34;{ include \u0026#34;func1.h\u0026#34; } extern \u0026#34;C\u0026#34;{ extern void func1(); } int main() { func1(); return 0; } ","title":"常用的宏定义"},{"content":"Linux 命令大全\n一、更新和升级包 1. 更新和升级包 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade\n2. 安装软件 sudo apt install tree\n3. 删除不需要的包 sudo apt autoremove\n4. 查看已安装的软件 dpkg -l | grep openssh-server\n5. 查看软件安装的路径 dpkg -L openssh-server\nwhereis gdb\n二、shell 操作和常用命令 1、查看输入的命令历史 history\n2、删除光标前面的字符串 ctrl + u\n3、删除光标后面的字符串 ctrl + k\n4、光标定位到头部 ctrl + a\n5、光标定位到尾部 ctrl + e\n6、命令、路径补全 Tab\n7、缩写别名 alias\n8、查看说明 man 5 passwd\n9、宿主目录 ~\n10、查看目录内容 tree ~\n11、打印工作目录 pwd\n12、表示当前用户是普通用户 $ 13、表示当前用户是超级用户 # 14、切换超级用户 sudo su\n15、 查看文件和目录 ls ls -a ls -l # -rwxrw-r-- 1 rick rick 0 Feb 12 18:37 test ls -lh ls -alF # drwxr-xr-x 1 rick rick 4096 Feb 12 18:37 rick/ ll 16、 cd cd /home/rick cd ~ cd cd - # 切换到上一个的历史目录 17、 mkdir 目录名 mkdir aa mkdir aa/bb rm aa -r mkdir aa/bb/cc -p 18、 touch 文件名  如果文件不存在，则创建文件 如果文件存在，更新文件时间  19、 rmdir 删除空目录  只能删除空目录  20、 rm 删除目录和文件  删除后很难恢复  rm -r # 用递归的方式删除目录 rm -ri # 提示 rm aa/* -r # 删除 aa 目录下的所有文件和目录 21、 cp 拷贝 cp file file1 # file1 不存在，则创建 file1 并把 file 中的内容拷贝进去 cp file file1 # file1 存在，则会用 file 中的内容覆盖 file1 中的内容 cp file dir # 将 file 拷贝到 dir 目录下 cp dir dir1 # dir1 目录不存在，则把 dir 的所有子目录拷贝到 dir1 目录下 rm dir1/* -r cp dir dir1 # dir1 目录存在，则把 dir 整个目录拷贝到 dir1 目录下 cp -r nginx_build/* nginx 22、 mv mv file file1 # file1 不存在，则是将 file 文件改名为 file1 mv file file1 # file1 存在，则用 file 中的内容覆盖 file1 中的内容，并删除 file mv file dir # dir 存在，将 file 移动到 dir 目录下 mv dir dir1 # dir1 不存在，就是将 dir 改名为 dir1 mv dir dir1 # dir1 存在，则将 dir 目录移动到 dir1下 23、 cat 将文件内容打印到终端  适用文件内容较小的情况  23、 more 将文件内容打印到终端  不能向上翻页 Enter 向下滚动一行 空格：向下翻页 退出：q  23、 less 将文件内容打印到终端  Enter 或 ctrl + n : 向下滚动一行 ctrl + p : 向上滚动一行 pgdn : 向下翻页 空格 : 向下翻页 pgup : 向上翻页 q : 退出  23、 head 打印文件内容的前 10 行到终端 24、 tail 打印文件内容的后 10 行到终端 25、 ln 创建软硬链接  创建软链接 ln -s 全文件名 链接名称 创建硬链接（在其他多个目录中管理文件，并且能时时同步修改） ln 文件名 链接名  26、 chmod 修改权限 chmod uo-rw program chmod u+r,g-x program chmod -440 program chmod 777 program 27、 chown 修改所有者或所属组 sudo chown sys program sudo chown rick:sys program 28、 chgrp 所属组 sudo chgrp rick program\n29、 find 查找 find ./ -name \u0026#34;program\u0026#34; # 按文件名查找 find ./ -type f # 按文件类型查找（7种） find ./ -size -4k find ./ -size +2k -size -10k # 按文件大小查找 find ./ -ctime -1 # 按日期查找（-ctime、-mtime、-atime） find ./ -type d -exec ls -l {} \\; # 查找指定目录，并列出该目录中文件详细信息 find ./ -type d | xargs ls -l # 利用管道，效率较高 30、 grep 所属组 grep -r \u0026#34;hello\u0026#34; ./ -n 31、 写入文件 ls -l \u0026gt; fileinfo\n32、 usermod 修改用户组 # 查看当前用户所属组 groups 用户名 # 一个用户仅仅属于某一个组，而不是同时属于多个组 sudo usermod -g 组名 用户名 # 给一个用户添加一个新的组，同时保留原来的组 sudo usermod -a -G 组名 用户名 33、查看环境变量 env\n34、修改环境变量 修改 ~/.bashrc 文件（当前用户）或 /etc/profile 文件（所有用户）\nexport PATH=\u0026#34;/mnt/h/wsl/emsdk:/mnt/h/wsl/emsdk/upstream/emscripten:/mnt/h/wsl/emsdk/node/14.18.2_64bit/bin:$PATH\u0026#34; source ~/.bashrc 35、ldd 列出动态库依赖关系 ldd 是 list, dynamic, dependencies 的缩写\nldd ffmpeg\n36、which 查找文件 which bash\n37、查看进程信息 ps -ef | grep nginx\n38、查看程序占用的端口 netstat -tunlp | grep 80\nlsof -i:80\n39、查看进程 ID（PID） pgrep -l nginx\n39、杀死进程 kill -9 PID\nkill PID1 PID2 PID3\n三、Linux 文件类型          - 普通文件   d 目录   l 符号链接   p 管道   s 套接字   c 字符设备（鼠标、键盘）   b 块设备（U盘、硬盘)    四、用户类型          user 文件所有者（rwx）   group 文件所属组用户（rw-）   other 其他用户（r--）    五、权限          r 读   w 写   x 执行    六、压缩包管理 1. 常见压缩格式  .gz \u0026ndash;gzip .bz2 \u0026ndash;bzip2  2. 常用压缩命令  gzip file 压缩 gunzip *.gz 解压 tar  .gz 压缩 tar -czvf test.tar.gz aa program .bz2 压缩 tar -cjvf test.tar.bz2 aa program .gz 解压 tar -xzvf test.tar.gz -C /tmp .bz2 解压 tar -xjvf test.tar.bz2 -C /tmp 详细列举归档文件 tar -tvf nginx.tar.gz   rar 需要安装 sudo apt-get install rar\nrar a all aa program\nrar a all aa/ program -r 目录加 -r\nrar x all.rar /tmp zip / unzip 需要安装 sudo apt-get install zip\nzip myzip aa program -r\nunzip myzip.zip -d /tmp  七、软件安装和制作 1. 在线安装 \u0026ndash; ubuntu  安装：sudo apt-get(apt) install 安装包名称 卸载：sudo apt-get(apt) remove 软件名称 软件列表更新：sudo apt-get(apt) update 清空缓存：sudo apt-get(apt) clean 缓存路径：/var/cache/apt/archives 中的红色 *.deb 文件  2. 软件包安装  安装：sudo dpkg -i xxx.deb 卸载：sudo dpkg -r 软件名称  3. 源码安装 4. 查看已安装软件 dpkg -l | grep openssh-server\n5. 查看软件安装路径 dpkg -L openssh-server\n八、ubuntu 启用 root 用户 1. 修改 sshd_config 中的 PermitRootLogin sudo vim /etc/ssh/sshd_config\n2. 重启 ssh 守护进程 sudo service ssh restart\n如果终端显示 ssh:unrecognized service，可能是因为服务没开启，通过命令 service ssh status 查看服务状态，可通过命令 sudo /etc/init.d/ssh start 启动服务\n","permalink":"https://874656645.github.io/posts/117-ubuntu-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","summary":"Linux 命令大全\n一、更新和升级包 1. 更新和升级包 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade\n2. 安装软件 sudo apt install tree\n3. 删除不需要的包 sudo apt autoremove\n4. 查看已安装的软件 dpkg -l | grep openssh-server\n5. 查看软件安装的路径 dpkg -L openssh-server\nwhereis gdb\n二、shell 操作和常用命令 1、查看输入的命令历史 history\n2、删除光标前面的字符串 ctrl + u\n3、删除光标后面的字符串 ctrl + k\n4、光标定位到头部 ctrl + a\n5、光标定位到尾部 ctrl + e\n6、命令、路径补全 Tab\n7、缩写别名 alias\n8、查看说明 man 5 passwd\n9、宿主目录 ~\n10、查看目录内容 tree ~","title":"Linux 常用命令"},{"content":"void printArr(const char ** p, int len){ for(int i = 0; i \u0026lt; len; ++i){ cout \u0026lt;\u0026lt; p[i] \u0026lt;\u0026lt; endl; } } void sortSelect(const char ** p, int len){ for(int i = 0; i \u0026lt; len - 1; ++i){ int max = i; for(int j = i + 1; j \u0026lt; len; ++j){ if(p[j] \u0026gt; p[max]){ max = j; } } // 交换  if(i != max){ const char* tmp = p[i]; p[i] = p[max]; p[max] = tmp; } } } int main() { const char* arr[] = {\u0026#34;aa\u0026#34;, \u0026#34;bb\u0026#34;, \u0026#34;cc\u0026#34;, \u0026#34;dd\u0026#34;, \u0026#34;ee\u0026#34;}; int len = sizeof(arr) / sizeof(char*); cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; printArr(arr, len); sortSelect(arr, len); cout \u0026lt;\u0026lt; \u0026#34;----------------\u0026#34; \u0026lt;\u0026lt; endl; printArr(arr, len); return 0; } 输出：\n5 aa bb cc dd ee ---------------- ee dd cc bb aa ","permalink":"https://874656645.github.io/posts/116-char-%E6%98%9F%E6%95%B0%E7%BB%84/","summary":"void printArr(const char ** p, int len){ for(int i = 0; i \u0026lt; len; ++i){ cout \u0026lt;\u0026lt; p[i] \u0026lt;\u0026lt; endl; } } void sortSelect(const char ** p, int len){ for(int i = 0; i \u0026lt; len - 1; ++i){ int max = i; for(int j = i + 1; j \u0026lt; len; ++j){ if(p[j] \u0026gt; p[max]){ max = j; } } // 交换  if(i != max){ const char* tmp = p[i]; p[i] = p[max]; p[max] = tmp; } } } int main() { const char* arr[] = {\u0026#34;aa\u0026#34;, \u0026#34;bb\u0026#34;, \u0026#34;cc\u0026#34;, \u0026#34;dd\u0026#34;, \u0026#34;ee\u0026#34;}; int len = sizeof(arr) / sizeof(char*); cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; printArr(arr, len); sortSelect(arr, len); cout \u0026lt;\u0026lt; \u0026#34;----------------\u0026#34; \u0026lt;\u0026lt; endl; printArr(arr, len); return 0; } 输出：","title":"char* 数组"},{"content":"装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代。\n装饰模式可以动态给一个类增加功能\n","permalink":"https://874656645.github.io/posts/115-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代。\n装饰模式可以动态给一个类增加功能","title":"装饰器模式"},{"content":"观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者。\n","permalink":"https://874656645.github.io/posts/114-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者。","title":"观察者模式"},{"content":"将一个请求封闭为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作（Action）模式或事务（Transaction）模式。\n命令模式可以将请求者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求\n","permalink":"https://874656645.github.io/posts/113-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","summary":"将一个请求封闭为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作（Action）模式或事务（Transaction）模式。\n命令模式可以将请求者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求","title":"命令模式"},{"content":"策略模式定义了一系列的算法，并将每个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。\n","permalink":"https://874656645.github.io/posts/112-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","summary":"策略模式定义了一系列的算法，并将每个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。","title":"策略模式"},{"content":"定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\nclass TemplateDrink{ public: virtual void boilWater() = 0; virtual void drew() = 0; virtual void pourCup() = 0; virtual void addSomething() = 0; void make(){ boilWater(); drew(); pourCup(); addSomething(); } }; class Tea : public TemplateDrink{ public: void boilWater() override{ cout \u0026lt;\u0026lt; \u0026#34;煮山泉水...\u0026#34; \u0026lt;\u0026lt; endl; } void drew() override{ cout \u0026lt;\u0026lt; \u0026#34;冲龙井茶...\u0026#34; \u0026lt;\u0026lt; endl; } void pourCup() override{ cout \u0026lt;\u0026lt; \u0026#34;倒入茶杯中...\u0026#34; \u0026lt;\u0026lt; endl; } void addSomething() override{ cout \u0026lt;\u0026lt; \u0026#34;加点柠檬...\u0026#34; \u0026lt;\u0026lt; endl; } }; class Coffee : public TemplateDrink{ public: void boilWater() override{ cout \u0026lt;\u0026lt; \u0026#34;煮矿泉水...\u0026#34; \u0026lt;\u0026lt; endl; } void drew() override{ cout \u0026lt;\u0026lt; \u0026#34;冲雀巢咖啡...\u0026#34; \u0026lt;\u0026lt; endl; } void pourCup() override{ cout \u0026lt;\u0026lt; \u0026#34;倒入咖啡杯中...\u0026#34; \u0026lt;\u0026lt; endl; } void addSomething() override{ cout \u0026lt;\u0026lt; \u0026#34;加点糖和牛奶...\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Tea myTea; myTea.make(); cout \u0026lt;\u0026lt; \u0026#34;-------------------\u0026#34; \u0026lt;\u0026lt; endl; Coffee myCoffee; myCoffee.make(); return 0; } ","permalink":"https://874656645.github.io/posts/111-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","summary":"定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\nclass TemplateDrink{ public: virtual void boilWater() = 0; virtual void drew() = 0; virtual void pourCup() = 0; virtual void addSomething() = 0; void make(){ boilWater(); drew(); pourCup(); addSomething(); } }; class Tea : public TemplateDrink{ public: void boilWater() override{ cout \u0026lt;\u0026lt; \u0026#34;煮山泉水...\u0026#34; \u0026lt;\u0026lt; endl; } void drew() override{ cout \u0026lt;\u0026lt; \u0026#34;冲龙井茶...\u0026#34; \u0026lt;\u0026lt; endl; } void pourCup() override{ cout \u0026lt;\u0026lt; \u0026#34;倒入茶杯中...\u0026#34; \u0026lt;\u0026lt; endl; } void addSomething() override{ cout \u0026lt;\u0026lt; \u0026#34;加点柠檬.","title":"模板方法模式"},{"content":"有一个已经写好的接口，但是不符合需求，适配器就是将已有的接口转化为需要的形式\nclass MyPrint{ public: void operator()(int a, int b){ cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; } }; class TargetInterface{ public: virtual void operator()(int v) = 0; }; class MyAdaptor : public TargetInterface{ public: MyAdaptor(int param):param(param){} void operator()(int v){ print(v, param); } private: MyPrint print; int param; }; MyAdaptor myBind2nd(int v){ return MyAdaptor(v); } int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(i); } for_each(v.begin(), v.end(), myBind2nd(10)); return 0; } ","permalink":"https://874656645.github.io/posts/110-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"有一个已经写好的接口，但是不符合需求，适配器就是将已有的接口转化为需要的形式\nclass MyPrint{ public: void operator()(int a, int b){ cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; } }; class TargetInterface{ public: virtual void operator()(int v) = 0; }; class MyAdaptor : public TargetInterface{ public: MyAdaptor(int param):param(param){} void operator()(int v){ print(v, param); } private: MyPrint print; int param; }; MyAdaptor myBind2nd(int v){ return MyAdaptor(v); } int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(i); } for_each(v.begin(), v.","title":"适配器模式"},{"content":"将复杂的子系统抽象到同一个接口进行管理，外界只需要通过此接口与子类系统进行交互，而不必直接与复杂的子类系统进行交互\n案例：家庭影院外观模式 实现KTV模式：电视打开，灯关掉，音响打开，麦克风打开，DVD打开\n实现游戏模式：电视打开，音响打开，游戏机打开\n","permalink":"https://874656645.github.io/posts/109-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","summary":"将复杂的子系统抽象到同一个接口进行管理，外界只需要通过此接口与子类系统进行交互，而不必直接与复杂的子类系统进行交互\n案例：家庭影院外观模式 实现KTV模式：电视打开，灯关掉，音响打开，麦克风打开，DVD打开\n实现游戏模式：电视打开，音响打开，游戏机打开","title":"外观模式"},{"content":"为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。\n","permalink":"https://874656645.github.io/posts/108-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","summary":"为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。","title":"代理模式"},{"content":" 单例在内存中只有一份，在内存中不会占用太多，程序退出时会随着程序统一释放内存，所以可以不必特意释放  一、懒汉式 不是线程安全的，所以多线程使用要加锁\nclass Singleton{ public: static Singleton* getInstance(){ if(s_instance == nullptr){ s_instance = new Singleton; } return s_instance; } // 可有可无，程序结束时，系统会自动回收程序的所有内存  class Garbo{ ~Garbo(){ if(s_instance){ cout \u0026lt;\u0026lt; \u0026#34;gc...\u0026#34; \u0026lt;\u0026lt; endl; delete s_instance; } } }; private: Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;Singleton()...\u0026#34; \u0026lt;\u0026lt; endl; } Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* s_instance; static Garbo s_gc; }; Singleton* Singleton::s_instance = nullptr; int main() { cout \u0026lt;\u0026lt; \u0026#34;main()...\u0026#34; \u0026lt;\u0026lt; endl; Singleton* s = Singleton::getInstance(); return 0; } 输出：\nmain()... Singleton()... 二、饿汉式 在 main 函数之前，单例就创建好了，所以是线程安全的\nclass Singleton{ public: static Singleton* getInstance(){ return s_instance; } private: Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;Singleton()...\u0026#34; \u0026lt;\u0026lt; endl; } Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* s_instance; }; Singleton* Singleton::s_instance = new Singleton; int main() { cout \u0026lt;\u0026lt; \u0026#34;main()...\u0026#34; \u0026lt;\u0026lt; endl; Singleton* s = Singleton::getInstance(); return 0; } 输出：\nSingleton()... main()... 三、更加简单的方式 class Singleton{ public: static Singleton* getInstance(){ static Singleton* s_instance = new Singleton; return s_instance; } void sayHello(){ cout \u0026lt;\u0026lt; \u0026#34;Hi there\u0026#34; \u0026lt;\u0026lt; endl; } private: Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;Singleton()...\u0026#34; \u0026lt;\u0026lt; endl; } Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; }; int main() { cout \u0026lt;\u0026lt; \u0026#34;main()...\u0026#34; \u0026lt;\u0026lt; endl; Singleton* s1 = Singleton::getInstance(); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s1-\u0026gt;sayHello(); Singleton* s2 = Singleton::getInstance(); cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; s2-\u0026gt;sayHello(); return 0; } 输出：\nmain()... Singleton()... 0x55cc7de532c0 Hi there 0x55cc7de532c0 Hi there ","permalink":"https://874656645.github.io/posts/107-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","summary":"单例在内存中只有一份，在内存中不会占用太多，程序退出时会随着程序统一释放内存，所以可以不必特意释放  一、懒汉式 不是线程安全的，所以多线程使用要加锁\nclass Singleton{ public: static Singleton* getInstance(){ if(s_instance == nullptr){ s_instance = new Singleton; } return s_instance; } // 可有可无，程序结束时，系统会自动回收程序的所有内存  class Garbo{ ~Garbo(){ if(s_instance){ cout \u0026lt;\u0026lt; \u0026#34;gc...\u0026#34; \u0026lt;\u0026lt; endl; delete s_instance; } } }; private: Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;Singleton()...\u0026#34; \u0026lt;\u0026lt; endl; } Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* s_instance; static Garbo s_gc; }; Singleton* Singleton::s_instance = nullptr; int main() { cout \u0026lt;\u0026lt; \u0026#34;main().","title":"单例模式"},{"content":" 抽象工厂针对的是产品族，而不是产品等级 产品族：同一产地或者同一厂商，功能不同 产品等级：功能相同，产地或者厂商不同 对于增加产品族，符合开闭原则 对于增加产品等级，不符合开闭原则  // 抽象工厂模式 class AbstractApple{ public: virtual void showName() = 0; }; class AbstractBanana{ public: virtual void showName() = 0; }; class AbstractPear{ public: virtual void showName() = 0; }; class ChinaApple : public AbstractApple{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是中国苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class ChinaBanana : public AbstractBanana{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是中国香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class ChinaPear : public AbstractPear{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是中国鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class USAApple : public AbstractApple{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是美国苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class USABanana : public AbstractBanana{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是美国香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class USAPear : public AbstractPear{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是美国鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class JapanApple : public AbstractApple{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是日本苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class JapanBanana : public AbstractBanana{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是日本香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class JapanPear : public AbstractPear{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是日本鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class AbstractFactory{ public: virtual AbstractApple* CreateApple() = 0; virtual AbstractBanana* CreateBanana() = 0; virtual AbstractPear* CreatePear() = 0; }; class ChinaFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new ChinaApple; } AbstractBanana* CreateBanana() override{ return new ChinaBanana; } AbstractPear* CreatePear() override{ return new ChinaPear; } }; class USAFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new USAApple; } AbstractBanana* CreateBanana() override{ return new USABanana; } AbstractPear* CreatePear() override{ return new USAPear; } }; class JapanFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new JapanApple; } AbstractBanana* CreateBanana() override{ return new JapanBanana; } AbstractPear* CreatePear() override{ return new JapanPear; } }; int main() { AbstractFactory* factory = nullptr; AbstractApple* apple = nullptr; AbstractBanana* banana = nullptr; AbstractPear* pear = nullptr; // 中国  factory = new ChinaFactory; apple = factory-\u0026gt;CreateApple(); apple-\u0026gt;showName(); banana = factory-\u0026gt;CreateBanana(); banana-\u0026gt;showName(); pear = factory-\u0026gt;CreatePear(); pear-\u0026gt;showName(); delete pear; delete banana; delete apple; delete factory; // 美国  factory = new USAFactory; apple = factory-\u0026gt;CreateApple(); apple-\u0026gt;showName(); banana = factory-\u0026gt;CreateBanana(); banana-\u0026gt;showName(); pear = factory-\u0026gt;CreatePear(); pear-\u0026gt;showName(); delete pear; delete banana; delete apple; delete factory; // 日本  factory = new JapanFactory; apple = factory-\u0026gt;CreateApple(); apple-\u0026gt;showName(); banana = factory-\u0026gt;CreateBanana(); banana-\u0026gt;showName(); pear = factory-\u0026gt;CreatePear(); pear-\u0026gt;showName(); delete pear; delete banana; delete apple; delete factory; return 0; } ","permalink":"https://874656645.github.io/posts/106-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","summary":" 抽象工厂针对的是产品族，而不是产品等级 产品族：同一产地或者同一厂商，功能不同 产品等级：功能相同，产地或者厂商不同 对于增加产品族，符合开闭原则 对于增加产品等级，不符合开闭原则  // 抽象工厂模式 class AbstractApple{ public: virtual void showName() = 0; }; class AbstractBanana{ public: virtual void showName() = 0; }; class AbstractPear{ public: virtual void showName() = 0; }; class ChinaApple : public AbstractApple{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是中国苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class ChinaBanana : public AbstractBanana{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是中国香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class ChinaPear : public AbstractPear{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是中国鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class USAApple : public AbstractApple{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是美国苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class USABanana : public AbstractBanana{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是美国香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class USAPear : public AbstractPear{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是美国鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class JapanApple : public AbstractApple{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是日本苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class JapanBanana : public AbstractBanana{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是日本香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class JapanPear : public AbstractPear{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是日本鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class AbstractFactory{ public: virtual AbstractApple* CreateApple() = 0; virtual AbstractBanana* CreateBanana() = 0; virtual AbstractPear* CreatePear() = 0; }; class ChinaFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new ChinaApple; } AbstractBanana* CreateBanana() override{ return new ChinaBanana; } AbstractPear* CreatePear() override{ return new ChinaPear; } }; class USAFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new USAApple; } AbstractBanana* CreateBanana() override{ return new USABanana; } AbstractPear* CreatePear() override{ return new USAPear; } }; class JapanFactory : public AbstractFactory{ public: AbstractApple* CreateApple() override{ return new JapanApple; } AbstractBanana* CreateBanana() override{ return new JapanBanana; } AbstractPear* CreatePear() override{ return new JapanPear; } }; int main() { AbstractFactory* factory = nullptr; AbstractApple* apple = nullptr; AbstractBanana* banana = nullptr; AbstractPear* pear = nullptr; // 中国  factory = new ChinaFactory; apple = factory-\u0026gt;CreateApple(); apple-\u0026gt;showName(); banana = factory-\u0026gt;CreateBanana(); banana-\u0026gt;showName(); pear = factory-\u0026gt;CreatePear(); pear-\u0026gt;showName(); delete pear; delete banana; delete apple; delete factory; // 美国  factory = new USAFactory; apple = factory-\u0026gt;CreateApple(); apple-\u0026gt;showName(); banana = factory-\u0026gt;CreateBanana(); banana-\u0026gt;showName(); pear = factory-\u0026gt;CreatePear(); pear-\u0026gt;showName(); delete pear; delete banana; delete apple; delete factory; // 日本  factory = new JapanFactory; apple = factory-\u0026gt;CreateApple(); apple-\u0026gt;showName(); banana = factory-\u0026gt;CreateBanana(); banana-\u0026gt;showName(); pear = factory-\u0026gt;CreatePear(); pear-\u0026gt;showName(); delete pear; delete banana; delete apple; delete factory; return 0; } ","title":"抽象工厂模式"},{"content":"工厂方法模式 = 简单工厂模式 + 开闭原则\n类的个数成倍增多，维护成本很高\n适用场景：\n 客户端不知道它所需要的对象的类 抽象工厂类通过其子类来指定创建哪个对象  // 工厂方法模式 class AbstractFruit{ public: virtual void showName() = 0; }; class Apple : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Banana : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Pear : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; // 抽象工厂 class AbstractFruitFactory{ public: virtual AbstractFruit* CreateFruit() = 0; }; class AppleFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Apple; } }; class PearFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Pear; } }; class BananaFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Banana; } }; int main() { AbstractFruitFactory* factory = nullptr; AbstractFruit* fruit = nullptr; factory = new AppleFactory; fruit = factory-\u0026gt;CreateFruit(); fruit-\u0026gt;showName(); delete fruit; delete factory; factory = new BananaFactory; fruit = factory-\u0026gt;CreateFruit(); fruit-\u0026gt;showName(); delete fruit; delete factory; factory = new PearFactory; fruit = factory-\u0026gt;CreateFruit(); fruit-\u0026gt;showName(); delete fruit; delete factory; return 0; } ","permalink":"https://874656645.github.io/posts/105-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","summary":"工厂方法模式 = 简单工厂模式 + 开闭原则\n类的个数成倍增多，维护成本很高\n适用场景：\n 客户端不知道它所需要的对象的类 抽象工厂类通过其子类来指定创建哪个对象  // 工厂方法模式 class AbstractFruit{ public: virtual void showName() = 0; }; class Apple : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Banana : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Pear : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; // 抽象工厂 class AbstractFruitFactory{ public: virtual AbstractFruit* CreateFruit() = 0; }; class AppleFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Apple; } }; class PearFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Pear; } }; class BananaFactory : public AbstractFruitFactory{ public: AbstractFruit* CreateFruit() override{ return new Banana; } }; int main() { AbstractFruitFactory* factory = nullptr; AbstractFruit* fruit = nullptr; factory = new AppleFactory; fruit = factory-\u0026gt;CreateFruit(); fruit-\u0026gt;showName(); delete fruit; delete factory; factory = new BananaFactory; fruit = factory-\u0026gt;CreateFruit(); fruit-\u0026gt;showName(); delete fruit; delete factory; factory = new PearFactory; fruit = factory-\u0026gt;CreateFruit(); fruit-\u0026gt;showName(); delete fruit; delete factory; return 0; } ","title":"工厂方法模式"},{"content":" 实现了客户端与功能类的解耦 但是违反了类的单一职责原则，整个类的代码冗长，阅读难度、维护难度和测试难度也很大 违反了开闭原则，增添功能要修改源代码  适用场景：\n 工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂 客户端只知道传入工厂类的参数，对于如何创建对象并不关心  // 简单工厂模式 class AbstractFruit{ public: virtual void showName() = 0; }; class Apple : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Banana : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Pear : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class FruitFactory{ public: static AbstractFruit* CreateFruit(string flag){ if(flag == \u0026#34;apple\u0026#34;){ return new Apple; } else if(flag == \u0026#34;banana\u0026#34;){ return new Banana; } else if(flag == \u0026#34;pear\u0026#34;){ return new Pear; } else{ return nullptr; } } }; int main() { AbstractFruit* fruit = FruitFactory::CreateFruit(\u0026#34;apple\u0026#34;); fruit-\u0026gt;showName(); delete fruit; fruit = FruitFactory::CreateFruit(\u0026#34;banana\u0026#34;); fruit-\u0026gt;showName(); delete fruit; fruit = FruitFactory::CreateFruit(\u0026#34;pear\u0026#34;); fruit-\u0026gt;showName(); delete fruit; return 0; } ","permalink":"https://874656645.github.io/posts/104-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","summary":" 实现了客户端与功能类的解耦 但是违反了类的单一职责原则，整个类的代码冗长，阅读难度、维护难度和测试难度也很大 违反了开闭原则，增添功能要修改源代码  适用场景：\n 工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂 客户端只知道传入工厂类的参数，对于如何创建对象并不关心  // 简单工厂模式 class AbstractFruit{ public: virtual void showName() = 0; }; class Apple : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是苹果！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Banana : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是香蕉！\u0026#34; \u0026lt;\u0026lt; endl; } }; class Pear : public AbstractFruit{ public: void showName() override{ cout \u0026lt;\u0026lt; \u0026#34;我是鸭梨！\u0026#34; \u0026lt;\u0026lt; endl; } }; class FruitFactory{ public: static AbstractFruit* CreateFruit(string flag){ if(flag == \u0026#34;apple\u0026#34;){ return new Apple; } else if(flag == \u0026#34;banana\u0026#34;){ return new Banana; } else if(flag == \u0026#34;pear\u0026#34;){ return new Pear; } else{ return nullptr; } } }; int main() { AbstractFruit* fruit = FruitFactory::CreateFruit(\u0026#34;apple\u0026#34;); fruit-\u0026gt;showName(); delete fruit; fruit = FruitFactory::CreateFruit(\u0026#34;banana\u0026#34;); fruit-\u0026gt;showName(); delete fruit; fruit = FruitFactory::CreateFruit(\u0026#34;pear\u0026#34;); fruit-\u0026gt;showName(); delete fruit; return 0; } ","title":"简单工厂模式"},{"content":"传统过程式设计 传统的过程式设计倾向于使高层次的模块依赖于低层次的模块，抽象层依赖于具体实现层\n// 底层实现 class BankWorker{ public: void saveService(){ cout \u0026lt;\u0026lt; \u0026#34;办理存款业务...\u0026#34; \u0026lt;\u0026lt; endl; } void transferService(){ cout \u0026lt;\u0026lt; \u0026#34;办理转账业务...\u0026#34; \u0026lt;\u0026lt; endl; } void payService(){ cout \u0026lt;\u0026lt; \u0026#34;办理支付业务...\u0026#34; \u0026lt;\u0026lt; endl; } }; // 中层封装 void doSaveBusiness(BankWorker* worker){ worker-\u0026gt;saveService(); } void doTransferBusiness(BankWorker* worker){ worker-\u0026gt;transferService(); } void doPayBusiness(BankWorker* worker){ worker-\u0026gt;payService(); } // 高层调用 void test1(){ BankWorker* bw = new BankWorker; doSaveBusiness(bw); doPayBusiness(bw); doTransferBusiness(bw); delete bw; } 依赖倒转 // 抽象层 class AbstractWorker{ public: virtual void doBusiness() = 0; }; // 实现层 class SaveBankWorker:public AbstractWorker{ public: void doBusiness()override{ cout \u0026lt;\u0026lt; \u0026#34;办理存款业务...\u0026#34; \u0026lt;\u0026lt; endl; } }; class PayBankWorker:public AbstractWorker{ public: void doBusiness()override{ cout \u0026lt;\u0026lt; \u0026#34;办理支付业务...\u0026#34; \u0026lt;\u0026lt; endl; } }; class TransferBankWorker:public AbstractWorker{ public: void doBusiness()override{ cout \u0026lt;\u0026lt; \u0026#34;办理转账业务...\u0026#34; \u0026lt;\u0026lt; endl; } }; // 业务封装 void doBusiness(AbstractWorker* aw){ aw-\u0026gt;doBusiness(); delete aw; } // 高层调用 void test2(){ doBusiness(new SaveBankWorker); doBusiness(new PayBankWorker); doBusiness(new TransferBankWorker); } ","permalink":"https://874656645.github.io/posts/103-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/","summary":"传统过程式设计 传统的过程式设计倾向于使高层次的模块依赖于低层次的模块，抽象层依赖于具体实现层\n// 底层实现 class BankWorker{ public: void saveService(){ cout \u0026lt;\u0026lt; \u0026#34;办理存款业务...\u0026#34; \u0026lt;\u0026lt; endl; } void transferService(){ cout \u0026lt;\u0026lt; \u0026#34;办理转账业务...\u0026#34; \u0026lt;\u0026lt; endl; } void payService(){ cout \u0026lt;\u0026lt; \u0026#34;办理支付业务...\u0026#34; \u0026lt;\u0026lt; endl; } }; // 中层封装 void doSaveBusiness(BankWorker* worker){ worker-\u0026gt;saveService(); } void doTransferBusiness(BankWorker* worker){ worker-\u0026gt;transferService(); } void doPayBusiness(BankWorker* worker){ worker-\u0026gt;payService(); } // 高层调用 void test1(){ BankWorker* bw = new BankWorker; doSaveBusiness(bw); doPayBusiness(bw); doTransferBusiness(bw); delete bw; } 依赖倒转 // 抽象层 class AbstractWorker{ public: virtual void doBusiness() = 0; }; // 实现层 class SaveBankWorker:public AbstractWorker{ public: void doBusiness()override{ cout \u0026lt;\u0026lt; \u0026#34;办理存款业务.","title":"依赖倒转原则"},{"content":"优先使用组合的方式，而不是继承\nclass AbstractCar{ public: virtual void run() = 0; }; class BMW:public AbstractCar{ public: void run()override{ cout \u0026lt;\u0026lt; \u0026#34;BMW run\u0026#34; \u0026lt;\u0026lt; endl; } }; class DaZhong:public AbstractCar{ public: void run()override{ cout \u0026lt;\u0026lt; \u0026#34;DaZhong run\u0026#34; \u0026lt;\u0026lt; endl; } }; #if 0// 错误的做法 class Person : public BMW{ public: void drive(){ run(); } }; void test1(){ Person p; p.drive(); } #endif // 正确做法 class Person{ public: Person(){ car = nullptr; } Person(AbstractCar* c){ car = c; } void drive(){ car-\u0026gt;run(); delete car; } void drive(AbstractCar* car){ car-\u0026gt;run(); delete car; } private: AbstractCar* car; }; void test2(){ // 方式一：  Person* p = new Person(new BMW); p-\u0026gt;drive(); delete p; p = new Person(new DaZhong); p-\u0026gt;drive(); delete p; // 方式二：  Person pp; pp.drive(new BMW); pp.drive(new DaZhong); } int main() { test2(); return 0; } ","permalink":"https://874656645.github.io/posts/102-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/","summary":"优先使用组合的方式，而不是继承\nclass AbstractCar{ public: virtual void run() = 0; }; class BMW:public AbstractCar{ public: void run()override{ cout \u0026lt;\u0026lt; \u0026#34;BMW run\u0026#34; \u0026lt;\u0026lt; endl; } }; class DaZhong:public AbstractCar{ public: void run()override{ cout \u0026lt;\u0026lt; \u0026#34;DaZhong run\u0026#34; \u0026lt;\u0026lt; endl; } }; #if 0// 错误的做法 class Person : public BMW{ public: void drive(){ run(); } }; void test1(){ Person p; p.drive(); } #endif // 正确做法 class Person{ public: Person(){ car = nullptr; } Person(AbstractCar* c){ car = c; } void drive(){ car-\u0026gt;run(); delete car; } void drive(AbstractCar* car){ car-\u0026gt;run(); delete car; } private: AbstractCar* car; }; void test2(){ // 方式一：  Person* p = new Person(new BMW); p-\u0026gt;drive(); delete p; p = new Person(new DaZhong); p-\u0026gt;drive(); delete p; // 方式二：  Person pp; pp.","title":"合成复用原则"},{"content":"又叫最少知识原则\n封装一个中间层进行隔离\nclass AbstractBuilding{ public: virtual string getQuality()const = 0; virtual void sale() = 0; }; class BuildingA:public AbstractBuilding{ public: BuildingA(){ m_quality = \u0026#34;高品质\u0026#34;; } string getQuality()const override{ return m_quality; } void sale()override{ cout \u0026lt;\u0026lt; \u0026#34;楼盘A：\u0026#34; \u0026lt;\u0026lt; m_quality \u0026lt;\u0026lt; endl; } private: string m_quality; }; class BuildingB:public AbstractBuilding{ public: BuildingB(){ m_quality = \u0026#34;低品质\u0026#34;; } string getQuality()const override{ return m_quality; } void sale()override{ cout \u0026lt;\u0026lt; \u0026#34;楼盘B：\u0026#34; \u0026lt;\u0026lt; m_quality \u0026lt;\u0026lt; endl; } private: string m_quality; }; // 错误的做法 // 客户端 void test1(){ string myRequest = \u0026#34;低品质\u0026#34;; BuildingA* bA = new BuildingA; if(bA-\u0026gt;getQuality() == myRequest){ bA-\u0026gt;sale(); delete bA; } BuildingB* bB = new BuildingB; if(bB-\u0026gt;getQuality() == myRequest){ bB-\u0026gt;sale(); delete bB; } } // 正确做法 // 封装一个中间类 class Mediator{ public: Mediator(){ AbstractBuilding* b = new BuildingA; vb.push_back(b); b = new BuildingB; vb.push_back(b); } AbstractBuilding* getBuilding(string req){ for(const auto \u0026amp;b : vb){ if(b-\u0026gt;getQuality() == req){ return b; } } return NULL; } ~Mediator(){ for(auto \u0026amp;b : vb){ if(b != NULL){ delete b; } } } private: vector\u0026lt;AbstractBuilding*\u0026gt; vb; }; // 客户端 void test2(){ string myRequest = \u0026#34;低品质\u0026#34;; Mediator m; AbstractBuilding* b = m.getBuilding(myRequest); if(b != NULL){ b-\u0026gt;sale(); } else{ cout \u0026lt;\u0026lt; \u0026#34;未找到需要的楼盘\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { test2(); return 0; } ","permalink":"https://874656645.github.io/posts/101-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/","summary":"又叫最少知识原则\n封装一个中间层进行隔离\nclass AbstractBuilding{ public: virtual string getQuality()const = 0; virtual void sale() = 0; }; class BuildingA:public AbstractBuilding{ public: BuildingA(){ m_quality = \u0026#34;高品质\u0026#34;; } string getQuality()const override{ return m_quality; } void sale()override{ cout \u0026lt;\u0026lt; \u0026#34;楼盘A：\u0026#34; \u0026lt;\u0026lt; m_quality \u0026lt;\u0026lt; endl; } private: string m_quality; }; class BuildingB:public AbstractBuilding{ public: BuildingB(){ m_quality = \u0026#34;低品质\u0026#34;; } string getQuality()const override{ return m_quality; } void sale()override{ cout \u0026lt;\u0026lt; \u0026#34;楼盘B：\u0026#34; \u0026lt;\u0026lt; m_quality \u0026lt;\u0026lt; endl; } private: string m_quality; }; // 错误的做法 // 客户端 void test1(){ string myRequest = \u0026#34;低品质\u0026#34;; BuildingA* bA = new BuildingA; if(bA-\u0026gt;getQuality() == myRequest){ bA-\u0026gt;sale(); delete bA; } BuildingB* bB = new BuildingB; if(bB-\u0026gt;getQuality() == myRequest){ bB-\u0026gt;sale(); delete bB; } } // 正确做法 // 封装一个中间类 class Mediator{ public: Mediator(){ AbstractBuilding* b = new BuildingA; vb.","title":"迪米特法则"},{"content":"对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码\n如下所示，如果想要扩展乘法、除法、取模等算法，就不用修改原码，只需增加新类\nclass AbstractCalculator{ public: virtual void setOperatorNum(int a, int b) = 0; virtual int getResult() = 0; }; class PlusCalculator:public AbstractCalculator{ public: void setOperatorNum(int a, int b)override{ m_a = a; m_b = b; } int getResult()override{ return m_a + m_b; } private: int m_a{0}; int m_b{0}; }; class MinusCalculator:public AbstractCalculator{ public: void setOperatorNum(int a, int b)override{ m_a = a; m_b = b; } int getResult()override{ return m_a - m_b; } private: int m_a{0}; int m_b{0}; }; int main() { AbstractCalculator* calculator = new PlusCalculator; calculator-\u0026gt;setOperatorNum(10, 20); cout \u0026lt;\u0026lt; calculator-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete calculator; calculator = nullptr; calculator = new MinusCalculator; calculator-\u0026gt;setOperatorNum(10, 20); cout \u0026lt;\u0026lt; calculator-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete calculator; calculator = nullptr; return 0; } ","permalink":"https://874656645.github.io/posts/100-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/","summary":"对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码\n如下所示，如果想要扩展乘法、除法、取模等算法，就不用修改原码，只需增加新类\nclass AbstractCalculator{ public: virtual void setOperatorNum(int a, int b) = 0; virtual int getResult() = 0; }; class PlusCalculator:public AbstractCalculator{ public: void setOperatorNum(int a, int b)override{ m_a = a; m_b = b; } int getResult()override{ return m_a + m_b; } private: int m_a{0}; int m_b{0}; }; class MinusCalculator:public AbstractCalculator{ public: void setOperatorNum(int a, int b)override{ m_a = a; m_b = b; } int getResult()override{ return m_a - m_b; } private: int m_a{0}; int m_b{0}; }; int main() { AbstractCalculator* calculator = new PlusCalculator; calculator-\u0026gt;setOperatorNum(10, 20); cout \u0026lt;\u0026lt; calculator-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete calculator; calculator = nullptr; calculator = new MinusCalculator; calculator-\u0026gt;setOperatorNum(10, 20); cout \u0026lt;\u0026lt; calculator-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete calculator; calculator = nullptr; return 0; } ","title":"开闭原则"},{"content":"原则目的：高内聚，低耦合\n 单一职责原则 Single Responsibility Principal（SRP）：类的职责单一，对外只提供一种功能 开闭原则 Open-Closed Principal（OCP）：对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码 里氏代换原则 Liskov Substitution Principal（LSP）：任何抽象类出现的地方都可以用他的实现类进行替换（多态） 依赖倒转原则 Dependence Inversion Principal（DIP）：依赖于抽象（接口），不要依赖具体的实现（类），针对接口编程 接口隔离原则 Interface Segregation Principal（ISP）：一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去 合成复用原则 Composite Reuse Principal（CRP）：对于继承和组合，优先使用组合 迪米特法则 Law of Demeter（LoD）：一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节（黑盒原理）  ","permalink":"https://874656645.github.io/posts/99-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","summary":"原则目的：高内聚，低耦合\n 单一职责原则 Single Responsibility Principal（SRP）：类的职责单一，对外只提供一种功能 开闭原则 Open-Closed Principal（OCP）：对扩展开放，对修改关闭，类的改动是通过增加代码进行的，而不是修改源代码 里氏代换原则 Liskov Substitution Principal（LSP）：任何抽象类出现的地方都可以用他的实现类进行替换（多态） 依赖倒转原则 Dependence Inversion Principal（DIP）：依赖于抽象（接口），不要依赖具体的实现（类），针对接口编程 接口隔离原则 Interface Segregation Principal（ISP）：一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去 合成复用原则 Composite Reuse Principal（CRP）：对于继承和组合，优先使用组合 迪米特法则 Law of Demeter（LoD）：一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节（黑盒原理）  ","title":"面向对象设计原则"},{"content":"设计模式\n一、概念  设计模式是在特定环境下人们解决某类重复出现的问题的一套成功或有效的解决方案。 软件模式并非仅限于设计模式，还包括架构模式、分析模式、过程模式等。 在一定环境下，用固定套路解决问题。 设计模式的基础是多态。  二、目的  学习设计模式有助于更加深入的理解面向对象思想 如何将代码分散在几个不同的类中 为什么要有接口 何谓针对抽象编程 何时不应该使用继承 如何不修改源代码增加新功能 更好地阅读和理解现有类库与其它系统中的源代码  三、软件设计模式种类 GoF 提出的设计模式有 23 种，加简单工厂模式，一共 24 种\n1、创建型模式 Creational 6种 如何创建对象\n 单例模式 简单工厂模式 工厂方法模式 抽象工厂模式 原型模式 建造者模式  2、结构型模式 Structural 7种 如何实现类或对象的组合\n让类和类进行组合，获得更大的结构\n 适配器模式 桥接模式 组合模式 装饰模式 外观模式 享元模式 代理模式  3、行为型模式 Behavioral 11种 类或对象怎样交互以及怎样分配职责\n 职责链模式 命令模式 解释器模式 迭代器模式 中介模式 备忘录模式 观察者模式 状态模式 策略模式 模板方法模式 访问者模式  ","permalink":"https://874656645.github.io/posts/98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"设计模式\n一、概念  设计模式是在特定环境下人们解决某类重复出现的问题的一套成功或有效的解决方案。 软件模式并非仅限于设计模式，还包括架构模式、分析模式、过程模式等。 在一定环境下，用固定套路解决问题。 设计模式的基础是多态。  二、目的  学习设计模式有助于更加深入的理解面向对象思想 如何将代码分散在几个不同的类中 为什么要有接口 何谓针对抽象编程 何时不应该使用继承 如何不修改源代码增加新功能 更好地阅读和理解现有类库与其它系统中的源代码  三、软件设计模式种类 GoF 提出的设计模式有 23 种，加简单工厂模式，一共 24 种\n1、创建型模式 Creational 6种 如何创建对象\n 单例模式 简单工厂模式 工厂方法模式 抽象工厂模式 原型模式 建造者模式  2、结构型模式 Structural 7种 如何实现类或对象的组合\n让类和类进行组合，获得更大的结构\n 适配器模式 桥接模式 组合模式 装饰模式 外观模式 享元模式 代理模式  3、行为型模式 Behavioral 11种 类或对象怎样交互以及怎样分配职责\n 职责链模式 命令模式 解释器模式 迭代器模式 中介模式 备忘录模式 观察者模式 状态模式 策略模式 模板方法模式 访问者模式  ","title":"设计模式"},{"content":"一、用例图  用例代表系统的某项完整功能 从客户角度来描述系统功能 包括参与者、用例、关系  1. 泛化关系 Generalization  父类和子类的关系  2. 包含关系 Include  一个功能肯定会使用另一个功能  3. 扩展关系 Extend  完成某个功能的时候偶尔会执行另一个功能  二、类图 用来显示系统中的类，接口以及它们之间的关系\n1. 泛化关系 Generalization（is a） 一种类与类之间的继承关系\n2. 实现关系 Realization（is a） 类与抽象类之间的实现关系\n3. 依赖关系 Dependence（use a） 两个相对独立的系统，一个系统负责构造另一个系统的实例，或者依赖另一个系统的服务\n类 A 做为类 B 方法的形参，而不是类 B 的成员属性\n4. 关联关系 Directed Association 两个相对独立的系统，一个系统的实例与另一个系统的一些实例存在固定的对应关系\n  聚合 Aggregation\n 聚合关系是关联关系的一种，是更强的关联关系 聚合是整体和部分之间的关系，例如汽车由引擎、轮胎以及其它零件组成 聚合关系也是通过成员变量来实现的，但是，关联关系所涉及的两个类处在同一个层次上，而聚合关系中，两个类处于不同层次上，一个代表整体，一个代表部分 整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享    组合 Composition\n  三、对象图 四、时序图 五、活动图 ","permalink":"https://874656645.github.io/posts/97-uml-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/","summary":"一、用例图  用例代表系统的某项完整功能 从客户角度来描述系统功能 包括参与者、用例、关系  1. 泛化关系 Generalization  父类和子类的关系  2. 包含关系 Include  一个功能肯定会使用另一个功能  3. 扩展关系 Extend  完成某个功能的时候偶尔会执行另一个功能  二、类图 用来显示系统中的类，接口以及它们之间的关系\n1. 泛化关系 Generalization（is a） 一种类与类之间的继承关系\n2. 实现关系 Realization（is a） 类与抽象类之间的实现关系\n3. 依赖关系 Dependence（use a） 两个相对独立的系统，一个系统负责构造另一个系统的实例，或者依赖另一个系统的服务\n类 A 做为类 B 方法的形参，而不是类 B 的成员属性\n4. 关联关系 Directed Association 两个相对独立的系统，一个系统的实例与另一个系统的一些实例存在固定的对应关系\n  聚合 Aggregation\n 聚合关系是关联关系的一种，是更强的关联关系 聚合是整体和部分之间的关系，例如汽车由引擎、轮胎以及其它零件组成 聚合关系也是通过成员变量来实现的，但是，关联关系所涉及的两个类处在同一个层次上，而聚合关系中，两个类处于不同层次上，一个代表整体，一个代表部分 整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享    组合 Composition\n  三、对象图 四、时序图 五、活动图 ","title":"UML 统一建模语言"},{"content":"  仿函数适配器 bind1st、bind2nd 将二元仿函数转为一元仿函数\n  仿函数适配器 not1、not2\n  仿函数适配器 ptr_fun 将普通函数转为函数对象，然后就可以与其它仿函数适配器一起使用了\n  仿函数适配器 mem_fun、mem_fun_ref 将成员函数转为适配器\n  class MyPrint : public binary_function\u0026lt;int, int, void\u0026gt;{ public: void operator()(int v, int val) const{ cout \u0026lt;\u0026lt; \u0026#34;v: \u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;, val: \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34;, v + val: \u0026#34; \u0026lt;\u0026lt; v + val \u0026lt;\u0026lt; endl; } }; void myPrint(int v, int val){ cout \u0026lt;\u0026lt; v + val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } class MySort: public binary_function\u0026lt;int, int, bool\u0026gt;{ public: bool operator() (int lhs, int rhs)const{ return lhs \u0026gt; rhs; } }; class MyGreater: public unary_function\u0026lt;int, bool\u0026gt;{ public: bool operator()(int v)const{ return v \u0026gt; 50; } }; void printVec(const vector\u0026lt;int\u0026gt; \u0026amp;v){ for(const auto \u0026amp;p : v){ cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } class Person{ public: Person(int id, int age):id(id), age(age){} void show(){ cout \u0026lt;\u0026lt; \u0026#34;id: \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;, age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl; } int id; int age; }; int main(){ vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(rand() % 100); } // bind1st bind2nd  for_each(v.begin(), v.end(), bind1st(MyPrint(), 100)); cout \u0026lt;\u0026lt; endl; // ptr_fun  for_each(v.begin(), v.end(), bind2nd(ptr_fun(myPrint), 100)); cout \u0026lt;\u0026lt; endl; printVec(v); // not1 not2  sort(v.begin(), v.end(), not2(MySort())); printVec(v); auto it = find_if(v.begin(), v.end(), not1(MyGreater())); if(it != v.end()){ cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } // mem_fun_ref mem_fun  vector\u0026lt;Person\u0026gt; vp; vp.emplace_back(Person(1, 2)); vp.emplace_back(Person(3, 4)); vp.emplace_back(Person(5, 6)); for_each(vp.begin(), vp.end(), mem_fun_ref(\u0026amp;Person::show)); cout \u0026lt;\u0026lt; \u0026#34;--------------\u0026#34; \u0026lt;\u0026lt; endl; vector\u0026lt;Person*\u0026gt; vpp; vpp.emplace_back(new Person(1, 2)); vpp.emplace_back(new Person(3, 4)); vpp.emplace_back(new Person(5, 6)); for_each(vpp.begin(), vpp.end(), mem_fun(\u0026amp;Person::show)); return 0; } v: 100, val: 83, v + val: 183 v: 100, val: 86, v + val: 186 v: 100, val: 77, v + val: 177 v: 100, val: 15, v + val: 115 v: 100, val: 93, v + val: 193 v: 100, val: 35, v + val: 135 v: 100, val: 86, v + val: 186 v: 100, val: 92, v + val: 192 v: 100, val: 49, v + val: 149 v: 100, val: 21, v + val: 121 183 186 177 115 193 135 186 192 149 121 83 86 77 15 93 35 86 92 49 21 15 21 35 49 77 83 86 86 92 93 15 id: 1, age: 2 id: 3, age: 4 id: 5, age: 6 -------------- id: 1, age: 2 id: 3, age: 4 id: 5, age: 6 ","permalink":"https://874656645.github.io/posts/96-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8/","summary":"仿函数适配器 bind1st、bind2nd 将二元仿函数转为一元仿函数\n  仿函数适配器 not1、not2\n  仿函数适配器 ptr_fun 将普通函数转为函数对象，然后就可以与其它仿函数适配器一起使用了\n  仿函数适配器 mem_fun、mem_fun_ref 将成员函数转为适配器\n  class MyPrint : public binary_function\u0026lt;int, int, void\u0026gt;{ public: void operator()(int v, int val) const{ cout \u0026lt;\u0026lt; \u0026#34;v: \u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;, val: \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34;, v + val: \u0026#34; \u0026lt;\u0026lt; v + val \u0026lt;\u0026lt; endl; } }; void myPrint(int v, int val){ cout \u0026lt;\u0026lt; v + val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } class MySort: public binary_function\u0026lt;int, int, bool\u0026gt;{ public: bool operator() (int lhs, int rhs)const{ return lhs \u0026gt; rhs; } }; class MyGreater: public unary_function\u0026lt;int, bool\u0026gt;{ public: bool operator()(int v)const{ return v \u0026gt; 50; } }; void printVec(const vector\u0026lt;int\u0026gt; \u0026amp;v){ for(const auto \u0026amp;p : v){ cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } class Person{ public: Person(int id, int age):id(id), age(age){} void show(){ cout \u0026lt;\u0026lt; \u0026#34;id: \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;, age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl; } int id; int age; }; int main(){ vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.","title":"函数对象适配器"},{"content":"  有的情况下，现在的折衷方案比未来的理想方案好得多\n  我考虑问题的本质是什么，再定义一个类抓住这个本质，并确保这个类能独立地工作。然后在遇到符合这个本质的问题时就使用这个类。\n  只要类定义正确，我就只能按照我编写它的初衷那样去用它。\n  C++ 哲学：抽象，实用，只为用到的东西付出代价。\n  类设计者的核查表：\n 你的类需要一个构造函数吗？ 你的数据成员是私有的吗？（使用函数，可以延迟计算，不必时时计算，保证数据成员的准确性） 你的类需要一个无参的构造函数吗？（对象数组） 是不是每个构造函数初始化所有的数据成员？ 类需要析构函数吗？ 类需要一个虚析构函数吗？ 你的类需要复制构造函数吗？（是否需要深拷贝） 你的类需要一个赋值操作符吗？ 你的赋值操作符能正确地将对象赋给对象本身吗？ 你的类需要定义关系操作符吗？ 删除数组时你记住了用 delete[] 吗？ 记得在复制构造函数和赋值操作符的参数类型中加上 const 了吗？ 如果函数有引用参数，它们应该是 const 引用吗？ 记得适当地声明成员函数为 const 的了吗？    代理类：用类来表示概念（RAII）\nclass Vehicle{ public: virtual double weight() = 0; virtual void start() = 0; virtual Vehicle* copy() const = 0; virtual ~Vehicle(){} }; class RoadVehicle: public Vehicle{ /* ... */ }; class AutoVehicle: public RoadVehicle{ /* ... */ }; class Aircraft: public Vehicle{ /* ... */ }; class Helicopter: public Aircraft{ /* ... */ }; // 定义代理类 class VehicleSurrogate{ public: VehicleSurrogate(){ // 空代理  vp(0); } VehicleSurrogate(const Vehicle\u0026amp; v){ vp = v.copy(); } ~VehicleSurrogate(){ delete vp; } VehicleSurrogate(const VehicleSurrogate\u0026amp; v){ vp(v.vp ? v.vp-\u0026gt;copy() : 0); } VehicleSurrogate\u0026amp; operator=(const VehicleSurrogate\u0026amp;){ if(this != \u0026amp;v){ delete vp; vp = (v.vp ? v.vp-\u0026gt;copy() : 0); } return *this; } /* 其实代理类也可以不依依写出 Vehicle 所能支持的其他操作 只需要实现 * 和 -\u0026gt; 的操作符重载即可，做一次转发， 但这样就过多地暴露了内存分配方面的策略，不太安全 */ double weight() const{ if(vp == 0){ throw \u0026#34;empty VehicleSurrogate.weight()\u0026#34;; } return vp-\u0026gt;weight(); } void start() { if(vp == 0){ throw \u0026#34;empty VehicleSurrogate.start()\u0026#34;; } return vp-\u0026gt;start(); } private: Vehicle* vp; }; int main(){ // Vehicle parking_lot[1000]; // wrong  VehicleSurrogate parking_lot[1000]; // OK  AutoVehicle x; parking_lot[num_vehicles++] = x; return 0; }   Handle 句柄类：就是一种只包含单个对象的容器 与智能指针的理念类似，智能指针更像是 Handle 类的抽象\nclass Point{ public: Point(int x = 0, int y = 0):xval(x), yval(y){ cout \u0026lt;\u0026lt; \u0026#34;Point()\u0026#34; \u0026lt;\u0026lt; endl; } Point(const Point\u0026amp; p){ cout \u0026lt;\u0026lt; \u0026#34;Point(const Point\u0026amp; p)\u0026#34; \u0026lt;\u0026lt; endl; xval = p.xval; yval = p.yval; } ~Point(){ cout \u0026lt;\u0026lt; \u0026#34;~Point()\u0026#34; \u0026lt;\u0026lt; endl; } int x() const {return xval;} int y() const {return yval;} Point\u0026amp; x(int xv){ xval = xv; return *this; } Point\u0026amp; y(int yv){ yval = yv; return *this; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;x: \u0026#34; \u0026lt;\u0026lt; xval \u0026lt;\u0026lt; \u0026#34; y: \u0026#34; \u0026lt;\u0026lt; yval \u0026lt;\u0026lt; endl; } private: int xval, yval; }; class Handle; class UPoint{ friend class Handle; Point p; int u; UPoint():u(1){} UPoint(int x, int y):p(x, y), u(1){} UPoint(const Point\u0026amp; p0):p(p0), u(1){} }; class Handle{ public: Handle():up(new UPoint){} Handle(int x, int y):up(new UPoint(x, y)){} Handle(const Point \u0026amp;p):up(new UPoint(p)){} Handle(const Handle \u0026amp;h):up(h.up){++up-\u0026gt;u;} ~Handle(){ if(--up-\u0026gt;u == 0){ delete up; } } Handle\u0026amp; operator=(const Handle\u0026amp; h){ ++h.up-\u0026gt;u; if(--up-\u0026gt;u == 0){ delete up; } up = h.up; cout \u0026lt;\u0026lt; up-\u0026gt;u \u0026lt;\u0026lt; endl; return *this; } int x() const{ return up-\u0026gt;p.x(); } int y() const{ return up-\u0026gt;p.y(); } /*指针语义 不必复制 UPoint 对象 Handle\u0026amp; x(int x){ up-\u0026gt;p.x(x); return *this; } Handle\u0026amp; y(int y){ up-\u0026gt;p.y(y); return *this; } */ /*值语义 写时复制 */ Handle\u0026amp; x(int x){ copyWhenWrite(); up-\u0026gt;p.x(x); return *this; } Handle\u0026amp; y(int y){ copyWhenWrite(); up-\u0026gt;p.y(y); return *this; } private: void copyWhenWrite(){ if(up-\u0026gt;u != 1){ --up-\u0026gt;u; up = new UPoint(up-\u0026gt;p); } } private: UPoint * up; }; int main() { Point p(10, 20); Handle hp(p); // 通过拷贝构造创建一个p的副本，并将 handle绑定到该副本  Handle hpp(hp); Handle hppp(hp); Handle hpppp; hpppp = hp; hpppp.x(100).y(200); cout \u0026lt;\u0026lt; hp.x() \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; hp.y() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; hpppp.x() \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; hpppp.y() \u0026lt;\u0026lt; endl; return 0; } 输出：\nPoint() Point(const Point\u0026amp; p) 1 2 3 Point() ~Point() 4 Point(const Point\u0026amp; p) 10, 20 100, 200 ~Point() ~Point() ~Point()   对象和值之间的差别只在要改变对象时才显现出来。换句话说，就是值和不可变的对象是无法区分的。\n  ","permalink":"https://874656645.github.io/posts/95-c++-%E6%B2%89%E6%80%9D%E5%BD%95%E7%AC%94%E8%AE%B0/","summary":"有的情况下，现在的折衷方案比未来的理想方案好得多\n  我考虑问题的本质是什么，再定义一个类抓住这个本质，并确保这个类能独立地工作。然后在遇到符合这个本质的问题时就使用这个类。\n  只要类定义正确，我就只能按照我编写它的初衷那样去用它。\n  C++ 哲学：抽象，实用，只为用到的东西付出代价。\n  类设计者的核查表：\n 你的类需要一个构造函数吗？ 你的数据成员是私有的吗？（使用函数，可以延迟计算，不必时时计算，保证数据成员的准确性） 你的类需要一个无参的构造函数吗？（对象数组） 是不是每个构造函数初始化所有的数据成员？ 类需要析构函数吗？ 类需要一个虚析构函数吗？ 你的类需要复制构造函数吗？（是否需要深拷贝） 你的类需要一个赋值操作符吗？ 你的赋值操作符能正确地将对象赋给对象本身吗？ 你的类需要定义关系操作符吗？ 删除数组时你记住了用 delete[] 吗？ 记得在复制构造函数和赋值操作符的参数类型中加上 const 了吗？ 如果函数有引用参数，它们应该是 const 引用吗？ 记得适当地声明成员函数为 const 的了吗？    代理类：用类来表示概念（RAII）\nclass Vehicle{ public: virtual double weight() = 0; virtual void start() = 0; virtual Vehicle* copy() const = 0; virtual ~Vehicle(){} }; class RoadVehicle: public Vehicle{ /* .","title":"C++ 沉思录笔记"},{"content":"","permalink":"https://874656645.github.io/posts/94-%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F%E6%A1%88%E4%BE%8B/","summary":"","title":"机房预约系统案例"},{"content":" while 循环中的 switch, break 只能中断 switch，不能中断 while 循环  void managerMenue(){ while(true){ cout \u0026lt;\u0026lt; \u0026#34;这是子菜单\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;是否返回主菜单？\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;1 是\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;2 否\u0026#34; \u0026lt;\u0026lt; endl; int i = 0; cin \u0026gt;\u0026gt; i; switch(i){ case 1: break; case 2: return; default: break; } // if(i == 1){  // // system(\u0026#34;reset\u0026#34;);  // break;  // }  // else if(i == 2){  // return;  // }  // else{  // cout \u0026lt;\u0026lt; \u0026#34;输入有误，请重新输入\u0026#34; \u0026lt;\u0026lt; endl;  // }  } cout \u0026lt;\u0026lt; \u0026#34;这是子菜单循环外代码\u0026#34; \u0026lt;\u0026lt; endl; } int main() { while(true){ cout \u0026lt;\u0026lt; \u0026#34;欢迎登陆！\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;这是主菜单\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;请输入选项：\u0026#34; \u0026lt;\u0026lt; endl; int i = 0; cin \u0026gt;\u0026gt; i; // switch(i)  // {  // case 1:  // system(\u0026#34;reset\u0026#34;);  // managerMenue();  // break;  // case 2:  // break;  // }  if(i == 1){ // system(\u0026#34;reset\u0026#34;);  managerMenue(); // break;  } else{ break; } cout \u0026lt;\u0026lt; \u0026#34;switch 外代码\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;while 外代码\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://874656645.github.io/posts/93-switch-%E4%B8%8E-if-else-%E5%8C%BA%E5%88%AB/","summary":" while 循环中的 switch, break 只能中断 switch，不能中断 while 循环  void managerMenue(){ while(true){ cout \u0026lt;\u0026lt; \u0026#34;这是子菜单\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;是否返回主菜单？\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;1 是\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;2 否\u0026#34; \u0026lt;\u0026lt; endl; int i = 0; cin \u0026gt;\u0026gt; i; switch(i){ case 1: break; case 2: return; default: break; } // if(i == 1){  // // system(\u0026#34;reset\u0026#34;);  // break;  // }  // else if(i == 2){  // return;  // }  // else{  // cout \u0026lt;\u0026lt; \u0026#34;输入有误，请重新输入\u0026#34; \u0026lt;\u0026lt; endl;  // }  } cout \u0026lt;\u0026lt; \u0026#34;这是子菜单循环外代码\u0026#34; \u0026lt;\u0026lt; endl; } int main() { while(true){ cout \u0026lt;\u0026lt; \u0026#34;欢迎登陆！\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;这是主菜单\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;请输入选项：\u0026#34; \u0026lt;\u0026lt; endl; int i = 0; cin \u0026gt;\u0026gt; i; // switch(i)  // {  // case 1:  // system(\u0026#34;reset\u0026#34;);  // managerMenue();  // break;  // case 2:  // break;  // }  if(i == 1){ // system(\u0026#34;reset\u0026#34;);  managerMenue(); // break;  } else{ break; } cout \u0026lt;\u0026lt; \u0026#34;switch 外代码\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;while 外代码\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","title":"switch 与 if Else 区别"},{"content":"","permalink":"https://874656645.github.io/posts/92-%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/","summary":"","title":"演讲比赛流程管理案例"},{"content":"一、常用遍历算法 1. for_each 2. transform  搬运的目标容器必须要提前开辟空间（resize 而不是 reserve），否则无法正常搬运  int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(i); } vector\u0026lt;int\u0026gt; v1; v1.resize(v.size()); // 要用 resize, 不能用 reserve  transform(v.begin(), v.end(), v1.begin(), [](int v){ return v * 2;}); for_each(v1.begin(), v1.end(), [](int v){ cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); cout \u0026lt;\u0026lt; endl; return 0; } 二、常用查找算法 1. find 2. find_if 3. adjacent_find 4. binary_search  无序序列不可用  5. count 6. count_if 三、常用排序算法 1. sort  不支持随机访问的容器不可用  2. random_shuffle 洗牌  指定范围内的元素随机调整次序 不支持随机访问的容器不可用 如果想每次都是随机序列，就添加一个随机种子  int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(i); } vector\u0026lt;int\u0026gt; v1; v1.resize(v.size()); srand((unsigned int)time(NULL)); // 设置随机种子  random_shuffle(v.begin(), v.end()); for_each(v.begin(), v.end(), [](int v){ cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); cout \u0026lt;\u0026lt; endl; return 0; } 3. merge  合并的两个容器要求是有序的，合并后也是有序的 两个序列的排序规则要一致 目标容器也要提前开辟空间  int main() { vector\u0026lt;int\u0026gt; v; vector\u0026lt;int\u0026gt; v1; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(i); v.push_back(i + 1); } vector\u0026lt;int\u0026gt; v2; v2.resize(v.size() + v1.size()); // 目标容器开辟空间  merge(v.begin(), v.end(), v1.begin(), v1.end(), v2.begin()); for_each(v2.begin(), v2.end(), [](int v){ cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); cout \u0026lt;\u0026lt; endl; return 0; } 输出：\n0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 4. reverse  不支持随机访问的容器不可用  四、常用拷贝和替换算法 1. copy  目标容器要提前开辟空间 等价于 = 运算符或者 拷贝构造  2. replace 3. replace_if 4. swap 五、算术生成算法 (numeric) 1. accumulate 计算容器元素累计总和 2. fill 向容器中添加元素 六、常用集合算法 1. set_intersection  求两个容器的交集 两个序列都是有序的，而且排序标准要一致 默认是按升序处理 结果交集序列也是有序的  int main() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for(int i = 0; i \u0026lt; 10; ++i){ v1.push_back(9 - i); v2.push_back(14 - i); } vector\u0026lt;int\u0026gt; v3; v3.resize(min(v1.size(), v2.size())); vector\u0026lt;int\u0026gt;::iterator itEnd = set_intersection(v1.begin(), v1.end() , v2.begin(), v2.end(), v3.begin(), [](int a, int b){ return a \u0026gt; b;}); for_each(v3.begin(), itEnd, [](int v){ cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); cout \u0026lt;\u0026lt; endl; return 0; } 输出：\n9 8 7 6 5 2. set_union  求两个容器的并集  3. set_difference  求两个容器的差集  ","permalink":"https://874656645.github.io/posts/91-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","summary":"一、常用遍历算法 1. for_each 2. transform  搬运的目标容器必须要提前开辟空间（resize 而不是 reserve），否则无法正常搬运  int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 10; ++i){ v.push_back(i); } vector\u0026lt;int\u0026gt; v1; v1.resize(v.size()); // 要用 resize, 不能用 reserve  transform(v.begin(), v.end(), v1.begin(), [](int v){ return v * 2;}); for_each(v1.begin(), v1.end(), [](int v){ cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); cout \u0026lt;\u0026lt; endl; return 0; } 二、常用查找算法 1. find 2. find_if 3. adjacent_find 4. binary_search  无序序列不可用  5.","title":"常用算法"},{"content":"算术仿函数 template\u0026lt;class T\u0026gt; T plus\u0026lt;T\u0026gt; //加法仿函数 template\u0026lt;class T\u0026gt; T minus\u0026lt;T\u0026gt; //减法仿函数 template\u0026lt;class T\u0026gt; T multiplies\u0026lt;T\u0026gt; //乘法仿函数 template\u0026lt;class T\u0026gt; T divides\u0026lt;T\u0026gt; //除法仿函数 template\u0026lt;class T\u0026gt; T modulus\u0026lt;T\u0026gt; //取模仿函数 template\u0026lt;class T\u0026gt; T negate\u0026lt;T\u0026gt; //取反仿函数 一元谓词 关系仿函数 template\u0026lt;class T\u0026gt; bool equal_to\u0026lt;T\u0026gt; //等于 template\u0026lt;class T\u0026gt; bool not_equal_to\u0026lt;T\u0026gt; //不等于 template\u0026lt;class T\u0026gt; bool greater\u0026lt;T\u0026gt; //大于 template\u0026lt;class T\u0026gt; bool greater_equal\u0026lt;T\u0026gt; //大于等于 template\u0026lt;class T\u0026gt; bool less\u0026lt;T\u0026gt; //小于 template\u0026lt;class T\u0026gt; bool less_equal\u0026lt;T\u0026gt; //小于等于 逻辑仿函数 template\u0026lt;class T\u0026gt; bool logical_and\u0026lt;T\u0026gt; //逻辑与 template\u0026lt;class T\u0026gt; bool logical_or\u0026lt;T\u0026gt; //逻辑或 template\u0026lt;class T\u0026gt; bool logical_not\u0026lt;T\u0026gt; //逻辑非 ","permalink":"https://874656645.github.io/posts/90-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-functional/","summary":"算术仿函数 template\u0026lt;class T\u0026gt; T plus\u0026lt;T\u0026gt; //加法仿函数 template\u0026lt;class T\u0026gt; T minus\u0026lt;T\u0026gt; //减法仿函数 template\u0026lt;class T\u0026gt; T multiplies\u0026lt;T\u0026gt; //乘法仿函数 template\u0026lt;class T\u0026gt; T divides\u0026lt;T\u0026gt; //除法仿函数 template\u0026lt;class T\u0026gt; T modulus\u0026lt;T\u0026gt; //取模仿函数 template\u0026lt;class T\u0026gt; T negate\u0026lt;T\u0026gt; //取反仿函数 一元谓词 关系仿函数 template\u0026lt;class T\u0026gt; bool equal_to\u0026lt;T\u0026gt; //等于 template\u0026lt;class T\u0026gt; bool not_equal_to\u0026lt;T\u0026gt; //不等于 template\u0026lt;class T\u0026gt; bool greater\u0026lt;T\u0026gt; //大于 template\u0026lt;class T\u0026gt; bool greater_equal\u0026lt;T\u0026gt; //大于等于 template\u0026lt;class T\u0026gt; bool less\u0026lt;T\u0026gt; //小于 template\u0026lt;class T\u0026gt; bool less_equal\u0026lt;T\u0026gt; //小于等于 逻辑仿函数 template\u0026lt;class T\u0026gt; bool logical_and\u0026lt;T\u0026gt; //逻辑与 template\u0026lt;class T\u0026gt; bool logical_or\u0026lt;T\u0026gt; //逻辑或 template\u0026lt;class T\u0026gt; bool logical_not\u0026lt;T\u0026gt; //逻辑非 ","title":"内建函数对象 functional"},{"content":"函数对象 重载函数调用操作符 () 的 类，其对象常称为函数对象\n 函数对象可以有自己的状态 函数对象可以作为参数传递 一个参数的函数对象叫做一元仿函数 两个参数的函数对象叫做二元仿函数  什么是谓词 返回 bool 类型的仿函数称为谓词\n一元谓词 如果 operator() 接受一个参数，那么叫做一元谓词\n比如 find_if 算法\n二元谓词 如果 operator() 接受两个参数，那么叫做二元谓词\n比如 sort 算法\n","permalink":"https://874656645.github.io/posts/89-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%B8%8E-predicate-%E8%B0%93%E8%AF%8D/","summary":"函数对象 重载函数调用操作符 () 的 类，其对象常称为函数对象\n 函数对象可以有自己的状态 函数对象可以作为参数传递 一个参数的函数对象叫做一元仿函数 两个参数的函数对象叫做二元仿函数  什么是谓词 返回 bool 类型的仿函数称为谓词\n一元谓词 如果 operator() 接受一个参数，那么叫做一元谓词\n比如 find_if 算法\n二元谓词 如果 operator() 接受两个参数，那么叫做二元谓词\n比如 sort 算法","title":"函数对象与 predicate 谓词"},{"content":"特点  所有元素都会根据元素的键值自动排序 默认排序规则是从小到大，可以通过仿函数指定排序规则 map / multimap 属于关联式容器，底层结构是用红黑树实现 不可以修改键值，可以通过删除再插入的方式实现 可以根据 key 值快速找到 value 值 可以通过下标 [] 的方式快速查找、插入和更新对应的 value  案例  公司今天招聘了10个员工（ABCDEFGHIJ），10 名员工进入公司之后，需要指派员工在哪个部门工作 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 随机给 10 名员工分配部门和工资 通过 multimap 进行信息的插入 key(部门编号) value(员工) 分部门显示员工信息  思路：\n 创建 10 名员工，放到 vector 中 遍历 vector 容器，取出每个员工，进行随机分组 分组后，将员工部门编号作为 key，具体员工作为 value，放入到 multimap 容器中 分部门显示员工信息  class Worker{ public: Worker(string name, int salary){ m_name = name; m_salary = salary; } void printWorker(){ cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34; 工资：\u0026#34; \u0026lt;\u0026lt; m_salary \u0026lt;\u0026lt; endl; } private: string m_name; int m_salary; }; void createWorkers(vector\u0026lt;Worker\u0026gt; \u0026amp;v){ string nameSeed = \u0026#34;ABCDEFGHIJ\u0026#34;; for(int i = 0; i \u0026lt; nameSeed.length(); ++i){ string name = \u0026#34;员工\u0026#34;; // 注意：不能写成 name = \u0026#34;员工\u0026#34; + nameSeed[i]  name += nameSeed[i]; v.push_back(Worker(name, rand() % 10000 + 5000)); } } void groupWorker(vector\u0026lt;Worker\u0026gt; \u0026amp;v, multimap\u0026lt;int, Worker\u0026gt; \u0026amp;m){ for(const auto \u0026amp;w : v){ int depId = rand() % 3; m.insert({depId, w}); } } int main() { srand((unsigned int)time(NULL)); // 创建员工  vector\u0026lt;Worker\u0026gt; vWorker; createWorkers(vWorker); // 员工分组  multimap\u0026lt;int, Worker\u0026gt; mWorker; groupWorker(vWorker, mWorker); // 打印 multimap 结果  for(auto it = mWorker.begin(); it != mWorker.end(); it++){ cout \u0026lt;\u0026lt; \u0026#34;部门：\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34;; it-\u0026gt;second.printWorker(); } cout \u0026lt;\u0026lt; \u0026#34;-----------------------------\u0026#34; \u0026lt;\u0026lt; endl; // 按部门分组打印  cout \u0026lt;\u0026lt; \u0026#34;部门0：\u0026#34; \u0026lt;\u0026lt; endl; auto it = mWorker.find(0); int num = mWorker.count(0); for(int i = 0; it != mWorker.end() \u0026amp;\u0026amp; i \u0026lt; num; it++, i++){ it-\u0026gt;second.printWorker(); } cout \u0026lt;\u0026lt; \u0026#34;-----------------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;部门1：\u0026#34; \u0026lt;\u0026lt; endl; it = mWorker.find(1); num = mWorker.count(1); for(int i = 0; it != mWorker.end() \u0026amp;\u0026amp; i \u0026lt; num; it++, i++){ it-\u0026gt;second.printWorker(); } cout \u0026lt;\u0026lt; \u0026#34;-----------------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;部门2：\u0026#34; \u0026lt;\u0026lt; endl; it = mWorker.find(2); num = mWorker.count(2); for(int i = 0; it != mWorker.end() \u0026amp;\u0026amp; i \u0026lt; num; it++, i++){ it-\u0026gt;second.printWorker(); } return 0; } 输出：\n部门：0 姓名：员工D 工资：6725 部门：0 姓名：员工H 工资：12290 部门：0 姓名：员工I 工资：8753 部门：1 姓名：员工A 工资：11577 部门：1 姓名：员工C 工资：10892 部门：1 姓名：员工F 工资：12622 部门：2 姓名：员工B 工资：6047 部门：2 姓名：员工E 工资：5629 部门：2 姓名：员工G 工资：8954 部门：2 姓名：员工J 工资：11160 ----------------------------- 部门0： 姓名：员工D 工资：6725 姓名：员工H 工资：12290 姓名：员工I 工资：8753 ----------------------------- 部门1： 姓名：员工A 工资：11577 姓名：员工C 工资：10892 姓名：员工F 工资：12622 ----------------------------- 部门2： 姓名：员工B 工资：6047 姓名：员工E 工资：5629 姓名：员工G 工资：8954 姓名：员工J 工资：11160 ","permalink":"https://874656645.github.io/posts/88-map-multimap-%E5%AE%B9%E5%99%A8/","summary":"特点  所有元素都会根据元素的键值自动排序 默认排序规则是从小到大，可以通过仿函数指定排序规则 map / multimap 属于关联式容器，底层结构是用红黑树实现 不可以修改键值，可以通过删除再插入的方式实现 可以根据 key 值快速找到 value 值 可以通过下标 [] 的方式快速查找、插入和更新对应的 value  案例  公司今天招聘了10个员工（ABCDEFGHIJ），10 名员工进入公司之后，需要指派员工在哪个部门工作 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 随机给 10 名员工分配部门和工资 通过 multimap 进行信息的插入 key(部门编号) value(员工) 分部门显示员工信息  思路：\n 创建 10 名员工，放到 vector 中 遍历 vector 容器，取出每个员工，进行随机分组 分组后，将员工部门编号作为 key，具体员工作为 value，放入到 multimap 容器中 分部门显示员工信息  class Worker{ public: Worker(string name, int salary){ m_name = name; m_salary = salary; } void printWorker(){ cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34; 工资：\u0026#34; \u0026lt;\u0026lt; m_salary \u0026lt;\u0026lt; endl; } private: string m_name; int m_salary; }; void createWorkers(vector\u0026lt;Worker\u0026gt; \u0026amp;v){ string nameSeed = \u0026#34;ABCDEFGHIJ\u0026#34;; for(int i = 0; i \u0026lt; nameSeed.","title":"map multimap 容器"},{"content":" 关联式容器 底层结构使用红黑树实现（二叉树-\u0026gt;二叉搜索树-\u0026gt;平衡二叉树-\u0026gt;红黑树） 自动排序 不可以修改值，可以通过删除再插入的方式实现  自定义数据类型：\nclass Person{ public: Person(string name, int age, int height){ this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; this-\u0026gt;m_height = height; } bool operator\u0026lt;(const Person \u0026amp;p2) const{ // 注意：函数和形参都要添加 const 修饰符  if(this-\u0026gt;m_age == p2.m_age){ return this-\u0026gt;m_height \u0026gt; p2.m_height; } return this-\u0026gt;m_age \u0026lt; p2.m_age; } void printPerson()const{ cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; \u0026#34; 身高：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_height \u0026lt;\u0026lt; endl; } private: string m_name; int m_age; int m_height; }; int main() { set\u0026lt;Person\u0026gt; lp; lp.insert(Person(\u0026#34;刘备\u0026#34;, 35 , 175)); lp.insert(Person(\u0026#34;曹操\u0026#34;, 45 , 180)); lp.insert(Person(\u0026#34;孙权\u0026#34;, 40 , 170)); lp.insert(Person(\u0026#34;赵云\u0026#34;, 25 , 190)); lp.insert(Person(\u0026#34;张飞\u0026#34;, 35 , 160)); lp.insert(Person(\u0026#34;关羽\u0026#34;, 35 , 200)); for(const auto \u0026amp;p : lp){ p.printPerson(); } return 0; } ","permalink":"https://874656645.github.io/posts/87-set-multiset-%E5%AE%B9%E5%99%A8/","summary":"关联式容器 底层结构使用红黑树实现（二叉树-\u0026gt;二叉搜索树-\u0026gt;平衡二叉树-\u0026gt;红黑树） 自动排序 不可以修改值，可以通过删除再插入的方式实现  自定义数据类型：\nclass Person{ public: Person(string name, int age, int height){ this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; this-\u0026gt;m_height = height; } bool operator\u0026lt;(const Person \u0026amp;p2) const{ // 注意：函数和形参都要添加 const 修饰符  if(this-\u0026gt;m_age == p2.m_age){ return this-\u0026gt;m_height \u0026gt; p2.m_height; } return this-\u0026gt;m_age \u0026lt; p2.m_age; } void printPerson()const{ cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; \u0026#34; 身高：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_height \u0026lt;\u0026lt; endl; } private: string m_name; int m_age; int m_height; }; int main() { set\u0026lt;Person\u0026gt; lp; lp.","title":"set multiset 容器"},{"content":"注意事项  双向循环链表 不支持随机访问 因为不支持随机访问，所以也不能用全局的排序算法 sort 一般不支持随机访问的容器会自己提供 sort 方法 自定义类型要指定排序规则  排序案例 案例描述：将 Person 自定义数据类型进行排序，Person 中属性有姓名、年龄、身高\n排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序\nclass Person{ public: Person(string name, int age, int height){ this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; this-\u0026gt;m_height = height; } bool operator\u0026lt;(const Person \u0026amp;p2){ if(this-\u0026gt;m_age == p2.m_age){ return this-\u0026gt;m_height \u0026gt; p2.m_height; } return this-\u0026gt;m_age \u0026lt; p2.m_age; } void printPerson()const{ cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; \u0026#34; 身高：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_height \u0026lt;\u0026lt; endl; } private: string m_name; int m_age; int m_height; }; int main() { list\u0026lt;Person\u0026gt; lp; lp.push_back(Person(\u0026#34;刘备\u0026#34;, 35 , 175)); lp.push_back(Person(\u0026#34;曹操\u0026#34;, 45 , 180)); lp.push_back(Person(\u0026#34;孙权\u0026#34;, 40 , 170)); lp.push_back(Person(\u0026#34;赵云\u0026#34;, 25 , 190)); lp.push_back(Person(\u0026#34;张飞\u0026#34;, 35 , 160)); lp.push_back(Person(\u0026#34;关羽\u0026#34;, 35 , 200)); for(const auto \u0026amp;p : lp){ p.printPerson(); } cout \u0026lt;\u0026lt; \u0026#34;排序后：\u0026#34; \u0026lt;\u0026lt; endl; lp.sort(); for(const auto \u0026amp;p : lp){ p.printPerson(); } return 0; } 输出：\n姓名：刘备 年龄：35 身高：175 姓名：曹操 年龄：45 身高：180 姓名：孙权 年龄：40 身高：170 姓名：赵云 年龄：25 身高：190 姓名：张飞 年龄：35 身高：160 姓名：关羽 年龄：35 身高：200 排序后： 姓名：赵云 年龄：25 身高：190 姓名：关羽 年龄：35 身高：200 姓名：刘备 年龄：35 身高：175 姓名：张飞 年龄：35 身高：160 姓名：孙权 年龄：40 身高：170 姓名：曹操 年龄：45 身高：180 ","permalink":"https://874656645.github.io/posts/86-list-%E5%AE%B9%E5%99%A8/","summary":"注意事项  双向循环链表 不支持随机访问 因为不支持随机访问，所以也不能用全局的排序算法 sort 一般不支持随机访问的容器会自己提供 sort 方法 自定义类型要指定排序规则  排序案例 案例描述：将 Person 自定义数据类型进行排序，Person 中属性有姓名、年龄、身高\n排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序\nclass Person{ public: Person(string name, int age, int height){ this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; this-\u0026gt;m_height = height; } bool operator\u0026lt;(const Person \u0026amp;p2){ if(this-\u0026gt;m_age == p2.m_age){ return this-\u0026gt;m_height \u0026gt; p2.m_height; } return this-\u0026gt;m_age \u0026lt; p2.m_age; } void printPerson()const{ cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; \u0026#34; 身高：\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_height \u0026lt;\u0026lt; endl; } private: string m_name; int m_age; int m_height; }; int main() { list\u0026lt;Person\u0026gt; lp; lp.","title":"list 容器"},{"content":" 先进先出 不允许遍历元素  queue 队列操作：\nsize()\nempty()\n","permalink":"https://874656645.github.io/posts/85-queue-%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8/","summary":"先进先出 不允许遍历元素  queue 队列操作：\nsize()\nempty()","title":"queue 队列容器适配器"},{"content":" 先进后出 栈不允许遍历元素 不能随机存取  stack 栈操作:\nsize()\nempty()\n","permalink":"https://874656645.github.io/posts/84-stack-%E6%A0%88%E5%AE%B9%E5%99%A8/","summary":"先进后出 栈不允许遍历元素 不能随机存取  stack 栈操作:\nsize()\nempty()","title":"stack 栈容器适配器"},{"content":"有 5 名选手：选手 ABCDE，10 个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。\n分析：\n 创建五名选手，放到 vector 中 遍历 vector 容器，取出来每一个选手，执行 for 循环，可以把 10 个评委打分存到 deque 容器中 sort 算法对 deque 容器中分数排序，去除最高和最低分 deque 容器遍历一遍，累加总分 获取平均分  class Player{ public: Player(string name){ m_name = name; m_avgScore = 0; } void setAvgScore(int v){ m_avgScore = v; } void printInfo()const{ cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;的平均分为：\u0026#34; \u0026lt;\u0026lt; m_avgScore \u0026lt;\u0026lt; endl; } private: string m_name; int m_avgScore; }; void createPlayers(vector\u0026lt;Player\u0026gt; \u0026amp;v){ string nameSeed = \u0026#34;ABCDE\u0026#34;; for(int i = 0; i \u0026lt; nameSeed.length(); ++i){ string name = \u0026#34;选手\u0026#34;; name += nameSeed[i]; v.push_back(Player(name)); } } void scorePlayers(vector\u0026lt;Player\u0026gt; \u0026amp;v){ for(auto \u0026amp;p : v){ // 把 10 个评委打分存到 deque 容器中  deque\u0026lt;int\u0026gt; scores; for(int i = 0; i \u0026lt; 10; ++i){ scores.push_back(rand() % 41 + 60); } // sort 算法对 deque 容器中分数排序，去除最高和最低分  sort(scores.begin(), scores.end()); #if 0// 测试打印分数 p.printInfo(); cout \u0026lt;\u0026lt; \u0026#34;------------------\u0026#34; \u0026lt;\u0026lt; endl; for(const auto \u0026amp;s : scores){ cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; #endif  scores.pop_back(); scores.pop_front(); // deque 容器遍历一遍，累加总分并计算平均分  int num = 0; for(const auto \u0026amp;s : scores){ num += s; } p.setAvgScore(num / scores.size()); } } void printScore(const vector\u0026lt;Player\u0026gt; \u0026amp;v){ for(const auto \u0026amp;p : v){ p.printInfo(); } } int main() { srand((unsigned int)time(NULL)); // 创建五名选手  vector\u0026lt;Player\u0026gt; v; createPlayers(v); // 10 个评委打分  scorePlayers(v); // 打印平均分  printScore(v); return 0; } 输出：\n选手A的平均分为：81 选手B的平均分为：84 选手C的平均分为：82 选手D的平均分为：83 选手E的平均分为：68 ","permalink":"https://874656645.github.io/posts/83-%E8%AF%84%E5%A7%94%E6%89%93%E5%88%86%E6%A1%88%E4%BE%8B/","summary":"有 5 名选手：选手 ABCDE，10 个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。\n分析：\n 创建五名选手，放到 vector 中 遍历 vector 容器，取出来每一个选手，执行 for 循环，可以把 10 个评委打分存到 deque 容器中 sort 算法对 deque 容器中分数排序，去除最高和最低分 deque 容器遍历一遍，累加总分 获取平均分  class Player{ public: Player(string name){ m_name = name; m_avgScore = 0; } void setAvgScore(int v){ m_avgScore = v; } void printInfo()const{ cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;的平均分为：\u0026#34; \u0026lt;\u0026lt; m_avgScore \u0026lt;\u0026lt; endl; } private: string m_name; int m_avgScore; }; void createPlayers(vector\u0026lt;Player\u0026gt; \u0026amp;v){ string nameSeed = \u0026#34;ABCDE\u0026#34;; for(int i = 0; i \u0026lt; nameSeed.","title":"评委打分案例"},{"content":"#include \u0026lt;ctime\u0026gt;using namespace std; int main() { srand((unsigned int)time(NULL)); cout \u0026lt;\u0026lt; rand() % 40 \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://874656645.github.io/posts/82-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/","summary":"#include \u0026lt;ctime\u0026gt;using namespace std; int main() { srand((unsigned int)time(NULL)); cout \u0026lt;\u0026lt; rand() % 40 \u0026lt;\u0026lt; endl; return 0; } ","title":"生成随机数"},{"content":"deque 容器的空间不用手动收缩，类内部会自动处理\n","permalink":"https://874656645.github.io/posts/81-deque-%E5%AE%B9%E5%99%A8/","summary":"deque 容器的空间不用手动收缩，类内部会自动处理","title":"deque 容器"},{"content":" resize() 或者 erase() 后 vector 的空间大小不会自动减小  int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 100000; ++i){ v.push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------------------\u0026#34; \u0026lt;\u0026lt; endl; v.resize(10); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------------------\u0026#34; \u0026lt;\u0026lt; endl; vector\u0026lt;int\u0026gt;(v).swap(v); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; return 0; } 输出：\nsize: 100000 capacity: 131072 ----------------------- size: 10 capacity: 131072 ----------------------- size: 10 capacity: 10 ","permalink":"https://874656645.github.io/posts/80-%E5%B7%A7%E5%A6%99%E6%94%B6%E7%BC%A9-vector-%E7%A9%BA%E9%97%B4/","summary":"resize() 或者 erase() 后 vector 的空间大小不会自动减小  int main() { vector\u0026lt;int\u0026gt; v; for(int i = 0; i \u0026lt; 100000; ++i){ v.push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------------------\u0026#34; \u0026lt;\u0026lt; endl; v.resize(10); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------------------\u0026#34; \u0026lt;\u0026lt; endl; vector\u0026lt;int\u0026gt;(v).swap(v); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.","title":"巧妙收缩 vector 空间"},{"content":"结论  allocator 分配器是定义内存模型的类，用于标准库的某些部分，尤其是 STL 容器，如果所有标准容器的最后一个(可选)模板参数没有指定，那么它将使用这个分配器，并且它是标准库中唯一一个预定义的分配器 vector 中存放的如果是对象类型，则会通过 allocator 在堆上开辟足够的空间来存放和管理集合中的对象 vector 中存放指针类型，一定要记得手动释放内存  存放对象 class Person{ public: Person(int age, int id){ m_age = age; m_id = id; cout \u0026lt;\u0026lt; \u0026#34;Person(int, int)...\u0026#34; \u0026lt;\u0026lt; endl; } Person(const Person\u0026amp; p){ m_age = p.m_age; m_id = p.m_id; cout \u0026lt;\u0026lt; \u0026#34;Person(const Person\u0026amp; p)...\u0026#34; \u0026lt;\u0026lt; endl; } ~Person(){ cout \u0026lt;\u0026lt; \u0026#34;~Person()...\u0026#34; \u0026lt;\u0026lt; endl; } void* operator new(size_t size){ void* p = malloc(size); cout \u0026lt;\u0026lt; \u0026#34;new()...\u0026#34; \u0026lt;\u0026lt; endl; return p; } void operator delete(void *p){ cout \u0026lt;\u0026lt; \u0026#34;delete()...\u0026#34; \u0026lt;\u0026lt; endl; if(p != NULL){ free(p); p = NULL; } } void show(){ cout \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; m_age \u0026lt;\u0026lt; \u0026#34; Id: \u0026#34; \u0026lt;\u0026lt; m_id \u0026lt;\u0026lt; endl; } private: int m_age; int m_id; }; void printPerson(Person \u0026amp;p){ p.show(); } int main() { // vector 中存放对象类型  std::vector\u0026lt;Person\u0026gt; v; v.reserve(3); v.push_back(Person(10, 20)); v.push_back(Person(30, 40)); v.push_back(Person(50, 60)); // 遍历 vector  for(vector\u0026lt;Person\u0026gt;::iterator it = v.begin(); it != v.end(); it++){ // 迭代器是指针  it-\u0026gt;show(); // 也可以这么写  // (*it).show();  } for_each(v.begin(), v.end(), printPerson); // 回调函数不支持函数重载？？  // 测试删除  Person* pp = \u0026amp;v[0]; // 记录 vector 中第一个元素的地址  // 方式一  v.clear(); // 这种释放方式，pp 指针仍然可以访问已释放的地址，存在安全隐患  // 方式二  vector\u0026lt;Person\u0026gt;().swap(v); // 这种方式不仅可以释放内存，还可以防止其它指针对已经释放的内存进行非法访问  // 利用 swap 函数和临时对象交换内存，交换以后，临时对象消失  cout \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; if(pp != NULL){ pp-\u0026gt;show(); }else{ cout \u0026lt;\u0026lt; \u0026#34;空指针\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 方式一输出：\nPerson(int, int)... Person(const Person\u0026amp; p)... ~Person()... Person(int, int)... Person(const Person\u0026amp; p)... ~Person()... Person(int, int)... Person(const Person\u0026amp; p)... ~Person()... Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 ~Person()... ~Person()... ~Person()... 0 Age: 10 Id: 20 方式二输出：\nPerson(int, int)... Person(const Person\u0026amp; p)... ~Person()... Person(int, int)... Person(const Person\u0026amp; p)... ~Person()... Person(int, int)... Person(const Person\u0026amp; p)... ~Person()... Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 ~Person()... ~Person()... ~Person()... 0 Age: 0 Id: 0 存放指针 void printPerson(Person *\u0026amp;p){ if(p == NULL){ cout \u0026lt;\u0026lt; \u0026#34;指针为空\u0026#34; \u0026lt;\u0026lt; endl; return; } p-\u0026gt;show(); } void delPerson(Person *\u0026amp;p){ delete p; p = NULL; } int main() { // vector 中存放对象指针，就必须手动释放内存  vector\u0026lt;Person*\u0026gt; v; v.reserve(3); v.push_back(new Person(10, 20)); v.push_back(new Person(30, 40)); v.push_back(new Person(50, 60)); for_each(v.begin(), v.end(), printPerson); // 不支持函数重载？？  // 手动释放内存  // for_each(v.begin(), v.end(), delPerson);  // for_each(v.begin(), v.end(), printPerson);  // 删除测试  Person *pp = v[0]; // 记录 vector 中第一个元素的地址，实际上是拷贝了指向第一个 Person 对象的地址  // 除非手动 delete 掉 vector 中的指针，否则不管是 clear 还是 swap 都没有真正释放内存  // 这两种方式只是把 vector 对象释放了，存储的指针所指向的空间并没有释放  // 方式一  v.clear(); // 这种情况下，pp 指针仍然可以访问  // 方式二  vector\u0026lt;Person*\u0026gt;().swap(v); cout \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; if(pp != NULL){ pp-\u0026gt;show(); }else{ cout \u0026lt;\u0026lt; \u0026#34;空指针\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 方式一输出：\nnew()... Person(int, int)... new()... Person(int, int)... new()... Person(int, int)... Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 0 Age: 10 Id: 20 方式二输出：\nnew()... Person(int, int)... new()... Person(int, int)... new()... Person(int, int)... Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 0 Age: 10 Id: 20 手动释放内存输出：\nnew()... Person(int, int)... new()... Person(int, int)... new()... Person(int, int)... Age: 10 Id: 20 Age: 30 Id: 40 Age: 50 Id: 60 ~Person()... delete()... ~Person()... delete()... ~Person()... delete()... 指针为空 指针为空 指针为空 0 空指针 ","permalink":"https://874656645.github.io/posts/79-vector-%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E5%AD%98%E6%94%BE%E5%9C%A8%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%A0%88%E4%B8%8A/","summary":"结论  allocator 分配器是定义内存模型的类，用于标准库的某些部分，尤其是 STL 容器，如果所有标准容器的最后一个(可选)模板参数没有指定，那么它将使用这个分配器，并且它是标准库中唯一一个预定义的分配器 vector 中存放的如果是对象类型，则会通过 allocator 在堆上开辟足够的空间来存放和管理集合中的对象 vector 中存放指针类型，一定要记得手动释放内存  存放对象 class Person{ public: Person(int age, int id){ m_age = age; m_id = id; cout \u0026lt;\u0026lt; \u0026#34;Person(int, int)...\u0026#34; \u0026lt;\u0026lt; endl; } Person(const Person\u0026amp; p){ m_age = p.m_age; m_id = p.m_id; cout \u0026lt;\u0026lt; \u0026#34;Person(const Person\u0026amp; p)...\u0026#34; \u0026lt;\u0026lt; endl; } ~Person(){ cout \u0026lt;\u0026lt; \u0026#34;~Person()...\u0026#34; \u0026lt;\u0026lt; endl; } void* operator new(size_t size){ void* p = malloc(size); cout \u0026lt;\u0026lt; \u0026#34;new()...\u0026#34; \u0026lt;\u0026lt; endl; return p; } void operator delete(void *p){ cout \u0026lt;\u0026lt; \u0026#34;delete().","title":"vector 中的元素存放在堆上还是栈上"},{"content":" 平时要有容器、算法、迭代器的思维模式 容器提供迭代器，算法使用迭代器  // 算法 int count(int* begin, int* end, int val){ int n = 0; while(begin != end){ if(*begin == val){ n++; } begin++; } return n; } int main() { // 容器  int arr[] = {1, 3, 0, 5, 1, 3, 1, 0}; // 迭代器  int* begin = arr; int* end = *(\u0026amp;arr + 1); int n = count(begin, end, 1); cout \u0026lt;\u0026lt; \u0026#34;count: \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://874656645.github.io/posts/78-stl-hello-world/","summary":" 平时要有容器、算法、迭代器的思维模式 容器提供迭代器，算法使用迭代器  // 算法 int count(int* begin, int* end, int val){ int n = 0; while(begin != end){ if(*begin == val){ n++; } begin++; } return n; } int main() { // 容器  int arr[] = {1, 3, 0, 5, 1, 3, 1, 0}; // 迭代器  int* begin = arr; int* end = *(\u0026amp;arr + 1); int n = count(begin, end, 1); cout \u0026lt;\u0026lt; \u0026#34;count: \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } ","title":"STL Hello World"},{"content":"一、文件读写  文件输入流 ifstream 文件输出流 ofstream 文件输入输出流 fstream 文件的打开方式 文件流的状态 文件流的定位：文件指针（输入指针、输出指针）  二、文本文件 #include \u0026lt;iostream\u0026gt;#include \u0026lt;fstream\u0026gt;using namespace std; void ReadWriteFile(){ ifstream ifs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\source.txt\u0026#34;, ios::in); ofstream ofs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\target.txt\u0026#34;, ios::out | ios::app); if (!ifs) { cout \u0026lt;\u0026lt; \u0026#34;输入文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } if (!ofs) { cout \u0026lt;\u0026lt; \u0026#34;输出文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } char ch; while (ifs.get(ch)) { cout \u0026lt;\u0026lt; ch; ofs \u0026lt;\u0026lt; ch; } ifs.close(); ofs.close(); } 三、二进制文件  文本文件和二进制文件在计算机中都是以二进制的方式存储的 程序中的对象都是二进制存储的 Windows 中的文本文件换行符用 \\r\\n 表示，二进制是以 \\n 存储，所以存储和显示时会做一下转换 Linux 中二进制和文本文件换行都是以 \\n 存储和表示  class Person { private: int m_age; int m_id; public: Person():m_age(0), m_id(0){ } Person(int age, int id){ m_age = age; m_id = id; } ~Person() = default; void show(){ cout \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; m_age \u0026lt;\u0026lt; \u0026#34; ID: \u0026#34; \u0026lt;\u0026lt; m_id \u0026lt;\u0026lt; endl; } }; void BinaryReadWrite(){ // 存储二进制  ofstream ofs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\target.txt\u0026#34;, ios::out | ios::binary); if (!ofs) { cout \u0026lt;\u0026lt; \u0026#34;存储文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } Person p1(10, 20), p2(30, 40); ofs.write((const char*)\u0026amp;p1, sizeof(Person)); ofs.write((const char*)\u0026amp;p2, sizeof(Person)); ofs.close(); // 读取二进制  ifstream ifs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\target.txt\u0026#34;, ios::in | ios::binary); if (!ifs) { cout \u0026lt;\u0026lt; \u0026#34;读取文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } Person p3, p4; ifs.read((char*)\u0026amp;p3, sizeof(Person)); ifs.read((char*)\u0026amp;p4, sizeof(Person)); p3.show(); p4.show(); ifs.close(); } ","permalink":"https://874656645.github.io/posts/77-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","summary":"一、文件读写  文件输入流 ifstream 文件输出流 ofstream 文件输入输出流 fstream 文件的打开方式 文件流的状态 文件流的定位：文件指针（输入指针、输出指针）  二、文本文件 #include \u0026lt;iostream\u0026gt;#include \u0026lt;fstream\u0026gt;using namespace std; void ReadWriteFile(){ ifstream ifs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\source.txt\u0026#34;, ios::in); ofstream ofs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\target.txt\u0026#34;, ios::out | ios::app); if (!ifs) { cout \u0026lt;\u0026lt; \u0026#34;输入文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } if (!ofs) { cout \u0026lt;\u0026lt; \u0026#34;输出文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } char ch; while (ifs.get(ch)) { cout \u0026lt;\u0026lt; ch; ofs \u0026lt;\u0026lt; ch; } ifs.close(); ofs.close(); } 三、二进制文件  文本文件和二进制文件在计算机中都是以二进制的方式存储的 程序中的对象都是二进制存储的 Windows 中的文本文件换行符用 \\r\\n 表示，二进制是以 \\n 存储，所以存储和显示时会做一下转换 Linux 中二进制和文本文件换行都是以 \\n 存储和表示  class Person { private: int m_age; int m_id; public: Person():m_age(0), m_id(0){ } Person(int age, int id){ m_age = age; m_id = id; } ~Person() = default; void show(){ cout \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; m_age \u0026lt;\u0026lt; \u0026#34; ID: \u0026#34; \u0026lt;\u0026lt; m_id \u0026lt;\u0026lt; endl; } }; void BinaryReadWrite(){ // 存储二进制  ofstream ofs(\u0026#34;D:\\\\Users\\\\cui_z\\\\Desktop\\\\target.","title":"文件操作"},{"content":"#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;iomanip\u0026gt; // 控制符头文件using namespace std; // 格式化输出 void func(){ // 方式一：使用成员方法  int number = 10; cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; cout.unsetf(ios::dec); // 八进制  cout.setf(ios::oct); cout.setf(ios::showbase); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // 012  // 十六进制  cout.unsetf(ios::oct); cout.setf(ios::hex); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // 0xa  // 固定宽度  cout.width(10); cout.fill(\u0026#39;*\u0026#39;); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // *******0xa  // 上面的设置只对当前输出有效，下次的输出格式要重新设置  cout.setf(ios::left); cout.width(10); cout.fill(\u0026#39;*\u0026#39;); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // 0xa*******  // 方式二：使用控制符的方式  cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; setiosflags(ios::showbase) \u0026lt;\u0026lt; setiosflags(ios::right) \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; setfill(\u0026#39;~\u0026#39;) \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // ~~~~~~~0xa } #include \u0026lt;iostream\u0026gt;#include \u0026lt;iomanip\u0026gt; using namespace std; int main() { double x = 1234567.89, y = 12.3456789; int m = 12, n = 1234567; // 控制精度为 6 位有效数字，会被四舍五入  // 整型不受精度控制  cout \u0026lt;\u0026lt; setprecision(6) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;------------------\u0026#34; \u0026lt;\u0026lt; endl; // 控制小数点后有 6 位小数，不够的补 0，同样会被四舍五入  // 同样，整型不受精度控制  cout \u0026lt;\u0026lt; setiosflags(ios::fixed) \u0026lt;\u0026lt; setprecision(6) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } 输出：\n1.23457e+06 12.3457 12 1234567 ------------------ 1234567.890000 12.345679 12 1234567 ","permalink":"https://874656645.github.io/posts/76-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/","summary":"#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;iomanip\u0026gt; // 控制符头文件using namespace std; // 格式化输出 void func(){ // 方式一：使用成员方法  int number = 10; cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; cout.unsetf(ios::dec); // 八进制  cout.setf(ios::oct); cout.setf(ios::showbase); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // 012  // 十六进制  cout.unsetf(ios::oct); cout.setf(ios::hex); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // 0xa  // 固定宽度  cout.width(10); cout.fill(\u0026#39;*\u0026#39;); cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // *******0xa  // 上面的设置只对当前输出有效，下次的输出格式要重新设置  cout.setf(ios::left); cout.width(10); cout.","title":"格式化输出"},{"content":"C++ 异常\n C++11 不再建议使用异常规范  // 异常规范 只能抛出 int float char 三种类型的异常 C++11以后不再建议使用 void func1() throw(int, float, char){ throw \u0026#34;string\u0026#34;; // terminate called after throwing an instance of \u0026#39;char const*\u0026#39; } // 不能抛出任何类型的异常 OK void func2() throw(){ throw -1; // terminate called after throwing an instance of \u0026#39;int\u0026#39; } // 可以抛出任何类型的异常 void func3(){ throw \u0026#34;error\u0026#34;; } int main() { try{ func1(); } catch(char const * e){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; } catch(...){ // 捕获所有异常  cout \u0026lt;\u0026lt; \u0026#34;捕获未知异常\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } ","permalink":"https://874656645.github.io/posts/75-%E5%BC%82%E5%B8%B8%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E/","summary":"C++ 异常\n C++11 不再建议使用异常规范  // 异常规范 只能抛出 int float char 三种类型的异常 C++11以后不再建议使用 void func1() throw(int, float, char){ throw \u0026#34;string\u0026#34;; // terminate called after throwing an instance of \u0026#39;char const*\u0026#39; } // 不能抛出任何类型的异常 OK void func2() throw(){ throw -1; // terminate called after throwing an instance of \u0026#39;int\u0026#39; } // 可以抛出任何类型的异常 void func3(){ throw \u0026#34;error\u0026#34;; } int main() { try{ func1(); } catch(char const * e){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; } catch(.","title":"异常接口声明"},{"content":"异常被抛出后，从进入 try 块起到异常被抛出前，这期间在栈上构造的所有对象都会被自动析构，析构的顺序与构造的顺序相反。\n与 return 类似\nclass Test{ public: Test(string name){ m_name = name; cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;被构造了\u0026#34; \u0026lt;\u0026lt; endl; } ~Test(){ cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;被析构了\u0026#34; \u0026lt;\u0026lt; endl; } private: string m_name; }; double func1(int x, int y){ Test t1(\u0026#34;t1\u0026#34;), t2(\u0026#34;t2\u0026#34;); if(y == 0){ throw y; } return x / y; } int main() { try{ Test t3(\u0026#34;t3\u0026#34;), t4(\u0026#34;t4\u0026#34;); func1(10, 0); } catch(int e){ cout \u0026lt;\u0026lt; \u0026#34;除数为 \u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; } return 0; } t3被构造了 t4被构造了 t1被构造了 t2被构造了 t2被析构了 t1被析构了 t4被析构了 t3被析构了 除数为 0 ","permalink":"https://874656645.github.io/posts/74-%E6%A0%88%E8%A7%A3%E6%97%8B-unwinding/","summary":"异常被抛出后，从进入 try 块起到异常被抛出前，这期间在栈上构造的所有对象都会被自动析构，析构的顺序与构造的顺序相反。\n与 return 类似\nclass Test{ public: Test(string name){ m_name = name; cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;被构造了\u0026#34; \u0026lt;\u0026lt; endl; } ~Test(){ cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;被析构了\u0026#34; \u0026lt;\u0026lt; endl; } private: string m_name; }; double func1(int x, int y){ Test t1(\u0026#34;t1\u0026#34;), t2(\u0026#34;t2\u0026#34;); if(y == 0){ throw y; } return x / y; } int main() { try{ Test t3(\u0026#34;t3\u0026#34;), t4(\u0026#34;t4\u0026#34;); func1(10, 0); } catch(int e){ cout \u0026lt;\u0026lt; \u0026#34;除数为 \u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; } return 0; } t3被构造了 t4被构造了 t1被构造了 t2被构造了 t2被析构了 t1被析构了 t4被析构了 t3被析构了 除数为 0 ","title":"栈解旋 Unwinding"},{"content":"一、try、catch、throw  可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型 C++ 异常机制是跨函数的，且是必须处理的。如果中间函数没有处理就一直抛到最顶层，如果 main 函数也不处理，程序就会挂掉  int main( ) { try{ throw \u0026#34;exception\u0026#34;; }catch(const char * e){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; }catch(...){ // 捕获所有异常  cout \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; } { cout \u0026lt;\u0026lt; \u0026#34;finally\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输出：\nStart exception finally 0 Finish 二、std::exception class exception { public: exception() throw(); exception(const exception\u0026amp; rhs) throw(); exception\u0026amp; operator=(const exception\u0026amp; rhs) throw(); virtual ~exception() throw(); virtual const char *what() const throw(); }; 派生了两个异常类：\n   类名 描述     logic_erro 报告程序的逻辑错误，可在程序执行前被检测到   runtime_erro 报告程序运行时的错误，只有在运行的时候才能检测到    由logic_erro派生的异常类：\n   类名 描述     domain_error 报告违反了前置条件   invalid_argument 指出函数的一个无效参数   length_error 指出有一个产生超过NPOS长度的对象的企图（NPOS为size_t的最大可表现值   out_of_range 报告参数越界   bad_cast 在运行时类型识别中有一个无效的dynamic_cast表达式   bad_typeid 报告在表达式typeid(*p)中有一个空指针P    由runtime_error派生的异常：\n   类名 描述     range_error 报告违反了后置条件   overflow_error 报告一个算术溢出   bad_alloc 报告一个存储分配错误    三、自定义异常 可以通过继承和重载 exception 类来定义新的异常\nstruct MyException : public exception { const char * what () const throw () // 表明没有任何异常抛出  { return \u0026#34;C++ Exception\u0026#34;; } }; int main() { try { throw MyException(); } catch(MyException\u0026amp; e) { cout \u0026lt;\u0026lt; \u0026#34;MyException caught\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } catch(std::exception\u0026amp; e) { //其他的错误  } catch(...) { cout \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; } { cout \u0026lt;\u0026lt; \u0026#34;finally\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } Start MyException caught C++ Exception finally 0 Finish ","permalink":"https://874656645.github.io/posts/57-%E5%BC%82%E5%B8%B8/","summary":"一、try、catch、throw  可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型 C++ 异常机制是跨函数的，且是必须处理的。如果中间函数没有处理就一直抛到最顶层，如果 main 函数也不处理，程序就会挂掉  int main( ) { try{ throw \u0026#34;exception\u0026#34;; }catch(const char * e){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; }catch(...){ // 捕获所有异常  cout \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; } { cout \u0026lt;\u0026lt; \u0026#34;finally\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输出：\nStart exception finally 0 Finish 二、std::exception class exception { public: exception() throw(); exception(const exception\u0026amp; rhs) throw(); exception\u0026amp; operator=(const exception\u0026amp; rhs) throw(); virtual ~exception() throw(); virtual const char *what() const throw(); }; 派生了两个异常类：","title":"异常"},{"content":"1. static_cast\u0026lt;\u0026gt;  可以转换内置数据类型； 不可以转换没有关系的指针或引用； 可以转换有继承关系的指针或引用（父类转子类或子类转父类都可以）；  // static_cast\u0026lt;\u0026gt;  // 1. 内置对象  int a = 97; char c = static_cast\u0026lt;char\u0026gt;(a); // OK  cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; // 2. 自定义类型对象  // Building bb;  // Animal aa = static_cast\u0026lt;Animal\u0026gt;(bb); // error: no matching function for call to ‘Animal::Animal(Building\u0026amp;)’  // 3. 不同类型的指针转换  // int *p = \u0026amp;a;  // char *pc = static_cast\u0026lt;char*\u0026gt;(p); // error: invalid static_cast from type ‘int*’ to type ‘char*’  // cout \u0026lt;\u0026lt; pc \u0026lt;\u0026lt; endl;  // Animal * pa = NULL;  // Building *pb = static_cast\u0026lt;Building*\u0026gt;(pa); // error: invalid static_cast from type ‘Animal*’ to type ‘Building*’  // 4. 有继承关系的指针或引用  Animal * pa = NULL; Cat *pc = static_cast\u0026lt;Cat*\u0026gt;(pa); // OK  pa = static_cast\u0026lt;Animal*\u0026gt;(pc); // OK 2. dynamic_cast\u0026lt;\u0026gt;  只能转换有继承关系的指针或引用，且只能将子类转为父类（从大到小），因为将父类转为子类会不安全（从小到大）  // dynamic_cast\u0026lt;\u0026gt;  // 1. 内置对象  // c = dynamic_cast\u0026lt;char\u0026gt;(a); // error: cannot dynamic_cast ‘a’ (of type ‘int’) to type ‘char’ (target is not pointer or reference)  // 2. 非继承关系指针  // Building *pb = dynamic_cast\u0026lt;Building*\u0026gt;(pa); // error: cannot dynamic_cast ‘pa’ (of type ‘class Animal*’) to type ‘class Building*’ (source type is not polymorphic)  // 3. 继承关系指针会做安全检查，只能将子类指针转为父类指针  // pc = dynamic_cast\u0026lt;Cat*\u0026gt;(pa); // error: cannot dynamic_cast ‘pa’ (of type ‘class Animal*’) to type ‘class Cat*’ (source type is not polymorphic)  pa = dynamic_cast\u0026lt;Animal*\u0026gt;(pc); // OK  3. const_cast\u0026lt;\u0026gt;  只能转换指针或引用类型，添加或去除 const 修饰 非 const 的可以直接转为 const 类型，但反之不行  int i = 0; int *a = \u0026amp;i const int* b = const_cast\u0026lt;const int*\u0026gt;(a); const int* bb = a; // OK a = const_cast\u0026lt;int*\u0026gt;(b); // OK a = b; // error: invalid conversion from ‘const int*’ to ‘int*’ [-fpermissive] 4. reinterpret_cast\u0026lt;\u0026gt; 对任何类型的指针进行强制转换，包括函数指针\n","permalink":"https://874656645.github.io/posts/73-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","summary":"1. static_cast\u0026lt;\u0026gt;  可以转换内置数据类型； 不可以转换没有关系的指针或引用； 可以转换有继承关系的指针或引用（父类转子类或子类转父类都可以）；  // static_cast\u0026lt;\u0026gt;  // 1. 内置对象  int a = 97; char c = static_cast\u0026lt;char\u0026gt;(a); // OK  cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; // 2. 自定义类型对象  // Building bb;  // Animal aa = static_cast\u0026lt;Animal\u0026gt;(bb); // error: no matching function for call to ‘Animal::Animal(Building\u0026amp;)’  // 3. 不同类型的指针转换  // int *p = \u0026amp;a;  // char *pc = static_cast\u0026lt;char*\u0026gt;(p); // error: invalid static_cast from type ‘int*’ to type ‘char*’  // cout \u0026lt;\u0026lt; pc \u0026lt;\u0026lt; endl;  // Animal * pa = NULL;  // Building *pb = static_cast\u0026lt;Building*\u0026gt;(pa); // error: invalid static_cast from type ‘Animal*’ to type ‘Building*’  // 4.","title":"类型转换"},{"content":"要求  可以对内置数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及 operator= 防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量  实现 template\u0026lt;class T\u0026gt; class MyArray{ public: MyArray(int capacity){ this-\u0026gt;m_capacity = capacity; this-\u0026gt;m_size = 0; this-\u0026gt;m_addr = new T[this-\u0026gt;m_capacity]; } MyArray(const MyArray\u0026amp; arr){ if(arr.m_addr == NULL){ return; } // 深拷贝  this-\u0026gt;m_capacity = arr.m_capacity; this-\u0026gt;m_size = arr.m_size; this-\u0026gt;m_addr = new T[this-\u0026gt;m_capacity]; for(int i = 0; i \u0026lt; m_size; ++i){ // T 类型是可拷贝的，= 运算符也是深拷贝  this-\u0026gt;m_addr[i] = arr.m_addr[i]; } } MyArray\u0026amp; operator=(const MyArray\u0026amp; arr){ if(this == \u0026amp;arr){ return *this; } if(this-\u0026gt;m_addr != NULL){ delete[] this-\u0026gt;m_addr; this-\u0026gt;m_addr = NULL; this-\u0026gt;m_capacity = 0; this-\u0026gt;m_size = 0; } this-\u0026gt;m_capacity = arr.m_capacity; this-\u0026gt;m_size = arr.m_size; this-\u0026gt;m_addr = new T[this-\u0026gt;m_capacity]; for(int i = 0; i \u0026lt; this-\u0026gt;m_size; ++i){ this-\u0026gt;m_addr[i] = arr.m_addr[i]; } return *this; } T\u0026amp; operator[](int index){ return this-\u0026gt;m_addr[index]; } void pushBack(T\u0026amp; data){ if(this-\u0026gt;m_size == this-\u0026gt;m_capacity){ return; } this-\u0026gt;m_addr[this-\u0026gt;m_size] = data; this-\u0026gt;m_size++; } // 可以接收右值引用  void pushBack(T\u0026amp;\u0026amp; data){ if(this-\u0026gt;m_size == this-\u0026gt;m_capacity){ return; } this-\u0026gt;m_addr[this-\u0026gt;m_size] = data; this-\u0026gt;m_size++; } // 这种方式也可以接收右值引用  void pushBack(const T\u0026amp; data){ if(this-\u0026gt;m_size == this-\u0026gt;m_capacity){ return; } this-\u0026gt;m_addr[this-\u0026gt;m_size] = data; this-\u0026gt;m_size++; } void popBack(){ if(this-\u0026gt;m_size == 0){ return; } this-\u0026gt;m_size--; } int getCapacity() const{ return m_capacity; } int getSize() const{ return m_size; } ~MyArray(){ if(this-\u0026gt;m_addr != NULL){ delete[] this-\u0026gt;m_addr; this-\u0026gt;m_addr = NULL; this-\u0026gt;m_size = 0; } } private: int m_capacity; int m_size; T *m_addr; }; int main() { int a = 10, b = 20, c = 30; MyArray\u0026lt;int\u0026gt; arr(10); arr.pushBack(a); arr.pushBack(b); arr.pushBack(c); arr.pushBack(100); arr.pushBack(200); for(int i = 0; i \u0026lt; arr.getSize(); ++i){ cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;-----------\u0026#34; \u0026lt;\u0026lt; endl; arr.popBack(); for(int i = 0; i \u0026lt; arr.getSize(); ++i){ cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;+++++++++++\u0026#34; \u0026lt;\u0026lt; endl; MyArray\u0026lt;int\u0026gt; arr2(arr); for(int i = 0; i \u0026lt; arr2.getSize(); ++i){ cout \u0026lt;\u0026lt; arr2[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;+++++++++++\u0026#34; \u0026lt;\u0026lt; endl; MyArray\u0026lt;int\u0026gt; arr3(5); arr3.pushBack(1); arr3.pushBack(2); arr3.pushBack(3); arr2 = arr3; for(int i = 0; i \u0026lt; arr2.getSize(); ++i){ cout \u0026lt;\u0026lt; arr2[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 输出：\n10 20 30 100 200 ----------- 10 20 30 100 +++++++++++ 10 20 30 100 +++++++++++ 1 2 3 ","permalink":"https://874656645.github.io/posts/72-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/","summary":"要求  可以对内置数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及 operator= 防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量  实现 template\u0026lt;class T\u0026gt; class MyArray{ public: MyArray(int capacity){ this-\u0026gt;m_capacity = capacity; this-\u0026gt;m_size = 0; this-\u0026gt;m_addr = new T[this-\u0026gt;m_capacity]; } MyArray(const MyArray\u0026amp; arr){ if(arr.m_addr == NULL){ return; } // 深拷贝  this-\u0026gt;m_capacity = arr.m_capacity; this-\u0026gt;m_size = arr.m_size; this-\u0026gt;m_addr = new T[this-\u0026gt;m_capacity]; for(int i = 0; i \u0026lt; m_size; ++i){ // T 类型是可拷贝的，= 运算符也是深拷贝  this-\u0026gt;m_addr[i] = arr.m_addr[i]; } } MyArray\u0026amp; operator=(const MyArray\u0026amp; arr){ if(this == \u0026amp;arr){ return *this; } if(this-\u0026gt;m_addr !","title":"自定义数组实现"},{"content":"一、类模板写法 1. 声明和定义写在一起 template\u0026lt;class T\u0026gt; class Person{ public: Person(T age){ this-\u0026gt;m_age = age; } void Show(){ cout \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } private: T m_age; }; int main() { Person\u0026lt;int\u0026gt; p(20); p.Show(); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; printP(p); return 0; } 2. 声明和定义分开写，但在同一文件中 template\u0026lt;class T\u0026gt; class Person{ public: Person(T age); void Show(); private: T m_age; }; template\u0026lt;class T\u0026gt; Person\u0026lt;T\u0026gt;::Person(T age){ this-\u0026gt;m_age = age; } template\u0026lt;class T\u0026gt; void Person\u0026lt;T\u0026gt;::Show(){ cout \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } int main() { Person\u0026lt;int\u0026gt; p(20); p.Show(); return 0; } 二、类模板派生  类模板派生普通类； 类模板派生类模板；  template\u0026lt;class T\u0026gt; class Base{ public: Base(T a){ this-\u0026gt;m_a = a; } void show(){ cout \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } private: T m_a; }; class Derive1 : public Base\u0026lt;int\u0026gt;{ public: Derive1(int a):Base\u0026lt;int\u0026gt;(a){ } }; template\u0026lt;class T1, class T2\u0026gt; class Derive2 : public Base\u0026lt;T1\u0026gt;{ public: Derive2(T1 a, T2 b):Base\u0026lt;T1\u0026gt;(a){ this-\u0026gt;b = b; } void show(){ Base\u0026lt;T1\u0026gt;::show(); cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } private: T2 b; }; int main() { Derive1 d(10); d.show(); cout \u0026lt;\u0026lt; \u0026#34;---------\u0026#34; \u0026lt;\u0026lt; endl; Derive2\u0026lt;int, char\u0026gt; dd(100, \u0026#39;a\u0026#39;); dd.show(); return 0; } 输出：\n10 --------- 100 a 三、类模板中写友元函数 1. 声明和定义一起写 template\u0026lt;class T\u0026gt; class Person{ // 友元重载  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Person\u0026lt;T\u0026gt; \u0026amp;p){ os \u0026lt;\u0026lt; p.m_age; return os; } // 普通友元  friend void printP(Person\u0026lt;T\u0026gt; p){ cout \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; } public: Person(T age){ this-\u0026gt;m_age = age; } void Show(){ cout \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } private: T m_age; }; int main() { Person\u0026lt;int\u0026gt; p(20); p.Show(); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; printP(p); return 0; } 2. 声明和定义分开写 // 前置声明 template\u0026lt;class T\u0026gt; class Person; template\u0026lt;class T\u0026gt; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Person\u0026lt;T\u0026gt; \u0026amp;p); template\u0026lt;class T\u0026gt; void printP(Person\u0026lt;T\u0026gt; p); template\u0026lt;class T\u0026gt; class Person{ // 友元重载  friend ostream\u0026amp; operator\u0026lt;\u0026lt; \u0026lt;T\u0026gt;(ostream \u0026amp;os, Person\u0026lt;T\u0026gt; \u0026amp;p); // 普通友元  friend void printP\u0026lt;T\u0026gt;(Person\u0026lt;T\u0026gt; p); public: Person(T age); void Show(); private: T m_age; }; template\u0026lt;class T\u0026gt; Person\u0026lt;T\u0026gt;::Person(T age){ this-\u0026gt;m_age = age; } template\u0026lt;class T\u0026gt; void Person\u0026lt;T\u0026gt;::Show(){ cout \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } template\u0026lt;class T\u0026gt; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Person\u0026lt;T\u0026gt; \u0026amp;p){ os \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; return os; } template\u0026lt;class T\u0026gt; void printP(Person\u0026lt;T\u0026gt; p){ cout \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; } int main() { Person\u0026lt;int\u0026gt; p(20); p.Show(); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; printP(p); return 0; } 四、结论  类模板中不要滥用友元； 将类模板的声明和定义放在同一个文件中，一般为 .hpp 文件；  五、类模板中的 static 变量 每个具体的类都有属于自己的静态变量，每个具体类的实例对象共享自己具体类的静态变量\ntemplate\u0026lt;class T\u0026gt; int Person\u0026lt;T\u0026gt;::s_a = 0; int main() { Person\u0026lt;int\u0026gt; p1(10), p2(20); Person\u0026lt;char\u0026gt; pp1(10), pp2(20); p1.s_a = 1; pp1.s_a = 100; cout \u0026lt;\u0026lt; p2.s_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pp2.s_a \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 100 ","permalink":"https://874656645.github.io/posts/71-%E7%B1%BB%E6%A8%A1%E6%9D%BF/","summary":"一、类模板写法 1. 声明和定义写在一起 template\u0026lt;class T\u0026gt; class Person{ public: Person(T age){ this-\u0026gt;m_age = age; } void Show(){ cout \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } private: T m_age; }; int main() { Person\u0026lt;int\u0026gt; p(20); p.Show(); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; printP(p); return 0; } 2. 声明和定义分开写，但在同一文件中 template\u0026lt;class T\u0026gt; class Person{ public: Person(T age); void Show(); private: T m_age; }; template\u0026lt;class T\u0026gt; Person\u0026lt;T\u0026gt;::Person(T age){ this-\u0026gt;m_age = age; } template\u0026lt;class T\u0026gt; void Person\u0026lt;T\u0026gt;::Show(){ cout \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } int main() { Person\u0026lt;int\u0026gt; p(20); p.","title":"类模板"},{"content":"各个 .cpp 文件是独立编译的，如果有其它的类和函数会先在本 .o 文件中生成符号，由最后的链接器去其它 .o 文件找具体的函数定义\n .c .cpp 文件经过 预编译器拷贝头文件、宏展开 生成 .i 文件（文本文件）\ng++ -E main.cpp -o main.i .i 文件经过 编译器 生成汇编程序 .s（文本文件）\ng++ -S main.i -o main.s .s 文件经过 汇编器 生成可定位目标文件 .o （二进制）\nWindows:\ng++ -c main.s -o main.obj\nLinux:\ng++ -c main.s -o main.o .o 文件经过 链接器 生成可执行目标文件 .exe .dll\ng++ main.s -o main  ","permalink":"https://874656645.github.io/posts/70-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","summary":"各个 .cpp 文件是独立编译的，如果有其它的类和函数会先在本 .o 文件中生成符号，由最后的链接器去其它 .o 文件找具体的函数定义\n .c .cpp 文件经过 预编译器拷贝头文件、宏展开 生成 .i 文件（文本文件）\ng++ -E main.cpp -o main.i .i 文件经过 编译器 生成汇编程序 .s（文本文件）\ng++ -S main.i -o main.s .s 文件经过 汇编器 生成可定位目标文件 .o （二进制）\nWindows:\ng++ -c main.s -o main.obj\nLinux:\ng++ -c main.s -o main.o .o 文件经过 链接器 生成可执行目标文件 .exe .dll\ng++ main.s -o main  ","title":"编译过程"},{"content":" 函数模板必须严格类型匹配，普通函数则可以进行数据类型隐式转换 对于内置数据类型，函数模板可进行推导，自定义类型不可以 函数模板可被重载 C++ 编译器优先考虑普通函数 可以通过空模板实参列表的语法限定编译器只能通过模板匹配 如果函数模板可以产生一个更好的匹配，就选择模板 编译器根据函数模板调用情况，从函数模板和具体类型产生不同的函数\n编译器会对函数模板进行两次编译  在声明的地方对模板代码本身进行编译； 在调用的地方对参数替换后的代码进行编译    template\u0026lt;class T\u0026gt; T MyAdd(T a, T b){ return a + b; } // 函数一 int MyAdd(int a, int b){ return a + b; } // 函数二 int MyAdd(int a, char c){ return a + c; } int main() { cout \u0026lt;\u0026lt; MyAdd(1, 2) \u0026lt;\u0026lt; endl; // 优先调用普通函数  cout \u0026lt;\u0026lt; MyAdd\u0026lt;\u0026gt;(1, 2) \u0026lt;\u0026lt; endl; // 强制调用模板函数  cout \u0026lt;\u0026lt; MyAdd(1.1, 2.2) \u0026lt;\u0026lt; endl; // 函数模板数据类型推导  cout \u0026lt;\u0026lt; MyAdd\u0026lt;double\u0026gt;(1.1, 2.2) \u0026lt;\u0026lt; endl; // 显式调用  cout \u0026lt;\u0026lt; MyAdd(1, \u0026#39;a\u0026#39;) \u0026lt;\u0026lt; endl; // 没有函数二则调用函数一 MyAdd (a=1, c=97 \u0026#39;a\u0026#39;)  cout \u0026lt;\u0026lt; MyAdd(\u0026#39;a\u0026#39;, 1) \u0026lt;\u0026lt; endl; // 没有函数一则调用函数二 MyAdd (a=97, c=1 \u0026#39;\\001\u0026#39;)  return 0; } 输出：\n3 3 3.3 3.3 98 98 ","permalink":"https://874656645.github.io/posts/69-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/","summary":"函数模板必须严格类型匹配，普通函数则可以进行数据类型隐式转换 对于内置数据类型，函数模板可进行推导，自定义类型不可以 函数模板可被重载 C++ 编译器优先考虑普通函数 可以通过空模板实参列表的语法限定编译器只能通过模板匹配 如果函数模板可以产生一个更好的匹配，就选择模板 编译器根据函数模板调用情况，从函数模板和具体类型产生不同的函数\n编译器会对函数模板进行两次编译  在声明的地方对模板代码本身进行编译； 在调用的地方对参数替换后的代码进行编译    template\u0026lt;class T\u0026gt; T MyAdd(T a, T b){ return a + b; } // 函数一 int MyAdd(int a, int b){ return a + b; } // 函数二 int MyAdd(int a, char c){ return a + c; } int main() { cout \u0026lt;\u0026lt; MyAdd(1, 2) \u0026lt;\u0026lt; endl; // 优先调用普通函数  cout \u0026lt;\u0026lt; MyAdd\u0026lt;\u0026gt;(1, 2) \u0026lt;\u0026lt; endl; // 强制调用模板函数  cout \u0026lt;\u0026lt; MyAdd(1.","title":"函数模板"},{"content":"通过函数指针实现多态，注册回调函数的方式\nvoid printAllArray(void* arr, int eleSize, int len, void(*myPrint)(void*)){ char* arrStart = (char*)arr; for(int i = 0; i \u0026lt; len; ++i){ char* eleStart = arrStart + i * eleSize; myPrint(eleStart); } printf(\u0026#34;\\n\u0026#34;); } void printInt(void* data){ int* ele = (int*)data; printf(\u0026#34;%d \u0026#34;, *ele); } struct Person{ char name[64]; int age; }; void printPerson(void* data){ struct Person* ele = (struct Person*)data; printf(\u0026#34;Name: %s, Age: %d \\n\u0026#34;, ele-\u0026gt;name, ele-\u0026gt;age); } int main() { int arr[] = {1, 2, 3, 4, 5}; printAllArray(arr, sizeof(int), 5, printInt); struct Person personArr[] = { {\u0026#34;aaa\u0026#34;, 20}, {\u0026#34;bbb\u0026#34;, 30}, {\u0026#34;ccc\u0026#34;, 40}, {\u0026#34;ddd\u0026#34;, 50}, {\u0026#34;eee\u0026#34;, 60}, }; printAllArray(personArr, sizeof(struct Person), 5, printPerson); return 0; } 输出：\n1 2 3 4 5 Name: aaa, Age: 20 Name: bbb, Age: 30 Name: ccc, Age: 40 Name: ddd, Age: 50 Name: eee, Age: 60 ","permalink":"https://874656645.github.io/posts/68-c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/","summary":"通过函数指针实现多态，注册回调函数的方式\nvoid printAllArray(void* arr, int eleSize, int len, void(*myPrint)(void*)){ char* arrStart = (char*)arr; for(int i = 0; i \u0026lt; len; ++i){ char* eleStart = arrStart + i * eleSize; myPrint(eleStart); } printf(\u0026#34;\\n\u0026#34;); } void printInt(void* data){ int* ele = (int*)data; printf(\u0026#34;%d \u0026#34;, *ele); } struct Person{ char name[64]; int age; }; void printPerson(void* data){ struct Person* ele = (struct Person*)data; printf(\u0026#34;Name: %s, Age: %d \\n\u0026#34;, ele-\u0026gt;name, ele-\u0026gt;age); } int main() { int arr[] = {1, 2, 3, 4, 5}; printAllArray(arr, sizeof(int), 5, printInt); struct Person personArr[] = { {\u0026#34;aaa\u0026#34;, 20}, {\u0026#34;bbb\u0026#34;, 30}, {\u0026#34;ccc\u0026#34;, 40}, {\u0026#34;ddd\u0026#34;, 50}, {\u0026#34;eee\u0026#34;, 60}, }; printAllArray(personArr, sizeof(struct Person), 5, printPerson); return 0; } 输出：","title":"C 语言面向接口编程"},{"content":"三层架构：业务逻辑层、抽象层、实现层\n原则：依赖倒转\n案例一：动物园 设计实现：\n 抽象层：Animal\n提供接口 voice 实现层：Dog、Cat\n分别实现 voice ，发出不同的声音 业务层：main 函数调用，只通过 Animal 的指针统一实现业务  案例二：编写一个 C++ 程序, 计算程序员( programmer )工资  要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer )的工资 要求利用抽象类统一界面，方便程序的扩展，比如:新增，计算架构师( architect ) 的工资  设计实现：\n 抽象层：Programmer\n提供计算工资的接口 实现层：JuniorProgrammer、MidProgrammer、AdvProgrammer\n分别对计算工资接口进行实现 业务层：通过 Programmer 类统一管理，实现业务逻辑，同时业务的可扩展性更强，如新增架构师类型  案例三：电脑组装，面向抽象层编程  组装电脑有 3 个抽象类，抽象的 cpu，抽象的显卡，抽象的内存。 现在要求组装两台电脑，一台是 Intel 的 CPU，Intel 的显卡和 Intel 的内存。另一台是 Intel 的 CPU、Nvidia 的显卡和 Kingston 的内存条。 针对抽象层编程。  设计实现：\n 抽象层：CPU、Card、Storage 三个抽象类和一个组合类 Computer 实现层：IntelCPU、IntelCard、IntelStorage、NvidiaCard、KingstonStorage 派生类 业务层：创建两个 Computer 实例  案例四：几何图形  设计一个基类 Shape 包含成员函数 Show(), 将 Show() 声明为纯虚函数。 Shape 类公有派生矩形类 Square（正方形）和圆类 Circle（圆形） 分别定义 Show() 实现其主要集合元素的显示。使用抽象类 Shape 类型的指针，当它指向某个派生类的对象时，就可以通过访问该对象的虚函数成员 Show() 用 ShowArea() 分别显示各种图形的面积.最后还要显示所有图形的各个面积。要求积累指针数组，数组的每个元素指向一个派生类对象。  设计实现：\n 抽象层：Shape 抽象类，有 Show() 和 ShowArea() 两个纯虚函数 实现层：Square、Circle 派生类，分别拥有自己的属性，并实现基类纯虚函数 业务层：通过 Shape 指针数组管理  案例五：企业员工信息管理系统  某小型公司,主要有四类人员:经理、技术人员、销售经理和推销员。 现在需要存储这些人员的姓名、编号、级别、当月薪水。计算月薪总额并显示全部信息。 人员编号基数为 1000,每输入一个人员信息编号顺序加 1。 程序要有对所有人员提升级别的功能。本例中为简单起见,所有人员的初始级别均为 1 级。然后进行升级,经理升为 4 级,技术人员和销售经理升为 3 级,推销员仍为1级。 月薪计算办法是: 经理拿固定月薪 8000 元;技术人员按每小时 100 元领取月薪; 推销员的月薪按该推销员当月销售额的 4% 提成;销售经理既拿固定月薪也领取销售提成,固定月薪为 5000 元,销售提成为所管辖部门当月销售总额的 5%。  设计实现：\n 抽象层：Employee，拥有姓名、编号、级别、当月薪水基础属性，并提供 pay()、displayStatus() 两个纯虚函数（接口） 实现层：Technician、Manager、Salesman，SalesManager 虚继承于 Manager、Salesman，且分别有自己的特有属性 业务层：分别显示基本信息并计算工资  ","permalink":"https://874656645.github.io/posts/67-%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%BC%96%E7%A8%8B/","summary":"三层架构：业务逻辑层、抽象层、实现层\n原则：依赖倒转\n案例一：动物园 设计实现：\n 抽象层：Animal\n提供接口 voice 实现层：Dog、Cat\n分别实现 voice ，发出不同的声音 业务层：main 函数调用，只通过 Animal 的指针统一实现业务  案例二：编写一个 C++ 程序, 计算程序员( programmer )工资  要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer )的工资 要求利用抽象类统一界面，方便程序的扩展，比如:新增，计算架构师( architect ) 的工资  设计实现：\n 抽象层：Programmer\n提供计算工资的接口 实现层：JuniorProgrammer、MidProgrammer、AdvProgrammer\n分别对计算工资接口进行实现 业务层：通过 Programmer 类统一管理，实现业务逻辑，同时业务的可扩展性更强，如新增架构师类型  案例三：电脑组装，面向抽象层编程  组装电脑有 3 个抽象类，抽象的 cpu，抽象的显卡，抽象的内存。 现在要求组装两台电脑，一台是 Intel 的 CPU，Intel 的显卡和 Intel 的内存。另一台是 Intel 的 CPU、Nvidia 的显卡和 Kingston 的内存条。 针对抽象层编程。  设计实现：","title":"面向抽象类编程"},{"content":"MyString.h\n#ifndef __MYSTRING_H_ #define __MYSTRING_H_  #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; class MyString { // 重载 \u0026lt;\u0026lt;  // 最好是 const 的，可以输出匿名变量（匿名变量不能被非 const 的左值引用接收）  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const MyString \u0026amp;s); // 重载 \u0026gt;\u0026gt;  friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, MyString \u0026amp;s); private: // 字符串的有效长度  int m_len; // 字符串指针  char* m_pStr; public: MyString(); MyString(const char *); MyString(const MyString \u0026amp;); ~MyString(); // 重载 =  MyString\u0026amp; operator=(const MyString \u0026amp;); // 重载 []  char\u0026amp; operator[](int index); // 重载 +  MyString operator+(const MyString \u0026amp;); // 重载 +=  MyString\u0026amp; operator+=(const MyString \u0026amp;); // 重载 ==  bool operator==(const MyString \u0026amp;); // 重载 !=  bool operator!=(const MyString \u0026amp;); }; #endif MyString.cpp\n#include \u0026#34;MyString.h\u0026#34; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const MyString \u0026amp;s){ os \u0026lt;\u0026lt; s.m_pStr; return os; } istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, MyString \u0026amp;s){ char temp[4096] = {0}; is \u0026gt;\u0026gt; temp; if (s.m_pStr != NULL) { s.m_len = 0; free(s.m_pStr); s.m_pStr = NULL; } s.m_len = strlen(temp); s.m_pStr = (char*)malloc(s.m_len); strcpy(s.m_pStr, temp); return is; } MyString::MyString() { m_len = 0; m_pStr = NULL; // 注意 \u0026#39;\\0\u0026#39; NULL \u0026#34;\u0026#34;的区别 } MyString::MyString(const char *c) { if (c != NULL) { m_len = strlen(c); m_pStr = (char*)malloc(m_len + 1); strcpy(m_pStr, c); } cout \u0026lt;\u0026lt; \u0026#34;MyString(const char *c)...\u0026#34; \u0026lt;\u0026lt; endl; } MyString::MyString(const MyString \u0026amp;s) { if (s.m_pStr != NULL) { m_len = s.m_len; m_pStr = (char*)malloc(m_len + 1); strcpy(m_pStr, s.m_pStr); } cout \u0026lt;\u0026lt; \u0026#34;MyString(const MyString \u0026amp;s)...\u0026#34; \u0026lt;\u0026lt; endl; } MyString::~MyString() { m_len = 0; if (m_pStr != NULL) { free(m_pStr); m_pStr = NULL; } cout \u0026lt;\u0026lt; \u0026#34;~MyString()...\u0026#34; \u0026lt;\u0026lt; endl; } MyString\u0026amp; MyString::operator=(const MyString \u0026amp;s) { cout \u0026lt;\u0026lt; \u0026#34;operator=(const MyString \u0026amp;s)...\u0026#34; \u0026lt;\u0026lt; endl; // 1. 是否是给自身赋值  if (this == \u0026amp;s) { return *this; } // 2. 处理自身垃圾  if (m_pStr != NULL) { free(m_pStr); m_pStr = NULL; } // 3. 深拷贝  if (s.m_pStr != NULL) { m_len = s.m_len; m_pStr = (char*)malloc(m_len + 1); strcpy(m_pStr, s.m_pStr); } // 4. 返回自身  return *this; } char\u0026amp; MyString::operator[](int index) { if (m_len == 0) { throw \u0026#34;bad memory\u0026#34;; } if (index \u0026lt; 0 || index \u0026gt;= m_len) { throw \u0026#34;out of range\u0026#34;; } return m_pStr[index]; } MyString MyString::operator+(const MyString \u0026amp;s) { // 方式一：  /* MyString temp; temp.m_len = m_len + s.m_len; temp.m_pStr = (char*)malloc(temp.m_len + 1); // memset(temp.m_pStr, 0, temp.m_len + 1); strcpy(temp.m_pStr, m_pStr); // 注意 strcpy 和 strcat 的使用 strcat(temp.m_pStr, s.m_pStr); // 注意 strcat 的使用 return temp; */ // 方式二：  MyString temp = *this; return temp += s; } MyString\u0026amp; MyString::operator+=(const MyString \u0026amp;s) { if (s.m_len \u0026gt; 0) { // 处理自身垃圾  if (m_pStr != NULL) { char* pTemp = m_pStr; m_len += s.m_len; m_pStr = (char*)malloc(m_len + 1); strcpy(m_pStr, pTemp); strcat(m_pStr, s.m_pStr); free(pTemp); pTemp = NULL; } } return *this; } bool MyString::operator==(const MyString \u0026amp;s) { if (m_len == 0 || s.m_len == 0) { return false; } if(m_len != s.m_len) { return false; } for (int i = 0; i \u0026lt; m_len; i++) { if (m_pStr[i] != s.m_pStr[i]) { return false; } } return true; } bool MyString::operator!=(const MyString \u0026amp;s) { return !(*this == s); } test.cpp\n#include \u0026lt;iostream\u0026gt;#include \u0026#34;MyString.h\u0026#34; using namespace std; int main(){ // 隐式转换  MyString s0 = \u0026#34;123\u0026#34;; cout \u0026lt;\u0026lt; s0 \u0026lt;\u0026lt; endl; // 构造函数  MyString s1(\u0026#34;abc\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // 拷贝构造  MyString s2 = s1; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; // 拷贝构造  MyString s3(s2); cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; // = 操作符  s3 = s1; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; // [] 操作符  cout \u0026lt;\u0026lt; s3[1] \u0026lt;\u0026lt; endl; s3[1] = \u0026#39;1\u0026#39;; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; // + 操作符  cout \u0026lt;\u0026lt; s1 + s2 +s3 \u0026lt;\u0026lt; endl; // += 操作符  s3 += s1; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; // == 操作符  cout \u0026lt;\u0026lt; (s3 == s1) \u0026lt;\u0026lt; endl; // != 操作符  cout \u0026lt;\u0026lt; (s3 != s1) \u0026lt;\u0026lt; endl; return 0; } 输出：\nMyString(const char *c)... abc MyString(const MyString \u0026amp;s)... abc MyString(const MyString \u0026amp;s)... abc operator=(const MyString \u0026amp;s)... abc b a1c abcabca1c ~MyString()... ~MyString()... a1cabc 0 1 ~MyString()... ~MyString()... ~MyString()... ","permalink":"https://874656645.github.io/posts/66-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/","summary":"MyString.h\n#ifndef __MYSTRING_H_ #define __MYSTRING_H_  #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; class MyString { // 重载 \u0026lt;\u0026lt;  // 最好是 const 的，可以输出匿名变量（匿名变量不能被非 const 的左值引用接收）  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const MyString \u0026amp;s); // 重载 \u0026gt;\u0026gt;  friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, MyString \u0026amp;s); private: // 字符串的有效长度  int m_len; // 字符串指针  char* m_pStr; public: MyString(); MyString(const char *); MyString(const MyString \u0026amp;); ~MyString(); // 重载 =  MyString\u0026amp; operator=(const MyString \u0026amp;); // 重载 []  char\u0026amp; operator[](int index); // 重载 +  MyString operator+(const MyString \u0026amp;); // 重载 +=  MyString\u0026amp; operator+=(const MyString \u0026amp;); // 重载 ==  bool operator==(const MyString \u0026amp;); // 重载 !","title":"实现一个简单的字符串类"},{"content":"1. 声明静态数组后一定要进行初始化，否则里面的值都是未知的 int main() { int ia[3] = {0}; // 这虽然只是给第一个元素赋了值，但剩余未赋值的元素都会初始化为0  char ca[3] = {0}; double da[3]; bool ba[3]; short sa[3]; float fa[3]; for(auto \u0026amp; i : da){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } return 0; } 输出：\n6.95128e-310 4.63759e-310 0 2. C++ 数组指针和数组类型  数组类型和数组指针（数组名）不是一种类型，只是恰好指向的地址相同而已 数组名是指针常量（int * const），代表数组中第一个元素的地址 数组类型代表整个数组  int main() { int arr[10]; cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; arr + 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;arr + 1 \u0026lt;\u0026lt; endl; return 0; } 输出：\n0x7fff7fd65c20 0x7fff7fd65c24 ---------- 0x7fff7fd65c20 0x7fff7fd65c48 定义数组类型：\n// 方法一：定义一个数组类型 typedef int(ARRAY_INT_10)[10]; // 方法二：定义一个数组指针（不推荐这种写法） typedef int(*ARRAY_INT_10_P)[10]; int main() { int arr[10]; // 方法一：  ARRAY_INT_10 *arr1 = \u0026amp;arr; for(int i = 0; i \u0026lt; 10; i++){ //arr2[i] = i; // 错误 cannot convert ‘int*’ to ‘int (*)[10]’  // arr 是数组指针，arr1 是数组名  (*arr1)[i] = i; // 正确，要对 arr1 降级  } for(int i = 0; i \u0026lt; 10; i++){ cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;-----\u0026#34; \u0026lt;\u0026lt; endl; // 方法二：  ARRAY_INT_10_P arr2 = \u0026amp;arr; for(int i = 0; i \u0026lt; 10; i++){ cout \u0026lt;\u0026lt; (*arr2)[i] \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;+++++\u0026#34; \u0026lt;\u0026lt; endl; // 方法三：  int(*arr3)[10] = \u0026amp;arr; for(int i = 0; i \u0026lt; 10; i++){ cout \u0026lt;\u0026lt; (*arr3)[i] \u0026lt;\u0026lt; endl; } return 0; } 错误输出：\nmain.cpp:50:26: error: cannot convert ‘int*’ to ‘int (*)[10]’ in initialization 50 | ARRAY_INT_10 *arr2 = arr; | ^~~ | | | int* 输出：\n0 1 2 3 4 5 6 7 8 9 ----- 0 1 2 3 4 5 6 7 8 9 +++++ 0 1 2 3 4 5 6 7 8 9 ","permalink":"https://874656645.github.io/posts/65-%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/","summary":"1. 声明静态数组后一定要进行初始化，否则里面的值都是未知的 int main() { int ia[3] = {0}; // 这虽然只是给第一个元素赋了值，但剩余未赋值的元素都会初始化为0  char ca[3] = {0}; double da[3]; bool ba[3]; short sa[3]; float fa[3]; for(auto \u0026amp; i : da){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } return 0; } 输出：\n6.95128e-310 4.63759e-310 0 2. C++ 数组指针和数组类型  数组类型和数组指针（数组名）不是一种类型，只是恰好指向的地址相同而已 数组名是指针常量（int * const），代表数组中第一个元素的地址 数组类型代表整个数组  int main() { int arr[10]; cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; arr + 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;arr + 1 \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"静态数组初始化"},{"content":"一、安装 C++ 开发环境 Using GCC with MinGW\n 安装 MSYS2 更新 MSYS2 pacman -Syu 在开始菜单中运行 MSYS2 MSYS，更新其余的基本包 pacman -Su 安装 C++ 开发环境：  clang++ x64 gdb: pacman -S --needed base-devel mingw-w64-ucrt-x86_64-clang mingw-w64-ucrt-x86_64-gdb g++ gdb: pacman -S --needed base-devel mingw-w64-x86_64-toolchain clang++ lldb: pacman -S --needed base-devel mingw-w64-clang-x86_64-lldb\n这个库会把 clang clang++ 等库安装到 msys64/clang64/bin 目录，但是 lldb 在 Windows 上的调试效果不如 gdb clang++ x86：pacman -S --needed base-devel mingw-w64-i686-clang   添加环境变量 D:\\msys64\\ucrt64\\bin 检查是否安装成功  clang++ --version g++ --version gdb --version    pacman -Syu // 更新整个系统 pacman -Su // 更新已安装的包 pacman -Ss 关键字 // 搜索含关键字的包 pacman -S 包名 // 安装包，也可以同时安装多个包，只需以空格分隔包名即可 pacman -Rs 包名 // 删除包及其依赖 pacman -R 包名 // 删除包 二、配置 VS Code 主要是修改 task.json 和 launch.json 两个配置文件；\n新版本的 VS Code 按 F5 会自动创建这两个配置文件，稍做修改就可以了；\ntask.json 示例：\n{ \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Build\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;clang++.exe\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-fdiagnostics-color=always\u0026#34;, \u0026#34;-g\u0026#34;, // \u0026#34;${file}\u0026#34;, // 单文件  \u0026#34;${fileDirname}\\\\*.cpp\u0026#34;, // 多文件  \u0026#34;-o\u0026#34;, \u0026#34;${workspaceRoot}\\\\bin64\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;-ggdb3\u0026#34;, // 生成和调试有关的信息  \u0026#34;-Wall\u0026#34;, // 开启额外警告  \u0026#34;-static-libgcc\u0026#34;, // 静态链接  \u0026#34;-std=c++17\u0026#34;, // 使用c++17标准  \u0026#34;-finput-charset=UTF-8\u0026#34;, // 输入编译器文本编码 默认为UTF-8  \u0026#34;-D _USE_MATH_DEFINES\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;detail\u0026#34;: \u0026#34;调试器生成的任务。\u0026#34; } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } launch.json 示例：\n{ // 使用 IntelliSense 了解相关属性。  // 悬停以查看现有属性的描述。  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387  \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Debug\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}\\\\bin64\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;gdb.exe\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;为 gdb 启用整齐打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;Build\u0026#34; } ] } ","permalink":"https://874656645.github.io/posts/64-vs-code-%E6%90%AD%E5%BB%BA-c++-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","summary":"一、安装 C++ 开发环境 Using GCC with MinGW\n 安装 MSYS2 更新 MSYS2 pacman -Syu 在开始菜单中运行 MSYS2 MSYS，更新其余的基本包 pacman -Su 安装 C++ 开发环境：  clang++ x64 gdb: pacman -S --needed base-devel mingw-w64-ucrt-x86_64-clang mingw-w64-ucrt-x86_64-gdb g++ gdb: pacman -S --needed base-devel mingw-w64-x86_64-toolchain clang++ lldb: pacman -S --needed base-devel mingw-w64-clang-x86_64-lldb\n这个库会把 clang clang++ 等库安装到 msys64/clang64/bin 目录，但是 lldb 在 Windows 上的调试效果不如 gdb clang++ x86：pacman -S --needed base-devel mingw-w64-i686-clang   添加环境变量 D:\\msys64\\ucrt64\\bin 检查是否安装成功  clang++ --version g++ --version gdb --version    pacman -Syu // 更新整个系统 pacman -Su // 更新已安装的包 pacman -Ss 关键字 // 搜索含关键字的包 pacman -S 包名 // 安装包，也可以同时安装多个包，只需以空格分隔包名即可 pacman -Rs 包名 // 删除包及其依赖 pacman -R 包名 // 删除包 二、配置 VS Code 主要是修改 task.","title":"VS Code 搭建 c++ gdb 开发环境"},{"content":"C/C++内存对齐详解\n内存对齐规则  对齐系数（也叫对齐模数）：gcc中默认 #pragma pack(4)，可以通过预编译命令 #pragma pack(n)，n = 1,2,4,8,16 来改变这一系数 有效对齐值：是给定值 #pragma pack(n) 和结构体中 最长数据类型长度中较小的那个。有效对齐值也叫 对齐单位    规则一：结构体第一个成员的偏移量 offset 为 0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节\n  规则二：结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节\n注意：上面两条规则都需要得到满足\n注意：成员变量首地址偏移和对齐都是与【有效对齐值】进行比较，而有效对齐值是对齐系数与结构体中最长数据类型中的较小者\n  // 64 位程序 struct { int i; char c1; char c2; }x1; struct{ char c1; int i; char c2; }x2; struct{ char c1; char c2; int i; }x3; struct { short i; char c1; char c2; }y1; struct{ char c1; short i; char c2; }y2; struct{ char c1; char c2; short i; }y3; int main() { printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x1)); // 输出8  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x2)); // 输出12  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x3)); // 输出8  cout \u0026lt;\u0026lt; \u0026#34;----------------\u0026#34; \u0026lt;\u0026lt; endl; printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y1)); // 输出4  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y2)); // 输出6  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y3)); // 输出4  return 0; } 既要考虑首地址偏移，又要是有效对齐值（对齐单位）的整数倍 y1 y2 y3结构体：\n以上测试都是在 Linux 环境下进行的，linux 下默认 #pragma pack(4)，且结构体中最长的数据类型为 2 个字节，所以有效对齐单位为 2 字节，下面根据上面所说的规则以 y2 来分析其内存布局：\n首先使用规则 1，对成员变量进行对齐：\nsizeof(c1) = 1 \u0026lt;= 2 (有效对齐位)，按照 1 字节对齐，占用第 0 单元；\nsizeof(i) = 2 \u0026lt;= 2 (有效对齐位)，相对于结构体首地址的偏移要为 2 的倍数，占用第 2，3 单元；\nsizeof(c2) = 1 \u0026lt;= 2 (有效对齐位)，相对于结构体首地址的偏移要为 1 的倍数，占用第 4 单元；\n然后使用规则 2，对结构体整体进行对齐：\ny2 中变量 i 占用内存最大占 2 字节，而有对齐系数为 4 字节，两者较小值就是 2 字节。因此整体也是按照 2 字节对齐。由规则 1 得到 y2 占 5 个字节，此处再按照规则 2 进行整体的 2 字节对齐，所以整个结构体占用 6 个字节。\n","permalink":"https://874656645.github.io/posts/63-c++-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/","summary":"C/C++内存对齐详解\n内存对齐规则  对齐系数（也叫对齐模数）：gcc中默认 #pragma pack(4)，可以通过预编译命令 #pragma pack(n)，n = 1,2,4,8,16 来改变这一系数 有效对齐值：是给定值 #pragma pack(n) 和结构体中 最长数据类型长度中较小的那个。有效对齐值也叫 对齐单位    规则一：结构体第一个成员的偏移量 offset 为 0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节\n  规则二：结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节\n注意：上面两条规则都需要得到满足\n注意：成员变量首地址偏移和对齐都是与【有效对齐值】进行比较，而有效对齐值是对齐系数与结构体中最长数据类型中的较小者\n  // 64 位程序 struct { int i; char c1; char c2; }x1; struct{ char c1; int i; char c2; }x2; struct{ char c1; char c2; int i; }x3; struct { short i; char c1; char c2; }y1; struct{ char c1; short i; char c2; }y2; struct{ char c1; char c2; short i; }y3; int main() { printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x1)); // 输出8  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x2)); // 输出12  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(x3)); // 输出8  cout \u0026lt;\u0026lt; \u0026#34;----------------\u0026#34; \u0026lt;\u0026lt; endl; printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y1)); // 输出4  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y2)); // 输出6  printf(\u0026#34;%ld\\n\u0026#34;,sizeof(y3)); // 输出4  return 0; } 既要考虑首地址偏移，又要是有效对齐值（对齐单位）的整数倍 y1 y2 y3结构体：","title":"C++ 内存对齐"},{"content":" 使用模板类 重载 -\u0026gt; 操作符 重载 * 操作符  template\u0026lt;typename T\u0026gt; class MyAutoPtr{ public: MyAutoPtr(T * t){ ptr = t; } ~MyAutoPtr(){ if(ptr != NULL){ delete ptr; ptr = NULL; } } T* operator-\u0026gt;(){ // 相当于 ptr-\u0026gt; , 所以返回 ptr 指针即可，将所有操作转发给真正的指针变量  return ptr; } T\u0026amp; operator*(){ // 相当于 (*ptr) ，所以返回 ptr 指向的对象引用即可  return *ptr; } private: T* ptr; }; class A{ public: A(int a){ cout \u0026lt;\u0026lt; \u0026#34;A(int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; } ~A(){ cout \u0026lt;\u0026lt; \u0026#34;~A()...\u0026#34; \u0026lt;\u0026lt; endl; } void printA(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } private: int a; }; int main( ) { MyAutoPtr\u0026lt;A\u0026gt; p(new A(10)); p-\u0026gt;printA(); // ptr-\u0026gt;printA()  (*p).printA(); // (*ptr).printA()  MyAutoPtr\u0026lt;int\u0026gt; ip(new int(100)); cout \u0026lt;\u0026lt; *ip \u0026lt;\u0026lt; endl; return 0; } 输出：\nA(int)... a = 10 a = 10 100 ~A()... ","permalink":"https://874656645.github.io/posts/62-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","summary":"使用模板类 重载 -\u0026gt; 操作符 重载 * 操作符  template\u0026lt;typename T\u0026gt; class MyAutoPtr{ public: MyAutoPtr(T * t){ ptr = t; } ~MyAutoPtr(){ if(ptr != NULL){ delete ptr; ptr = NULL; } } T* operator-\u0026gt;(){ // 相当于 ptr-\u0026gt; , 所以返回 ptr 指针即可，将所有操作转发给真正的指针变量  return ptr; } T\u0026amp; operator*(){ // 相当于 (*ptr) ，所以返回 ptr 指向的对象引用即可  return *ptr; } private: T* ptr; }; class A{ public: A(int a){ cout \u0026lt;\u0026lt; \u0026#34;A(int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; } ~A(){ cout \u0026lt;\u0026lt; \u0026#34;~A().","title":"自定义智能指针"},{"content":"一、进程与线程  进程是资源分配和调度的一个独立单位；而线程是进程的一个实体，是 CPU 调度和分配的基本单位 同一个进程中的多个线程的内存资源是共享的，各线程都可以改变进程中的变量。因此在执行多线程运算的时候要注意执行顺序  二、并行与并发  并行（parallellism）指的是多个任务在同一时刻同时在执行 并发（concurrency）是指在一个时间段内，多个任务交替进行。虽然看起来像在同时执行，但其实是交替的  三、多任务处理 多线程是多任务处理的一种特殊形式，一般情况下，有基于进程和基于线程的两种类型的多任务处理方式。\n 基于进程的多任务处理是程序的并发执行 基于线程的多任务处理是同一程序的片段的并发执行  四、C++11 线程管理 thread 库  C++11 提供了多线程库，使用时需要 #include \u0026lt;thread\u0026gt; 头文件，该头文件主要包含了对线程的管理类 std::thread 以及其他管理线程相关的类 每个应用程序至少有一个进程，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个子线程。每个线程都需要一个入口函数，入口函数返回退出，该线程也会退出，主线程就是以 main 函数作为入口函数的线程 主线程退出后，运行中的子线程也会被销毁 std::thread 的构造函数需要的是可调用（callable）类型，除了函数外，还可以调用 lambda 表达式、重载了 () 运算符的类的实例 把函数对象传入 std::thread 时，应传入函数名称（不带括号） 当启动一个线程后，一定要在该线程 thread 销毁前，调用 join() 或者 detach()，确定以何种方式等待线程执行结束  detach 方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束 join 方式，等待关联的线程完成，才会继续执行 join() 后的代码 在以 detach 的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用按值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束    1、调用全局函数启动线程 #include \u0026lt;thread\u0026gt; using namespace std; void func(int i){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } int main() { for(int i = 0; i \u0026lt; 4; ++i){ // 创建一个线程t，第一个参数为调用的函数，第二个参数为传递的参数  thread t(func, i); // 表示允许该线程在后台运行  t.detach(); } return 0; } 输出：\nStart 10 2 3 0 Finish 2、调用类成员函数启动线程 class Test{ public: explicit Test(int a){ this-\u0026gt;a = a; } void fuc1(int n){ cout \u0026lt;\u0026lt; \u0026#34;fuc1() n = \u0026#34; \u0026lt;\u0026lt; n * a \u0026lt;\u0026lt; endl; } static void fuc2(int n){ cout \u0026lt;\u0026lt; \u0026#34;static fuc2() n = \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } private: int a; }; int main() { Test t(5); thread t1(\u0026amp;Test::fuc1, \u0026amp;t, 10); t1.join(); thread t2(\u0026amp;Test::fuc2, 100); t2.join(); return 0; } 输出：\nStart fuc1() n = 50 static fuc2() n = 100 0 Finish 3、转移线程的所有权 thread 是可移动的 (movable) 的，但不可复制的 (copyable)。可以通过 move 来改变线程的所有权，灵活的决定线程在什么时候 join 或者 detach\nthread t1(f1); thread t3(move(t1)); 将线程从 t1 转移给 t3，这时候 t1 就不再拥有线程的所有权，调用 t1.join 或 t1.detach 会出现异常，要使用 t3 来管理线程。这也就意味着 thread 可以作为函数的返回类型，或者作为参数传递给函数，能够更为方便的管理线程\n4、线程标识的获取 线程的标识类型为 std:🧵:id，有两种方式获得到线程的 id：\n 通过 thread 的实例调用 get_id() 直接获取 在当前线程上调用 this_thread::get_id() 获取  5、线程暂停 如果让线程从外部暂停会引发很多并发问题，这也是为什么std::thread没有直接提供pause函数的原因。如果线程在运行过程中，确实需要停顿，就可以用 this_thread::sleep_for\nclass Test{ public: explicit Test(int a){ this-\u0026gt;a = a; } void fuc1(int n){ this_thread::sleep_for(chrono::seconds(3)); cout \u0026lt;\u0026lt; \u0026#34;fuc1() n = \u0026#34; \u0026lt;\u0026lt; n * a \u0026lt;\u0026lt; endl; } static void fuc2(int n){ cout \u0026lt;\u0026lt; \u0026#34;static fuc2() n = \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } private: int a; }; int main() { Test t(5); thread t1(\u0026amp;Test::fuc1, \u0026amp;t, 10); cout \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; endl; t1.join(); //t1.detach(); // 主线程销后，t1 这个等待线程也会被销毁（没有执行fuc1函数的输出）  thread t2(\u0026amp;Test::fuc2, 100); cout \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; endl; t2.join(); cout \u0026lt;\u0026lt; \u0026#34;main thread id: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 140270821496576 140270813103872 static fuc2() n = 100 main thread id: 140270844794624 0 Finish 6、异常情况下等待线程完成 为了避免主线程出现异常时将子线程终结，就要保证子线程在函数退出前完成，即在函数退出前调用 join()\n 方法一：异常捕获  void func() { thread t([]{ cout \u0026lt;\u0026lt; \u0026#34;hello C++ 11\u0026#34; \u0026lt;\u0026lt; endl; }); try { do_something_else(); } catch (...) { t.join(); throw; } t.join(); }  方法二：资源获取即初始化（RAII）  无论是何种情况，当函数退出时，对象 guard 调用其析构函数销毁，从而能够保证 join 一定会被调用\nclass thread_guard { private: thread \u0026amp;t; public: /*加入explicit防止隐式转换*/ explicit thread_guard(thread\u0026amp; _t) { t = _t; } thread_guard(const thread_guard\u0026amp;) = delete; //删除默认拷贝构造函数  thread_guard\u0026amp; operator=(const thread_guard\u0026amp;) = delete; //删除默认赋值运算符  ~thread_guard() { if (t.joinable()) t.join(); } }; void func(){ thread t([]{ cout \u0026lt;\u0026lt; \u0026#34;Hello thread\u0026#34; \u0026lt;\u0026lt;endl ; }); thread_guard guard(t); } ","permalink":"https://874656645.github.io/posts/61-c++-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","summary":"一、进程与线程  进程是资源分配和调度的一个独立单位；而线程是进程的一个实体，是 CPU 调度和分配的基本单位 同一个进程中的多个线程的内存资源是共享的，各线程都可以改变进程中的变量。因此在执行多线程运算的时候要注意执行顺序  二、并行与并发  并行（parallellism）指的是多个任务在同一时刻同时在执行 并发（concurrency）是指在一个时间段内，多个任务交替进行。虽然看起来像在同时执行，但其实是交替的  三、多任务处理 多线程是多任务处理的一种特殊形式，一般情况下，有基于进程和基于线程的两种类型的多任务处理方式。\n 基于进程的多任务处理是程序的并发执行 基于线程的多任务处理是同一程序的片段的并发执行  四、C++11 线程管理 thread 库  C++11 提供了多线程库，使用时需要 #include \u0026lt;thread\u0026gt; 头文件，该头文件主要包含了对线程的管理类 std::thread 以及其他管理线程相关的类 每个应用程序至少有一个进程，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个子线程。每个线程都需要一个入口函数，入口函数返回退出，该线程也会退出，主线程就是以 main 函数作为入口函数的线程 主线程退出后，运行中的子线程也会被销毁 std::thread 的构造函数需要的是可调用（callable）类型，除了函数外，还可以调用 lambda 表达式、重载了 () 运算符的类的实例 把函数对象传入 std::thread 时，应传入函数名称（不带括号） 当启动一个线程后，一定要在该线程 thread 销毁前，调用 join() 或者 detach()，确定以何种方式等待线程执行结束  detach 方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束 join 方式，等待关联的线程完成，才会继续执行 join() 后的代码 在以 detach 的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用按值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束    1、调用全局函数启动线程 #include \u0026lt;thread\u0026gt; using namespace std; void func(int i){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } int main() { for(int i = 0; i \u0026lt; 4; ++i){ // 创建一个线程t，第一个参数为调用的函数，第二个参数为传递的参数  thread t(func, i); // 表示允许该线程在后台运行  t.","title":"C++ 多线程"},{"content":"error: cannot bind non-const lvalue reference of type ‘T\u0026amp;’ to an rvalue of type ‘T’\n如果一个参数是以非 const 引用传入，c++ 编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。\n但如果你 把一个临时变量当作非 const 引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉。\n所以，修改一个临时变量是毫无意义的。据此，c++ 编译器加入了临时变量不能作为非 const 引用的这个语义限制。\nc++ 中临时变量是右值类型，不能取引用，只能在当前行使用，不能作为非 const 的引用参数\nstd::move() 返回的也是一个右值\n对于临时变量或字面量的右值引用可以使用 cosnt \u0026amp; 或 \u0026amp;\u0026amp; 类型的参数接收\n一般来说，右值的地址不能通过解引用来获得，因为它们是字面量，或者因为它们本质上是临时的(例如由函数或显式构造函数调用返回的值)。通过将一个对象传递给这个函数，可以获得一个引用它的右值。\nclass T{ public: T(int v){ a = v; } T operator+(T \u0026amp;t){ T temp = this-\u0026gt;a + t.a; return temp; } void printT(T \u0026amp;t){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; t.a \u0026lt;\u0026lt; endl; } // 方式一  void printT(const T \u0026amp;t){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; t.a \u0026lt;\u0026lt; endl; } // 方式二 C++11 以后添加的右值引用新特性  void printT(T \u0026amp;\u0026amp;t){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; t.a \u0026lt;\u0026lt; endl; } private: int a; }; int main() { T t0(0), t1(1), t2(2); t0.printT(t1 + t2); // t1 + t2 返回临时变量 右值  return 0; } 输出：\nmain.cpp:29:18: error: cannot bind non-const lvalue reference of type ‘T\u0026amp;’ to an rvalue of type ‘T’ 29 | t0.printT(t1 + t2); | ~~~^~~~ main.cpp:20:20: note: initializing argument 1 of ‘void T::printT(T\u0026amp;)’ 20 | void printT(T \u0026amp;t){ | ~~~^ ","permalink":"https://874656645.github.io/posts/60-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BAno-const%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0/","summary":"error: cannot bind non-const lvalue reference of type ‘T\u0026amp;’ to an rvalue of type ‘T’\n如果一个参数是以非 const 引用传入，c++ 编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。\n但如果你 把一个临时变量当作非 const 引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉。\n所以，修改一个临时变量是毫无意义的。据此，c++ 编译器加入了临时变量不能作为非 const 引用的这个语义限制。\nc++ 中临时变量是右值类型，不能取引用，只能在当前行使用，不能作为非 const 的引用参数\nstd::move() 返回的也是一个右值\n对于临时变量或字面量的右值引用可以使用 cosnt \u0026amp; 或 \u0026amp;\u0026amp; 类型的参数接收\n一般来说，右值的地址不能通过解引用来获得，因为它们是字面量，或者因为它们本质上是临时的(例如由函数或显式构造函数调用返回的值)。通过将一个对象传递给这个函数，可以获得一个引用它的右值。\nclass T{ public: T(int v){ a = v; } T operator+(T \u0026amp;t){ T temp = this-\u0026gt;a + t.a; return temp; } void printT(T \u0026amp;t){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; t.","title":"临时变量不能绑定 no-const 左值引用类型"},{"content":"还有类型转换函数\n#include \u0026lt;iostream\u0026gt; using namespace std; class Complex{ // friend Complex complexAdd(Complex \u0026amp;c1, Complex \u0026amp;c2);  // friend Complex operator+(Complex \u0026amp;c1, Complex \u0026amp;c2);  // friend Complex\u0026amp; operator+= (Complex \u0026amp;c1, Complex \u0026amp;c2);  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Complex \u0026amp;c); friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, Complex \u0026amp;c); public: Complex(){ cout \u0026lt;\u0026lt; \u0026#34;Complex()...\u0026#34; \u0026lt;\u0026lt; endl; a = 0; b = 0; } Complex(int a, int b){ cout \u0026lt;\u0026lt; \u0026#34;Complex(int, int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; this-\u0026gt;b = b; } ~Complex(){ cout \u0026lt;\u0026lt; \u0026#34;~Complex()...\u0026#34; \u0026lt;\u0026lt; endl; } void printComplex(){ cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;b \u0026lt;\u0026lt; \u0026#34;i)\u0026#34; \u0026lt;\u0026lt; endl; } // 方式二：在类内部实现（方式一和二是一样的，所以只能保留一种）  // c1 + c2 的写法会同时匹配这两种实现方式，如果都有实现就会产生二义性  // 不能返回引用类型  // + 操作符重载  Complex operator+(Complex \u0026amp;c2){ Complex temp(this-\u0026gt;a + c2.a, this-\u0026gt;b + c2.b); return temp; } // += 操作符重载  Complex\u0026amp; operator+=(Complex \u0026amp;c2){ cout \u0026lt;\u0026lt; \u0026#34;operator+=()...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a += c2.a; this-\u0026gt;b += c2.b; return *this; } // 单目运算符 前++，因为可以进行连续前++操作，所以返回引用类型  Complex\u0026amp; operator++(){ this-\u0026gt;a++; this-\u0026gt;b++; return *this; } // 单目运算符 后++，不能进行连续 后++ 操作，返回类型加const  // 为了与 前++ 进行区分，使用亚元形参  const Complex operator++(int){ Complex temp(this-\u0026gt;a, this-\u0026gt;b); this-\u0026gt;a++; this-\u0026gt;b++; return temp; } // = 操作符重载  Complex\u0026amp; operator=(Complex \u0026amp;c){ // 1、是否与自身相同  if(this == \u0026amp;c) return *this; // 2、如果自身有开辟内存，就清理自己的垃圾  // 3、深拷贝  this-\u0026gt;a = c.a; this-\u0026gt;b = c.b; return *this; } // [] 操作符重载  int\u0026amp; operator[](int index){ if(index == 1){ return this-\u0026gt;a; } if(index == 2){ return this-\u0026gt;b; } throw \u0026#34;error index\u0026#34;; } // == 操作符重载  bool operator==(Complex \u0026amp;c){ return (this-\u0026gt;a == c.a \u0026amp;\u0026amp; this-\u0026gt;b == c.b); } // != 操作符重载  bool operator!=(Complex \u0026amp;c){ return !(*this == c); } // () 操作符重载，仿函数  bool operator()(){ return (this-\u0026gt;a != 0 \u0026amp;\u0026amp; this-\u0026gt;b != 0); } // new 操作符重载，会传入所创对象的大小（sizeof(Complex)）  // 返回的是 void* 的指针  // p-\u0026gt;operator new(sizeof(Complex))  void* operator new(size_t n){ void* p = malloc(n); cout \u0026lt;\u0026lt; \u0026#34;重载了 new... 空间大小是：\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\t指针地址是：\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return p; } // new[] 操作符重载，这个 n 多了一个指针的大小，不知道为什么？  void* operator new[](size_t n){ void* p = malloc(n); cout \u0026lt;\u0026lt; \u0026#34;重载了 new[]... 空间大小是：\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\t指针地址是：\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return p; } // delete 操作符重载，会传入所要删除的指针，类型是 void*  void operator delete(void *p){ cout \u0026lt;\u0026lt; \u0026#34;重载了 delete... 指针地址是：\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; if(p != NULL){ free((Complex*)p); // 应该也可以不用强转，在 malloc 时会管理一张程序内存分配表，里面有分配指针所对应的大小  p = NULL; } } // delete[] 操作符重载，会传入所要删除的指针，类型是 void*  void operator delete[](void *p){ cout \u0026lt;\u0026lt; \u0026#34;重载了 delete[]... 指针地址是：\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; if(p != NULL){ free(p); p = NULL; } } // \u0026amp;\u0026amp; 操作符重载（不建议重载，因为不会发生短路现象）  bool operator\u0026amp;\u0026amp;(Complex \u0026amp;c){ return ((*this)()) \u0026amp;\u0026amp; c(); } // || 操作符重载（不建议重载，因为不会发生短路现象）  bool operator||(Complex \u0026amp;c){ return (*this)() || c(); } private: int a; // 实部  int b; // 虚部 }; #if 0Complex complexAdd(Complex \u0026amp;c1, Complex \u0026amp;c2){ Complex temp(c1.a + c2.a, c1.b + c2.b); return temp; } // 方式一：用全局函数重载(友元重载) Complex operator+(Complex \u0026amp;c1, Complex \u0026amp;c2){ Complex temp(c1.a + c2.a, c1.b + c2.b); return temp; } Complex\u0026amp; operator+= (Complex \u0026amp;c1, Complex \u0026amp;c2){ c1.a += c2.a; c1.b += c2.b; return c1; } #endif // 左移 // 只能用全局函数实现重载，如果在类内部实现，调用形式就成了 c.operator\u0026lt;\u0026lt;(cout) // 因为可以连续调用，所以返回 ostream 对象引用 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Complex \u0026amp;c){ os \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; c.a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; c.b \u0026lt;\u0026lt; \u0026#34;i)\u0026#34; \u0026lt;\u0026lt; endl; return os; } // 右移同理 istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, Complex \u0026amp;c){ cout \u0026lt;\u0026lt; \u0026#34;a: \u0026#34;; is \u0026gt;\u0026gt; c.a; cout \u0026lt;\u0026lt; \u0026#34;b: \u0026#34;; is \u0026gt;\u0026gt; c.b; return is; } int main( ) { Complex c1(1, 2), c2(3, 4); c1.printComplex(); c2.printComplex(); // Complex c3 = complexAdd(c1, c2);  Complex c3 = c1 + c2 + c1; // 方式一等同于 operator+(c1, c2);  // 方式二等同于 c1.operator+(c2);  c3.printComplex(); cin \u0026gt;\u0026gt; c1; // operator\u0026gt;\u0026gt;(cin, c1)  cout \u0026lt;\u0026lt; c1 \u0026lt;\u0026lt; endl; // operator\u0026lt;\u0026lt;(cout, c1)  cout \u0026lt;\u0026lt; c1[1] \u0026lt;\u0026lt; endl; c1[1] = 5; cout \u0026lt;\u0026lt; c1; try{ c1[0] = 0; } catch(char const *e){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; } if(c1()){ cout \u0026lt;\u0026lt; \u0026#34;c1 is valid\u0026#34; \u0026lt;\u0026lt; endl; } else{ cout \u0026lt;\u0026lt; \u0026#34;c1 is not valid\u0026#34; \u0026lt;\u0026lt; endl; } // 测试数组  cout \u0026lt;\u0026lt; \u0026#34;静态数组大小是：\u0026#34; \u0026lt;\u0026lt; sizeof(Complex[2]) \u0026lt;\u0026lt; endl; Complex *cArray = new Complex[2]; // 这里的地址比 delete[] 的地址高了一个字节，不知道为什么？  cout \u0026lt;\u0026lt; \u0026#34;首地址是：\u0026#34; \u0026lt;\u0026lt; (cArray - sizeof(char)) \u0026lt;\u0026lt; endl; delete[] cArray; // 测试 \u0026amp;\u0026amp; || 是否发生短路  c1[1] = c1[2] = 0; if(c1 \u0026amp;\u0026amp; (c1 += c2)){ // c1.operator\u0026amp;\u0026amp;(c1 += c2)  cout \u0026lt;\u0026lt; \u0026#34;真\u0026#34; \u0026lt;\u0026lt; endl; } else{ cout \u0026lt;\u0026lt; \u0026#34;假\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;============\u0026#34; \u0026lt;\u0026lt; endl; c1[1] = -3; c2[2] = -4; if(c1 || (c1 += c2)){ // c1.operator||(c1 += c2)  cout \u0026lt;\u0026lt; \u0026#34;真\u0026#34; \u0026lt;\u0026lt; endl; } else{ cout \u0026lt;\u0026lt; \u0026#34;假\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输出：\n(1, 2i) (3, 4i) (5, 8i) a: 10 b: 20 (10, 20i) 1 (5, 2i) error index c1 is valid 重载了 new... 空间大小是：8 Complex(int, int)... 对象 c1 的地址是：0x5641c235a2c0 ~Complex()... 重载了 delete... 指针地址是：0x5641c235a2c0 静态数组大小是：16 重载了 new[]... 空间大小是：24 指针地址是：0x5640c52efeb0 Complex()... Complex()... 首地址是：0x5640c52efeb8 ~Complex()... ~Complex()... 重载了 delete[]... 指针地址是：0x5640c52efeb0 operator+=()... 真 ============ operator+=()... 假 ","permalink":"https://874656645.github.io/posts/59-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/","summary":"还有类型转换函数\n#include \u0026lt;iostream\u0026gt; using namespace std; class Complex{ // friend Complex complexAdd(Complex \u0026amp;c1, Complex \u0026amp;c2);  // friend Complex operator+(Complex \u0026amp;c1, Complex \u0026amp;c2);  // friend Complex\u0026amp; operator+= (Complex \u0026amp;c1, Complex \u0026amp;c2);  friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Complex \u0026amp;c); friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, Complex \u0026amp;c); public: Complex(){ cout \u0026lt;\u0026lt; \u0026#34;Complex()...\u0026#34; \u0026lt;\u0026lt; endl; a = 0; b = 0; } Complex(int a, int b){ cout \u0026lt;\u0026lt; \u0026#34;Complex(int, int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; this-\u0026gt;b = b; } ~Complex(){ cout \u0026lt;\u0026lt; \u0026#34;~Complex().","title":"操作符重载"},{"content":"买卖货物问题：\n#include \u0026lt;iostream\u0026gt; using namespace std; class Goods{ public: Goods(){ m_pNext = nullptr; m_weight = 0; cout \u0026lt;\u0026lt; \u0026#34;买入了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } Goods(int weight){ m_pNext = nullptr; m_weight = weight; total_weight += m_weight; cout \u0026lt;\u0026lt; \u0026#34;买入了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } ~Goods(){ total_weight -= m_weight; // m_pNext 不是在本类中 new 的，所以也不用 delete  this-\u0026gt;m_pNext = nullptr; cout \u0026lt;\u0026lt; \u0026#34;卖出了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } static int getTotalWeight(){ return total_weight; } Goods *m_pNext; private: int m_weight; static int total_weight; }; int Goods::total_weight = 0; void buy(Goods *\u0026amp;head, int weight){ Goods *pNewGoods = new Goods(weight); if(head == nullptr){ head = pNewGoods; } else{ pNewGoods-\u0026gt;m_pNext = head; head = pNewGoods; } } void sale(Goods *\u0026amp;head){ if(head == nullptr){ cout \u0026lt;\u0026lt; \u0026#34;没有货物了\u0026#34; \u0026lt;\u0026lt; endl; return; } Goods *temp = head; head = head-\u0026gt;m_pNext; delete temp; temp = nullptr; } int main( ) { Goods *head = nullptr; int choice; do{ // 提供菜单  cout \u0026lt;\u0026lt; \u0026#34;输入 1 进货\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 2 出货\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 0 退出\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; choice; switch(choice){ case 0: // 退出  return 0; case 1: { // 进货  int w = 0; cout \u0026lt;\u0026lt; \u0026#34;输入货物重量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; w; buy(head, w); break; } case 2: // 出货  sale(head); break; } cout \u0026lt;\u0026lt; \u0026#34;目前货物的总重量是：\u0026#34; \u0026lt;\u0026lt; Goods::getTotalWeight() \u0026lt;\u0026lt; endl; }while(1); return 0; } 输出：\n输入 1 进货 输入 2 出货 输入 0 退出 1 输入货物重量： 10 买入了货物，重量是：10 目前货物的总重量是：10 输入 1 进货 输入 2 出货 输入 0 退出 1 输入货物重量： 20 买入了货物，重量是：20 目前货物的总重量是：30 输入 1 进货 输入 2 出货 输入 0 退出 1 输入货物重量： 30 买入了货物，重量是：30 目前货物的总重量是：60 输入 1 进货 输入 2 出货 输入 0 退出 2 卖出了货物，重量是：30 目前货物的总重量是：30 输入 1 进货 输入 2 出货 输入 0 退出 2 卖出了货物，重量是：20 目前货物的总重量是：10 输入 1 进货 输入 2 出货 输入 0 退出 2 卖出了货物，重量是：10 目前货物的总重量是：0 输入 1 进货 输入 2 出货 输入 0 退出 2 没有货物了 目前货物的总重量是：0 输入 1 进货 输入 2 出货 输入 0 退出 0 ","permalink":"https://874656645.github.io/posts/58-%E5%85%B7%E6%9C%89%E9%93%BE%E8%A1%A8%E7%89%B9%E6%80%A7%E7%9A%84%E7%B1%BB/","summary":"买卖货物问题：\n#include \u0026lt;iostream\u0026gt; using namespace std; class Goods{ public: Goods(){ m_pNext = nullptr; m_weight = 0; cout \u0026lt;\u0026lt; \u0026#34;买入了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } Goods(int weight){ m_pNext = nullptr; m_weight = weight; total_weight += m_weight; cout \u0026lt;\u0026lt; \u0026#34;买入了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } ~Goods(){ total_weight -= m_weight; // m_pNext 不是在本类中 new 的，所以也不用 delete  this-\u0026gt;m_pNext = nullptr; cout \u0026lt;\u0026lt; \u0026#34;卖出了货物，重量是：\u0026#34; \u0026lt;\u0026lt; m_weight \u0026lt;\u0026lt; endl; } static int getTotalWeight(){ return total_weight; } Goods *m_pNext; private: int m_weight; static int total_weight; }; int Goods::total_weight = 0; void buy(Goods *\u0026amp;head, int weight){ Goods *pNewGoods = new Goods(weight); if(head == nullptr){ head = pNewGoods; } else{ pNewGoods-\u0026gt;m_pNext = head; head = pNewGoods; } } void sale(Goods *\u0026amp;head){ if(head == nullptr){ cout \u0026lt;\u0026lt; \u0026#34;没有货物了\u0026#34; \u0026lt;\u0026lt; endl; return; } Goods *temp = head; head = head-\u0026gt;m_pNext; delete temp; temp = nullptr; } int main( ) { Goods *head = nullptr; int choice; do{ // 提供菜单  cout \u0026lt;\u0026lt; \u0026#34;输入 1 进货\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 2 出货\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 0 退出\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; choice; switch(choice){ case 0: // 退出  return 0; case 1: { // 进货  int w = 0; cout \u0026lt;\u0026lt; \u0026#34;输入货物重量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; w; buy(head, w); break; } case 2: // 出货  sale(head); break; } cout \u0026lt;\u0026lt; \u0026#34;目前货物的总重量是：\u0026#34; \u0026lt;\u0026lt; Goods::getTotalWeight() \u0026lt;\u0026lt; endl; }while(1); return 0; } 输出：","title":"具有链表特性的类"},{"content":"1、六大组件介绍  容器：数据结构，用来存放数据 算法：常用算法 迭代器：容器和算法之间的胶合剂，“范型指针” 仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数 配置器：为容器分配并管理内存 适配器：修改其他组件接口  2、STL 常用的容器有哪些以及各自的特点是什么?    名称 特点     vector 底层数据结构为数组，支持快速随机访问   list 底层数据结构为双向链表，支持快速增删   deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问   stack 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   queue 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   priority_queue 底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现   set 底层数据结构为红黑树，有序，不重复   multiset 底层数据结构为红黑树，有序，可重复   map 底层数据结构为红黑树，有序，不重复   multimap 底层数据结构为红黑树，有序，可重复   unordered_set 底层数据结构为hash表，无序，不重复   unordered_multiset 底层数据结构为hash表，无序，可重复   unordered_map 底层数据结构为hash表，无序，不重复   unordered_multimap 底层数据结构为hash表，无序，可重复    3、vector 和 list 的区别  vector底层实现是数组，所以在内存中是连续存放的，随机读取效率高，但插入、删除效率低；list底层实现是双向链表，所以在内存中是任意存放的，插入、删除效率高，但访问元素效率低 vector在中间节点进行插入、删除会导致内存拷贝，而list不会 vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请  4、vector 扩容原理 以原内存空间大小的两倍配置一份新的内存空间，并将原空间数据拷贝过来进行初始化\n5、map 和 set 有什么区别  map中的元素是键值对；Set仅是关键字的简单集合 set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key map支持用关键字作下标操作，set不支持下标操作  6、map 和 unordered_map 的区别  map内部实现了一个红黑树，红黑树的每一个节点都代表着map的一个元素，因此所有元素都是有序的，对其进行查找、插入、删除得效率都是O(log n)；但是，因为每个结点都需要额外保存数据，所以空间占用率比较高 unordered_map内部实现了一个哈希表，因此内部元素是无序的，对其进行查找、插入、删除得效率都是O(1)；但是建立哈希表比较费时  7、STL 中迭代器的作用，有指针为何还要迭代器  Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-\u0026gt;、*、++、\u0026ndash;等，相当于一种智能指针 迭代器产生原因：Iterator采用的是面向对象的思想，把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果  ","permalink":"https://874656645.github.io/posts/56-stl-%E6%80%BB%E7%BB%93/","summary":"1、六大组件介绍  容器：数据结构，用来存放数据 算法：常用算法 迭代器：容器和算法之间的胶合剂，“范型指针” 仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数 配置器：为容器分配并管理内存 适配器：修改其他组件接口  2、STL 常用的容器有哪些以及各自的特点是什么?    名称 特点     vector 底层数据结构为数组，支持快速随机访问   list 底层数据结构为双向链表，支持快速增删   deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问   stack 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   queue 底层一般用deque/list实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时   priority_queue 底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现   set 底层数据结构为红黑树，有序，不重复   multiset 底层数据结构为红黑树，有序，可重复   map 底层数据结构为红黑树，有序，不重复   multimap 底层数据结构为红黑树，有序，可重复   unordered_set 底层数据结构为hash表，无序，不重复   unordered_multiset 底层数据结构为hash表，无序，可重复   unordered_map 底层数据结构为hash表，无序，不重复   unordered_multimap 底层数据结构为hash表，无序，可重复    3、vector 和 list 的区别  vector底层实现是数组，所以在内存中是连续存放的，随机读取效率高，但插入、删除效率低；list底层实现是双向链表，所以在内存中是任意存放的，插入、删除效率高，但访问元素效率低 vector在中间节点进行插入、删除会导致内存拷贝，而list不会 vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请  4、vector 扩容原理 以原内存空间大小的两倍配置一份新的内存空间，并将原空间数据拷贝过来进行初始化","title":"STL 总结"},{"content":"vector 常用操作 #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; int main() { //1.定义和初始化  vector\u0026lt;int\u0026gt; vec1; //默认初始化，vec1为空  vector\u0026lt;int\u0026gt; vec2(vec1); //使用vec1初始化vec2  vector\u0026lt;int\u0026gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2  vector\u0026lt;int\u0026gt; vec4(10); //10个值为0的元素  vector\u0026lt;int\u0026gt; vec5(10,4); //10个值为4的元素  //2.常用操作方法  //2.1 添加函数  vec1.push_back(100); // 尾部添加元素  vec1.insert(vec1.end(),5,3); // 从vec1.back位置插入5个值为3的元素  //2.2 删除函数  vec1.pop_back(); // 删除末尾元素  vec1.erase(vec1.begin(),vec1.begin()+2); // 删除vec1[0]-vec1[2]之间的元素，不包括vec1[2]其他元素前移  vec1.clear(); // 清空元素，元素在内存中并未消失，通常使用swap()来清空  vector\u0026lt;int\u0026gt;().swap(V); // 利用swap函数和临时对象交换内存，交换以后，临时对象消失，释放内存。  // 必须是同类型的 vector  // 且只有存储对象时才有效  //2.3 遍历函数  vec1[0]; //取得第一个元素  vec1.at(int pos); //返回pos位置元素的引用  vec1.front(); //返回首元素的引用  vec1.back(); //返回尾元素的引用  vector\u0026lt;int\u0026gt;::iterator begin= vec1.begin(); //返回向量头指针，指向第一个元素  vector\u0026lt;int\u0026gt;::iterator end= vec1.end(); //返回向量尾指针，指向向量最后一个元素的下一个位置  vector\u0026lt;int\u0026gt;::iterator rbegin= vec1.rbegin(); //反向迭代器，指向最后一个元素  vector\u0026lt;int\u0026gt;::iterator rend= vec1.rend(); //反向迭代器，指向第一个元素之前的位置  //2.4 判断函数  bool isEmpty = vec1.empty(); //判断是否为空  //2.5 大小函数  int size = vec1.size(); //元素个数  vec1.capacity(); //返回容器当前能够容纳的元素个数  vec1.max_size(); //返回容器最大的可能存储的元素个数  //2.6 改动函数  vec1.assign(int n,const T\u0026amp; x); //赋n个值为x的元素到vec1中，这会清除掉vec1中以前的内容。  vec1.assign(const_iterator first,const_iterator last); //当前向量中[first,last)中元素设置成迭代器所指向量的元素，这会清除掉vec1中以前的内容。 } ","permalink":"https://874656645.github.io/posts/55-vector/","summary":"vector 常用操作 #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; int main() { //1.定义和初始化  vector\u0026lt;int\u0026gt; vec1; //默认初始化，vec1为空  vector\u0026lt;int\u0026gt; vec2(vec1); //使用vec1初始化vec2  vector\u0026lt;int\u0026gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2  vector\u0026lt;int\u0026gt; vec4(10); //10个值为0的元素  vector\u0026lt;int\u0026gt; vec5(10,4); //10个值为4的元素  //2.常用操作方法  //2.1 添加函数  vec1.push_back(100); // 尾部添加元素  vec1.insert(vec1.end(),5,3); // 从vec1.back位置插入5个值为3的元素  //2.2 删除函数  vec1.pop_back(); // 删除末尾元素  vec1.erase(vec1.begin(),vec1.begin()+2); // 删除vec1[0]-vec1[2]之间的元素，不包括vec1[2]其他元素前移  vec1.clear(); // 清空元素，元素在内存中并未消失，通常使用swap()来清空  vector\u0026lt;int\u0026gt;().swap(V); // 利用swap函数和临时对象交换内存，交换以后，临时对象消失，释放内存。  // 必须是同类型的 vector  // 且只有存储对象时才有效  //2.3 遍历函数  vec1[0]; //取得第一个元素  vec1.","title":"vector"},{"content":"STL六大组件\nSTL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。STL中包括六大组件：容器、算法、迭代器、适配器、仿函数、空间配置器\n适配器：适配器是一种设计模式(设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结)，该中模式是将一个类的接口转换成客户希望的另外一个接口。\n一、容器 序列式容器（vector、deque、list）、关联式容器（map、set）、容器适配器（stack、queue、priority_queue）\n1. vector 是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。由于具有连续的存储空间，所以在插入和删除操作方面，效率比较慢\n2. deque deque 是 double ended queue 的缩写，双向队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。与 vector 不同，deque 不能保证将所有元素存储在连续的存储空间上\n3. list list 是 STL 实现的双向链表，与 vector 相比, 它允许快速的插入和删除，但是随机访问却比较慢\n4. map、multimap、unordered_map、unordered_multimap  map 是 STL 的一个关联容器，它是一种键值对容器，里面的数据都是成对出现的，且键值是唯一的，可在我们处理一对一数据的时候，在编程上提供快速通道。map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。 multimap 中的元素也是有序的，但允许存在相同键值的 unordered_map 中的元素是唯一的，但无序（也不是插入顺序），而是根据它们的散列值（hash values）组织成桶（buckets），从而允许通过键值直接快速访问单个元素（速度一般比 map 更快） unordered_multimap 无序且不唯一  5. set、multiset、unordered_set、unordered_multiset  set 的含义是集合，它是一个有序的容器，里面的元素都是唯一且排序好的，支持插入、删除、查找等操作，就像一个集合一样，所有的操作都是严格在 logn时间内完成，效率非常高，使用方法类似 list multiset 也是排序好的，但是可以存有相同的元素 unordered_set 无序但元素是不可重复的 unordered_multiset 无序，元素也不唯一  二、容器适配器 虽然 stack、queue、priority_queue 中也可以存放元素，但在 STL 中并没有将其划分在容器的行列，而是将其称为容器适配器，这是因为每个容器在底层都有自己的实现方式，而 stack、queue、priority_queue 只是在底层将其他容器进行了封装\nstd::stack template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class stack; std::queue template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class queue; std::priority_queue template\u0026lt;class T, class Container = vector\u0026lt;T\u0026gt;, class Compare = less\u0026lt;typename Container::value_type\u0026gt;\u0026gt; class priority_queue; 为什么选择 deque 作为 stack 和 queue 的底层默认容器？\nstack 是后进先出的特殊线性数据结构，只要具有 push_back() 和 pop_back() 操作的线性结构，都可以作为 stack 的底层容器，比如 vector 和 list 都可以；\nqueue 是先进先出的特殊线性数据结构，只要具有 push_back() 和 pop_front() 操作的线性结构，都可以作为 queue 的底层容器，比如 list。\n但是 STL 中对 stack 和 queue 默认选择 deque 作为其底层容器，主要是因为：\n stack 和 queue 不需要遍历(因此 stack 和 queue 没有迭代器)，只需要在固定的一端或者两端进行操作。 在 stack 中元素增长时，deque 比 vector 的效率高。 在 queue 中的元素增长时，deque 不仅效率高，而且内存使用率高  三、算法  十大经典算法  ","permalink":"https://874656645.github.io/posts/54-c++-stl/","summary":"STL六大组件\nSTL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。STL中包括六大组件：容器、算法、迭代器、适配器、仿函数、空间配置器\n适配器：适配器是一种设计模式(设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结)，该中模式是将一个类的接口转换成客户希望的另外一个接口。\n一、容器 序列式容器（vector、deque、list）、关联式容器（map、set）、容器适配器（stack、queue、priority_queue）\n1. vector 是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。由于具有连续的存储空间，所以在插入和删除操作方面，效率比较慢\n2. deque deque 是 double ended queue 的缩写，双向队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。与 vector 不同，deque 不能保证将所有元素存储在连续的存储空间上\n3. list list 是 STL 实现的双向链表，与 vector 相比, 它允许快速的插入和删除，但是随机访问却比较慢\n4. map、multimap、unordered_map、unordered_multimap  map 是 STL 的一个关联容器，它是一种键值对容器，里面的数据都是成对出现的，且键值是唯一的，可在我们处理一对一数据的时候，在编程上提供快速通道。map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。 multimap 中的元素也是有序的，但允许存在相同键值的 unordered_map 中的元素是唯一的，但无序（也不是插入顺序），而是根据它们的散列值（hash values）组织成桶（buckets），从而允许通过键值直接快速访问单个元素（速度一般比 map 更快） unordered_multimap 无序且不唯一  5. set、multiset、unordered_set、unordered_multiset  set 的含义是集合，它是一个有序的容器，里面的元素都是唯一且排序好的，支持插入、删除、查找等操作，就像一个集合一样，所有的操作都是严格在 logn时间内完成，效率非常高，使用方法类似 list multiset 也是排序好的，但是可以存有相同的元素 unordered_set 无序但元素是不可重复的 unordered_multiset 无序，元素也不唯一  二、容器适配器 虽然 stack、queue、priority_queue 中也可以存放元素，但在 STL 中并没有将其划分在容器的行列，而是将其称为容器适配器，这是因为每个容器在底层都有自己的实现方式，而 stack、queue、priority_queue 只是在底层将其他容器进行了封装\nstd::stack template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class stack; std::queue template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class queue; std::priority_queue template\u0026lt;class T, class Container = vector\u0026lt;T\u0026gt;, class Compare = less\u0026lt;typename Container::value_type\u0026gt;\u0026gt; class priority_queue; 为什么选择 deque 作为 stack 和 queue 的底层默认容器？","title":"C++ STL"},{"content":"C++ 中 new 操作符内幕：new operator、operator new、placement new \n1、new / delete 具体步骤 new\n 第一步：调用 operator new 函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值 第三部：对象构造完成后，返回一个指向该对象的指针  delete\n 第一步：调用对象的析构函数 第二步：编译器调用 operator delete 函数释放内存空间  2、new/delete 与 malloc/free 的区别是什么？  malloc/free 是 C 语言的标准库函数， new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存 malloc/free 不会去自动调用构造和析构函数，对于基本数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求 malloc/free 需要指定分配内存的大小，而 new/delete 会自动计算所需内存大小 new 返回的是指定对象的指针，而 malloc 返回的是 void*，因此 malloc 的返回值一般都需要进行强制类型转换  operator new 重载：\nclass Person{ public: Person(){ id = 0; score = 0; cout \u0026lt;\u0026lt; \u0026#34;Person()\u0026#34; \u0026lt;\u0026lt; endl; } Person(int id, int score):id(id),score(score){ cout \u0026lt;\u0026lt; \u0026#34;Person(int, int)\u0026#34; \u0026lt;\u0026lt; endl; } Person(const Person \u0026amp;p){ cout \u0026lt;\u0026lt; \u0026#34;Person(const Person \u0026amp;p)\u0026#34; \u0026lt;\u0026lt; endl; id = p.id; score = p.score; } // operator new  void* operator new(size_t s){ cout \u0026lt;\u0026lt; \u0026#34;new 1\u0026#34; \u0026lt;\u0026lt; endl; void* p = malloc(s); return p; } // placement new  void* operator new(size_t s, void* p){ cout \u0026lt;\u0026lt; \u0026#34;new 2\u0026#34; \u0026lt;\u0026lt; endl; return p; } int id; int score; }; int main() { void* p = malloc(sizeof(Person)); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; Person* pp = new (p) Person(10, 20); cout \u0026lt;\u0026lt; pp \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pp-\u0026gt;id \u0026lt;\u0026lt; endl; Person* myP = new Person; return 0; } 输出：\n0x55b01ec9aeb0 new 2 Person(int, int) 0x55b01ec9aeb0 10 new 1 Person() 3、C++内存管理 在 C++ 中，虚拟内存分为代码段、数据段、BSS段、堆区、栈区以及文件映射区六部分\n 代码段：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码 数据段：存储程序中已初始化的全局变量和静态变量 BSS段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量（这个段的数据全都是0） 堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存 映射区：存储动态链接库以及调用mmap函数进行的文件映射 栈区：使用栈空间存储函数的返回地址、参数、局部变量、返回值（最靠近CPU的区）  4、内存的分配方式（三种）   静态存储区分配：是在程序编译时就已经分配好的，在整个运行期间都存在，如全局变量、常量、静态变量\n  栈上分配：函数内的局部变量就是从这分配的，但分配的内存容易有限\n  堆上分配：也称动态分配，如我们用 new,malloc 分配内存，用 delete,free 来释放的内存。堆内存空间可由用户手动分配和释放，所以其生存周期由用户指定，较为灵活。但频繁的分配、释放大小不同的堆空间会产生内存碎片\n  5、内存池 内存池是一种内存分配方式。通常我们习惯直接使用new、malloc申请内存，这样做的缺点在于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，预先申请分配一定数量、大小相等（一般情况下）的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是，使得内存分配效率得到提升\n6、内存泄漏 内存泄漏一般是指堆内存的泄漏，也就是程序在运行过程中动态申请的内存空间不再使用后没有及时释放，导致那块内存不能被再次使用\n7、C++中的不安全是什么概念？ C++中的不安全包括两种：一是程序得不到正确的结果，二是发生不可预知的错误（占用了不该用的内存空间）。可能会发生如下问题：\n 最严重的：内存泄漏，程序崩溃； 一般严重的：发生一些逻辑错误，且不便于调试； 较轻的：丢失部分数据，就像强制转换一样  8、内存中的堆与栈有什么区别？  申请方式：栈由系统自动分配和管理，堆由程序员手动分配和管理 效率：栈由系统分配，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行，因此，其速度快，不会有内存碎片；堆由程序员分配，堆是由C/C++函数库提供的，机制复杂，需要一系列分配内存、合并内存和释放内存的算法，因此效率较低，可能由于操作不当产生内存碎片 扩展方向：栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展 程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间；同时，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间  ","permalink":"https://874656645.github.io/posts/53-new-delete-%E4%B8%8E%E5%86%85%E5%AD%98/","summary":"C++ 中 new 操作符内幕：new operator、operator new、placement new \n1、new / delete 具体步骤 new\n 第一步：调用 operator new 函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值 第三部：对象构造完成后，返回一个指向该对象的指针  delete\n 第一步：调用对象的析构函数 第二步：编译器调用 operator delete 函数释放内存空间  2、new/delete 与 malloc/free 的区别是什么？  malloc/free 是 C 语言的标准库函数， new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存 malloc/free 不会去自动调用构造和析构函数，对于基本数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求 malloc/free 需要指定分配内存的大小，而 new/delete 会自动计算所需内存大小 new 返回的是指定对象的指针，而 malloc 返回的是 void*，因此 malloc 的返回值一般都需要进行强制类型转换  operator new 重载：\nclass Person{ public: Person(){ id = 0; score = 0; cout \u0026lt;\u0026lt; \u0026#34;Person()\u0026#34; \u0026lt;\u0026lt; endl; } Person(int id, int score):id(id),score(score){ cout \u0026lt;\u0026lt; \u0026#34;Person(int, int)\u0026#34; \u0026lt;\u0026lt; endl; } Person(const Person \u0026amp;p){ cout \u0026lt;\u0026lt; \u0026#34;Person(const Person \u0026amp;p)\u0026#34; \u0026lt;\u0026lt; endl; id = p.","title":"new、delete 与内存"},{"content":"在堆上声明一个数组 int main( ) { #if 0// 方式一： int** pArr = NULL; pArr = new int*[4]; for(int i = 0; i \u0026lt; 4; i++){ pArr[i] = new int[8]; } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ if(j == 0) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pArr[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; } } // 删除 for(int i = 0; i \u0026lt; 4; ++i){ delete [] pArr[i]; } delete [] pArr; #endif  // 方式二：  cout \u0026lt;\u0026lt; sizeof(int[5]) \u0026lt;\u0026lt; endl; // 初始化  int(*pArr)[8] = new int[4][8]; memset(pArr, 0, sizeof(int[4][8])); // 或者  // int(*pArr)[8] = new int[4][8]{{0}};  cout \u0026lt;\u0026lt; sizeof(int[4][8]) \u0026lt;\u0026lt; endl; for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ cout \u0026lt;\u0026lt; pArr[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; } cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; delete[] pArr; // 取地址  int arr[3][4]{{0}}; int(*p)[3][4] = \u0026amp;arr; cout \u0026lt;\u0026lt; arr[2][3] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p[2][3] \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 0\t0\t0\t0\t0\t0\t0\t0\t0\t1\t2\t3\t4\t5\t6\t7\t0\t2\t4\t6\t8\t10\t12\t14\t0\t3\t6\t9\t12\t15\t18\t21\t0 Finish 在栈上声明一个数组 int main( ) { int a[3]; // 全部初始化为 0  int b[3]{4}; // 第一个值是 4，其余初始化为 0  int c[3] = {4}; // 同上  // new 一维数组  int* d = new int[3]{4}; // 同上  // 与 vector 不同  vector\u0026lt;int\u0026gt; v(3, 4);// 3 个值都是 4  return 0; } ","permalink":"https://874656645.github.io/posts/52-new-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/","summary":"在堆上声明一个数组 int main( ) { #if 0// 方式一： int** pArr = NULL; pArr = new int*[4]; for(int i = 0; i \u0026lt; 4; i++){ pArr[i] = new int[8]; } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ if(j == 0) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pArr[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; } } // 删除 for(int i = 0; i \u0026lt; 4; ++i){ delete [] pArr[i]; } delete [] pArr; #endif  // 方式二：  cout \u0026lt;\u0026lt; sizeof(int[5]) \u0026lt;\u0026lt; endl; // 初始化  int(*pArr)[8] = new int[4][8]; memset(pArr, 0, sizeof(int[4][8])); // 或者  // int(*pArr)[8] = new int[4][8]{{0}};  cout \u0026lt;\u0026lt; sizeof(int[4][8]) \u0026lt;\u0026lt; endl; for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ pArr[i][j] = i * j; } } for(int i = 0; i \u0026lt; 4; ++i){ for(int j = 0; j \u0026lt; 8; ++j){ cout \u0026lt;\u0026lt; pArr[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; } cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; delete[] pArr; // 取地址  int arr[3][4]{{0}}; int(*p)[3][4] = \u0026amp;arr; cout \u0026lt;\u0026lt; arr[2][3] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p[2][3] \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"new 二维数组"},{"content":"1. this指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用该成员函数的对象的首地址\n 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值 this 是个右值，所以不能取 this 的地址  2. delete this  类的成员函数中可以调用 delete this，但是在释放后，对象后续调用的方法不能再用到 this 指针 delete this 释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，此时其中的值是不确定的 delete 的本质是为将被释放的内存调用一个或多个析构函数，如果在类的析构函数中调用 delete this，会陷入无限递归，造成栈溢出  3. 一个空类class中有什么？ 构造函数、拷贝构造函数、析构函数、赋值运算符重载、取地址操作符重载、被 const 修饰的取地址操作符重载\n4. C++ 计算一个类的 sizeof  一个空的类 sizeof 返回 1，因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址 类内的普通成员函数不参与 sizeof 的统计，因为 sizeof 是针对实例的，而普通成员函数，是针对类体的 一个类如果含有虚函数，则这个类中有一个指向虚函数表的指针（虚函数指针），32位程序占4个字节，64位程序占8个字节 静态成员不影响类的大小，被编译器放在程序的数据段中 普通继承的类sizeof，会得到基类的大小加上派生类自身成员的大小 当存在虚拟继承时，派生类中会有一个指向虚基类表的指针。所以其大小应为普通继承的大小，再加上虚基类表的指针大小  5. 构造函数和析构函数能被继承吗? 不能。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么\n6. 构造函数能不能是虚函数？ 不能。虚函数对应一个虚函数表，可是这个虚函数表存储在对象的内存空间的。问题就在于，如果构造函数是虚的，就需要通过 虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，就不会有虚函数表\n7. 构造函数和析构函数能不能被重载？ 构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数。\n8. 构造函数调用顺序，析构函数调用顺序？ 基类的构造函数——\u0026gt;成员类对象的构造函数——\u0026gt;派生类的构造函数；\n析构函数相反：派生类析构——\u0026gt;成员类对象析构——\u0026gt;基类析构\n9. 构造函数和析构函数调用时机  全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数 局部自动对象：建立对象时调用构造函数，函数结束时调用析构函数 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数 静态局部变量对象：建立对象时调用构造函数，在主函数结束时调用析构函数  10. 拷贝构造函数中深拷贝和浅拷贝区别  深拷贝会先申请一块和拷贝数据一样大的内存空间，然后将数据逐字节拷贝过去，拷贝后两个指针指向不同的两个内存空间 浅拷贝仅是拷贝指针地址，拷贝后两个指针指向同一个内存空间\n当浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针，因为所指向的内存空间已经被释放了  11. 什么时候必须重写拷贝构造函数？ 当构造函数涉及到动态内存分配时，要自己写拷贝构造函数，并且要深拷贝\n12. 面向过程编程和面向对象编程的区别  面向过程：就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现（函数驱动） 面向对象：面向对象是一种对现实世界理解和抽象的方法，强调的是通过将需求要素转化为对象进行问题处理的一种思想（对象驱动）  13. 为什么内联函数，构造函数，静态成员函数不能为virtual函数？  内联函数：内联函数是在编译时期展开，而虚函数的特性是运行时才动态联编，所以两者矛盾，不能定义内联函数为虚函数 构造函数：构造函数用来创建一个新的对象，而虚函数的运行是建立在对象的基础上，在构造函数执行时，对象尚未形成，所以不能将构造函数定义为虚函数 静态成员函数：静态成员函数属于一个类而非某一对象，没有this指针，它无法进行对象的判别 友元函数：C++不支持友元函数的继承，对于没有继承性的函数没有虚函数  ","permalink":"https://874656645.github.io/posts/51-%E7%B1%BB%E5%85%B6%E5%AE%83%E6%80%BB%E7%BB%93/","summary":"1. this指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用该成员函数的对象的首地址\n 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值 this 是个右值，所以不能取 this 的地址  2. delete this  类的成员函数中可以调用 delete this，但是在释放后，对象后续调用的方法不能再用到 this 指针 delete this 释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，此时其中的值是不确定的 delete 的本质是为将被释放的内存调用一个或多个析构函数，如果在类的析构函数中调用 delete this，会陷入无限递归，造成栈溢出  3. 一个空类class中有什么？ 构造函数、拷贝构造函数、析构函数、赋值运算符重载、取地址操作符重载、被 const 修饰的取地址操作符重载\n4. C++ 计算一个类的 sizeof  一个空的类 sizeof 返回 1，因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址 类内的普通成员函数不参与 sizeof 的统计，因为 sizeof 是针对实例的，而普通成员函数，是针对类体的 一个类如果含有虚函数，则这个类中有一个指向虚函数表的指针（虚函数指针），32位程序占4个字节，64位程序占8个字节 静态成员不影响类的大小，被编译器放在程序的数据段中 普通继承的类sizeof，会得到基类的大小加上派生类自身成员的大小 当存在虚拟继承时，派生类中会有一个指向虚基类表的指针。所以其大小应为普通继承的大小，再加上虚基类表的指针大小  5. 构造函数和析构函数能被继承吗? 不能。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么\n6. 构造函数能不能是虚函数？ 不能。虚函数对应一个虚函数表，可是这个虚函数表存储在对象的内存空间的。问题就在于，如果构造函数是虚的，就需要通过 虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，就不会有虚函数表","title":"类其它总结"},{"content":" 构造函数可以互调，但不能在函数体内，只能通过初始化列表的形式 构造函数中不要写业务逻辑 析构函数中不要 delete this ，这会导致析构递归，最终导致栈溢出  class Test{ public: Test(int a, int b, int c){ _a = a; _b = b; _c = c; } // 正确  Test(int a, int b):Test(a, b, 100){ } /* // 错误 Test(int a, int b){ _a = a; _b = b; Test(a, b, 100); // 此处只是产生一个临时对象，马上又被释放掉了，没有任何意义 } */ int getA(){ return _a; } int getB(){ return _b; } int getC(){ return _c; } private: int _a; int _b; int _c; }; int main( ) { Test t1(10, 20); cout \u0026lt;\u0026lt; t1.getA() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; t1.getB() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; t1.getC() \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 10 20 100 0 Finish ","permalink":"https://874656645.github.io/posts/50-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BA%92%E8%B0%83/","summary":"构造函数可以互调，但不能在函数体内，只能通过初始化列表的形式 构造函数中不要写业务逻辑 析构函数中不要 delete this ，这会导致析构递归，最终导致栈溢出  class Test{ public: Test(int a, int b, int c){ _a = a; _b = b; _c = c; } // 正确  Test(int a, int b):Test(a, b, 100){ } /* // 错误 Test(int a, int b){ _a = a; _b = b; Test(a, b, 100); // 此处只是产生一个临时对象，马上又被释放掉了，没有任何意义 } */ int getA(){ return _a; } int getB(){ return _b; } int getC(){ return _c; } private: int _a; int _b; int _c; }; int main( ) { Test t1(10, 20); cout \u0026lt;\u0026lt; t1.","title":"构造函数重载与互调"},{"content":"思路是借助类的静态成员函数\n方式一：\nclass A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void setCur(){ s_curA = this; } static void callback(){ s_curA-\u0026gt;print(); } private: static A* s_curA; int m_a; }; A* A::s_curA = nullptr; typedef void (*FUN_S)(); void Handle(FUN_S call){ call(); } int main( ) { A a(10), b(20); a.setCur(); Handle(A::callback); b.setCur(); Handle(A::callback); return 0; } 方式二：\nclass A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } static void callback(void *a){ ((A*)a)-\u0026gt;print(); } private: int m_a; }; typedef void (*FUN)(void *); void Handle(void *a, FUN call){ call(a); } int main( ) { A a(10), b(20); Handle(\u0026amp;a, A::callback); Handle(\u0026amp;b, A::callback); return 0; } 输出：\nStart m_a = 10 m_a = 20 0 Finish 还可以进一步封装：\ntypedef void (*FUN_S)(); void Handle(FUN_S call){ cout \u0026lt;\u0026lt; \u0026#34;Handle(FUN_S) begin...\u0026#34; \u0026lt;\u0026lt; endl; call(); cout \u0026lt;\u0026lt; \u0026#34;Handle(FUN_S) end...\u0026#34; \u0026lt;\u0026lt; endl; } typedef void (*FUN)(void *); void Handle(void *a, FUN call){ cout \u0026lt;\u0026lt; \u0026#34;Handle(void *, FUN) begin...\u0026#34; \u0026lt;\u0026lt; endl; call(a); cout \u0026lt;\u0026lt; \u0026#34;Handle(void *, FUN) end...\u0026#34; \u0026lt;\u0026lt; endl; } class A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void setCur(){ s_curA = this; } void startup(){ setCur(); Handle(A::callback); } void startup(int){ Handle(this, A::callback); } static void callback(){ s_curA-\u0026gt;print(); } static void callback(void *a){ ((A*)a)-\u0026gt;print(); } private: static A* s_curA; int m_a; }; A* A::s_curA = nullptr; int main( ) { A a(10), b(20); a.startup(); b.startup(); cout \u0026lt;\u0026lt; \u0026#34;======================================\u0026#34; \u0026lt;\u0026lt; endl; a.startup(1); b.startup(1); return 0; } 输出：\nStart Handle(FUN_S) begin... m_a = 10 Handle(FUN_S) end... Handle(FUN_S) begin... m_a = 20 Handle(FUN_S) end... ====================================== Handle(void *, FUN) begin... m_a = 10 Handle(void *, FUN) end... Handle(void *, FUN) begin... m_a = 20 Handle(void *, FUN) end... 0 Finish ","permalink":"https://874656645.github.io/posts/49-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","summary":"思路是借助类的静态成员函数\n方式一：\nclass A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void setCur(){ s_curA = this; } static void callback(){ s_curA-\u0026gt;print(); } private: static A* s_curA; int m_a; }; A* A::s_curA = nullptr; typedef void (*FUN_S)(); void Handle(FUN_S call){ call(); } int main( ) { A a(10), b(20); a.setCur(); Handle(A::callback); b.setCur(); Handle(A::callback); return 0; } 方式二：\nclass A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } static void callback(void *a){ ((A*)a)-\u0026gt;print(); } private: int m_a; }; typedef void (*FUN)(void *); void Handle(void *a, FUN call){ call(a); } int main( ) { A a(10), b(20); Handle(\u0026amp;a, A::callback); Handle(\u0026amp;b, A::callback); return 0; } 输出：","title":"类的成员函数作为回调函数"},{"content":" 父类指针可以new子类对象，子类指针不可以new父类对象，但是可以接收强转的已经存在的父类指针 父类指针指向本类对象，调用的虚函数和普通函数都是自己的 将子类指针指向父类对象，虚函数执行的是父类的，也可以调用子类函数（这种操作是错误的，编译会报错，虽然可通过指针强转，但是不建议这样做，可能会导致未知错误） 父类指针指向子类对象，虚函数执行的是子类的，并且不能调用子类的函数 父类指针与子类指针之间赋值可以理解为指针所指内容的一种浅拷贝\nFather *f = (Father*)Child * 子类的虚函数指针覆盖父类的，并且子类特有的函数指针不会拷贝过去\nChild *c = (Child*)new Father父类的虚函数指针覆盖子类的，同时也有子类特有的函数指针  class A{ public: void printA(){ cout \u0026lt;\u0026lt; \u0026#34;printA()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void print(){ cout \u0026lt;\u0026lt; \u0026#34;A::print()\u0026#34; \u0026lt;\u0026lt; endl; } }; class B:public A{ public: void printB(){ cout \u0026lt;\u0026lt; \u0026#34;printB()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void print() override{ cout \u0026lt;\u0026lt; \u0026#34;B::print() b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } private: int b; }; int main( ) { // 1、指向自己的类对象（将父类对象赋值给父类指针）  A *a = new A; // 1.1 调用自己的函数  a-\u0026gt;printA(); // printA()  // 1.2 调用虚函数  a-\u0026gt;print(); // A::print()  // 2、将指向父类的父类指针强转为子类指针（将父类对象赋值给子类指针）  // b = new A; // error: incompatible pointer types assigning to \u0026#39;B *\u0026#39; from \u0026#39;A *\u0026#39;  B *b = (B*)new A; // 2.1 调用父类函数  b-\u0026gt;printA(); // printA()  // 2.2 调用虚函数（执行父类的）  b-\u0026gt;print(); // A::print() 调用父类的  // 2.3 可以调用子类函数  b-\u0026gt;printB(); // printB() b = 0  // 3、将子类对象赋值给父类指针  a = new B; // 3.1 调用父类函数  a-\u0026gt;printA(); // printA()  // 3.2 调用子类的函数  // a-\u0026gt;printB(); // error: no member named \u0026#39;printB\u0026#39; in \u0026#39;A\u0026#39;; did you mean \u0026#39;printA\u0026#39;?  // 3.3 调用虚函数（执行子类的）  a-\u0026gt;print(); // B::print() b = 0  // 4、指向子类对象的子类指针强转为父类指针（效果等同情况3）  b = new B; a = (A*)b; a-\u0026gt;printA(); // printA()  //a-\u0026gt;printB(); // error: no member named \u0026#39;printB\u0026#39; in \u0026#39;A\u0026#39;  a-\u0026gt;print(); // B::print() b = 0  return 0; } ","permalink":"https://874656645.github.io/posts/48-%E7%B1%BB%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8E%9F%E5%88%99/","summary":"父类指针可以new子类对象，子类指针不可以new父类对象，但是可以接收强转的已经存在的父类指针 父类指针指向本类对象，调用的虚函数和普通函数都是自己的 将子类指针指向父类对象，虚函数执行的是父类的，也可以调用子类函数（这种操作是错误的，编译会报错，虽然可通过指针强转，但是不建议这样做，可能会导致未知错误） 父类指针指向子类对象，虚函数执行的是子类的，并且不能调用子类的函数 父类指针与子类指针之间赋值可以理解为指针所指内容的一种浅拷贝\nFather *f = (Father*)Child * 子类的虚函数指针覆盖父类的，并且子类特有的函数指针不会拷贝过去\nChild *c = (Child*)new Father父类的虚函数指针覆盖子类的，同时也有子类特有的函数指针  class A{ public: void printA(){ cout \u0026lt;\u0026lt; \u0026#34;printA()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void print(){ cout \u0026lt;\u0026lt; \u0026#34;A::print()\u0026#34; \u0026lt;\u0026lt; endl; } }; class B:public A{ public: void printB(){ cout \u0026lt;\u0026lt; \u0026#34;printB()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void print() override{ cout \u0026lt;\u0026lt; \u0026#34;B::print() b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } private: int b; }; int main( ) { // 1、指向自己的类对象（将父类对象赋值给父类指针）  A *a = new A; // 1.","title":"类的兼容性原则"},{"content":" 如果类的内部没有专门创建实例的代码，则是无法创建任何实例的 如果父类构造函数设置成了私有的，则子类无法编译，因为在初始化子类时会先执行父类的构造  class A{ public: private: A(int ){ } }; class B:public A{ public: int x; }; int main( ) { B b; b.x = 0; return 0; } 输出：\nStart prog.cc:19:7: error: call to implicitly-deleted default constructor of \u0026#39;B\u0026#39; B b; ^ prog.cc:13:9: note: default constructor of \u0026#39;B\u0026#39; is implicitly deleted because base class \u0026#39;A\u0026#39; has an inaccessible default constructor class B:public A{ ^ 1 error generated. 1 Finish ","permalink":"https://874656645.github.io/posts/47-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%A7%81%E6%9C%89/","summary":" 如果类的内部没有专门创建实例的代码，则是无法创建任何实例的 如果父类构造函数设置成了私有的，则子类无法编译，因为在初始化子类时会先执行父类的构造  class A{ public: private: A(int ){ } }; class B:public A{ public: int x; }; int main( ) { B b; b.x = 0; return 0; } 输出：\nStart prog.cc:19:7: error: call to implicitly-deleted default constructor of \u0026#39;B\u0026#39; B b; ^ prog.cc:13:9: note: default constructor of \u0026#39;B\u0026#39; is implicitly deleted because base class \u0026#39;A\u0026#39; has an inaccessible default constructor class B:public A{ ^ 1 error generated. 1 Finish ","title":"构造函数私有"},{"content":"一、只能在堆上 方法：将析构函数设置为私有\n原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象\nclass Test { public: void printT(){ cout \u0026lt;\u0026lt; \u0026#34;printT\u0026#34; \u0026lt;\u0026lt; endl; } void freeT(){ delete this; } private: ~Test(){ cout \u0026lt;\u0026lt; \u0026#34;~Test()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main( ) { // 不能在栈上创建对象  //Test t; // prog.cc:25:10: error: variable of type \u0026#39;Test\u0026#39; has private destructor  // 只能在堆上创建对象  Test *t = new Test; t-\u0026gt;printT(); // 销毁对象  t-\u0026gt;freeT(); return 0; } 输出：\nStart printT ~Test() 0 Finish 二、只能在栈上 方法：将 new 和 delete 重载为私有\n原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象\n","permalink":"https://874656645.github.io/posts/46-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/","summary":"一、只能在堆上 方法：将析构函数设置为私有\n原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象\nclass Test { public: void printT(){ cout \u0026lt;\u0026lt; \u0026#34;printT\u0026#34; \u0026lt;\u0026lt; endl; } void freeT(){ delete this; } private: ~Test(){ cout \u0026lt;\u0026lt; \u0026#34;~Test()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main( ) { // 不能在栈上创建对象  //Test t; // prog.cc:25:10: error: variable of type \u0026#39;Test\u0026#39; has private destructor  // 只能在堆上创建对象  Test *t = new Test; t-\u0026gt;printT(); // 销毁对象  t-\u0026gt;freeT(); return 0; } 输出：\nStart printT ~Test() 0 Finish 二、只能在栈上 方法：将 new 和 delete 重载为私有","title":"定义一个只能在堆上（栈上）生成对象的类"},{"content":" 抽象类：含有纯虚函数的类，不能实例化对象 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：\n1）所有成员都是 public，没有私有和受保护的非静态成员；\n2）没有定义任何构造函数；\n3）没有类内初始化；\n4）没有基类，也没有 virtual 函数  // 接口类 class A { virtual void printA() = 0; // 纯虚函数 }; // 抽象类 class AA:public A { public: // 覆写接口类的纯虚函数  void printA() override { cout \u0026lt;\u0026lt; \u0026#34;class AA printA()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void printAA() = 0; }; // 可实例化的类 class B:public AA { public: // 覆写父类（抽象类）的纯虚函数  void printAA() override { cout \u0026lt;\u0026lt; \u0026#34;class B printAA()\u0026#34; \u0026lt;\u0026lt; endl; } void printB() { cout \u0026lt;\u0026lt; \u0026#34;printB()\u0026#34; \u0026lt;\u0026lt; endl; } }; // 聚合类 class C { public: int x; int y; void print(){ cc(); } private: void cc(){ cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;, z = \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; } static int z; }; int C::z = 0; class D { public: int a; int b; C c; void print(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; c.print(); } }; int main( ) { B b; b.printA(); b.printB(); // 初始化聚合类  D d = {1, 2, {3, 4}}; d.print(); return 0; } 输出：\nStart class AA printA() class B printAA() printB() a = 1, b = 2 x = 3, y = 4, z = 0 0 Finish 既然有抽象类，为什么要用接口呢？\n 接口带来的最大好处就是避免了多继承带来的复杂性和低效性，并且同时可以提供多重继承的好处 抽象类对事物进行抽象，更多的是为了继承，为了扩展，为了实现代码的重用，子类和父类之间体现的是is-a关系 接口则更多的体现一种行为约束，一种规则，一旦实现了这个接口，就要给出这个接口中所有方法的具体实现，也就是说实现类对于接口中所有的方法都是有意义的 接口用于抽象事物的特性，抽象类用于代码复用  ","permalink":"https://874656645.github.io/posts/45-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E7%B1%BB%E8%81%9A%E5%90%88%E7%B1%BB/","summary":"抽象类：含有纯虚函数的类，不能实例化对象 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：\n1）所有成员都是 public，没有私有和受保护的非静态成员；\n2）没有定义任何构造函数；\n3）没有类内初始化；\n4）没有基类，也没有 virtual 函数  // 接口类 class A { virtual void printA() = 0; // 纯虚函数 }; // 抽象类 class AA:public A { public: // 覆写接口类的纯虚函数  void printA() override { cout \u0026lt;\u0026lt; \u0026#34;class AA printA()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void printAA() = 0; }; // 可实例化的类 class B:public AA { public: // 覆写父类（抽象类）的纯虚函数  void printAA() override { cout \u0026lt;\u0026lt; \u0026#34;class B printAA()\u0026#34; \u0026lt;\u0026lt; endl; } void printB() { cout \u0026lt;\u0026lt; \u0026#34;printB()\u0026#34; \u0026lt;\u0026lt; endl; } }; // 聚合类 class C { public: int x; int y; void print(){ cc(); } private: void cc(){ cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;, z = \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; } static int z; }; int C::z = 0; class D { public: int a; int b; C c; void print(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; c.","title":"抽象类、接口类、聚合类"},{"content":"虚继承和虚基类 参考\n 在C++中，在定义公共基类A的派生类B、C\u0026hellip;的时候，如果在继承方式前使用关键字virtual对继承方式限定，这样的继承方式就是虚拟继承，公共基类A成为虚基类。这样，在具有公共基类的、使用了虚拟继承方式的多个派生类B、C\u0026hellip;的公共派生类D中，该基类A的成员就只有一份拷贝 一个类有多个基类，这样的继承关系称为多继承。在多继承的情况下，如果不同基类的成员名称相同，匹配度相同, 则会造成二义性。为了避免多继承产生的二义性，在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 会在虚继承的类中生成一个指向虚基类的指针 {vbptr} 会在内存中生成一个虚基类表 D::$vbtable@B@  微软的Visual Studio提供给用户显示C++对象在内存中的布局的选项\ncl [filename].cpp /d1 reportSingleClassLayout[className]\n一般继承：\nclass A { public: int dataA; }; class B:public A { public: int dataB; }; class C:public A { public: int dataC; }; class D : public B, public C { public: int dataD; }; 输出：\nclass D size(20): +--- 0 | +--- (base class B) 0 | | +--- (base class A) 0 | | | dataA | | +--- 4 | | dataB | +--- 8 | +--- (base class C) 8 | | +--- (base class A) 8 | | | dataA | | +--- 12 | | dataC | +--- 16 | dataD +--- 调用：\nint main( ) { D d; cout \u0026lt;\u0026lt; d.dataA \u0026lt;\u0026lt; endl; return 0; } 调用输出：\nStart prog.cc:29:15: error: non-static member \u0026#39;dataA\u0026#39; found in multiple base-class subobjects of type \u0026#39;A\u0026#39;: class D -\u0026gt; class B -\u0026gt; class A class D -\u0026gt; class C -\u0026gt; class A cout \u0026lt;\u0026lt; d.dataA \u0026lt;\u0026lt; endl; ^ prog.cc:9:9: note: member found by ambiguous name lookup int dataA; ^ 1 error generated. 1 Finish 虚继承：\nclass A { public: int dataA; }; class B:virtual public A { public: int dataB; }; class C:virtual public A { public: int dataC; }; class D : public B, public C { public: int dataD; }; B 类输出：\nclass B size(12): +--- 0 | {vbptr} 4 | dataB +--- +--- (virtual base A) 8 | dataA +--- B::$vbtable@: 0 | 0 1 | 8 (Bd(B+0)A) vbi: class offset o.vbptr o.vbte fVtorDisp A 8 0 4 0 C 类输出：\nclass C size(12): +--- 0 | {vbptr} 4 | dataC +--- +--- (virtual base A) 8 | dataA +--- C::$vbtable@: 0 | 0 1 | 8 (Cd(C+0)A) vbi: class offset o.vbptr o.vbte fVtorDisp A 8 0 4 0 D 类输出：\nclass D size(24): +--- 0 | +--- (base class B) 0 | | {vbptr} 4 | | dataB | +--- 8 | +--- (base class C) 8 | | {vbptr} 12 | | dataC | +--- 16 | dataD +--- +--- (virtual base A) 20 | dataA +--- D::$vbtable@B@: 0 | 0 1 | 20 (Dd(B+0)A) D::$vbtable@C@: 0 | 0 1 | 12 (Dd(C+0)A) vbi: class offset o.vbptr o.vbte fVtorDisp A 20 0 4 0 ","permalink":"https://874656645.github.io/posts/44-%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB/","summary":"虚继承和虚基类 参考\n 在C++中，在定义公共基类A的派生类B、C\u0026hellip;的时候，如果在继承方式前使用关键字virtual对继承方式限定，这样的继承方式就是虚拟继承，公共基类A成为虚基类。这样，在具有公共基类的、使用了虚拟继承方式的多个派生类B、C\u0026hellip;的公共派生类D中，该基类A的成员就只有一份拷贝 一个类有多个基类，这样的继承关系称为多继承。在多继承的情况下，如果不同基类的成员名称相同，匹配度相同, 则会造成二义性。为了避免多继承产生的二义性，在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 会在虚继承的类中生成一个指向虚基类的指针 {vbptr} 会在内存中生成一个虚基类表 D::$vbtable@B@  微软的Visual Studio提供给用户显示C++对象在内存中的布局的选项\ncl [filename].cpp /d1 reportSingleClassLayout[className]\n一般继承：\nclass A { public: int dataA; }; class B:public A { public: int dataB; }; class C:public A { public: int dataC; }; class D : public B, public C { public: int dataD; }; 输出：\nclass D size(20): +--- 0 | +--- (base class B) 0 | | +--- (base class A) 0 | | | dataA | | +--- 4 | | dataB | +--- 8 | +--- (base class C) 8 | | +--- (base class A) 8 | | | dataA | | +--- 12 | | dataC | +--- 16 | dataD +--- 调用：","title":"虚继承和虚基类"},{"content":"1. C++ 多态分类及实现  重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载（静态多态、静态编译） 子类多态（Subtype Polymorphism，运行期）：虚函数（动态多态、动态编译） 参数多态（Parametric Polymorphism，编译期）：类模板（泛型）、函数模板（函数指针） 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换  2. 虚表指针、虚函数指针、虚函数表  虚表指针：在含有虚函数的类的对象中，指向虚函数表的指针，在运行时确定 虚函数指针：指向虚函数的地址的指针 {vfptr} 虚函数表：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚函数表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建 Shape::$vftable@  class Shape { public: virtual ~Shape(){ cout \u0026lt;\u0026lt; \u0026#34;~Shape()\u0026#34; \u0026lt;\u0026lt; endl; } }; class Point { public: ~Point(){ cout \u0026lt;\u0026lt; \u0026#34;~Point()\u0026#34; \u0026lt;\u0026lt; endl; } private: int m_x{0}; int m_y{0}; char m_c; }; class Circle : public Shape { public: ~Circle(){ cout \u0026lt;\u0026lt; \u0026#34;~Circle()\u0026#34; \u0026lt;\u0026lt; endl; } private: Point m_p; }; int main( ) { // 8 类中存有指向虚函数表的指针  cout \u0026lt;\u0026lt; sizeof(Shape) \u0026lt;\u0026lt; endl; // 16 类中存有指向虚函数表的指针  // 以及Point对象的大小（此时Point类中不包含任何变量），虽然真实大小是 8 + 1  // 但是额外多的1个字节导致内存大小扩增了 8(每次扩增的最小数值是8 \u0026lt;alignment member\u0026gt; (size=7))  cout \u0026lt;\u0026lt; sizeof(Circle) \u0026lt;\u0026lt; endl; // 8 类中的int占4个字节，char占1个字节  // 但每次扩增的最小数值是4(\u0026lt;alignment member\u0026gt; (size=3))  cout \u0026lt;\u0026lt; sizeof(Point) \u0026lt;\u0026lt; endl; Circle c; return 0; } Start 8 24 12 ~Circle() ~Point() ~Shape() 0 Finish Shape 类\n// 没有虚函数 class Shape size(1): +--- +--- // 有虚析构函数 class Shape size(8): +--- 0 | {vfptr} +--- Shape::$vftable@: | \u0026amp;Shape_meta | 0 0 | \u0026amp;Shape::{dtor} Shape::{dtor} this adjustor: 0 Shape::__delDtor this adjustor: 0 Shape::__vecDelDtor this adjustor: 0 Point 类\nclass Point size(8): +--- 0 | m_x 4 | m_y 8 | m_c | \u0026lt;alignment member\u0026gt; (size=3) +--- Circle 类\nclass Circle size(24): +--- 0 | +--- (base class Shape) 0 | | {vfptr} | +--- 8 | Point m_p | \u0026lt;alignment member\u0026gt; (size=4) +--- Circle::$vftable@: | \u0026amp;Circle_meta | 0 0 | \u0026amp;Circle::{dtor} Circle::{dtor} this adjustor: 0 Circle::__delDtor this adjustor: 0 Circle::__vecDelDtor this adjustor: 0 ","permalink":"https://874656645.github.io/posts/43-%E5%A4%9A%E6%80%81%E6%80%BB%E7%BB%93/","summary":"1. C++ 多态分类及实现  重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载（静态多态、静态编译） 子类多态（Subtype Polymorphism，运行期）：虚函数（动态多态、动态编译） 参数多态（Parametric Polymorphism，编译期）：类模板（泛型）、函数模板（函数指针） 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换  2. 虚表指针、虚函数指针、虚函数表  虚表指针：在含有虚函数的类的对象中，指向虚函数表的指针，在运行时确定 虚函数指针：指向虚函数的地址的指针 {vfptr} 虚函数表：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚函数表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建 Shape::$vftable@  class Shape { public: virtual ~Shape(){ cout \u0026lt;\u0026lt; \u0026#34;~Shape()\u0026#34; \u0026lt;\u0026lt; endl; } }; class Point { public: ~Point(){ cout \u0026lt;\u0026lt; \u0026#34;~Point()\u0026#34; \u0026lt;\u0026lt; endl; } private: int m_x{0}; int m_y{0}; char m_c; }; class Circle : public Shape { public: ~Circle(){ cout \u0026lt;\u0026lt; \u0026#34;~Circle()\u0026#34; \u0026lt;\u0026lt; endl; } private: Point m_p; }; int main( ) { // 8 类中存有指向虚函数表的指针  cout \u0026lt;\u0026lt; sizeof(Shape) \u0026lt;\u0026lt; endl; // 16 类中存有指向虚函数表的指针  // 以及Point对象的大小（此时Point类中不包含任何变量），虽然真实大小是 8 + 1  // 但是额外多的1个字节导致内存大小扩增了 8(每次扩增的最小数值是8 \u0026lt;alignment member\u0026gt; (size=7))  cout \u0026lt;\u0026lt; sizeof(Circle) \u0026lt;\u0026lt; endl; // 8 类中的int占4个字节，char占1个字节  // 但每次扩增的最小数值是4(\u0026lt;alignment member\u0026gt; (size=3))  cout \u0026lt;\u0026lt; sizeof(Point) \u0026lt;\u0026lt; endl; Circle c; return 0; } Start 8 24 12 ~Circle() ~Point() ~Shape() 0 Finish Shape 类","title":"多态总结"},{"content":"1. 函数默认参数和占位参数（亚元） 形参中的占位参数又叫亚元，并没有什么实际意义，只在函数重载中起到作用\n// 亚元，设置了默认值所以调用时可以不传参数 // 否则就必须传入两个参数 void foo(int a, int = 0){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } int main() { foo(20); return 0; } 2. 函数重载  函数名相同，形参列表不同（形参个数、类型、顺序） 函数返回值不起作用 函数重载和默认参数不要同时使用（函数调用时容易产生二义性） 倾轧技术（name mangling），底层会将函数名进行编译  用 v c i f l d 表示 void char int float long double 及其引用 int fun(int) =\u0026gt; fun_i\nint fun(int, char, double) =\u0026gt; fun_icd   重载函数匹配顺序  如果能够严格匹配，则调用完全匹配的 如果没有完全匹配的，则调用隐式转换的 都匹配不上，编译失败    3. 函数指针 int test(int a, int b){ cout \u0026lt;\u0026lt; \u0026#34;test(\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; return 0; } // 方式一： typedef int(FUN)(int, int); // 方式二： typedef int(*FUN_P)(int, int); int main() { // 方式一：  FUN *f1 = NULL; f1 = test; f1(10, 20); (*f1)(10, 20); // 方式二：  FUN_P f2 = NULL; f2 = test; f2(10, 20); // 方式三：  int (*f3)(int, int) = NULL; f3 = test; f3(10, 20); return 0; } 输出：\nStart test(10, 20) test(10, 20) test(10, 20) test(10, 20) 0 Finish ","permalink":"https://874656645.github.io/posts/42-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%92%8C%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0/","summary":"1. 函数默认参数和占位参数（亚元） 形参中的占位参数又叫亚元，并没有什么实际意义，只在函数重载中起到作用\n// 亚元，设置了默认值所以调用时可以不传参数 // 否则就必须传入两个参数 void foo(int a, int = 0){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } int main() { foo(20); return 0; } 2. 函数重载  函数名相同，形参列表不同（形参个数、类型、顺序） 函数返回值不起作用 函数重载和默认参数不要同时使用（函数调用时容易产生二义性） 倾轧技术（name mangling），底层会将函数名进行编译  用 v c i f l d 表示 void char int float long double 及其引用 int fun(int) =\u0026gt; fun_i\nint fun(int, char, double) =\u0026gt; fun_icd   重载函数匹配顺序  如果能够严格匹配，则调用完全匹配的 如果没有完全匹配的，则调用隐式转换的 都匹配不上，编译失败    3.","title":"函数默认参数和占位参数"},{"content":"一、程序运行前  代码区（只读的、共享） 数据区（全局变量和静态变量）  二、程序运行后  栈区 堆区 全局静态区（全局变量、静态变量、常量） 代码区  Linux程序运行内存虚拟地址空间：\n三、全局变量与静态变量的区别 作用域不同\n全局变量默认是 extern 的\n静态变量是文件作用域\nC/C++ 中 extern 关键字详解\n","permalink":"https://874656645.github.io/posts/41-%E5%86%85%E5%AD%98%E5%8C%BA%E9%97%B4%E5%88%92%E5%88%86/","summary":"一、程序运行前  代码区（只读的、共享） 数据区（全局变量和静态变量）  二、程序运行后  栈区 堆区 全局静态区（全局变量、静态变量、常量） 代码区  Linux程序运行内存虚拟地址空间：\n三、全局变量与静态变量的区别 作用域不同\n全局变量默认是 extern 的\n静态变量是文件作用域\nC/C++ 中 extern 关键字详解","title":"内存区间划分"},{"content":" 指针也是一种变量，作为函数形参和返回值的时候也是值拷贝（拷贝的是一个地址） 使用指针引用的方式，代码更加简洁，逻辑更加清晰 释放掉指针指向的空间后，一定记得把指针置空 声明指针时就进行初始化或将其指向 NULL 是个好习惯  指针值拷贝：\nvoid test(int * a){ a = new int(20); //*a = 20;  cout \u0026lt;\u0026lt; \u0026#34;test point a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;test:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; } int main() { int *a = new int(10); cout \u0026lt;\u0026lt; \u0026#34;main point a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;main:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; test(a); cout \u0026lt;\u0026lt; \u0026#34;main:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart main point a = 0x7ffea2597be0 main:0x195d010\ta = 10 test point a = 0x7ffea2597ba8 test:0x195e040\ta = 20 main:0x195d010\ta = 10 0 Finish struct teacher{ char name[64]; int id; }; // 方式一： // 如果想要在函数内部实现指针内存分配 // 就只能用二级指针的形参 int getTT(struct teacher ** tpp){ struct teacher *tp = (struct teacher *)malloc(sizeof(struct teacher)); if(tp == NULL){ return -1; } tp-\u0026gt;id = 100; strcpy(tp-\u0026gt;name, \u0026#34;zhang3\u0026#34;); *tpp = tp; return 0; } // 如果是想释放指针，也可以用一级指针 void freeTT(struct teacher **tpp){ if(tpp == NULL){ return; } if(*tpp != NULL){ free(*tpp); *tpp = NULL; } } void freeTT(struct teacher *tpp){ if(tpp == NULL){ return; } if(tpp != NULL){ free(tpp); // 此处的tpp是一个指针复本，置空没有效果  // 所以只能在外部将指针置空  tpp = NULL; } } // 方式二： // 指针引用的方式，更加简洁 int getT(struct teacher *\u0026amp; tp){ tp = (struct teacher *)malloc(sizeof(struct teacher)); if(tp == NULL){ return -1; } tp-\u0026gt;id = 100; strcpy(tp-\u0026gt;name, \u0026#34;zhang3\u0026#34;); return 0; } void freeT(struct teacher *\u0026amp; tp){ if(tp == NULL){ return; } free(tp); tp = NULL; } int main() { struct teacher *tp = NULL; // 1、利用二级指针  //getTT(\u0026amp;tp);  // 2、利用指针引用  getT(tp); cout \u0026lt;\u0026lt; tp-\u0026gt;id \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tp-\u0026gt;name \u0026lt;\u0026lt; endl; //freeTT(\u0026amp;tp);  freeT(tp); cout \u0026lt;\u0026lt; \u0026#34;==========================\u0026#34; \u0026lt;\u0026lt; endl; if(tp == NULL){ cout \u0026lt;\u0026lt; \u0026#34;free ok\u0026#34; \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; tp-\u0026gt;id \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tp-\u0026gt;name \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 100 zhang3 ========================== free ok 0 Finish ","permalink":"https://874656645.github.io/posts/40-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/","summary":"指针也是一种变量，作为函数形参和返回值的时候也是值拷贝（拷贝的是一个地址） 使用指针引用的方式，代码更加简洁，逻辑更加清晰 释放掉指针指向的空间后，一定记得把指针置空 声明指针时就进行初始化或将其指向 NULL 是个好习惯  指针值拷贝：\nvoid test(int * a){ a = new int(20); //*a = 20;  cout \u0026lt;\u0026lt; \u0026#34;test point a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;test:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; } int main() { int *a = new int(10); cout \u0026lt;\u0026lt; \u0026#34;main point a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;main:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; test(a); cout \u0026lt;\u0026lt; \u0026#34;main:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\ta = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"指针引用"},{"content":"一、抽象、封装 数据抽象：是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制，是一种依赖于接口实现分离的设计技术\n数据封装：是一种把数据和操作数据的函数捆绑在一起的机制\n1. 好处  类的内部受到保护，不会因无意的用户级错误导致对象状态受损 类实现可能随着时间的推移而发生变化，数据抽象可以更好的应对不断变化的需求  2. 策略  通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。 抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可  3. 接口 接口描述了类的行为和功能，而不需要完成类的特定实现。如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类\n设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n可用于实例化对象的类被称为具体类\n接口的好处实现了解耦合的作用。 可以将软件架构分为业务逻辑层、抽象层和实现层\n二、继承 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。类派生列表以一个或多个基类命名\n派生类可以访问基类中所有的非私有成员，同时，一个派生类继承了所有的基类方法，但下列情况除外：\n 基类的构造函数、析构函数和拷贝构造函数 基类的重载运算符 基类的友元函数  三、多态 虚函数：虚函数是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链编到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链编，或后期绑定。\n 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数 一般要将父类的析构函数设置为虚函数，如果不把父类的析构函数设置为虚函数，在 delete 父类指针时就不会调用子类的析构了 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数 若在基类中不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数，在函数参数后直接加 = 0 告诉编译器，函数没有主体，这种虚函数即是纯虚函数  测试类：\n// 基类 Shape class Shape { protected: int width, height; public: Shape(int a = 0, int b = 0) { width = a; height = b; } virtual ~Shape() { cout \u0026lt;\u0026lt; \u0026#34;Shape destructor\u0026#34; \u0026lt;\u0026lt; endl; } // pure virtual function  virtual int area() = 0; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { auto res = area * 70; cout \u0026lt;\u0026lt; \u0026#34;PaintCost: \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return res; } }; class Rectangle: public Shape, public PaintCost { public: Rectangle(int a = 0, int b = 0):Shape(a, b) { } ~Rectangle() { cout \u0026lt;\u0026lt; \u0026#34;Rectangle destructor\u0026#34; \u0026lt;\u0026lt; endl; } void printPro() { // 访问父类的成员变量（不能访问父类的私有成员）  cout \u0026lt;\u0026lt; \u0026#34;width: \u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34;\\theight: \u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; endl; } int area () { auto area = width * height; cout \u0026lt;\u0026lt; \u0026#34;Rectangle class area: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt;endl; return area; } }; class Triangle: public Shape { public: Triangle(int a = 0, int b = 0):Shape(a, b) { } ~Triangle() { cout \u0026lt;\u0026lt; \u0026#34;Triangle destructor\u0026#34; \u0026lt;\u0026lt; endl; } int area () { auto area = width * height / 2; cout \u0026lt;\u0026lt; \u0026#34;Triangle class area: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt;endl; return area; } }; 多继承：\nint main() { Rectangle rec(10, 20); rec.printPro(); // 调用父类函数  rec.getCost(10); return 0; } 输出：\nStart width: 10\theight: 20 PaintCost: 700 Rectangle destructor Shape destructor 0 Finish 多态：\nint main() { Shape *shape = new Rectangle(10, 7); Triangle tri(10,5); shape-\u0026gt;area(); //Rectangle class area  delete shape; shape = \u0026amp;tri; shape-\u0026gt;area(); //Triangle class area  // delete shape; // 这种指针不能 delete  return 0; } 输出：\nStart Rectangle class area: 70 Rectangle destructor Shape destructor Triangle class area: 25 Triangle destructor Shape destructor 0 Finish 实现多态的原因： 如果父类有 virtual 方法，编译器会创建一个虚函数表（在只读区），同时会在类中存储一个指向虚函数表的指针 VPTR，这个表也会被子类继承，如果子类中重写了父类的虚函数，就会在子类中覆盖所继承的虚函数表中的函数\n虚函数表指针是分步初始化的，在构建父类时指向的还是父类的虚函数表\nclass A{ public: A(){ cout \u0026lt;\u0026lt; \u0026#34;A()...\u0026#34; \u0026lt;\u0026lt; endl; print(); } virtual ~A(){ cout \u0026lt;\u0026lt; \u0026#34;~A()...\u0026#34; \u0026lt;\u0026lt; endl; print(); } virtual void print(){ cout \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; } }; class B : public A{ public: B(){ cout \u0026lt;\u0026lt; \u0026#34;B()...\u0026#34; \u0026lt;\u0026lt; endl; print(); } ~B(){ cout \u0026lt;\u0026lt; \u0026#34;~B()...\u0026#34; \u0026lt;\u0026lt; endl; print(); } virtual void print(){ cout \u0026lt;\u0026lt; \u0026#34;B\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { A *a = new B; delete a; return 0; } 输出：\nA()... A B()... B ~B()... B ~A()... A ","permalink":"https://874656645.github.io/posts/39-%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/","summary":"一、抽象、封装 数据抽象：是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制，是一种依赖于接口实现分离的设计技术\n数据封装：是一种把数据和操作数据的函数捆绑在一起的机制\n1. 好处  类的内部受到保护，不会因无意的用户级错误导致对象状态受损 类实现可能随着时间的推移而发生变化，数据抽象可以更好的应对不断变化的需求  2. 策略  通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。 抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可  3. 接口 接口描述了类的行为和功能，而不需要完成类的特定实现。如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类\n设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n可用于实例化对象的类被称为具体类\n接口的好处实现了解耦合的作用。 可以将软件架构分为业务逻辑层、抽象层和实现层\n二、继承 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。类派生列表以一个或多个基类命名\n派生类可以访问基类中所有的非私有成员，同时，一个派生类继承了所有的基类方法，但下列情况除外：\n 基类的构造函数、析构函数和拷贝构造函数 基类的重载运算符 基类的友元函数  三、多态 虚函数：虚函数是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链编到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链编，或后期绑定。\n 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数 一般要将父类的析构函数设置为虚函数，如果不把父类的析构函数设置为虚函数，在 delete 父类指针时就不会调用子类的析构了 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数 若在基类中不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数，在函数参数后直接加 = 0 告诉编译器，函数没有主体，这种虚函数即是纯虚函数  测试类：\n// 基类 Shape class Shape { protected: int width, height; public: Shape(int a = 0, int b = 0) { width = a; height = b; } virtual ~Shape() { cout \u0026lt;\u0026lt; \u0026#34;Shape destructor\u0026#34; \u0026lt;\u0026lt; endl; } // pure virtual function  virtual int area() = 0; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { auto res = area * 70; cout \u0026lt;\u0026lt; \u0026#34;PaintCost: \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return res; } }; class Rectangle: public Shape, public PaintCost { public: Rectangle(int a = 0, int b = 0):Shape(a, b) { } ~Rectangle() { cout \u0026lt;\u0026lt; \u0026#34;Rectangle destructor\u0026#34; \u0026lt;\u0026lt; endl; } void printPro() { // 访问父类的成员变量（不能访问父类的私有成员）  cout \u0026lt;\u0026lt; \u0026#34;width: \u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34;\\theight: \u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; endl; } int area () { auto area = width * height; cout \u0026lt;\u0026lt; \u0026#34;Rectangle class area: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt;endl; return area; } }; class Triangle: public Shape { public: Triangle(int a = 0, int b = 0):Shape(a, b) { } ~Triangle() { cout \u0026lt;\u0026lt; \u0026#34;Triangle destructor\u0026#34; \u0026lt;\u0026lt; endl; } int area () { auto area = width * height / 2; cout \u0026lt;\u0026lt; \u0026#34;Triangle class area: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt;endl; return area; } }; 多继承：","title":"抽象、封装、继承、多态"},{"content":" 使用 static 关键字来把类成员定义为静态的。静态成员在类的所有对象中是共享的，当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本 如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零 不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数） 普通成员函数有 this 指针，可以访问类中的任意成员；  class A { string name {\u0026#34;C++\u0026#34;}; int id {1024}; static int objCount; public: A(); friend void printA(const A \u0026amp;a); void printA(); static void printC(); }; // 静态成员类外初始化 int A::objCount = 0; A::A(){ objCount++; } void A::printA(){ cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;objCount \u0026lt;\u0026lt; \u0026#34;\\tname = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;id \u0026lt;\u0026lt; endl; } void A::printC(){ // 静态函数内没有this指针  cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; objCount \u0026lt;\u0026lt; endl; // error: \u0026#39;this\u0026#39; is unavailable for static member functions  // cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;objCount \u0026lt;\u0026lt; endl; } void printA(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; a.objCount \u0026lt;\u0026lt; \u0026#34;\\tname = \u0026#34; \u0026lt;\u0026lt; a.name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; a.id \u0026lt;\u0026lt; endl; } int main() { // 类静态成员函数  A::printC(); // 友员函数  A a; printA(a); // 成员函数  A b; b.printA(); return 0; } 输出：\nStart objCount = 0 objCount = 1\tname = C++\tid = 1024 objCount = 2\tname = C++\tid = 1024 0 Finish ","permalink":"https://874656645.github.io/posts/38-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/","summary":"使用 static 关键字来把类成员定义为静态的。静态成员在类的所有对象中是共享的，当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本 如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零 不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数） 普通成员函数有 this 指针，可以访问类中的任意成员；  class A { string name {\u0026#34;C++\u0026#34;}; int id {1024}; static int objCount; public: A(); friend void printA(const A \u0026amp;a); void printA(); static void printC(); }; // 静态成员类外初始化 int A::objCount = 0; A::A(){ objCount++; } void A::printA(){ cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;objCount \u0026lt;\u0026lt; \u0026#34;\\tname = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;id \u0026lt;\u0026lt; endl; } void A::printC(){ // 静态函数内没有this指针  cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; objCount \u0026lt;\u0026lt; endl; // error: \u0026#39;this\u0026#39; is unavailable for static member functions  // cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;objCount \u0026lt;\u0026lt; endl; } void printA(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;objCount = \u0026#34; \u0026lt;\u0026lt; a.","title":"类的静态成员"},{"content":"  友元利弊：\n友元不是类的成员但能访问类中的私有成员。友元的作用在于提高程序的运行效率，但也破坏了类的封装。\n  注意事项：\n（1）友元关系不能被继承；\n（2）友元关系是单向的，不具有交换性；\n（3）友元关系不具有传递性；\n  一、友元函数  类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员 尽管友元函数的原型有在类的定义中出现过，但是 友元函数并不是成员函数 this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针  1. 友元函数是全局函数\nclass A { friend void printA(const A \u0026amp;a); public: void printA(); private: string name {\u0026#34;C++\u0026#34;}; int id {1024}; }; void A::printA(){ cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;id \u0026lt;\u0026lt; endl; } // 请注意：printA() 不是任何类的成员函数 void printA(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; a.name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; a.id \u0026lt;\u0026lt; endl; } int main() { A a; printA(a); a.printA(); return 0; } 输出：\nStart name = C++\tid = 1024 name = C++\tid = 1024 0 Finish 2. 友元函数是类的成员方法\n小技巧：为了防止相互嵌套，可以将其中一个类的声明和实现拆开\nclass Point; class PointManager{ public: double getDistance(Point \u0026amp;p1, Point \u0026amp;p2); private: }; class Point{ friend double PointManager::getDistance(Point \u0026amp;p1, Point \u0026amp;p2); public: Point(int x, int y){ this-\u0026gt;x = x; this-\u0026gt;y = y; } private: int x; int y; }; double PointManager::getDistance(Point \u0026amp;p1, Point \u0026amp;p2){ int dx = p1.x - p2.x; int dy = p1.y - p2.y; return sqrt(dx * dx + dy * dy); } int main( ) { Point p1(1, 1), p2(3, 1); PointManager pm; cout \u0026lt;\u0026lt; pm.getDistance(p1, p2) \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 2 0 Finish 二、友元类 class A{ friend class B; // 将 B 声明为友元类后，在 B 中 A 就是透明的 public: A(int a){ this-\u0026gt;a = a; } void printA(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;a \u0026lt;\u0026lt; endl; } private: int a; }; class B{ public: B(int b){ this-\u0026gt;b = b; } void printB(){ A a(10); cout \u0026lt;\u0026lt; \u0026#34;print a in b: \u0026#34; \u0026lt;\u0026lt; a.a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;b \u0026lt;\u0026lt; endl; } private: int b; }; int main( ) { B b(-10); b.printB(); return 0; } Start print a in b: 10 b = -10 0 Finish ","permalink":"https://874656645.github.io/posts/37-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8B%E5%85%83%E7%B1%BB/","summary":"友元利弊：\n友元不是类的成员但能访问类中的私有成员。友元的作用在于提高程序的运行效率，但也破坏了类的封装。\n  注意事项：\n（1）友元关系不能被继承；\n（2）友元关系是单向的，不具有交换性；\n（3）友元关系不具有传递性；\n  一、友元函数  类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员 尽管友元函数的原型有在类的定义中出现过，但是 友元函数并不是成员函数 this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针  1. 友元函数是全局函数\nclass A { friend void printA(const A \u0026amp;a); public: void printA(); private: string name {\u0026#34;C++\u0026#34;}; int id {1024}; }; void A::printA(){ cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;\\tid = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;id \u0026lt;\u0026lt; endl; } // 请注意：printA() 不是任何类的成员函数 void printA(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; a.","title":"友元函数与友元类"},{"content":"结论：\n 拷贝构造函数是函数，赋值运算符是运算符的重载； 拷贝构造函数会生成新的类对象，赋值运算符不会； 拷贝构造函数是用一个已存在的对象去构造一个不存在的对象；而赋值运算符重载函数是用一个存在的对象去给另一个已存在并初始化过的对象进行赋值; 若接受返回值的对象已经初始化过，则会调用赋值运算符，且该对象还会调用析构函数，当对象中包含指针时，会使该指针失效，因此需要重载赋值运算符，使用类似深拷贝或移动构造函数的方法赋值，才能避免指针失效。 如果只有显示的构造函数，系统会提供默认的拷贝构造； 如果显示提供了拷贝构造，系统就不会提供默认的无参构造了，用户必需显示提供构造函数； 当既没有显式的构造函数，也没有拷贝构造时，系统才会提供默认的无参构造； 显示提供拷贝构造就必需显示提供构造函数； 显示提供赋值运算符重载就必需显示提供拷贝构造；  成员初始化列表  使用成员变量初始化列表，少了一次调用默认构造函数的过程，提高效率 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 成员变量初始化的顺序跟在初始化列表的顺序无关，与变量声明的顺序有关  测试类 class A { public: A(){ cout \u0026lt;\u0026lt; \u0026#34;default constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } A(int t){ x = new int(0); y = t; cout \u0026lt;\u0026lt; \u0026#34;second constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } A(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;const copy constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; this-\u0026gt;x = a.x; this-\u0026gt;y = a.y; } A\u0026amp; operator = (const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;const assignment constructor\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;x = a.x; this-\u0026gt;y = a.y; return *this; } ~A(){ cout \u0026lt;\u0026lt; \u0026#34;destructor delete \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; delete x; } public: int * x {nullptr}; int y{0}; }; A f(){ A ret(3); cout \u0026lt;\u0026lt; \u0026#34;stack f adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;ret \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; ret.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; ret.y \u0026lt;\u0026lt; endl; return ret; } // 匿名对象 = ret (此处会调用拷贝构造) 一、拷贝构造 1. 对象需要通过另外一个对象进行初始化 int main() { A a(1); A c = a; cout \u0026lt;\u0026lt; \u0026#34;global adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;c \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart second constructor adrres: 0x7ffdf2cf5cc0\tpoint x: 0x1e9db20\ty: 1 const copy constructor adrres: 0x7ffdf2cf5cb0\tpoint x: 0\ty: 0 global adrres: 0x7ffdf2cf5cb0\tpoint x: 0x1e9db20\ty: 1 destructor delete 0x7ffdf2cf5cb0 destructor delete 0x7ffdf2cf5cc0 0 Finish 2. 对象通过值传递方式进入函数 void g(A a){ cout \u0026lt;\u0026lt; \u0026#34;stack g adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; a.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; a.y \u0026lt;\u0026lt; endl; } int main() { A a(1); g(a); return 0; } 输出：\nStart second constructor adrres: 0x7ffddc160510\tpoint x: 0x2448b20\ty: 1 const copy constructor adrres: 0x7ffddc160520\tpoint x: 0\ty: 0 stack g adrres: 0x7ffddc160520\tpoint x: 0x2448b20\ty: 1 destructor delete 0x7ffddc160520 destructor delete 0x7ffddc160510 0 Finish 3. 当对象以值传递的方式从函数返回  函数返回匿名对象时会调用拷贝构造 变量在接收匿名对象时就不会调用拷贝构造了  class A { //注意把拷贝构造设为禁止使用，否则看不到效果  A(const A \u0026amp;a) = delete; } int main() { f(); // 如果没有变量接收匿名对象，编译器就直接回收了，立即执行对象析构  A c = f(); // 匿名对象直接转正，就不会调用拷贝构造了  A d; d = f(); // 此处会调用 = 号操作符重载（d = 匿名对象）  // 然后匿名对象会执行析构，立即销毁  cout \u0026lt;\u0026lt; \u0026#34;global adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;c \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart prog.cc: In function \u0026#39;A f()\u0026#39;: prog.cc:40:12: error: use of deleted function \u0026#39;A::A(const A\u0026amp;)\u0026#39; 40 | return ret; | ^~~ prog.cc:20:5: note: declared here 20 | A(const A \u0026amp;a) = delete; | ^ 1 Finish 正常输出：虽然没有输出调用拷贝构造的信息，但确实有关系\nStart second constructor adrres: 0x7fff0f7062d0\tpoint x: 0x127eb20\ty: 3 stack f adrres: 0x7fff0f7062d0\tpoint x: 0x127eb20\ty: 3 global adrres: 0x7fff0f7062d0\tpoint x: 0x127eb20\ty: 3 destructor delete 0x7fff0f7062d0 0 Finish 二、赋值构造  注意：拷贝构造不能是 delete 的  1. 对象直接赋值给另一个对象，且接受值的对象已经初始化过 int main() { A a(1); A c; c = a; cout \u0026lt;\u0026lt; \u0026#34;global adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;c \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart second constructor adrres: 0x7ffee27a6fa0\tpoint x: 0xcdeb20\ty: 1 default constructor adrres: 0x7ffee27a6f90\tpoint x: 0\ty: 0 const assignment constructor global adrres: 0x7ffee27a6f90\tpoint x: 0xcdeb20\ty: 1 destructor delete 0x7ffee27a6f90 destructor delete 0x7ffee27a6fa0 0 Finish 2. 对象以值传递方式从函数返回，且接受返回值的对象已经初始化过  注意：返回函数调用后，会调用析构，如果对象中包含指针时，会使该指针失效  int main() { A c; c = f(); // 此时调用指针会出错，f()结束，调用对象析构，对象中的指针被 delete 掉了  // cout \u0026lt;\u0026lt; *c.x \u0026lt;\u0026lt; endl;  cout \u0026lt;\u0026lt; \u0026#34;global adrres: \u0026#34; \u0026lt;\u0026lt; \u0026amp;c \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart default constructor adrres: 0x7ffd3aed2be0\tpoint x: 0\ty: 0 second constructor adrres: 0x7ffd3aed2bf0\tpoint x: 0x1475b20\ty: 3 stack f adrres: 0x7ffd3aed2bf0\tpoint x: 0x1475b20\ty: 3 const assignment constructor destructor delete 0x7ffd3aed2bf0 global adrres: 0x7ffd3aed2be0\tpoint x: 0x1475b20\ty: 3 destructor delete 0x7ffd3aed2be0 0 Finish ","permalink":"https://874656645.github.io/posts/36-%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0/","summary":"结论：\n 拷贝构造函数是函数，赋值运算符是运算符的重载； 拷贝构造函数会生成新的类对象，赋值运算符不会； 拷贝构造函数是用一个已存在的对象去构造一个不存在的对象；而赋值运算符重载函数是用一个存在的对象去给另一个已存在并初始化过的对象进行赋值; 若接受返回值的对象已经初始化过，则会调用赋值运算符，且该对象还会调用析构函数，当对象中包含指针时，会使该指针失效，因此需要重载赋值运算符，使用类似深拷贝或移动构造函数的方法赋值，才能避免指针失效。 如果只有显示的构造函数，系统会提供默认的拷贝构造； 如果显示提供了拷贝构造，系统就不会提供默认的无参构造了，用户必需显示提供构造函数； 当既没有显式的构造函数，也没有拷贝构造时，系统才会提供默认的无参构造； 显示提供拷贝构造就必需显示提供构造函数； 显示提供赋值运算符重载就必需显示提供拷贝构造；  成员初始化列表  使用成员变量初始化列表，少了一次调用默认构造函数的过程，提高效率 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 成员变量初始化的顺序跟在初始化列表的顺序无关，与变量声明的顺序有关  测试类 class A { public: A(){ cout \u0026lt;\u0026lt; \u0026#34;default constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } A(int t){ x = new int(0); y = t; cout \u0026lt;\u0026lt; \u0026#34;second constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } A(const A \u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;const copy constructor\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;adrres: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;\\tpoint x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\ty: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; this-\u0026gt;x = a.","title":"构造、拷贝构造、赋值构造"},{"content":" 重载： 在同一作用域中，两个函数名相同，但是参数列表不同（个数、类型、顺序），返回值类型没有要求； 重写（覆盖）： 子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写或覆盖； 重定义： 派生类中函数与基类中的函数同名（形参没有要求），但是这个函数在基类中并没有被定义为虚函数 隐藏： 派生类中重定义了父类的函数，此时基类的函数会被隐藏； 模板： 函数模板是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表，只适用于 参数个数相同而类型不同 的函数。 构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数  1、重载  类的静态函数也可以重载； 形参中一级指针和二级指针被认为是不同类型的参数；  class A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;print()\u0026#34; \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void freeP(A ** p){ if(p == NULL){ return; } if(*p != NULL){ free(*p); *p = NULL; } } void freeP(A * p){ if(p != NULL){ free(p); p = NULL; } } static void printS(){ cout \u0026lt;\u0026lt; \u0026#34;printS() s_a = \u0026#34; \u0026lt;\u0026lt; s_a \u0026lt;\u0026lt; endl; } static void printS(int s){ cout \u0026lt;\u0026lt; \u0026#34;printS(int s) \u0026#34; \u0026lt;\u0026lt; s_a * s \u0026lt;\u0026lt; endl; } static void printS(void *p, int s){ cout \u0026lt;\u0026lt; \u0026#34;printS(void *p, int s) \u0026#34; \u0026lt;\u0026lt; ((A*)p)-\u0026gt;m_a * s \u0026lt;\u0026lt; endl; } static int s_a; private: int m_a; }; int A::s_a = 0; int main( ) { A *a = new A(1); a-\u0026gt;printS(a, 20); a-\u0026gt;print(); A::s_a = 10; a-\u0026gt;printS(); a-\u0026gt;printS(10); a-\u0026gt;freeP(a); if(a == NULL){ cout \u0026lt;\u0026lt; \u0026#34;*a is not valid\u0026#34; \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; \u0026#34;*a is valid\u0026#34; \u0026lt;\u0026lt; endl; a-\u0026gt;print(); return 0; } 输出：\nStart printS(void *p, int s) 20 print()m_a = 1 printS() s_a = 10 printS(int s) 100 *a is valid print()m_a = 0 0 Finish 重写（覆盖）与重定义（隐藏）  struct B{ virtual void print(){ cout \u0026lt;\u0026lt; \u0026#34;B::print\u0026#34; \u0026lt;\u0026lt; endl; } void printT(){ cout \u0026lt;\u0026lt; \u0026#34;B::printT\u0026#34; \u0026lt;\u0026lt; endl; } }; struct D:B{ void print() override{ cout \u0026lt;\u0026lt; \u0026#34;D::print\u0026#34; \u0026lt;\u0026lt; endl; } void printT(int a){ cout \u0026lt;\u0026lt; \u0026#34;D::printT\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { D* d = new D; d-\u0026gt;print(); d-\u0026gt;printT(0); B* b = static_cast\u0026lt;B*\u0026gt;(d); b-\u0026gt;print(); b-\u0026gt;printT(); return 0; } 输出：\nD::print D::printT D::print B::printT ","permalink":"https://874656645.github.io/posts/35-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F%E6%A8%A1%E6%9D%BF/","summary":"重载： 在同一作用域中，两个函数名相同，但是参数列表不同（个数、类型、顺序），返回值类型没有要求； 重写（覆盖）： 子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写或覆盖； 重定义： 派生类中函数与基类中的函数同名（形参没有要求），但是这个函数在基类中并没有被定义为虚函数 隐藏： 派生类中重定义了父类的函数，此时基类的函数会被隐藏； 模板： 函数模板是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表，只适用于 参数个数相同而类型不同 的函数。 构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数， 而析构函数只能有一个，且不能带参数  1、重载  类的静态函数也可以重载； 形参中一级指针和二级指针被认为是不同类型的参数；  class A{ public: A(int a){ m_a = a; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;print()\u0026#34; \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; endl; } void freeP(A ** p){ if(p == NULL){ return; } if(*p != NULL){ free(*p); *p = NULL; } } void freeP(A * p){ if(p != NULL){ free(p); p = NULL; } } static void printS(){ cout \u0026lt;\u0026lt; \u0026#34;printS() s_a = \u0026#34; \u0026lt;\u0026lt; s_a \u0026lt;\u0026lt; endl; } static void printS(int s){ cout \u0026lt;\u0026lt; \u0026#34;printS(int s) \u0026#34; \u0026lt;\u0026lt; s_a * s \u0026lt;\u0026lt; endl; } static void printS(void *p, int s){ cout \u0026lt;\u0026lt; \u0026#34;printS(void *p, int s) \u0026#34; \u0026lt;\u0026lt; ((A*)p)-\u0026gt;m_a * s \u0026lt;\u0026lt; endl; } static int s_a; private: int m_a; }; int A::s_a = 0; int main( ) { A *a = new A(1); a-\u0026gt;printS(a, 20); a-\u0026gt;print(); A::s_a = 10; a-\u0026gt;printS(); a-\u0026gt;printS(10); a-\u0026gt;freeP(a); if(a == NULL){ cout \u0026lt;\u0026lt; \u0026#34;*a is not valid\u0026#34; \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; \u0026#34;*a is valid\u0026#34; \u0026lt;\u0026lt; endl; a-\u0026gt;print(); return 0; } 输出：","title":"函数重载、重写、隐藏、模板"},{"content":"当一个函数被声明为内联函数之后，在编译阶段，编译器会用内联函数的函数体取替换程序中出现的内联函数调用表达式，而其他的函数都是在运行时才被替换，这其实就是用空间换时间，提高了函数调用的效率。同时，内联函数具有几个特点：\n 适用于函数体积很小并频繁使用的函数 内联函数中不可以出现循环、递归或开关操作 内联函数的声明必须在函数定义之前 内联函数的定义必须出现在内联函数的第一次调用前 在类中声明同时定义的成员函数（除了虚函数）会自动隐式的当成内联函数 虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联  优点：\n 内联函数在被调用处进行代码展开，省去了参数压栈、跳转返回、栈帧开辟与回收，结果返回等操作，从而提高程序运行速度； 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换，而宏定义则不会； 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能； 内联函数在运行时可调试，而宏定义不可以。  缺点：\n 代码膨胀，消耗了更多的内存空间； inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接； 内联函数其实是不可控的，它只是对编译器的建议，是否对函数内联，决定权在于编译器; 不能对函数进行取址操作  ","permalink":"https://874656645.github.io/posts/34-inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/","summary":"当一个函数被声明为内联函数之后，在编译阶段，编译器会用内联函数的函数体取替换程序中出现的内联函数调用表达式，而其他的函数都是在运行时才被替换，这其实就是用空间换时间，提高了函数调用的效率。同时，内联函数具有几个特点：\n 适用于函数体积很小并频繁使用的函数 内联函数中不可以出现循环、递归或开关操作 内联函数的声明必须在函数定义之前 内联函数的定义必须出现在内联函数的第一次调用前 在类中声明同时定义的成员函数（除了虚函数）会自动隐式的当成内联函数 虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联  优点：\n 内联函数在被调用处进行代码展开，省去了参数压栈、跳转返回、栈帧开辟与回收，结果返回等操作，从而提高程序运行速度； 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换，而宏定义则不会； 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能； 内联函数在运行时可调试，而宏定义不可以。  缺点：\n 代码膨胀，消耗了更多的内存空间； inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接； 内联函数其实是不可控的，它只是对编译器的建议，是否对函数内联，决定权在于编译器; 不能对函数进行取址操作  ","title":"inline 内联函数"},{"content":"Unix 的 fork 函数 fork函数可以创建一个和当前映像一样的子进程，这个函数会返回两个值：从子进程返回0，从父进程返回子进程的PID；\n 1）在父进程中，fork返回新创建子进程的进程ID； 2）在子进程中，fork返回0； 3）如果出现错误，fork返回一个负值；  #include \u0026lt;iostream\u0026gt;#include \u0026lt;unistd.h\u0026gt; using namespace std; int main() { pid_t fpid; //fpid表示fork函数返回的值  int count = 0; cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; fpid = fork(); if (fpid \u0026lt; 0) printf(\u0026#34;error in fork!\\n\u0026#34;); else if (fpid == 0) { printf(\u0026#34;i am the child process, my process id is %d\\n\u0026#34;,getpid()); cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; count++; } else { printf(\u0026#34;i am the parent process, my process id is %d\\n\u0026#34;,getpid()); cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; count++; } printf(\u0026#34;统计结果是: %d\\n\u0026#34;,count); return 0; } 输出：\nStart 0x7ffd3ed42530 i am the parent process, my process id is 22 0x7ffd3ed42530 统计结果是: 1 i am the child process, my process id is 23 0x7ffd3ed42530 统计结果是: 1 0 Finish ","permalink":"https://874656645.github.io/posts/33-fork-unix/","summary":"Unix 的 fork 函数 fork函数可以创建一个和当前映像一样的子进程，这个函数会返回两个值：从子进程返回0，从父进程返回子进程的PID；\n 1）在父进程中，fork返回新创建子进程的进程ID； 2）在子进程中，fork返回0； 3）如果出现错误，fork返回一个负值；  #include \u0026lt;iostream\u0026gt;#include \u0026lt;unistd.h\u0026gt; using namespace std; int main() { pid_t fpid; //fpid表示fork函数返回的值  int count = 0; cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; fpid = fork(); if (fpid \u0026lt; 0) printf(\u0026#34;error in fork!\\n\u0026#34;); else if (fpid == 0) { printf(\u0026#34;i am the child process, my process id is %d\\n\u0026#34;,getpid()); cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; count++; } else { printf(\u0026#34;i am the parent process, my process id is %d\\n\u0026#34;,getpid()); cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; count++; } printf(\u0026#34;统计结果是: %d\\n\u0026#34;,count); return 0; } 输出：","title":"fork Unix"},{"content":"C++ 是 C 的超集和增强，校验更加严格\nC 主要是面向过程，C++ 是面向对象，面向过程是函数驱动，面向对象是对象驱动\n1 新增命名空间  给{}作用域起了个名称，后面不用加分号; 命名空间可以嵌套  namespace X { namespace Y { } } 2 新增引用类型  引用在一定程度上可以替代指针，作用与常指针类似 int * const a 引用没有定义，是一种关系声明，声明它和原有某一变量（实体）的关系，\n故而类型与原类型保持一致，且不分配内存，与被引用的变量有相同的地址 声明时必须初始化，一经声明，不可变更 可对引用再次引用，多次引用的结果是某一变量具有多个别名 \u0026amp; 符号在 = 号左边是引用，在 = 号右边为取地址  3 枚举检测增强  不能将整型隐式转化为枚举  4 变量定义增强  C++ 变量不必都声明在函数顶部，可以随使用随定义  5 全局变量定义检测严格  C 全局变量重复定义，C++ 不可以，全局变量检测增强  // C 语言 int g_val; // bss段 int g_val = 10; // data段 6 函数形参个数和函数返回值检测增强 // C 语言 f() // 默认返回值 int { return 10; } int g(int a) { return 10; } // 调用 g(10, 20, 30, 40); // 可编译通过，但是有警告 7 struct 结构体增强  功能与类基本等同，只不过 class 默认是 private 权限，struct 默认是 public 权限  // C 语言声明结构体变量 struct Student s; // C++ 语言声明结构体变量 Student s; 8 新增 bool 关键字，1 个字节  C 用 0 表示 false，非 0 表示 true C++ 中 bool 为 1 个字节，但是只有 true 和 false 两个值  9 三目运算符增强（语法糖）  C 中三目运算符不可以当左值  // C 语言 int a = 10, b = 20; ((a \u0026lt; b) ? a : b) = 50; // 错误 *((a \u0026lt; b) ? \u0026amp;a : \u0026amp;b) = 50; // 正确，a 此时是50 // C++ 三目运算左值 int a = 10, b = 20; ((a \u0026lt; b) ? a : b) = 50; // 正确，a 此时是50（返回的是引用） 10 const 增强  C中的 const 变量可以通过指针的方式进行修改，是假常量  // C 语言 const int a = 10; int *p = \u0026amp;a; *p = 20; printf(\u0026#34;a = %d\u0026#34;, a);  C++ 中的 const 变量放在了全局空间的符号表中，是不可更改的  // C++ 语言 const int a = 10; // 常量区符号表中（key value 键值对），编译过程中进行替换  // #define 是在预处理阶段展开，不受作用域限制 int *p = \u0026amp;a; // 在栈中开辟了一个临时变量空间 *p = 20; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // a = 10 cout \u0026lt;\u0026lt; \u0026#34;*p = \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; // *p = 20 ","permalink":"https://874656645.github.io/posts/32-c-%E4%B8%8E-c++-%E7%9A%84%E5%B7%AE%E5%BC%82/","summary":"C++ 是 C 的超集和增强，校验更加严格\nC 主要是面向过程，C++ 是面向对象，面向过程是函数驱动，面向对象是对象驱动\n1 新增命名空间  给{}作用域起了个名称，后面不用加分号; 命名空间可以嵌套  namespace X { namespace Y { } } 2 新增引用类型  引用在一定程度上可以替代指针，作用与常指针类似 int * const a 引用没有定义，是一种关系声明，声明它和原有某一变量（实体）的关系，\n故而类型与原类型保持一致，且不分配内存，与被引用的变量有相同的地址 声明时必须初始化，一经声明，不可变更 可对引用再次引用，多次引用的结果是某一变量具有多个别名 \u0026amp; 符号在 = 号左边是引用，在 = 号右边为取地址  3 枚举检测增强  不能将整型隐式转化为枚举  4 变量定义增强  C++ 变量不必都声明在函数顶部，可以随使用随定义  5 全局变量定义检测严格  C 全局变量重复定义，C++ 不可以，全局变量检测增强  // C 语言 int g_val; // bss段 int g_val = 10; // data段 6 函数形参个数和函数返回值检测增强 // C 语言 f() // 默认返回值 int { return 10; } int g(int a) { return 10; } // 调用 g(10, 20, 30, 40); // 可编译通过，但是有警告 7 struct 结构体增强  功能与类基本等同，只不过 class 默认是 private 权限，struct 默认是 public 权限  // C 语言声明结构体变量 struct Student s; // C++ 语言声明结构体变量 Student s; 8 新增 bool 关键字，1 个字节  C 用 0 表示 false，非 0 表示 true C++ 中 bool 为 1 个字节，但是只有 true 和 false 两个值  9 三目运算符增强（语法糖）  C 中三目运算符不可以当左值  // C 语言 int a = 10, b = 20; ((a \u0026lt; b) ?","title":"C 与 C++ 的差异"},{"content":"int add(int count, ...) { // 指针大小与程序位数有关（32位指针是4个字节，64位指针是8个字节）  int intSize = sizeof(int*) / sizeof(int); int sum = 0; // cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl;  int *p = \u0026amp;count + intSize; // cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;  for (int i = 0; i \u0026lt; count; ++i) { sum += *p; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; p += intSize; } return sum; } int main() { cout \u0026lt;\u0026lt; add(3, 1, 2, 3) \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 2 3 6 ","permalink":"https://874656645.github.io/posts/31-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%E5%85%A5%E6%A0%88/","summary":"int add(int count, ...) { // 指针大小与程序位数有关（32位指针是4个字节，64位指针是8个字节）  int intSize = sizeof(int*) / sizeof(int); int sum = 0; // cout \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl;  int *p = \u0026amp;count + intSize; // cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;  for (int i = 0; i \u0026lt; count; ++i) { sum += *p; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; p += intSize; } return sum; } int main() { cout \u0026lt;\u0026lt; add(3, 1, 2, 3) \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"函数形参从右到左入栈"},{"content":"1. 32 位和 64 位程序指针是多少位 32位指针大小为4个字节，64位指针大小位8个字节\n2. 指针加 1，是对该指针增加 1 个储存单位 “存储单位”，指的是指针指向的数据类型所占的内存的字节数。不同类型的指针加1后，增加的大小不同。\nint main() { int a[] = {1, 2, 3, 4, 5}; // \u0026amp;a是数组指针，其类型为 int (*)[5]，a是长度为5的int数组指针，所以要加 5*sizeof(int)，所以ptr实际是a[5]；  // \u0026amp;a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）  // 但是prt与(\u0026amp;a+1)类型是不一样的(这点很重要，prt指向的是整形)，所以prt-1只会减去sizeof(int)  int *ptr = (int*)(\u0026amp;a + 1); cout \u0026lt;\u0026lt; *(a + 1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *(ptr - 1) \u0026lt;\u0026lt; endl; return 0; } 输出：\n2 5 注： a，\u0026amp;a的地址是一样的，但意思不一样：\n a是数组首地址，也就是a[0]的地址，a+1是数组下一元素的地址，即a[1] \u0026amp;a是对象（整个数组作为一个对象）首地址，而\u0026amp;a+1是下一个对象的地址，即a[5].  ","permalink":"https://874656645.github.io/posts/30-%E6%8C%87%E9%92%88-+1/","summary":"1. 32 位和 64 位程序指针是多少位 32位指针大小为4个字节，64位指针大小位8个字节\n2. 指针加 1，是对该指针增加 1 个储存单位 “存储单位”，指的是指针指向的数据类型所占的内存的字节数。不同类型的指针加1后，增加的大小不同。\nint main() { int a[] = {1, 2, 3, 4, 5}; // \u0026amp;a是数组指针，其类型为 int (*)[5]，a是长度为5的int数组指针，所以要加 5*sizeof(int)，所以ptr实际是a[5]；  // \u0026amp;a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）  // 但是prt与(\u0026amp;a+1)类型是不一样的(这点很重要，prt指向的是整形)，所以prt-1只会减去sizeof(int)  int *ptr = (int*)(\u0026amp;a + 1); cout \u0026lt;\u0026lt; *(a + 1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *(ptr - 1) \u0026lt;\u0026lt; endl; return 0; } 输出：\n2 5 注： a，\u0026amp;a的地址是一样的，但意思不一样：\n a是数组首地址，也就是a[0]的地址，a+1是数组下一元素的地址，即a[1] \u0026amp;a是对象（整个数组作为一个对象）首地址，而\u0026amp;a+1是下一个对象的地址，即a[5].  ","title":"指针 + 1"},{"content":"template\u0026lt;class T\u0026gt; class Test { public: Test(T t){ m_t = t;}; // explicit Test(T t){ m_t = t;};  T getValue(){ return m_t; }; private: T m_t; }; int main() { Test\u0026lt;int\u0026gt; tInt(1); cout \u0026lt;\u0026lt; tInt.getValue() \u0026lt;\u0026lt; endl; Test\u0026lt;double\u0026gt; tD(1.15); cout \u0026lt;\u0026lt; tD.getValue() \u0026lt;\u0026lt; endl; Test\u0026lt;float\u0026gt; tF = 1.3f; // 构造函数没有explicit修饰，可以隐式转换  cout \u0026lt;\u0026lt; tF.getValue() \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 1 1.15 1.3 0 Finish ","permalink":"https://874656645.github.io/posts/29-%E6%A8%A1%E6%9D%BF%E7%B1%BB/","summary":"template\u0026lt;class T\u0026gt; class Test { public: Test(T t){ m_t = t;}; // explicit Test(T t){ m_t = t;};  T getValue(){ return m_t; }; private: T m_t; }; int main() { Test\u0026lt;int\u0026gt; tInt(1); cout \u0026lt;\u0026lt; tInt.getValue() \u0026lt;\u0026lt; endl; Test\u0026lt;double\u0026gt; tD(1.15); cout \u0026lt;\u0026lt; tD.getValue() \u0026lt;\u0026lt; endl; Test\u0026lt;float\u0026gt; tF = 1.3f; // 构造函数没有explicit修饰，可以隐式转换  cout \u0026lt;\u0026lt; tF.getValue() \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart 1 1.15 1.3 0 Finish ","title":"模板类"},{"content":"template \u0026lt;typename T\u0026gt; inline const T\u0026amp; Max (const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? b:a; }; int main() { int i = 39; int j = 20; cout \u0026lt;\u0026lt; \u0026#34;Max(i, j): \u0026#34; \u0026lt;\u0026lt; Max(i, j) \u0026lt;\u0026lt; endl; double f1 = 13.5; double f2 = 20.7; cout \u0026lt;\u0026lt; \u0026#34;Max(f1, f2): \u0026#34; \u0026lt;\u0026lt; Max(f1, f2) \u0026lt;\u0026lt; endl; string s1 = \u0026#34;Hello\u0026#34;; string s2 = \u0026#34;World\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Max(s1, s2): \u0026#34; \u0026lt;\u0026lt; Max(s1, s2) \u0026lt;\u0026lt; endl; return 0; } 输出：\nStart Max(i, j): 39 Max(f1, f2): 20.7 Max(s1, s2): World 0 Finish ","permalink":"https://874656645.github.io/posts/28-%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/","summary":"template \u0026lt;typename T\u0026gt; inline const T\u0026amp; Max (const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? b:a; }; int main() { int i = 39; int j = 20; cout \u0026lt;\u0026lt; \u0026#34;Max(i, j): \u0026#34; \u0026lt;\u0026lt; Max(i, j) \u0026lt;\u0026lt; endl; double f1 = 13.5; double f2 = 20.7; cout \u0026lt;\u0026lt; \u0026#34;Max(f1, f2): \u0026#34; \u0026lt;\u0026lt; Max(f1, f2) \u0026lt;\u0026lt; endl; string s1 = \u0026#34;Hello\u0026#34;; string s2 = \u0026#34;World\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Max(s1, s2): \u0026#34; \u0026lt;\u0026lt; Max(s1, s2) \u0026lt;\u0026lt; endl; return 0; } 输出：","title":"模板函数"},{"content":" 注：软件版本为10.6，需要 服务端 token 注：天地图官网的服务（https://t0.tianditu.gov.cn/img_w/wmts）使用的 dpi 大小采用的是国家标准，并不是 OGC 标准，会导致 ArcMap 加载影像后，矢量化的坐标不对  影像底图：\nhttp://t0.tianditu.com/img_c/esri/wmts 天地图影像（经纬度，CGCS2000）\nhttp://t0.tianditu.com/cia_c/esri/wmts 天地图影像注记（经纬度，CGCS2000）\nhttp://t0.tianditu.com/img_w/esri/wmts 天地图影像（墨卡托，WGS1984）\nhttp://t0.tianditu.com/cia_w/esri/wmts 天地图影像注记（墨卡托，WGS1984）\n矢量底图：\nhttp://t0.tianditu.com/vec_c/esri/wmts 天地图矢量（经纬度，CGCS2000）\nhttp://t0.tianditu.com/cva_c/esri/wmts 天地图矢量注记（经纬度，CGCS2000）\nhttp://t0.tianditu.com/vec_w/esri/wmts 天地图矢量（墨卡托，WGS1984）\nhttp://t0.tianditu.com/cva_w/esri/wmts 天地图矢量注记（墨卡托，WGS1984）\nArcMap WMTS\n","permalink":"https://874656645.github.io/posts/27-arcmap-%E5%8A%A0%E8%BD%BD%E5%A4%A9%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1/","summary":"注：软件版本为10.6，需要 服务端 token 注：天地图官网的服务（https://t0.tianditu.gov.cn/img_w/wmts）使用的 dpi 大小采用的是国家标准，并不是 OGC 标准，会导致 ArcMap 加载影像后，矢量化的坐标不对  影像底图：\nhttp://t0.tianditu.com/img_c/esri/wmts 天地图影像（经纬度，CGCS2000）\nhttp://t0.tianditu.com/cia_c/esri/wmts 天地图影像注记（经纬度，CGCS2000）\nhttp://t0.tianditu.com/img_w/esri/wmts 天地图影像（墨卡托，WGS1984）\nhttp://t0.tianditu.com/cia_w/esri/wmts 天地图影像注记（墨卡托，WGS1984）\n矢量底图：\nhttp://t0.tianditu.com/vec_c/esri/wmts 天地图矢量（经纬度，CGCS2000）\nhttp://t0.tianditu.com/cva_c/esri/wmts 天地图矢量注记（经纬度，CGCS2000）\nhttp://t0.tianditu.com/vec_w/esri/wmts 天地图矢量（墨卡托，WGS1984）\nhttp://t0.tianditu.com/cva_w/esri/wmts 天地图矢量注记（墨卡托，WGS1984）\nArcMap WMTS","title":"ArcMap 加载天地图服务"},{"content":"#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;using namespace std; // 声明函数指针变量 int (*fn)(int) = NULL; // 定义函数指针类型 typedef int (*Fn)(int); int cal(int v){ return v; }; int max(int a, int b){ return a \u0026gt; b ? a : b; } // 函数指针做为参数 void proc(int v, Fn f){ cout \u0026lt;\u0026lt; f(v) \u0026lt;\u0026lt; endl; }; // 函数指针作为函数返回值 int (* retFP(string fName))(int, int){ // lambda 表达式作为函数指针返回  int (*fp)(int,int) = [](int x, int y){ return x \u0026gt; y ? y : x;}; // 返回一个全局函数  if(fName == \u0026#34;max\u0026#34;){ fp = max; } return fp; } // 或者下面的方式 typedef int (*RetFP)(int, int); RetFP retFP(string fName){ int (*fp)(int,int) = [](int x, int y){ return x \u0026gt; y ? y : x;}; if(fName == \u0026#34;max\u0026#34;){ fp = max; } return fp; } int main() { fn = cal; cout \u0026lt;\u0026lt; (*fn)(10) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; fn(10) \u0026lt;\u0026lt; endl; Fn f1 = cal; cout \u0026lt;\u0026lt; (*f1)(20) \u0026lt;\u0026lt; endl; proc(30, cal); auto myFP = retFP(\u0026#34;max\u0026#34;); cout \u0026lt;\u0026lt; myFP(3, 6) \u0026lt;\u0026lt; endl; return 0; } Start 10 10 20 30 0 Finish 成员函数指针：\nstruct type { int i; type(): i(3) {} void f(int v) const { // this-\u0026gt;i = v; // compile error: this is a pointer to const  const_cast\u0026lt;type*\u0026gt;(this)-\u0026gt;i = v; // OK as long as the type object isn\u0026#39;t const  } }; int main() { type t; // if this was const type t, then t.f(4) would be undefined behavior  t.f(4); std::cout \u0026lt;\u0026lt; \u0026#34;type::i = \u0026#34; \u0026lt;\u0026lt; t.i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // type::i = 4  void (type::*pmf)(int) const = \u0026amp;type::f; // pointer to member function  (t.*pmf)(40); std::cout \u0026lt;\u0026lt; \u0026#34;type::i = \u0026#34; \u0026lt;\u0026lt; t.i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // type::i = 40 } ","permalink":"https://874656645.github.io/posts/26-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/","summary":"#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;using namespace std; // 声明函数指针变量 int (*fn)(int) = NULL; // 定义函数指针类型 typedef int (*Fn)(int); int cal(int v){ return v; }; int max(int a, int b){ return a \u0026gt; b ? a : b; } // 函数指针做为参数 void proc(int v, Fn f){ cout \u0026lt;\u0026lt; f(v) \u0026lt;\u0026lt; endl; }; // 函数指针作为函数返回值 int (* retFP(string fName))(int, int){ // lambda 表达式作为函数指针返回  int (*fp)(int,int) = [](int x, int y){ return x \u0026gt; y ?","title":"函数指针"},{"content":"  指针函数本质是一个函数，返回值是一个指针；\n  函数指针是指向函数的一个指针变量；\n  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt; using namespace std; // 指针函数fun char * fun(const char * p) { cout \u0026lt;\u0026lt; \u0026#34;fun: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return nullptr; }; // 函数指针pf char * (*pf)(const char * p); int main() { pf = fun; // 函数指针pf指向函数fun  pf(\u0026#34;Hello\u0026#34;); return 0; } ","permalink":"https://874656645.github.io/posts/25-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/","summary":"  指针函数本质是一个函数，返回值是一个指针；\n  函数指针是指向函数的一个指针变量；\n  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt; using namespace std; // 指针函数fun char * fun(const char * p) { cout \u0026lt;\u0026lt; \u0026#34;fun: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return nullptr; }; // 函数指针pf char * (*pf)(const char * p); int main() { pf = fun; // 函数指针pf指向函数fun  pf(\u0026#34;Hello\u0026#34;); return 0; } ","title":"指针函数和函数指针"},{"content":" 修饰构造函数，防止隐式转换，赋值初始化，赋值列表初始化 修饰转换函数，可以防止隐式转换，但按语境转换除外 explicit 可加在带多个参数的构造方法上(converting to ‘XXX’ from initializer list)  struct B { explicit B(int) {} explicit operator bool() const { return true; } }; int main() { B b1(1); // OK：直接初始化  B b2 = 1; // 错误：被 explicit 修饰构造函数的对象不可以赋值初始化  B b3{ 1 }; // OK：直接列表初始化  B b4 = { 1 }; // 错误：被 explicit 修饰构造函数的对象不可以赋值列表初始化  B b5 = (B)1; // OK：允许 static_cast 的显式转换  if (b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b6(b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b7 = b1; // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换  bool b8 = static_cast\u0026lt;bool\u0026gt;(b1); // OK：static_cast 进行直接初始化  return 0; } 从初始化列表隐式转换：\nclass T{ public: T(int a, int b){ cout \u0026lt;\u0026lt; \u0026#34;T(int, int)...\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;a = a; this-\u0026gt;b = b; } ~T(){ cout \u0026lt;\u0026lt; \u0026#34;~T()...\u0026#34; \u0026lt;\u0026lt; endl; } void printT(){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } private: int a; int b; }; T func(){ cout \u0026lt;\u0026lt; \u0026#34;in func()...\u0026#34; \u0026lt;\u0026lt; endl; return {3, 4}; } int main() { T t = func(); t.printT(); return 0; } 输出：\nin func()... T(int, int)... a = 3, b = 4 ~T()... ","permalink":"https://874656645.github.io/posts/24-explicit-%E5%85%B3%E9%94%AE%E5%AD%97/","summary":"修饰构造函数，防止隐式转换，赋值初始化，赋值列表初始化 修饰转换函数，可以防止隐式转换，但按语境转换除外 explicit 可加在带多个参数的构造方法上(converting to ‘XXX’ from initializer list)  struct B { explicit B(int) {} explicit operator bool() const { return true; } }; int main() { B b1(1); // OK：直接初始化  B b2 = 1; // 错误：被 explicit 修饰构造函数的对象不可以赋值初始化  B b3{ 1 }; // OK：直接列表初始化  B b4 = { 1 }; // 错误：被 explicit 修饰构造函数的对象不可以赋值列表初始化  B b5 = (B)1; // OK：允许 static_cast 的显式转换  if (b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b6(b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换  bool b7 = b1; // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换  bool b8 = static_cast\u0026lt;bool\u0026gt;(b1); // OK：static_cast 进行直接初始化  return 0; } 从初始化列表隐式转换：","title":"explicit（显式）关键字"},{"content":"局部变量、静态局部变量、全局变量、全局静态变量、字符串常量以及动态申请的内存区\n 局部变量存储在栈中 全局变量、静态变量（全局和局部静态变量）存储在静态存储区 new申请的内存是在堆中 字符串常量也是存储在静态存储区   栈中的变量内存会随着定义所在区间的结束自动释放；而对于堆，需要手动free，否则它就一直存在，直到程序结束； 对于静态存储区，其中的变量常量在程序运行期间会一直存在，不会释放，且变量常量在其中只有一份拷贝，不会出现相同的变量和常量的不同拷贝。  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt; using namespace std; //返回的是局部变量的地址，该地址位于动态数据区，栈里 char *s1() { char* p1 = \u0026#34;qqq\u0026#34;;//为了测试‘char p[]=\u0026#34;Hello world!\u0026#34;’中的字符串在静态存储区是否也有一份拷贝  char p[]=\u0026#34;Hello world!\u0026#34;; char* p2 = \u0026#34;w\u0026#34;;//为了测试‘char p[]=\u0026#34;Hello world!\u0026#34;’中的字符串在静态存储区是否也有一份拷贝  printf(\u0026#34;in s1 p=%p\\n\u0026#34;, p); printf(\u0026#34;in s1 p1=%p\\n\u0026#34;, p1); printf(\u0026#34;in s1: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!\u0026#34;)); printf(\u0026#34;in s1 p2=%p\\n\u0026#34;, p2); return p1; // 这里不能返回局部变量 p } //返回的是字符串常量的地址，该地址位于静态数据区 char *s2() { char *q=\u0026#34;Hello world!\u0026#34;; printf(\u0026#34;in s2 q=%p\\n\u0026#34;, q); printf(\u0026#34;in s2: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!\u0026#34;)); return q; } //返回的是静态局部变量的地址，该地址位于静态数据区 char *s3() { static char r[]=\u0026#34;Hello world!\u0026#34;; printf(\u0026#34;in s3 r=%p\\n\u0026#34;, r); printf(\u0026#34;in s3: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!\u0026#34;)); return r; } int main() { char *t1, *t2, *t3; t1=s1(); t2=s2(); t3=s3(); printf(\u0026#34;in main:\u0026#34;); printf(\u0026#34;p=%p, q=%p, r=%p\\n\u0026#34;, t1, t2, t3); printf(\u0026#34;%s\\n\u0026#34;, t1); printf(\u0026#34;%s\\n\u0026#34;, t2); printf(\u0026#34;%s\\n\u0026#34;, t3); cout \u0026lt;\u0026lt; sizeof(\u0026#39;a\u0026#39;) \u0026lt;\u0026lt; endl; return 0; } 输出：\nin s1 p=0x7ffef76f34d3 in s1 p1=0x401010 in s1: string\u0026#39;s address: 0x40102f in s1 p2=0x401014 in s2 q=0x40102f in s2: string\u0026#39;s address: 0x40102f in s3 r=0x601798 in s3: string\u0026#39;s address: 0x40102f in main:p=0x401010, q=0x40102f, r=0x601798 qqq Hello world! Hello world! 1 这个结果正好应证了上面解释，同时，还可是得出一个结论：\n 字符串常量，之所以称之为常量，因为它可以看作是一个没有命名的字符串且为常量，存放在静态数据区。 这里说的静态数据区，是相对于堆、栈等动态数据区而言的。 静态数据区存放的是全局变量和静态变量，从这一点上来说，字符串常量又可以称之为一个无名的静态变量， 因为\u0026quot;Hello world!\u0026quot;这个字符串在函数 s1 和 s2 中都引用了，但在内存中却只有一份拷贝，这与静态变量性质相当神似。  #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt;int main() { const char *b = NULL, *c = NULL; char a[] = \u0026#34;hello world!\u0026#34;; b = \u0026#34;hello world!\u0026#34;; c = \u0026#34;hello world!\u0026#34;; printf(\u0026#34;%p\\n\u0026#34;, a); printf(\u0026#34;%p\\n\u0026#34;, b); printf(\u0026#34;%p\\n\u0026#34;, c); printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;(\u0026#34;hello world!\u0026#34;)); } 输出：\nStart 0x7ffca882ddf3 0x400d40 0x400d40 0x400d40 0 Finish ","permalink":"https://874656645.github.io/posts/23-c++-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8/","summary":"局部变量、静态局部变量、全局变量、全局静态变量、字符串常量以及动态申请的内存区\n 局部变量存储在栈中 全局变量、静态变量（全局和局部静态变量）存储在静态存储区 new申请的内存是在堆中 字符串常量也是存储在静态存储区   栈中的变量内存会随着定义所在区间的结束自动释放；而对于堆，需要手动free，否则它就一直存在，直到程序结束； 对于静态存储区，其中的变量常量在程序运行期间会一直存在，不会释放，且变量常量在其中只有一份拷贝，不会出现相同的变量和常量的不同拷贝。  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt; using namespace std; //返回的是局部变量的地址，该地址位于动态数据区，栈里 char *s1() { char* p1 = \u0026#34;qqq\u0026#34;;//为了测试‘char p[]=\u0026#34;Hello world!\u0026#34;’中的字符串在静态存储区是否也有一份拷贝  char p[]=\u0026#34;Hello world!\u0026#34;; char* p2 = \u0026#34;w\u0026#34;;//为了测试‘char p[]=\u0026#34;Hello world!\u0026#34;’中的字符串在静态存储区是否也有一份拷贝  printf(\u0026#34;in s1 p=%p\\n\u0026#34;, p); printf(\u0026#34;in s1 p1=%p\\n\u0026#34;, p1); printf(\u0026#34;in s1: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!\u0026#34;)); printf(\u0026#34;in s1 p2=%p\\n\u0026#34;, p2); return p1; // 这里不能返回局部变量 p } //返回的是字符串常量的地址，该地址位于静态数据区 char *s2() { char *q=\u0026#34;Hello world!\u0026#34;; printf(\u0026#34;in s2 q=%p\\n\u0026#34;, q); printf(\u0026#34;in s2: string\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;(\u0026#34;Hello world!","title":"C++ 字符串常量存储"},{"content":"1、const 修饰指针和引用 常对象：const Class A 只能调用 const 成员函数\n常量指针：const int * 所指的地址内容为 常量只读，但是可指向其它对象的地址（可以重指向）\n指针常量：int * const 指针所指的地址不能变（不可以重指向），但地址的内容可以被修改，与引用变量效果类似\n常量引用：const int \u0026amp; 相当于是对象的一个别名，对象内容为 只读，并且不能指向其它对象\nconst int \u0026amp;a = 40 与 constexpr int a = 40 效果类似，但后者只能在全局区声明\nconst int \u0026amp;a = 40 等同于 const int * const a = new int(40)（指针的指向和存放的内容都不可更改）\nClassA myA(10), myB(-10); const ClassA a; // 常对象（只能调用常成员函数） const ClassA * b = \u0026amp;myA; // 常量指针 ClassA * const b = \u0026amp;myA; // 指针常量 const ClassA \u0026amp;bb = myB; // 常量引用  b = \u0026amp;myB; // 合法（可以指向其它对象） b-\u0026gt;setA(10); // 错误（只读） bb.setA(100); // 错误（只读） bb = myA; // 错误（不可指向其它对象） char greet[] = \u0026#34;Hello\u0026#34;, w[] = \u0026#34;World\u0026#34;; const char * p = greet; char * const pp = greet; cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; *p = \u0026#39;W\u0026#39;; //error: assignment of read-only location \u0026#39;* p\u0026#39;  // *p = \u0026#39;W\u0026#39;; p = w; // 合法（常量指针可以改变指向，不能改变存储的内容） pp = w; //error: assignment of read-only variable \u0026#39;pp\u0026#39;  // pp = w; *pp = \u0026#39;W\u0026#39;; // 合法（指针常量可以改变存储的内容，不能改变指向） cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; w \u0026lt;\u0026lt; endl; return 0; 2、const变量存放位置  局部变量存放在栈区 对于全局对象，编译期一般不分配内存，放在符号表中以提高访问效率 对于字面值常量，存放在常量存储区  ","permalink":"https://874656645.github.io/posts/22-const-%E4%BF%AE%E9%A5%B0%E7%AC%A6/","summary":"1、const 修饰指针和引用 常对象：const Class A 只能调用 const 成员函数\n常量指针：const int * 所指的地址内容为 常量只读，但是可指向其它对象的地址（可以重指向）\n指针常量：int * const 指针所指的地址不能变（不可以重指向），但地址的内容可以被修改，与引用变量效果类似\n常量引用：const int \u0026amp; 相当于是对象的一个别名，对象内容为 只读，并且不能指向其它对象\nconst int \u0026amp;a = 40 与 constexpr int a = 40 效果类似，但后者只能在全局区声明\nconst int \u0026amp;a = 40 等同于 const int * const a = new int(40)（指针的指向和存放的内容都不可更改）\nClassA myA(10), myB(-10); const ClassA a; // 常对象（只能调用常成员函数） const ClassA * b = \u0026amp;myA; // 常量指针 ClassA * const b = \u0026amp;myA; // 指针常量 const ClassA \u0026amp;bb = myB; // 常量引用  b = \u0026amp;myB; // 合法（可以指向其它对象） b-\u0026gt;setA(10); // 错误（只读） bb.","title":"const 修饰符"},{"content":"  路径中有空格\nm_process-\u0026gt;startDetached(strAppDir + \u0026quot;/ThreeDScreen.exe\u0026quot;, QStringList())\n  杀死一个进程（注：-t 参数会将创建的子进程一起杀死）\nQProcess::startDetached(\u0026quot;taskkill -t -f /IM iexplore.exe\u0026quot;);\n  ","permalink":"https://874656645.github.io/posts/21-qprocess-%E4%BD%BF%E7%94%A8/","summary":"  路径中有空格\nm_process-\u0026gt;startDetached(strAppDir + \u0026quot;/ThreeDScreen.exe\u0026quot;, QStringList())\n  杀死一个进程（注：-t 参数会将创建的子进程一起杀死）\nQProcess::startDetached(\u0026quot;taskkill -t -f /IM iexplore.exe\u0026quot;);\n  ","title":"Qt QProcess 使用"},{"content":" QString使用的是UTF-8编码 从字符常量中获取中文  QString msg = QString::fromLocal8Bit(\u0026quot;This is a debug message at 中文\u0026quot;);\n以QString做为形参变量传递  qDebug(msg.toUtf8());\nQString与操作系统间读写，会自动将UTF-8与操作系统的编码做转换（比如日志系统）  void QtLog::WriteLine(const QString \u0026amp;logFileName, const QString \u0026amp;logMsg) { QFile file(logFileName); file.open(QIODevice::WriteOnly | QIODevice::Append); QTextStream text_stream(\u0026amp;file); text_stream \u0026lt;\u0026lt; logMsg \u0026lt;\u0026lt; \u0026#34;\\r\\n\u0026#34;; file.flush(); file.close(); } QString strAppDir = QCoreApplication::applicationDirPath(); // 不用转码  QString message, text, fileName = strAppDir + \u0026#34;/Log/\u0026#34;; QDir dir(fileName); if (!dir.exists()) { // 注：不能创建两级文件夹  bool ismkdir = dir.mkdir(fileName); } ","permalink":"https://874656645.github.io/posts/20-qstring-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","summary":" QString使用的是UTF-8编码 从字符常量中获取中文  QString msg = QString::fromLocal8Bit(\u0026quot;This is a debug message at 中文\u0026quot;);\n以QString做为形参变量传递  qDebug(msg.toUtf8());\nQString与操作系统间读写，会自动将UTF-8与操作系统的编码做转换（比如日志系统）  void QtLog::WriteLine(const QString \u0026amp;logFileName, const QString \u0026amp;logMsg) { QFile file(logFileName); file.open(QIODevice::WriteOnly | QIODevice::Append); QTextStream text_stream(\u0026amp;file); text_stream \u0026lt;\u0026lt; logMsg \u0026lt;\u0026lt; \u0026#34;\\r\\n\u0026#34;; file.flush(); file.close(); } QString strAppDir = QCoreApplication::applicationDirPath(); // 不用转码  QString message, text, fileName = strAppDir + \u0026#34;/Log/\u0026#34;; QDir dir(fileName); if (!dir.exists()) { // 注：不能创建两级文件夹  bool ismkdir = dir.mkdir(fileName); } ","title":"Qt QString 中文乱码"},{"content":"1、设置IE为单进程模式  64位操作系统的 IE 默认每个 Tab 页都是一个进程，并且 Tab 页的进程是 32 位的，主进程是 64 位的，如下图所示  值为0时是单进程模式，1是多进程\n","permalink":"https://874656645.github.io/posts/19-ie64-%E4%BD%8D%E6%8F%92%E4%BB%B6/","summary":"1、设置IE为单进程模式  64位操作系统的 IE 默认每个 Tab 页都是一个进程，并且 Tab 页的进程是 32 位的，主进程是 64 位的，如下图所示  值为0时是单进程模式，1是多进程","title":"IE 64位插件"},{"content":"1、查看纹理 渲染——材质编辑器——精简材质编辑器\n2、合并Mesh——附加 3、资源跟踪器快捷键 Shift + T ","permalink":"https://874656645.github.io/posts/18-3dmax-%E6%93%8D%E4%BD%9C/","summary":"1、查看纹理 渲染——材质编辑器——精简材质编辑器\n2、合并Mesh——附加 3、资源跟踪器快捷键 Shift + T ","title":"3DMax 操作"},{"content":"1、随机数 python 脚本\nimport random def randNum(): res = random.randint(1, 7) return res 2、自增 python 脚本\ntotal = 0 def accumulate(increment): global total if total: total += increment else: total = increment return total ","permalink":"https://874656645.github.io/posts/17-arcgis-%E5%AD%97%E6%AE%B5%E9%9A%8F%E6%9C%BA%E6%95%B0/","summary":"1、随机数 python 脚本\nimport random def randNum(): res = random.randint(1, 7) return res 2、自增 python 脚本\ntotal = 0 def accumulate(increment): global total if total: total += increment else: total = increment return total ","title":"ArcGIS 字段计算（自增、随机数）"},{"content":"查看库的版本（win32 or 64） 1、通过 vs 自带工具 dumpbin.exe dumpbin.exe /headers dll文件路径\n2、使用 notepad++ 直接用 记事本 或者 notepad++ 打开exe文件（dll文件），会有很多乱码，不要头疼，接下来只需要在第二段中找到 PE 两个字母，在其后的不远出会出现d 或者L。若是d，则证明该程序是64位；若是L，则证明是32位。\n","permalink":"https://874656645.github.io/posts/15-%E6%9F%A5%E7%9C%8B-dll-%E7%89%88%E6%9C%AC/","summary":"查看库的版本（win32 or 64） 1、通过 vs 自带工具 dumpbin.exe dumpbin.exe /headers dll文件路径\n2、使用 notepad++ 直接用 记事本 或者 notepad++ 打开exe文件（dll文件），会有很多乱码，不要头疼，接下来只需要在第二段中找到 PE 两个字母，在其后的不远出会出现d 或者L。若是d，则证明该程序是64位；若是L，则证明是32位。","title":"查看 dll 版本"},{"content":"miniconda包管理器常用命令 0、指定conda的工作平台 set CONDA_FORCE_32BIT=1 // 指定 conda 的工作平台为 win-32\nset CONDA_FORCE_32BIT= // 指定 conda 的工作平台为 x64\n1、指定conda的资源镜像 # 推荐使用中科大的 conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free # 清华的镜像好像用不了了 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free # 设置搜索时显示通道地址 conda config --set show_channel_urls yes 执行此命令后会在当前的用户文件夹下生成一个 .condarc 的配置文件\n2、搜索某个库的所有版本 conda search gdal\n3、查看当前环境下已安装的包 conda list\n4、创建一个虚拟环境 conda create --name python34 python=3.4\n5、激活某个环境 activate python34 // for windows\nsource activate python34 // for Linux \u0026amp; Mac\n6、取消激活 conda deactivate // for windows\nsource conda deactivate // for Linux \u0026amp; Mac\n7、删除一个环境 conda remove --name python34 --all\n8、查看已安装的环境 conda info -e\n9、查看当前激活环境下的安装包 conda list\n10、查看某个指定环境的安装包 conda list -n python34\n11、安装到当前激活环境 conda install gdal\n12、安装到指定环境 conda install -n python34 numpy\n13、清理 conda clean -p // 删除没有用的包\nconda clean -t // 删除tar打包\n14、查看帮助 conda --help conda -h conda env -h conda update -h 15、查看当前所有环境 conda info --envs\n","permalink":"https://874656645.github.io/posts/14-conda-learn/","summary":"miniconda包管理器常用命令 0、指定conda的工作平台 set CONDA_FORCE_32BIT=1 // 指定 conda 的工作平台为 win-32\nset CONDA_FORCE_32BIT= // 指定 conda 的工作平台为 x64\n1、指定conda的资源镜像 # 推荐使用中科大的 conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free # 清华的镜像好像用不了了 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free # 设置搜索时显示通道地址 conda config --set show_channel_urls yes 执行此命令后会在当前的用户文件夹下生成一个 .condarc 的配置文件\n2、搜索某个库的所有版本 conda search gdal\n3、查看当前环境下已安装的包 conda list\n4、创建一个虚拟环境 conda create --name python34 python=3.4\n5、激活某个环境 activate python34 // for windows\nsource activate python34 // for Linux \u0026amp; Mac\n6、取消激活 conda deactivate // for windows","title":"Conda Learn"},{"content":"win10 小娜开始菜单无法搜索应用 1.用管理员权限打开 powershell.exe 或者 cmd;\n2.在其中输入下列命令，重新注册激活小娜\nGet-AppXPackage -Name Microsoft.Windows.Cortana | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register \u0026quot;$($_.InstallLocation)\\AppXManifest.xml\u0026quot;}\n","permalink":"https://874656645.github.io/posts/13-restart-cortana/","summary":"win10 小娜开始菜单无法搜索应用 1.用管理员权限打开 powershell.exe 或者 cmd;\n2.在其中输入下列命令，重新注册激活小娜\nGet-AppXPackage -Name Microsoft.Windows.Cortana | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register \u0026quot;$($_.InstallLocation)\\AppXManifest.xml\u0026quot;}","title":"Restart Cortana"},{"content":"cmake命令\n1、生成 VS 2015 win64 版本的解决方案 注：下面的命令要在cmd下使用，power shell不可以\ncmake -H. -B./cmk_build/Win64 -G \u0026quot;Visual Studio 15 2017 Win64\u0026quot;\n2、指定目标版本 cmake -D CMAKE_SYSTEM_VERSION=8.1 -H. -B./cmk_build/Win64 -G \u0026quot;Visual Studio 15 2017 Win64\u0026quot;\n3、使用 MinGW 编译器 cmake -H. -B./cmk_build/MinGW -G \u0026quot;MinGW Makefiles\u0026quot;\n","permalink":"https://874656645.github.io/posts/12-cmake-learn/","summary":"cmake命令\n1、生成 VS 2015 win64 版本的解决方案 注：下面的命令要在cmd下使用，power shell不可以\ncmake -H. -B./cmk_build/Win64 -G \u0026quot;Visual Studio 15 2017 Win64\u0026quot;\n2、指定目标版本 cmake -D CMAKE_SYSTEM_VERSION=8.1 -H. -B./cmk_build/Win64 -G \u0026quot;Visual Studio 15 2017 Win64\u0026quot;\n3、使用 MinGW 编译器 cmake -H. -B./cmk_build/MinGW -G \u0026quot;MinGW Makefiles\u0026quot;","title":"Cmake Learn"},{"content":"vcpkg安装及使用\n注意：需要安装vs的英文语言包1、指定 vcpkg 中 msvc 的编译版本 在 vcpkg/triplets/文件夹下的所有cmake文件中添加代码 set(VCPKG_PLATFORM_TOOLSET v140)\n如果同时安装了vs2017，需要确保安装vs2017的英文语言包\n","permalink":"https://874656645.github.io/posts/11-vcpkg-learn/","summary":"vcpkg安装及使用\n注意：需要安装vs的英文语言包1、指定 vcpkg 中 msvc 的编译版本 在 vcpkg/triplets/文件夹下的所有cmake文件中添加代码 set(VCPKG_PLATFORM_TOOLSET v140)\n如果同时安装了vs2017，需要确保安装vs2017的英文语言包","title":"Vcpkg Learn"},{"content":"Power shell执行策略 原文网址\n1、查看当前的安全策略 Get-ExecutionPolicy\n2、修改执行策略 ps:这种方法会将执行策略保存到注册表\nSet-ExecutionPolicy UnRestricted\nor\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned\n3、查看所有支持的执行策略 [System.Enum]::GetNames([Microsoft.PowerShell.ExecutionPolicy])\n4、获取影响当前会话的所有执行策略 Get-ExecutionPolicy -List\n6、为当前 Windows PowerShell 会话设置执行策略 PowerShell.exe -ExecutionPolicy RemoteSigned\n","permalink":"https://874656645.github.io/posts/10-power-shell-executionpolicy/","summary":"Power shell执行策略 原文网址\n1、查看当前的安全策略 Get-ExecutionPolicy\n2、修改执行策略 ps:这种方法会将执行策略保存到注册表\nSet-ExecutionPolicy UnRestricted\nor\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned\n3、查看所有支持的执行策略 [System.Enum]::GetNames([Microsoft.PowerShell.ExecutionPolicy])\n4、获取影响当前会话的所有执行策略 Get-ExecutionPolicy -List\n6、为当前 Windows PowerShell 会话设置执行策略 PowerShell.exe -ExecutionPolicy RemoteSigned","title":"Power Shell ExecutionPolicy"},{"content":"1、使用requests库访问网址 2、使用xpath技术提取网页目标图片网址 3、通过os库保存图片到本地 #coding = utf-8 import requests import os from lxml import etree from urllib.parse import quote,unquote # import urllib.request class DmdSpider(object): name = \u0026#34;dmd\u0026#34; save_path = \u0026#39;E:/python/manhuadao/pics/\u0026#39; __picNo = 0 # 访问漫画岛网页 def start_request(self, url): header = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\u0026#39;} r = requests.get(url, params=header) # print(r.text) self.__get_imgs(r) # 自动跳转下一页 html = etree.HTML(r.text) next_urls = html.xpath(\u0026#39;//div[@class=\u0026#34;read-bottom\u0026#34;]//a[@class=\u0026#34;next\u0026#34;]/@href\u0026#39;) # print(next) for href in next_urls: nexturl = href.split(\u0026#39;=\u0026#39;)[-1] self.start_request(unquote(nexturl)) # 使用xpath提取网页中的图片网址 def __get_imgs(self, resbonse): html = etree.HTML(resbonse.text) # print(html) # result = etree.tostring(html) # print(result.decode(\u0026#34;utf-8\u0026#34;)) img_srcs = html.xpath(\u0026#39;//div[@class=\u0026#34;center-t\u0026#34;]//div[@class=\u0026#34;main-content\u0026#34;]//img/@src\u0026#39;) # print(img_srcs) for url in img_srcs: self.__save_img(url) # 下载图片 def __save_img(self, url): # arr = url.split(\u0026#39;-\u0026#39;) # picName = arr[-1].split(\u0026#39;.\u0026#39;)[0] header = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\u0026#39;} # request = urllib.request.Request(url, None, header)  # response = urllib.request.urlopen(request) # with open(\u0026#39;E:/python/manhuadao/pics/%s.jpg\u0026#39; %picName, \u0026#34;wb\u0026#34;) as f: # f.write(response.read()) # print(response) response = requests.get(url, params = header) # print(response.content) if not os.path.exists(self.save_path): os.makedirs(self.save_path) with open(self.save_path + \u0026#39;%s.jpg\u0026#39;%self.__picNo, \u0026#34;wb\u0026#34;) as f: f.write(response.content) self.__picNo = self.__picNo + 1 def main(): dmd = DmdSpider() dmd.start_request(\u0026#39;http://www.manhuadao.cn/Comic/ComicView?comicid=58df8c73d401da325c9cf77c\u0026amp;chapterid=9587480\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: main() ","permalink":"https://874656645.github.io/posts/9-crawl-pictures-from-website/","summary":"1、使用requests库访问网址 2、使用xpath技术提取网页目标图片网址 3、通过os库保存图片到本地 #coding = utf-8 import requests import os from lxml import etree from urllib.parse import quote,unquote # import urllib.request class DmdSpider(object): name = \u0026#34;dmd\u0026#34; save_path = \u0026#39;E:/python/manhuadao/pics/\u0026#39; __picNo = 0 # 访问漫画岛网页 def start_request(self, url): header = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\u0026#39;} r = requests.get(url, params=header) # print(r.text) self.__get_imgs(r) # 自动跳转下一页 html = etree.HTML(r.text) next_urls = html.xpath(\u0026#39;//div[@class=\u0026#34;read-bottom\u0026#34;]//a[@class=\u0026#34;next\u0026#34;]/@href\u0026#39;) # print(next) for href in next_urls: nexturl = href.","title":"Crawl Pictures From Website"},{"content":"原文网址\n在python中使用virtualenv创建虚拟环境 注意：要使用cmd命令行，不能使用Power Shell1、使用pip安装 pip install virtualenv\n2、创建项目目录并用cd进入 mkdir E:\\python\\Virtualenv cd E:\\python\\Virtualenv 3、创建虚拟环境 virtualenv -p c:\\Python36\\python.exe env\n或者\nvirtualenv env\n此命令会在当前目录下创建一个env目录\n4、启动虚拟环境 env\\Scripts\\activate\n5、离开虚拟环境 deactivate\n6、删除env文件夹即可 ","permalink":"https://874656645.github.io/posts/8-python-virtualenv/","summary":"原文网址\n在python中使用virtualenv创建虚拟环境 注意：要使用cmd命令行，不能使用Power Shell1、使用pip安装 pip install virtualenv\n2、创建项目目录并用cd进入 mkdir E:\\python\\Virtualenv cd E:\\python\\Virtualenv 3、创建虚拟环境 virtualenv -p c:\\Python36\\python.exe env\n或者\nvirtualenv env\n此命令会在当前目录下创建一个env目录\n4、启动虚拟环境 env\\Scripts\\activate\n5、离开虚拟环境 deactivate\n6、删除env文件夹即可 ","title":"Python Virtualenv"},{"content":"原文网址\n1. Using a virtual environment (recommended) pip install virtualenv\n详细操作\n2. Creating a new Scrapy project scrapy startproject tutorial\n3. Writing a spider to crawl a site and extract data This is the code for our first Spider. Save it in a file named quotes_spider.py under the tutorial/spiders directory in your project:\nimport scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; def start_requests(self): urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, \u0026#39;http://quotes.toscrape.com/page/2/\u0026#39;, ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self, response): page = response.url.split(\u0026#34;/\u0026#34;)[-2] filename = \u0026#39;quotes-%s.html\u0026#39; % page with open(filename, \u0026#39;wb\u0026#39;) as f: f.write(response.body) self.log(\u0026#39;Saved file %s\u0026#39; % filename) 3.1 Extracting data in our spider import scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; start_urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, \u0026#39;http://quotes.toscrape.com/page/2/\u0026#39;, ] def parse(self, response): for quote in response.css(\u0026#39;div.quote\u0026#39;): yield { \u0026#39;text\u0026#39;: quote.css(\u0026#39;span.text::text\u0026#39;).get(), \u0026#39;author\u0026#39;: quote.css(\u0026#39;small.author::text\u0026#39;).get(), \u0026#39;tags\u0026#39;: quote.css(\u0026#39;div.tags a.tag::text\u0026#39;).getall(), } 3.2 Storing the scraped data scrapy crawl quotes -o quotes.json\nor\nscrapy crawl quotes -o quotes.jl\n4. Exporting the scraped data using the command line scrapy crawl quotes\n5. Changing spider to recursively follow links import scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; start_urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, ] def parse(self, response): for quote in response.css(\u0026#39;div.quote\u0026#39;): yield { \u0026#39;text\u0026#39;: quote.css(\u0026#39;span.text::text\u0026#39;).get(), \u0026#39;author\u0026#39;: quote.css(\u0026#39;small.author::text\u0026#39;).get(), \u0026#39;tags\u0026#39;: quote.css(\u0026#39;div.tags a.tag::text\u0026#39;).getall(), } next_page = response.css(\u0026#39;li.next a::attr(href)\u0026#39;).get() if next_page is not None: next_page = response.urljoin(next_page) yield scrapy.Request(next_page, callback=self.parse) 5.1 A shortcut for creating Requests import scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; start_urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, ] def parse(self, response): for quote in response.css(\u0026#39;div.quote\u0026#39;): yield { \u0026#39;text\u0026#39;: quote.css(\u0026#39;span.text::text\u0026#39;).get(), \u0026#39;author\u0026#39;: quote.css(\u0026#39;span small::text\u0026#39;).get(), \u0026#39;tags\u0026#39;: quote.css(\u0026#39;div.tags a.tag::text\u0026#39;).getall(), } next_page = response.css(\u0026#39;li.next a::attr(href)\u0026#39;).get() if next_page is not None: yield response.follow(next_page, callback=self.parse) 6. Using spider arguments scrapy crawl quotes -o quotes-humor.json -a tag=humor\nimport scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; def start_requests(self): url = \u0026#39;http://quotes.toscrape.com/\u0026#39; tag = getattr(self, \u0026#39;tag\u0026#39;, None) if tag is not None: url = url + \u0026#39;tag/\u0026#39; + tag yield scrapy.Request(url, self.parse) def parse(self, response): for quote in response.css(\u0026#39;div.quote\u0026#39;): yield { \u0026#39;text\u0026#39;: quote.css(\u0026#39;span.text::text\u0026#39;).get(), \u0026#39;author\u0026#39;: quote.css(\u0026#39;small.author::text\u0026#39;).get(), } next_page = response.css(\u0026#39;li.next a::attr(href)\u0026#39;).get() if next_page is not None: yield response.follow(next_page, self.parse) ","permalink":"https://874656645.github.io/posts/7-scrapy-learn/","summary":"原文网址\n1. Using a virtual environment (recommended) pip install virtualenv\n详细操作\n2. Creating a new Scrapy project scrapy startproject tutorial\n3. Writing a spider to crawl a site and extract data This is the code for our first Spider. Save it in a file named quotes_spider.py under the tutorial/spiders directory in your project:\nimport scrapy class QuotesSpider(scrapy.Spider): name = \u0026#34;quotes\u0026#34; def start_requests(self): urls = [ \u0026#39;http://quotes.toscrape.com/page/1/\u0026#39;, \u0026#39;http://quotes.toscrape.com/page/2/\u0026#39;, ] for url in urls: yield scrapy.","title":"Scrapy Learn"},{"content":"1. 配置npm镜像源 1.1 临时使用 npm --registry https://registry.npm.taobao.org install --save-dev electron\n1.2 持久使用 npm config set registry https://registry.npm.taobao.org\n1.3 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info electron 1.4 通过cnpm使用 npm install -g cnpm --registry=https://registry.npm.taobao.org\n1.5 使用 cnpm install express\n","permalink":"https://874656645.github.io/posts/6-npm-commond-learning/","summary":"1. 配置npm镜像源 1.1 临时使用 npm --registry https://registry.npm.taobao.org install --save-dev electron\n1.2 持久使用 npm config set registry https://registry.npm.taobao.org\n1.3 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info electron 1.4 通过cnpm使用 npm install -g cnpm --registry=https://registry.npm.taobao.org\n1.5 使用 cnpm install express","title":"Npm Commond Learning"},{"content":"1. Use npm run example 1.1 Clone repository git clone https://github.com/electron/electron-quick-start\n1.2 Go into the repository cd electron-quick-start\n1.3 Install dependencies PS:为了加快下载依赖模块的速度，通过修改镜像源ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ npm install\n或者是\nnpm install --registry=https://registry.npm.taobao.org\n1.4 Run the app npm start\n2. Use yarn create a electron program 2.1 Create a program folder md electron-yarn-cz\n进入项目文件夹\ncd electron-yarn-cz\n2.2 Create a program config file yarn init\n2.3 Instal electron environment yarn add electron --dev --registry=https://registry.npm.taobao.org\n2.4 Add main.js and index.html 2.5 Edit package.json file \u0026#34;main\u0026#34;: \u0026#34;main.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;electron .\u0026#34; } 3. 打包项目 _推荐devtron 和 electron-builder 2个开发工具，配置简单，功能强大\n3.1 添加打包模块 yarn add electron-builder --dev\n3.2 在package.js中添加命令 \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;electron .\u0026#34;, \u0026#34;pack\u0026#34;: \u0026#34;electron-builder --dir\u0026#34;, \u0026#34;dist\u0026#34;: \u0026#34;electron-builder\u0026#34; } 3.3 运行 yarn dist ","permalink":"https://874656645.github.io/posts/5-learn-electron/","summary":"1. Use npm run example 1.1 Clone repository git clone https://github.com/electron/electron-quick-start\n1.2 Go into the repository cd electron-quick-start\n1.3 Install dependencies PS:为了加快下载依赖模块的速度，通过修改镜像源ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ npm install\n或者是\nnpm install --registry=https://registry.npm.taobao.org\n1.4 Run the app npm start\n2. Use yarn create a electron program 2.1 Create a program folder md electron-yarn-cz\n进入项目文件夹\ncd electron-yarn-cz\n2.2 Create a program config file yarn init\n2.3 Instal electron environment yarn add electron --dev --registry=https://registry.npm.taobao.org\n2.4 Add main.","title":"Learn Electron"},{"content":"win10查看端口使用情况 1. 察看所有已使用的端口 netstat -ano\n2. 查看特定端口的使用 netstat -ano|findstr \u0026quot;443\u0026quot;\n3. 查看占用端口的进程PID tasklist|findstr \u0026quot;7648\u0026quot;\n","permalink":"https://874656645.github.io/posts/4-netstat/","summary":"win10查看端口使用情况 1. 察看所有已使用的端口 netstat -ano\n2. 查看特定端口的使用 netstat -ano|findstr \u0026quot;443\u0026quot;\n3. 查看占用端口的进程PID tasklist|findstr \u0026quot;7648\u0026quot;","title":"Netstat"},{"content":"一、Git 常用命令 1、初始化本地仓库  适合远程仓库是空仓库  cd public git init git remote add blog https://github.com/874656645/rick  如果新建的仓库有东西，最好先克隆到本地，再向里面添加文件  git clone https://github.com/adityatelange/hugo-PaperMod.git\n 克隆含有子仓库的代码  git clone -b exampleSite --recursive https://github.com/adityatelange/hugo-PaperMod.git\n 克隆某一个分支  git clone -b exampleSite https://github.com/adityatelange/hugo-PaperMod.git\n2、更新远程仓库代码到本地 git pull blog master\n3、将变化提交到本地仓库 git commit -m \u0026quot;delete all files\u0026quot;\ngit commit -am \u0026quot;update\u0026quot;\n4、push推送到远程仓库 git push blog master\n5、添加远程仓库别名和网址 git remote add blog https://github.com/874656645/rick\n6、删除配置的远程仓库别名 git remote remove blog\n7、添加文件 git add -A\n8、删除文件 git rm *\n9、删除远程仓库中的文件、文件夹 git rm -r --cached \u0026quot;*.*\u0026quot;\n*.*表示全部文件和文件夹，如果想删除具体的文件或文件夹，使用具体的名称就可以了\n10、查看所有分支并切换 git branch -a\ngit branch -r\ngit checkout dev5\n11、删除远程分支 git push blog --delete name\n12、解决failed to push some refs to git git pull --rebase blog master\n13、不需验证用户名和密码 执行如下命令\ngit config --global credential.helper store\n此命令会在 .gitconfig 文件中添加如下文本\n[credential] helper = store 14、重新输入用户名和密码 git config --system --unset credential.helper\n或者把上面文件中的 store 删掉\n15、添加子仓库 git submodule add \u0026lt;仓库地址\u0026gt; \u0026lt;本地路径\u0026gt;\n添加成功后，在父仓库根目录增加了 .gitmodule 文件，并且在父仓库的 git 配置文件中加入了 submodule 段\n16、checkout 子仓库 git submodule update --init --recursive\ngit submodule init\ngit submodule update\n17、删除子模块 git submodule deinit {MOD_NAME}\n逆初始化模块，其中 {MOD_NAME} 为模块目录，执行后可发现模块目录被清空\ngit rm --cached {MOD_NAME}\n删除 .gitmodules 中记录的模块信息（\u0026ndash;cached 选项清除 .git/modules 中的缓存）\n但是测试有问题， git 配置文件中的 submodule 段和*.git/modules* 中仍有缓存\n18、常用命令 二、连接超时的情况   修改 windows 的 host 文件，win + R 打开运行，输入 drivers，在 etc 目录下找到 host 文件，添加如下内容（注：ip 地址可通过此网站查询）：\n140.82.112.3 github.com git 199.232.69.194 github.global.ssl.fastly.net   还要能科学上网\n  打开 cmd，尝试能否 ping 通 ping github.com\n  ","permalink":"https://874656645.github.io/posts/3-git-commond/","summary":"一、Git 常用命令 1、初始化本地仓库  适合远程仓库是空仓库  cd public git init git remote add blog https://github.com/874656645/rick  如果新建的仓库有东西，最好先克隆到本地，再向里面添加文件  git clone https://github.com/adityatelange/hugo-PaperMod.git\n 克隆含有子仓库的代码  git clone -b exampleSite --recursive https://github.com/adityatelange/hugo-PaperMod.git\n 克隆某一个分支  git clone -b exampleSite https://github.com/adityatelange/hugo-PaperMod.git\n2、更新远程仓库代码到本地 git pull blog master\n3、将变化提交到本地仓库 git commit -m \u0026quot;delete all files\u0026quot;\ngit commit -am \u0026quot;update\u0026quot;\n4、push推送到远程仓库 git push blog master\n5、添加远程仓库别名和网址 git remote add blog https://github.com/874656645/rick\n6、删除配置的远程仓库别名 git remote remove blog","title":"Git Commond"},{"content":"使用 Hugo 创建静态网站 Hugo 官网 Hugo 中文网 网站皮肤 Step1：创建站点 进入到 E:/Hugo/Sites文件夹\nhugo new site HugoLearning.com\ncd HugoLearning.com\ngit init\nStep2：添加样式主题 在皮肤列表挑选一个心仪的皮肤，找到相关的 GitHub 地址，创建目录 themes，在 themes 目录里把皮肤 git clone 下来\ngit submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke\n编辑 config.toml 配置文件\n最后一行添加 theme = \u0026quot;ananke\u0026quot;\n或者在命令行执行 echo 'theme = \u0026quot;ananke\u0026quot;' \u0026gt;\u0026gt; config.toml\nStep3：添加markdown文件内容 hugo new posts/Hello-Hugo.md\nhugo new --kind post posts/1-Papermod-Theme-中文.md\nNote: post is a kind of archetypes( post.md )\nStep4: 启动网站 hugo server -D\n然后输入控制台提示的网址，比如： http://localhost:1313/\nStep5：生成网站 命令行执行 hugo，在网站目录生成public文件夹，发布的网站文件都在这个文件中\n 注意：如果看不到内容，将md文件中的draft设置为false  Step5：将网站发布到 git 使用git工具将文件上传到远程仓库就可以了，仓库还需要做一些设置；\n","permalink":"https://874656645.github.io/posts/2-hugo-create-a-new-site/","summary":"使用 Hugo 创建静态网站 Hugo 官网 Hugo 中文网 网站皮肤 Step1：创建站点 进入到 E:/Hugo/Sites文件夹\nhugo new site HugoLearning.com\ncd HugoLearning.com\ngit init\nStep2：添加样式主题 在皮肤列表挑选一个心仪的皮肤，找到相关的 GitHub 地址，创建目录 themes，在 themes 目录里把皮肤 git clone 下来\ngit submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke\n编辑 config.toml 配置文件\n最后一行添加 theme = \u0026quot;ananke\u0026quot;\n或者在命令行执行 echo 'theme = \u0026quot;ananke\u0026quot;' \u0026gt;\u0026gt; config.toml\nStep3：添加markdown文件内容 hugo new posts/Hello-Hugo.md\nhugo new --kind post posts/1-Papermod-Theme-中文.md\nNote: post is a kind of archetypes( post.md )\nStep4: 启动网站 hugo server -D","title":"Hugo Create a New Site by Hugo"},{"content":"1、随机数 SQL 脚本\nupdate \u0026#34;CYBuildings2\u0026#34; set \u0026#34;imgIndex\u0026#34; = FLOOR(1 + (RANDOM()+9223372036854775808)/2.0/9223372036854775808 * 7); ","permalink":"https://874656645.github.io/posts/16-spatialite-%E9%9A%8F%E6%9C%BA%E6%95%B0/","summary":"1、随机数 SQL 脚本\nupdate \u0026#34;CYBuildings2\u0026#34; set \u0026#34;imgIndex\u0026#34; = FLOOR(1 + (RANDOM()+9223372036854775808)/2.0/9223372036854775808 * 7); ","title":"spatialite 随机数"}]